const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./BivariateGreetings-BCOl6pZv.js","./index-DEeSWGoZ.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _config, _readSessionIntercomSetting, _setIntercomSetting;
import { u as useFixtureState, r as reactExports, a as reactDomExports, R as React, b as React$1, _ as __vitePreload, c as ReactDOM, d as commonjsGlobal, g as getDefaultExportFromCjs, e as createRoot } from "./index-DEeSWGoZ.js";
function getDefaultSelectValue({ options, defaultValue }) {
  if (typeof defaultValue === "string") {
    return defaultValue;
  }
  const [firstOption] = options;
  if (typeof firstOption === "object") {
    return firstOption.options[0];
  }
  return firstOption;
}
function useCurrentSelectValue(selectName, args) {
  const [fixtureState] = useFixtureState("inputs");
  const inputFs = fixtureState && fixtureState[selectName];
  return inputFs && inputFs.type === "select" ? inputFs.currentValue : getDefaultSelectValue(args);
}
function useSelectFixtureState(selectName, args) {
  const [, setFixtureState] = useFixtureState("inputs");
  const defaultValue = getDefaultSelectValue(args);
  reactExports.useEffect(() => {
    setFixtureState((prevFs) => {
      const inputFs = prevFs && prevFs[selectName];
      if (inputFs && inputFs.type === "select" && inputFs.defaultValue === defaultValue)
        return prevFs;
      return {
        ...prevFs,
        [selectName]: {
          type: "select",
          options: args.options,
          defaultValue,
          currentValue: defaultValue
        }
      };
    });
  }, [JSON.stringify(args.options), defaultValue, selectName, setFixtureState]);
}
function useSetSelectValue(selectName) {
  const [, setFixtureState] = useFixtureState("inputs");
  return reactExports.useCallback((value) => {
    setFixtureState((prevFs) => {
      const inputFs = prevFs && prevFs[selectName];
      if (!inputFs || inputFs.type !== "select") {
        console.warn(`Invalid fixture state for select: ${selectName}`);
        return prevFs ?? {};
      }
      return {
        ...prevFs,
        [selectName]: {
          ...inputFs,
          currentValue: value
        }
      };
    });
  }, [selectName, setFixtureState]);
}
function useFixtureSelect(selectName, args) {
  if (!args || !args.options || !args.options.length)
    throw new Error("No options provided to useSelect");
  if (typeof args.options[0] === "object") {
    if (!args.options[0].options.length)
      throw new Error("No options provided to useSelect");
  }
  useSelectFixtureState(selectName, args);
  const currentValue = useCurrentSelectValue(selectName, args);
  const setValue = useSetSelectValue(selectName);
  return [currentValue, setValue];
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$3 = reactExports, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$9 = Object.prototype.hasOwnProperty, n$1 = f$3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$1 = { key: true, ref: true, __self: true, __source: true };
function q$1(c2, a2, g2) {
  var b2, d2 = {}, e = null, h2 = null;
  void 0 !== g2 && (e = "" + g2);
  void 0 !== a2.key && (e = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2) m$9.call(a2, b2) && !p$1.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$1, type: c2, key: e, ref: h2, props: d2, _owner: n$1.current };
}
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q$1;
reactJsxRuntime_production_min.jsxs = q$1;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
function t() {
  return t = Object.assign ? Object.assign.bind() : function(e) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (e[r2] = n2[r2]);
    }
    return e;
  }, t.apply(this, arguments);
}
const n = ["children", "options"], r$1 = { blockQuote: "0", breakLine: "1", breakThematic: "2", codeBlock: "3", codeFenced: "4", codeInline: "5", footnote: "6", footnoteReference: "7", gfmTask: "8", heading: "9", headingSetext: "10", htmlBlock: "11", htmlComment: "12", htmlSelfClosing: "13", image: "14", link: "15", linkAngleBraceStyleDetector: "16", linkBareUrlDetector: "17", linkMailtoDetector: "18", newlineCoalescer: "19", orderedList: "20", paragraph: "21", ref: "22", refImage: "23", refLink: "24", table: "25", tableSeparator: "26", text: "27", textBolded: "28", textEmphasized: "29", textEscaped: "30", textMarked: "31", textStrikethroughed: "32", unorderedList: "33" };
var i$1;
!function(e) {
  e[e.MAX = 0] = "MAX", e[e.HIGH = 1] = "HIGH", e[e.MED = 2] = "MED", e[e.LOW = 3] = "LOW", e[e.MIN = 4] = "MIN";
}(i$1 || (i$1 = {}));
const l = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "className", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((e, t2) => (e[t2.toLowerCase()] = t2, e), { for: "htmlFor" }), a$1 = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: " ", quot: "“" }, o$1 = ["style", "script"], c$1 = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi, s$i = /mailto:/i, d = /\n{2,}$/, u = /^(\s*>[\s\S]*?)(?=\n{2,})/, p = /^ *> ?/gm, f$2 = /^ {2,}\n/, h = /^(?:( *[-*_])){3,} *(?:\n *)+\n/, m$8 = /^\s*(`{3,}|~{3,}) *(\S+)?([^\n]*?)?\n([\s\S]+?)\s*\1 *(?:\n *)*\n?/, g = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/, y = /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/, k = /^(?:\n *)*\n/, x = /\r\n?/g, b = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/, v = /^\[\^([^\]]+)]/, S = /\f/g, E = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/, $ = /^\s*?\[(x|\s)\]/, w = /^ *(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, C = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, z = /^([^\n]+)\n *(=|-){3,} *(?:\n *)+\n/, L = /^ *(?!<[a-z][^ >/]* ?\/>)<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>\n?(\s*(?:<\1[^>]*?>[\s\S]*?<\/\1>|(?!<\1\b)[\s\S])*?)<\/\1>(?!<\/\1>)\n*/i, A = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi, T = /^<!--[\s\S]*?(?:-->)/, O = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/, B = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i, M = /^\{.*\}$/, R = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, I = /^<([^ >]+@[^ >]+)>/, U = /^<([^ >]+:\/[^ >]+)>/, D = /-([a-z])?/gi, j = /^(.*\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/, N = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/, H = /^!\[([^\]]*)\] ?\[([^\]]*)\]/, F = /^\[([^\]]*)\] ?\[([^\]]*)\]/, P = /(\[|\])/g, _ = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/, W = /\t/g, G = /(^ *\||\| *$)/g, Z = /^ *:-+: *$/, q = /^ *:-+ *$/, Q = /^ *-+: *$/, V = "((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~~.*?~~|==.*?==|.|\\n)*?)", X = new RegExp(`^([*_])\\1${V}\\1\\1(?!\\1)`), J = new RegExp(`^([*_])${V}\\1(?!\\1|\\w)`), K = new RegExp(`^==${V}==`), Y = new RegExp(`^~~${V}~~`), ee = /^\\([^0-9A-Za-z\s])/, te = /^[\s\S]+?(?=[^0-9A-Z\s\u00c0-\uffff&#;.()'"]|\d+\.|\n\n| {2,}\n|\w+:\S|$)/i, ne = /^\n+/, re = /^([ \t]*)/, ie = /\\([^\\])/g, le = / *\n+$/, ae = /(?:^|\n)( *)$/, oe = "(?:\\d+\\.)", ce = "(?:[*+-])";
function se(e) {
  return "( *)(" + (1 === e ? oe : ce) + ") +";
}
const de = se(1), ue = se(2);
function pe(e) {
  return new RegExp("^" + (1 === e ? de : ue));
}
const fe = pe(1), he = pe(2);
function me(e) {
  return new RegExp("^" + (1 === e ? de : ue) + "[^\\n]*(?:\\n(?!\\1" + (1 === e ? oe : ce) + " )[^\\n]*)*(\\n|$)", "gm");
}
const ge = me(1), ye = me(2);
function ke(e) {
  const t2 = 1 === e ? oe : ce;
  return new RegExp("^( *)(" + t2 + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + t2 + " (?!" + t2 + " ))\\n*|\\s*\\n*$)");
}
const xe = ke(1), be = ke(2);
function ve(e, t2) {
  const n2 = 1 === t2, i2 = n2 ? xe : be, l2 = n2 ? ge : ye, a2 = n2 ? fe : he;
  return { match(e2, t3, n3) {
    const r2 = ae.exec(n3);
    return r2 && (t3.list || !t3.inline && !t3.simple) ? i2.exec(e2 = r2[1] + e2) : null;
  }, order: 1, parse(e2, t3, r2) {
    const i3 = n2 ? +e2[2] : void 0, o2 = e2[0].replace(d, "\n").match(l2);
    let c2 = false;
    return { items: o2.map(function(e3, n3) {
      const i4 = a2.exec(e3)[0].length, l3 = new RegExp("^ {1," + i4 + "}", "gm"), s2 = e3.replace(l3, "").replace(a2, ""), d2 = n3 === o2.length - 1, u2 = -1 !== s2.indexOf("\n\n") || d2 && c2;
      c2 = u2;
      const p2 = r2.inline, f2 = r2.list;
      let h2;
      r2.list = true, u2 ? (r2.inline = false, h2 = s2.replace(le, "\n\n")) : (r2.inline = true, h2 = s2.replace(le, ""));
      const m2 = t3(h2, r2);
      return r2.inline = p2, r2.list = f2, m2;
    }), ordered: n2, start: i3 };
  }, render: (t3, n3, i3) => e(t3.ordered ? "ol" : "ul", { key: i3.key, start: t3.type === r$1.orderedList ? t3.start : void 0 }, t3.items.map(function(t4, r2) {
    return e("li", { key: r2 }, n3(t4, i3));
  })) };
}
const Se = new RegExp(`^\\[((?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`), Ee = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/, $e = [u, m$8, g, w, z, C, T, j, ge, xe, ye, be], we = [...$e, /^[^\n]+(?:  \n|\n{2,})/, L, B];
function Ce(e) {
  return e.replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, "a").replace(/[çÇ]/g, "c").replace(/[ðÐ]/g, "d").replace(/[ÈÉÊËéèêë]/g, "e").replace(/[ÏïÎîÍíÌì]/g, "i").replace(/[Ññ]/g, "n").replace(/[øØœŒÕõÔôÓóÒò]/g, "o").replace(/[ÜüÛûÚúÙù]/g, "u").replace(/[ŸÿÝý]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
}
function ze(e) {
  return Q.test(e) ? "right" : Z.test(e) ? "center" : q.test(e) ? "left" : null;
}
function Le(e, t2, n2, i2) {
  const l2 = n2.inTable;
  n2.inTable = true;
  let a2 = e.trim().split(/( *(?:`[^`]*`|<.*?>.*?<\/.*?>(?!<\/.*?>)|\\\||\|) *)/).reduce((e2, l3) => ("|" === l3.trim() ? e2.push(i2 ? { type: r$1.tableSeparator } : { type: r$1.text, text: l3 }) : "" !== l3 && e2.push.apply(e2, t2(l3, n2)), e2), []);
  n2.inTable = l2;
  let o2 = [[]];
  return a2.forEach(function(e2, t3) {
    e2.type === r$1.tableSeparator ? 0 !== t3 && t3 !== a2.length - 1 && o2.push([]) : (e2.type !== r$1.text || null != a2[t3 + 1] && a2[t3 + 1].type !== r$1.tableSeparator || (e2.text = e2.text.trimEnd()), o2[o2.length - 1].push(e2));
  }), o2;
}
function Ae(e, t2, n2) {
  n2.inline = true;
  const i2 = e[2] ? e[2].replace(G, "").split("|").map(ze) : [], l2 = e[3] ? function(e2, t3, n3) {
    return e2.trim().split("\n").map(function(e3) {
      return Le(e3, t3, n3, true);
    });
  }(e[3], t2, n2) : [], a2 = Le(e[1], t2, n2, !!l2.length);
  return n2.inline = false, l2.length ? { align: i2, cells: l2, header: a2, type: r$1.table } : { children: a2, type: r$1.paragraph };
}
function Te(e, t2) {
  return null == e.align[t2] ? {} : { textAlign: e.align[t2] };
}
function Oe(e) {
  return function(t2, n2) {
    return n2.inline ? e.exec(t2) : null;
  };
}
function Be(e) {
  return function(t2, n2) {
    return n2.inline || n2.simple ? e.exec(t2) : null;
  };
}
function Me(e) {
  return function(t2, n2) {
    return n2.inline || n2.simple ? null : e.exec(t2);
  };
}
function Re(e) {
  return function(t2) {
    return e.exec(t2);
  };
}
function Ie(e, t2, n2) {
  if (t2.inline || t2.simple) return null;
  if (n2 && !n2.endsWith("\n")) return null;
  let r2 = "";
  e.split("\n").every((e2) => !$e.some((t3) => t3.test(e2)) && (r2 += e2 + "\n", e2.trim()));
  const i2 = r2.trimEnd();
  return "" == i2 ? null : [r2, i2];
}
function Ue(e) {
  try {
    if (decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g, "").match(/^\s*(javascript|vbscript|data(?!:image)):/i)) return null;
  } catch (e2) {
    return null;
  }
  return e;
}
function De(e) {
  return e.replace(ie, "$1");
}
function je(e, t2, n2) {
  const r2 = n2.inline || false, i2 = n2.simple || false;
  n2.inline = true, n2.simple = true;
  const l2 = e(t2, n2);
  return n2.inline = r2, n2.simple = i2, l2;
}
function Ne(e, t2, n2) {
  const r2 = n2.inline || false, i2 = n2.simple || false;
  n2.inline = false, n2.simple = true;
  const l2 = e(t2, n2);
  return n2.inline = r2, n2.simple = i2, l2;
}
function He(e, t2, n2) {
  const r2 = n2.inline || false;
  n2.inline = false;
  const i2 = e(t2, n2);
  return n2.inline = r2, i2;
}
const Fe = (e, t2, n2) => ({ children: je(t2, e[1], n2) });
function Pe() {
  return {};
}
function _e() {
  return null;
}
function We(...e) {
  return e.filter(Boolean).join(" ");
}
function Ge(e, t2, n2) {
  let r2 = e;
  const i2 = t2.split(".");
  for (; i2.length && (r2 = r2[i2[0]], void 0 !== r2); ) i2.shift();
  return r2 || n2;
}
function Ze(n2 = "", i2 = {}) {
  function d2(e, n3, ...r2) {
    const l2 = Ge(i2.overrides, `${e}.props`, {});
    return i2.createElement(function(e2, t2) {
      const n4 = Ge(t2, e2);
      return n4 ? "function" == typeof n4 || "object" == typeof n4 && "render" in n4 ? n4 : Ge(t2, `${e2}.component`, e2) : e2;
    }(e, i2.overrides), t({}, n3, l2, { className: We(null == n3 ? void 0 : n3.className, l2.className) || void 0 }), ...r2);
  }
  function G2(t2) {
    t2 = t2.replace(E, "");
    let n3 = false;
    i2.forceInline ? n3 = true : i2.forceBlock || (n3 = false === _.test(t2));
    const r2 = le2(ie2(n3 ? t2 : `${t2.trimEnd().replace(ne, "")}

`, { inline: n3 }));
    for (; "string" == typeof r2[r2.length - 1] && !r2[r2.length - 1].trim(); ) r2.pop();
    if (null === i2.wrapper) return r2;
    const l2 = i2.wrapper || (n3 ? "span" : "div");
    let a2;
    if (r2.length > 1 || i2.forceWrapper) a2 = r2;
    else {
      if (1 === r2.length) return a2 = r2[0], "string" == typeof a2 ? d2("span", { key: "outer" }, a2) : a2;
      a2 = null;
    }
    return reactExports.createElement(l2, { key: "outer" }, a2);
  }
  function Z2(t2, n3) {
    const r2 = n3.match(c$1);
    return r2 ? r2.reduce(function(n4, r3, a2) {
      const o2 = r3.indexOf("=");
      if (-1 !== o2) {
        const c2 = function(e) {
          return -1 !== e.indexOf("-") && null === e.match(O) && (e = e.replace(D, function(e2, t3) {
            return t3.toUpperCase();
          })), e;
        }(r3.slice(0, o2)).trim(), s2 = function(e) {
          const t3 = e[0];
          return ('"' === t3 || "'" === t3) && e.length >= 2 && e[e.length - 1] === t3 ? e.slice(1, -1) : e;
        }(r3.slice(o2 + 1).trim()), d3 = l[c2] || c2, u2 = n4[d3] = function(e, t3, n5, r4) {
          return "style" === t3 ? n5.split(/;\s?/).reduce(function(e2, t4) {
            const n6 = t4.slice(0, t4.indexOf(":"));
            return e2[n6.trim().replace(/(-[a-z])/g, (e3) => e3[1].toUpperCase())] = t4.slice(n6.length + 1).trim(), e2;
          }, {}) : "href" === t3 || "src" === t3 ? r4(n5, e, t3) : (n5.match(M) && (n5 = n5.slice(1, n5.length - 1)), "true" === n5 || "false" !== n5 && n5);
        }(t2, c2, s2, i2.sanitizer);
        "string" == typeof u2 && (L.test(u2) || B.test(u2)) && (n4[d3] = reactExports.cloneElement(G2(u2.trim()), { key: a2 }));
      } else "style" !== r3 && (n4[l[r3] || r3] = true);
      return n4;
    }, {}) : null;
  }
  i2.overrides = i2.overrides || {}, i2.sanitizer = i2.sanitizer || Ue, i2.slugify = i2.slugify || Ce, i2.namedCodesToUnicode = i2.namedCodesToUnicode ? t({}, a$1, i2.namedCodesToUnicode) : a$1, i2.createElement = i2.createElement || reactExports.createElement;
  const q2 = [], Q2 = {}, V2 = { [r$1.blockQuote]: { match: Me(u), order: 1, parse: (e, t2, n3) => ({ children: t2(e[0].replace(p, ""), n3) }), render: (e, t2, n3) => d2("blockquote", { key: n3.key }, t2(e.children, n3)) }, [r$1.breakLine]: { match: Re(f$2), order: 1, parse: Pe, render: (e, t2, n3) => d2("br", { key: n3.key }) }, [r$1.breakThematic]: { match: Me(h), order: 1, parse: Pe, render: (e, t2, n3) => d2("hr", { key: n3.key }) }, [r$1.codeBlock]: { match: Me(g), order: 0, parse: (e) => ({ lang: void 0, text: e[0].replace(/^ {4}/gm, "").replace(/\n+$/, "") }), render: (e, n3, r2) => d2("pre", { key: r2.key }, d2("code", t({}, e.attrs, { className: e.lang ? `lang-${e.lang}` : "" }), e.text)) }, [r$1.codeFenced]: { match: Me(m$8), order: 0, parse: (e) => ({ attrs: Z2("code", e[3] || ""), lang: e[2] || void 0, text: e[4], type: r$1.codeBlock }) }, [r$1.codeInline]: { match: Be(y), order: 3, parse: (e) => ({ text: e[2] }), render: (e, t2, n3) => d2("code", { key: n3.key }, e.text) }, [r$1.footnote]: { match: Me(b), order: 0, parse: (e) => (q2.push({ footnote: e[2], identifier: e[1] }), {}), render: _e }, [r$1.footnoteReference]: { match: Oe(v), order: 1, parse: (e) => ({ target: `#${i2.slugify(e[1], Ce)}`, text: e[1] }), render: (e, t2, n3) => d2("a", { key: n3.key, href: i2.sanitizer(e.target, "a", "href") }, d2("sup", { key: n3.key }, e.text)) }, [r$1.gfmTask]: { match: Oe($), order: 1, parse: (e) => ({ completed: "x" === e[1].toLowerCase() }), render: (e, t2, n3) => d2("input", { checked: e.completed, key: n3.key, readOnly: true, type: "checkbox" }) }, [r$1.heading]: { match: Me(i2.enforceAtxHeadings ? C : w), order: 1, parse: (e, t2, n3) => ({ children: je(t2, e[2], n3), id: i2.slugify(e[2], Ce), level: e[1].length }), render: (e, t2, n3) => d2(`h${e.level}`, { id: e.id, key: n3.key }, t2(e.children, n3)) }, [r$1.headingSetext]: { match: Me(z), order: 0, parse: (e, t2, n3) => ({ children: je(t2, e[1], n3), level: "=" === e[2] ? 1 : 2, type: r$1.heading }) }, [r$1.htmlBlock]: { match: Re(L), order: 1, parse(e, t2, n3) {
    const [, r2] = e[3].match(re), i3 = new RegExp(`^${r2}`, "gm"), l2 = e[3].replace(i3, ""), a2 = (c2 = l2, we.some((e2) => e2.test(c2)) ? He : je);
    var c2;
    const s2 = e[1].toLowerCase(), d3 = -1 !== o$1.indexOf(s2), u2 = (d3 ? s2 : e[1]).trim(), p2 = { attrs: Z2(u2, e[2]), noInnerParse: d3, tag: u2 };
    return n3.inAnchor = n3.inAnchor || "a" === s2, d3 ? p2.text = e[3] : p2.children = a2(t2, l2, n3), n3.inAnchor = false, p2;
  }, render: (e, n3, r2) => d2(e.tag, t({ key: r2.key }, e.attrs), e.text || n3(e.children, r2)) }, [r$1.htmlSelfClosing]: { match: Re(B), order: 1, parse(e) {
    const t2 = e[1].trim();
    return { attrs: Z2(t2, e[2] || ""), tag: t2 };
  }, render: (e, n3, r2) => d2(e.tag, t({}, e.attrs, { key: r2.key })) }, [r$1.htmlComment]: { match: Re(T), order: 1, parse: () => ({}), render: _e }, [r$1.image]: { match: Be(Ee), order: 1, parse: (e) => ({ alt: e[1], target: De(e[2]), title: e[3] }), render: (e, t2, n3) => d2("img", { key: n3.key, alt: e.alt || void 0, title: e.title || void 0, src: i2.sanitizer(e.target, "img", "src") }) }, [r$1.link]: { match: Oe(Se), order: 3, parse: (e, t2, n3) => ({ children: Ne(t2, e[1], n3), target: De(e[2]), title: e[3] }), render: (e, t2, n3) => d2("a", { key: n3.key, href: i2.sanitizer(e.target, "a", "href"), title: e.title }, t2(e.children, n3)) }, [r$1.linkAngleBraceStyleDetector]: { match: Oe(U), order: 0, parse: (e) => ({ children: [{ text: e[1], type: r$1.text }], target: e[1], type: r$1.link }) }, [r$1.linkBareUrlDetector]: { match: (e, t2) => t2.inAnchor ? null : Oe(R)(e, t2), order: 0, parse: (e) => ({ children: [{ text: e[1], type: r$1.text }], target: e[1], title: void 0, type: r$1.link }) }, [r$1.linkMailtoDetector]: { match: Oe(I), order: 0, parse(e) {
    let t2 = e[1], n3 = e[1];
    return s$i.test(n3) || (n3 = "mailto:" + n3), { children: [{ text: t2.replace("mailto:", ""), type: r$1.text }], target: n3, type: r$1.link };
  } }, [r$1.orderedList]: ve(d2, 1), [r$1.unorderedList]: ve(d2, 2), [r$1.newlineCoalescer]: { match: Me(k), order: 3, parse: Pe, render: () => "\n" }, [r$1.paragraph]: { match: Ie, order: 3, parse: Fe, render: (e, t2, n3) => d2("p", { key: n3.key }, t2(e.children, n3)) }, [r$1.ref]: { match: Oe(N), order: 0, parse: (e) => (Q2[e[1]] = { target: e[2], title: e[4] }, {}), render: _e }, [r$1.refImage]: { match: Be(H), order: 0, parse: (e) => ({ alt: e[1] || void 0, ref: e[2] }), render: (e, t2, n3) => Q2[e.ref] ? d2("img", { key: n3.key, alt: e.alt, src: i2.sanitizer(Q2[e.ref].target, "img", "src"), title: Q2[e.ref].title }) : null }, [r$1.refLink]: { match: Oe(F), order: 0, parse: (e, t2, n3) => ({ children: t2(e[1], n3), fallbackChildren: t2(e[0].replace(P, "\\$1"), n3), ref: e[2] }), render: (e, t2, n3) => Q2[e.ref] ? d2("a", { key: n3.key, href: i2.sanitizer(Q2[e.ref].target, "a", "href"), title: Q2[e.ref].title }, t2(e.children, n3)) : d2("span", { key: n3.key }, t2(e.fallbackChildren, n3)) }, [r$1.table]: { match: Me(j), order: 1, parse: Ae, render(e, t2, n3) {
    const r2 = e;
    return d2("table", { key: n3.key }, d2("thead", null, d2("tr", null, r2.header.map(function(e2, i3) {
      return d2("th", { key: i3, style: Te(r2, i3) }, t2(e2, n3));
    }))), d2("tbody", null, r2.cells.map(function(e2, i3) {
      return d2("tr", { key: i3 }, e2.map(function(e3, i4) {
        return d2("td", { key: i4, style: Te(r2, i4) }, t2(e3, n3));
      }));
    })));
  } }, [r$1.text]: { match: Re(te), order: 4, parse: (e) => ({ text: e[0].replace(A, (e2, t2) => i2.namedCodesToUnicode[t2] ? i2.namedCodesToUnicode[t2] : e2) }), render: (e) => e.text }, [r$1.textBolded]: { match: Be(X), order: 2, parse: (e, t2, n3) => ({ children: t2(e[2], n3) }), render: (e, t2, n3) => d2("strong", { key: n3.key }, t2(e.children, n3)) }, [r$1.textEmphasized]: { match: Be(J), order: 3, parse: (e, t2, n3) => ({ children: t2(e[2], n3) }), render: (e, t2, n3) => d2("em", { key: n3.key }, t2(e.children, n3)) }, [r$1.textEscaped]: { match: Be(ee), order: 1, parse: (e) => ({ text: e[1], type: r$1.text }) }, [r$1.textMarked]: { match: Be(K), order: 3, parse: Fe, render: (e, t2, n3) => d2("mark", { key: n3.key }, t2(e.children, n3)) }, [r$1.textStrikethroughed]: { match: Be(Y), order: 3, parse: Fe, render: (e, t2, n3) => d2("del", { key: n3.key }, t2(e.children, n3)) } };
  true === i2.disableParsingRawHTML && (delete V2[r$1.htmlBlock], delete V2[r$1.htmlSelfClosing]);
  const ie2 = function(e) {
    let t2 = Object.keys(e);
    function n3(r2, i3) {
      let l2 = [], a2 = "";
      for (; r2; ) {
        let o2 = 0;
        for (; o2 < t2.length; ) {
          const c2 = t2[o2], s2 = e[c2], d3 = s2.match(r2, i3, a2);
          if (d3) {
            const e2 = d3[0];
            r2 = r2.substring(e2.length);
            const t3 = s2.parse(d3, n3, i3);
            null == t3.type && (t3.type = c2), l2.push(t3), a2 = e2;
            break;
          }
          o2++;
        }
      }
      return l2;
    }
    return t2.sort(function(t3, n4) {
      let r2 = e[t3].order, i3 = e[n4].order;
      return r2 !== i3 ? r2 - i3 : t3 < n4 ? -1 : 1;
    }), function(e2, t3) {
      return n3(function(e3) {
        return e3.replace(x, "\n").replace(S, "").replace(W, "    ");
      }(e2), t3);
    };
  }(V2), le2 = (ae2 = /* @__PURE__ */ function(e, t2) {
    return function(n3, r2, i3) {
      const l2 = e[n3.type].render;
      return t2 ? t2(() => l2(n3, r2, i3), n3, r2, i3) : l2(n3, r2, i3);
    };
  }(V2, i2.renderRule), function e(t2, n3 = {}) {
    if (Array.isArray(t2)) {
      const r2 = n3.key, i3 = [];
      let l2 = false;
      for (let r3 = 0; r3 < t2.length; r3++) {
        n3.key = r3;
        const a2 = e(t2[r3], n3), o2 = "string" == typeof a2;
        o2 && l2 ? i3[i3.length - 1] += a2 : null !== a2 && i3.push(a2), l2 = o2;
      }
      return n3.key = r2, i3;
    }
    return ae2(t2, e, n3);
  });
  var ae2;
  const oe2 = G2(n2);
  return q2.length ? d2("div", null, oe2, d2("footer", { key: "footer" }, q2.map(function(e) {
    return d2("div", { id: i2.slugify(e.identifier, Ce), key: e.identifier }, e.identifier, le2(ie2(e.footnote, { inline: true })));
  }))) : oe2;
}
const Markdown = (t2) => {
  let { children: r2 = "", options: i2 } = t2, l2 = function(e, t3) {
    if (null == e) return {};
    var n2, r3, i3 = {}, l3 = Object.keys(e);
    for (r3 = 0; r3 < l3.length; r3++) t3.indexOf(n2 = l3[r3]) >= 0 || (i3[n2] = e[n2]);
    return i3;
  }(t2, n);
  return reactExports.cloneElement(Ze(r2, i2), l2);
};
function r(e) {
  var t2, f2, n2 = "";
  if ("string" == typeof e || "number" == typeof e) n2 += e;
  else if ("object" == typeof e) if (Array.isArray(e)) for (t2 = 0; t2 < e.length; t2++) e[t2] && (f2 = r(e[t2])) && (n2 && (n2 += " "), n2 += f2);
  else for (t2 in e) e[t2] && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function clsx() {
  for (var e, t2, f2 = 0, n2 = ""; f2 < arguments.length; ) (e = arguments[f2++]) && (t2 = r(e)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const Close24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.54039 5.54039C5.79423 5.28655 6.20578 5.28655 6.45963 5.54039L12 11.0808L17.5404 5.54039C17.7942 5.28655 18.2058 5.28655 18.4596 5.54039C18.7135 5.79423 18.7135 6.20578 18.4596 6.45963L12.9192 12L18.4596 17.5404C18.7135 17.7942 18.7135 18.2058 18.4596 18.4596C18.2058 18.7135 17.7942 18.7135 17.5404 18.4596L12 12.9192L6.45963 18.4596C6.20578 18.7135 5.79423 18.7135 5.54039 18.4596C5.28655 18.2058 5.28655 17.7942 5.54039 17.5404L11.0808 12L5.54039 6.45963C5.28655 6.20578 5.28655 5.79423 5.54039 5.54039Z", fill: "currentColor" }) });
Close24.displayName = "Close24";
const Memo$5 = reactExports.memo(Close24);
const Close16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.64645 2.64645C2.84171 2.45118 3.15829 2.45118 3.35355 2.64645L13.3536 12.6464C13.5488 12.8417 13.5488 13.1583 13.3536 13.3536C13.1583 13.5488 12.8417 13.5488 12.6464 13.3536L2.64645 3.35355C2.45118 3.15829 2.45118 2.84171 2.64645 2.64645Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.3536 2.64645C13.1583 2.45118 12.8417 2.45118 12.6464 2.64645L2.64645 12.6464C2.45118 12.8417 2.45118 13.1583 2.64645 13.3536C2.84171 13.5488 3.15829 13.5488 3.35355 13.3536L13.3536 3.35355C13.5488 3.15829 13.5488 2.84171 13.3536 2.64645Z", fill: "currentColor" })] });
Close16.displayName = "Close16";
const Memo$4 = reactExports.memo(Close16);
const ChevronDown16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.64645 5.64645C2.84171 5.45118 3.15829 5.45118 3.35355 5.64645L8 10.2929L12.6464 5.64645C12.8417 5.45118 13.1583 5.45118 13.3536 5.64645C13.5488 5.84171 13.5488 6.15829 13.3536 6.35355L8.35355 11.3536C8.15829 11.5488 7.84171 11.5488 7.64645 11.3536L2.64645 6.35355C2.45118 6.15829 2.45118 5.84171 2.64645 5.64645Z", fill: "currentColor" }) });
ChevronDown16.displayName = "ChevronDown16";
const Memo$3 = reactExports.memo(ChevronDown16);
const People16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.9603 9.61389C12.0294 9.34652 12.3021 9.18573 12.5695 9.25477C13.1535 9.40556 13.6709 9.74603 14.0404 10.2227C14.4099 10.6994 14.6107 11.2854 14.6111 11.8885V13C14.6111 13.2761 14.3873 13.5 14.1111 13.5C13.835 13.5 13.6111 13.2761 13.6111 13V11.8893C13.6108 11.5077 13.4838 11.1369 13.25 10.8354C13.0163 10.5338 12.6889 10.3184 12.3195 10.223C12.0521 10.154 11.8913 9.88127 11.9603 9.61389Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.18618 9.96398C2.6967 9.45346 3.38911 9.16666 4.11108 9.16666H8.55553C9.27751 9.16666 9.96992 9.45346 10.4804 9.96398C10.9909 10.4745 11.2778 11.1669 11.2778 11.8889V13C11.2778 13.2761 11.0539 13.5 10.7778 13.5C10.5016 13.5 10.2778 13.2761 10.2778 13V11.8889C10.2778 11.4321 10.0963 10.9941 9.77332 10.6711C9.45034 10.3481 9.01229 10.1667 8.55553 10.1667H4.11108C3.65432 10.1667 3.21627 10.3481 2.89329 10.6711C2.57031 10.9941 2.38886 11.4321 2.38886 11.8889V13C2.38886 13.2761 2.165 13.5 1.88886 13.5C1.61272 13.5 1.38886 13.2761 1.38886 13V11.8889C1.38886 11.1669 1.67567 10.4745 2.18618 9.96398Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.73774 2.94818C9.80623 2.68067 10.0786 2.51934 10.3461 2.58783C10.9317 2.73776 11.4507 3.07831 11.8213 3.55579C12.192 4.03327 12.3931 4.62053 12.3931 5.22498C12.3931 5.82943 12.192 6.41669 11.8213 6.89417C11.4507 7.37166 10.9317 7.71221 10.3461 7.86213C10.0786 7.93063 9.80623 7.76929 9.73774 7.50178C9.66924 7.23427 9.83058 6.96188 10.0981 6.89338C10.4685 6.79853 10.7969 6.58308 11.0314 6.281C11.2659 5.97892 11.3931 5.60739 11.3931 5.22498C11.3931 4.84258 11.2659 4.47105 11.0314 4.16896C10.7969 3.86688 10.4685 3.65143 10.0981 3.55658C9.83058 3.48809 9.66924 3.2157 9.73774 2.94818Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.33331 3.5C5.38216 3.5 4.61109 4.27107 4.61109 5.22222C4.61109 6.17338 5.38216 6.94444 6.33331 6.94444C7.28447 6.94444 8.05554 6.17338 8.05554 5.22222C8.05554 4.27107 7.28447 3.5 6.33331 3.5ZM3.61109 5.22222C3.61109 3.71878 4.82987 2.5 6.33331 2.5C7.83676 2.5 9.05554 3.71878 9.05554 5.22222C9.05554 6.72566 7.83676 7.94444 6.33331 7.94444C4.82987 7.94444 3.61109 6.72566 3.61109 5.22222Z", fill: "currentColor" })] });
People16.displayName = "People16";
const Memo$2 = reactExports.memo(People16);
const Area16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.83334 3.49999H11.1667V4.49999H4.83334V3.49999ZM4.50001 4.83332V11.1667H3.50001V4.83332H4.50001ZM12.5 4.83332V11.1667H11.5V4.83332H12.5ZM4.83334 11.5H11.1667V12.5H4.83334V11.5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.66667 11.6667V12.3333H4.33334V11.6667H3.66667ZM3.16667 10.6667C2.89053 10.6667 2.66667 10.8905 2.66667 11.1667V12.8333C2.66667 13.1095 2.89053 13.3333 3.16667 13.3333H4.83334C5.10948 13.3333 5.33334 13.1095 5.33334 12.8333V11.1667C5.33334 10.8905 5.10948 10.6667 4.83334 10.6667H3.16667Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.66667 3.66666V4.33332H4.33334V3.66666H3.66667ZM3.16667 2.66666C2.89053 2.66666 2.66667 2.89051 2.66667 3.16666V4.83332C2.66667 5.10947 2.89053 5.33332 3.16667 5.33332H4.83334C5.10948 5.33332 5.33334 5.10947 5.33334 4.83332V3.16666C5.33334 2.89051 5.10948 2.66666 4.83334 2.66666H3.16667Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.6667 3.66666V4.33332H12.3333V3.66666H11.6667ZM11.1667 2.66666C10.8905 2.66666 10.6667 2.89051 10.6667 3.16666V4.83332C10.6667 5.10947 10.8905 5.33332 11.1667 5.33332H12.8333C13.1095 5.33332 13.3333 5.10947 13.3333 4.83332V3.16666C13.3333 2.89051 13.1095 2.66666 12.8333 2.66666H11.1667Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.6667 11.6667V12.3333H12.3333V11.6667H11.6667ZM11.1667 10.6667C10.8905 10.6667 10.6667 10.8905 10.6667 11.1667V12.8333C10.6667 13.1095 10.8905 13.3333 11.1667 13.3333H12.8333C13.1095 13.3333 13.3333 13.1095 13.3333 12.8333V11.1667C13.3333 10.8905 13.1095 10.6667 12.8333 10.6667H11.1667Z", fill: "currentColor" })] });
Area16.displayName = "Area16";
const Memo$1 = reactExports.memo(Area16);
const InfoOutline16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.00002 2.66669C5.0545 2.66669 2.66669 5.0545 2.66669 8.00002C2.66669 10.9455 5.0545 13.3334 8.00002 13.3334C10.9455 13.3334 13.3334 10.9455 13.3334 8.00002C13.3334 5.0545 10.9455 2.66669 8.00002 2.66669ZM1.66669 8.00002C1.66669 4.50222 4.50222 1.66669 8.00002 1.66669C11.4978 1.66669 14.3334 4.50222 14.3334 8.00002C14.3334 11.4978 11.4978 14.3334 8.00002 14.3334C4.50222 14.3334 1.66669 11.4978 1.66669 8.00002Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 6.87481C8.27614 6.87481 8.5 7.09867 8.5 7.37481V11C8.5 11.2761 8.27614 11.5 8 11.5C7.72386 11.5 7.5 11.2761 7.5 11V7.37481C7.5 7.09867 7.72386 6.87481 8 6.87481Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 4.5C8.27614 4.5 8.5 4.72386 8.5 5V5.01C8.5 5.28614 8.27614 5.51 8 5.51C7.72386 5.51 7.5 5.28614 7.5 5.01V5C7.5 4.72386 7.72386 4.5 8 4.5Z", fill: "currentColor" })] });
InfoOutline16.displayName = "InfoOutline16";
const Memo = reactExports.memo(InfoOutline16);
function Text({ children, type, className }) {
  return reactExports.isValidElement(children) ? reactExports.cloneElement(children, { className: `k-font-${type} ${children.props.className} ${className}` }) : jsxRuntimeExports.jsx("span", { className: `k-font-${type} ${className}`, children });
}
const button = "_button_1231j_1";
const buttonDark = "_buttonDark_1231j_58";
const buttonInner = "_buttonInner_1231j_75";
const tiny = "_tiny_1231j_80";
const withContent = "_withContent_1231j_81";
const small = "_small_1231j_92";
const medium = "_medium_1231j_96";
const large = "_large_1231j_108";
const withIcon = "_withIcon_1231j_114";
const buttonContent = "_buttonContent_1231j_52";
const iconBefore = "_iconBefore_1231j_155";
const iconAfter = "_iconAfter_1231j_156";
const primary = "_primary_1231j_163";
const active$2 = "_active_1231j_174";
const invert = "_invert_1231j_180";
const s$h = {
  button,
  buttonDark,
  buttonInner,
  tiny,
  withContent,
  small,
  medium,
  large,
  withIcon,
  buttonContent,
  iconBefore,
  iconAfter,
  primary,
  active: active$2,
  "invert-outline": "_invert-outline_1231j_180",
  invert
};
const Button = reactExports.forwardRef(({ children, className, active: active2, variant = "primary", size = "medium", dark = false, iconBefore: iconBefore2, iconAfter: iconAfter2, ...props }, ref) => {
  const hasContent = reactExports.Children.count(children) > 0;
  const hasIcon = iconBefore2 || iconAfter2;
  return jsxRuntimeExports.jsx("button", { ref, className: clsx(s$h.button, {
    [s$h.buttonDark]: dark
  }, s$h[variant], s$h[size], {
    [s$h.active]: active2,
    [s$h.withContent]: hasContent,
    [s$h.withIcon]: hasIcon
  }, className), ...props, children: jsxRuntimeExports.jsxs("div", { className: clsx(s$h.buttonInner), children: [iconBefore2 && jsxRuntimeExports.jsx("div", { className: s$h.iconBefore, children: iconBefore2 }), hasContent && jsxRuntimeExports.jsx("span", { className: s$h.buttonContent, children }), iconAfter2 && jsxRuntimeExports.jsx("div", { className: s$h.iconAfter, children: iconAfter2 })] }) });
});
Button.displayName = "Button";
const typeToClass = (type) => `k-font-${type}`;
const getClassName = (type, margins, className) => `${typeToClass(type)} ${margins ? "" : typeToClass("unset-margins")} ${className ?? ""} `;
function Heading({ children, type, tag, margins = true }) {
  if (reactExports.isValidElement(children)) {
    return reactExports.cloneElement(children, {
      className: getClassName(type, margins, children.props.className)
    });
  }
  return reactExports.createElement(tag ? tag : "h" + type.slice(-1), { className: getClassName(type, margins) }, children);
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis2) {
  return axis2 === "x" ? "y" : "x";
}
function getAxisLength(axis2) {
  return axis2 === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list2 = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list2 = list2.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list2 = list2.concat(list2.map(getOppositeAlignmentPlacement));
    }
  }
  return list2;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x2,
    y: y2
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis2 = getAlignmentAxis(placement);
    const length = getAxisLength(axis2);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis2 === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis2] - coords[axis2] - rects.floating[length];
    const startDiff = coords[axis2] - rects.reference[axis2];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis2]: coords[axis2] + alignmentOffset,
      data: {
        [axis2]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow$1(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow$1(value).Node;
}
function isElement$1(value) {
  return value instanceof Element || value instanceof getWindow$1(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow$1(value).HTMLElement;
}
function isShadowRoot$1(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow$1(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css2 = getComputedStyle$1(element);
  return css2.transform !== "none" || css2.perspective !== "none" || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement$1(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result2 = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot$1(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot$1(result2) ? result2.host : result2;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list2, traverseIframes) {
  var _node$ownerDocument2;
  if (list2 === void 0) {
    list2 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow$1(scrollableAncestor);
  if (isBody) {
    return list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions(element) {
  const css2 = getComputedStyle$1(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement$1(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow$1(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow$1(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement$1(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow$1(domElement);
    const offsetWin = offsetParent && isElement$1(offsetParent) ? getWindow$1(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentIFrame = getWindow$1(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow$1(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement$1(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement$1(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result2 = getOverflowAncestors(element, [], false).filter((el) => isElement$1(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result2 = result2.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result2);
  return result2;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow$1(element);
  if (!isHTMLElement(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
const getElementRects = async function(_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(floating)
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement$1,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId2;
  const root = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId2);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId2 = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
const arrow$2 = (options) => {
  const {
    element,
    padding
  } = options;
  function isRef(value) {
    return Object.prototype.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(args) {
      if (isRef(element)) {
        if (element.current != null) {
          return arrow$3({
            element: element.current,
            padding
          }).fn(args);
        }
        return {};
      } else if (element) {
        return arrow$3({
          element,
          padding
        }).fn(args);
      }
      return {};
    }
  };
};
var index$1 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length, i2, keys;
  if (a2 && b2 && typeof a2 == "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b2.length) return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function useLatestRef$1(value) {
  const ref = reactExports.useRef(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const whileElementsMountedRef = useLatestRef$1(whileElementsMounted);
  const platformRef = useLatestRef$1(platform2);
  const [reference, _setReference] = reactExports.useState(null);
  const [floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (referenceRef.current !== node) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (floatingRef.current !== node) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index$1(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$1(() => {
    if (reference && floating) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(reference, floating, update);
      } else {
        update();
      }
    }
  }, [reference, floating, update, whileElementsMountedRef]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference,
    floating
  }), [reference, floating]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    reference: setReference,
    floating: setFloating
  }), [data, update, refs, elements, setReference, setFloating]);
}
const tooltipContainer = "_tooltipContainer_g6vht_4";
const hoverTooltip = "_hoverTooltip_g6vht_15";
const popup = "_popup_g6vht_18";
const contentBody = "_contentBody_g6vht_23";
const bodyBottom = "_bodyBottom_g6vht_36";
const unset = "_unset_g6vht_41";
const arrow$1 = "_arrow_g6vht_45";
const arrowInner = "_arrowInner_g6vht_74";
const tooltipContent$1 = "_tooltipContent_g6vht_81";
const closeIcon = "_closeIcon_g6vht_88";
const s$g = {
  tooltipContainer,
  hoverTooltip,
  popup,
  contentBody,
  bodyBottom,
  unset,
  arrow: arrow$1,
  "arrow-top": "_arrow-top_g6vht_58",
  "arrow-bottom": "_arrow-bottom_g6vht_62",
  "arrow-left": "_arrow-left_g6vht_66",
  "arrow-right": "_arrow-right_g6vht_70",
  arrowInner,
  tooltipContent: tooltipContent$1,
  closeIcon
};
function mapPlacement(deprecadedPlacement) {
  switch (deprecadedPlacement) {
    case "top-left":
      return "top-start";
    case "top-right":
      return "top-end";
    case "bottom-left":
      return "bottom-start";
    case "bottom-right":
      return "bottom-end";
  }
}
function calculatePlacement(deprecadedPlacement, placement, position) {
  if (deprecadedPlacement && placement)
    console.error("You should not use both placement and deprecadedPlacement props at the same time. Placement prop will be used.");
  if (placement)
    return placement;
  if (position) {
    if (typeof deprecadedPlacement === "function") {
      return mapPlacement(deprecadedPlacement(position));
    } else if (deprecadedPlacement)
      return mapPlacement(deprecadedPlacement);
  }
  return;
}
const defaultPlacement = "top";
function Tooltip$1({ children, position, triggerRef, transitionRef, placement: placementProp, getPlacement, classes, hoverBehavior = false, onOuterClick, onClose, open = true, offset: offsetValue = 7 }) {
  const onClickOuter = reactExports.useCallback((e) => {
    if (onOuterClick && hoverBehavior === true) {
      return;
    }
    if (onOuterClick) {
      onOuterClick(e);
      return;
    }
    onClose == null ? void 0 : onClose(e);
  }, [hoverBehavior, onOuterClick, onClose]);
  const arrowRef = reactExports.useRef(null);
  const placement = reactExports.useMemo(() => calculatePlacement(getPlacement, placementProp, position) || defaultPlacement, [getPlacement, placementProp, position]);
  const { refs, x: floatingX, y: floatingY, strategy, middlewareData: { arrow: { x: arrowX2, y: arrowY2 } = {} }, placement: finalPlacement } = useFloating$1({
    placement,
    open,
    whileElementsMounted: autoUpdate,
    middleware: [offset(offsetValue), flip(), shift({ padding: 5 }), arrow$2({ element: arrowRef })]
  });
  const positionVariables = reactExports.useMemo(() => ({
    "--tooltip-arrox-x-position": arrowX2 != null ? `${arrowX2}px` : "",
    "--tooltip-arrow-y-position": arrowY2 != null ? `${arrowY2}px` : "",
    "--tooltip-x-position": `${floatingX ?? 0}px`,
    "--tooltip-y-position": `${floatingY ?? 0}px`,
    "--tooltip-placement": strategy
  }), [arrowX2, arrowY2, floatingX, floatingY, strategy]);
  const arrowSide = reactExports.useMemo(() => {
    const side = finalPlacement.split("-")[0] || defaultPlacement;
    return `arrow-${side}`;
  }, [finalPlacement]);
  reactExports.useLayoutEffect(() => {
    if (triggerRef) {
      refs.setReference(triggerRef.current);
    } else if (position) {
      const { x: x2, y: y2 } = position;
      refs.setReference({
        getBoundingClientRect() {
          return { width: 0, height: 0, x: x2, y: y2, top: y2, left: x2, right: x2, bottom: y2 };
        }
      });
    }
  }, [position, refs, triggerRef]);
  if (position && triggerRef) {
    console.error("Both position and triggerRef are provided. Tooltip will be rendered with triggerRef");
  }
  if (!position && !triggerRef) {
    console.error("Tooltip will not be rendered because neither position nor triggerRef are provided");
    return null;
  }
  if (!open)
    return null;
  const onCloseProp = hoverBehavior ? void 0 : onClose;
  return jsxRuntimeExports.jsx("div", { ref: transitionRef, className: clsx(s$g.tooltipContainer, { [s$g.hoverTooltip]: hoverBehavior }), onClick: onClickOuter, style: positionVariables, children: jsxRuntimeExports.jsxs("div", { ref: refs.setFloating, className: s$g.tooltipContent, children: [jsxRuntimeExports.jsxs("div", { className: clsx(s$g.contentBody, clsx), children: [jsxRuntimeExports.jsxs("div", { children: [children, jsxRuntimeExports.jsx("div", { className: s$g.bodyBottom })] }), onCloseProp && jsxRuntimeExports.jsx("div", { className: s$g.closeIcon, onClick: onCloseProp, children: jsxRuntimeExports.jsx(Memo$4, {}) })] }), jsxRuntimeExports.jsx("div", { ref: arrowRef, className: clsx(s$g.arrow, s$g[arrowSide]), children: jsxRuntimeExports.jsx("div", { className: s$g.arrowInner }) })] }) });
}
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result2 = inert || lookUp && node && isInert2(node.parentNode);
  return result2;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content2 = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content2, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
  return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i2 = 0; i2 < nodes.length; i2++) {
    if (nodes[i2].checked && nodes[i2].form === form) {
      return nodes[i2];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i2) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i2,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container2, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container2], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container2, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
function _extends$3() {
  _extends$3 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
var index = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
let serverHandoffComplete = false;
let count$1 = 0;
const genId = () => "floating-ui-" + count$1++;
function useFloatingId() {
  const [id, setId] = reactExports.useState(() => serverHandoffComplete ? genId() : void 0);
  index(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  reactExports.useEffect(() => {
    if (!serverHandoffComplete) {
      serverHandoffComplete = true;
    }
  }, []);
  return id;
}
const useReactId = React[/* @__PURE__ */ "useId".toString()];
const useId = useReactId || useFloatingId;
const FloatingArrow = /* @__PURE__ */ reactExports.forwardRef(function FloatingArrow2(_ref, ref) {
  var _rest$style;
  let {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow2
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d: d2,
    ...rest
  } = _ref;
  strokeWidth *= 2;
  const halfStrokeWidth = strokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const [side, alignment] = placement.split("-");
  const isRTL2 = floating ? platform.isRTL(floating) : false;
  const isCustomShape = !!d2;
  const isVerticalSide = side === "top" || side === "bottom";
  const yOffsetProp = staticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = staticOffset && alignment === "end" ? "right" : "left";
  if (staticOffset && isRTL2) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowOffsetY = isCustomShape ? 0 : halfStrokeWidth;
  const arrowX2 = (arrow2 == null ? void 0 : arrow2.x) != null ? staticOffset || arrow2.x : "";
  const arrowY2 = (arrow2 == null ? void 0 : arrow2.y) != null ? staticOffset || arrow2.y + arrowOffsetY : "";
  const dValue = d2 || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  const clipPathId = useId();
  return /* @__PURE__ */ reactExports.createElement("svg", _extends$3({}, rest, {
    // @ts-ignore
    suppressHydrationWarning: true,
    "aria-hidden": true,
    ref,
    width: isCustomShape ? width : width + strokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      ...rest.style,
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX2,
      [yOffsetProp]: arrowY2,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + strokeWidth / 2 + "px)",
      transform: "" + rotation + ((_rest$style = rest.style) != null && _rest$style.transform ? " " + rest.style.transform : "")
    }
  }), strokeWidth > 0 && /* @__PURE__ */ reactExports.createElement("path", {
    clipPath: "url(#" + clipPathId + ")",
    fill: "none",
    stroke,
    strokeWidth: strokeWidth + (d2 ? 0 : 1),
    d: dValue
  }), /* @__PURE__ */ reactExports.createElement("path", {
    stroke: strokeWidth && !d2 ? rest.fill : "none",
    d: dValue
  }), /* @__PURE__ */ reactExports.createElement("clipPath", {
    id: clipPathId
  }, /* @__PURE__ */ reactExports.createElement("rect", {
    x: -halfStrokeWidth,
    y: halfStrokeWidth * (isCustomShape ? -1 : 1),
    width: width + strokeWidth,
    height: width
  })));
});
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event2, data) {
      var _map$get;
      (_map$get = map.get(event2)) == null ? void 0 : _map$get.forEach((handler) => handler(data));
    },
    on(event2, listener) {
      map.set(event2, [...map.get(event2) || [], listener]);
    },
    off(event2, listener) {
      map.set(event2, (map.get(event2) || []).filter((l2) => l2 !== listener));
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ reactExports.createContext(null);
const FloatingTreeContext = /* @__PURE__ */ reactExports.createContext(null);
const useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = reactExports.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
const useFloatingTree = () => reactExports.useContext(FloatingTreeContext);
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function getWindow(value) {
  return getDocument(value).defaultView || window;
}
function isElement(value) {
  return value ? value instanceof getWindow(value).Element : false;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isMouseLikePointerType(pointerType, strict) {
  const values = ["mouse", "pen"];
  {
    values.push("", void 0);
  }
  return values.includes(pointerType);
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
const safePolygonIdentifier = "data-floating-ui-safe-polygon";
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  return value == null ? void 0 : value[prop];
}
const useHover = function(context2, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements: {
      domReference,
      floating
    },
    refs
  } = context2;
  const {
    enabled = true,
    delay = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = props;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef(handleClose);
  const delayRef = useLatestRef(delay);
  const pointerTypeRef = reactExports.useRef();
  const timeoutRef = reactExports.useRef();
  const handlerRef = reactExports.useRef();
  const restTimeoutRef = reactExports.useRef();
  const blockMouseMoveRef = reactExports.useRef(true);
  const performedPointerEventsMutationRef = reactExports.useRef(false);
  const unbindMouseMoveRef = reactExports.useRef(() => {
  });
  const isHoverOpen = reactExports.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  }, [dataRef]);
  reactExports.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onDismiss() {
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      blockMouseMoveRef.current = true;
    }
    events.on("dismiss", onDismiss);
    return () => {
      events.off("dismiss", onDismiss);
    };
  }, [enabled, events]);
  reactExports.useEffect(() => {
    if (!enabled || !handleCloseRef.current || !open) {
      return;
    }
    function onLeave() {
      if (isHoverOpen()) {
        onOpenChange(false);
      }
    }
    const html = getDocument(floating).documentElement;
    html.addEventListener("mouseleave", onLeave);
    return () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [floating, open, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);
  const closeWithDelay = reactExports.useCallback(function(runElseBranch) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = setTimeout(() => onOpenChange(false), closeDelay);
    } else if (runElseBranch) {
      clearTimeout(timeoutRef.current);
      onOpenChange(false);
    }
  }, [delayRef, onOpenChange]);
  const cleanupMouseMoveHandler = reactExports.useCallback(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = void 0;
  }, []);
  const clearPointerEvents = reactExports.useCallback(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(refs.floating.current).body;
      body.style.pointerEvents = "";
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  }, [refs]);
  reactExports.useEffect(() => {
    if (!enabled) {
      return;
    }
    function isClickLikeOpenEvent() {
      return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
    }
    function onMouseEnter(event2) {
      clearTimeout(timeoutRef.current);
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, "open") === 0) {
        return;
      }
      dataRef.current.openEvent = event2;
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = setTimeout(() => {
          onOpenChange(true);
        }, openDelay);
      } else {
        onOpenChange(true);
      }
    }
    function onMouseLeave(event2) {
      if (isClickLikeOpenEvent()) {
        return;
      }
      unbindMouseMoveRef.current();
      const doc = getDocument(floating);
      clearTimeout(restTimeoutRef.current);
      if (handleCloseRef.current) {
        if (!open) {
          clearTimeout(timeoutRef.current);
        }
        handlerRef.current = handleCloseRef.current({
          ...context2,
          tree,
          x: event2.clientX,
          y: event2.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            closeWithDelay();
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler);
        unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      closeWithDelay();
    }
    function onScrollMouseLeave(event2) {
      if (isClickLikeOpenEvent()) {
        return;
      }
      handleCloseRef.current == null ? void 0 : handleCloseRef.current({
        ...context2,
        tree,
        x: event2.clientX,
        y: event2.clientY,
        onClose() {
          clearPointerEvents();
          cleanupMouseMoveHandler();
          closeWithDelay();
        }
      })(event2);
    }
    if (isElement(domReference)) {
      const ref = domReference;
      open && ref.addEventListener("mouseleave", onScrollMouseLeave);
      floating == null ? void 0 : floating.addEventListener("mouseleave", onScrollMouseLeave);
      move && ref.addEventListener("mousemove", onMouseEnter, {
        once: true
      });
      ref.addEventListener("mouseenter", onMouseEnter);
      ref.addEventListener("mouseleave", onMouseLeave);
      return () => {
        open && ref.removeEventListener("mouseleave", onScrollMouseLeave);
        floating == null ? void 0 : floating.removeEventListener("mouseleave", onScrollMouseLeave);
        move && ref.removeEventListener("mousemove", onMouseEnter);
        ref.removeEventListener("mouseenter", onMouseEnter);
        ref.removeEventListener("mouseleave", onMouseLeave);
      };
    }
  }, [domReference, floating, enabled, context2, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);
  index(() => {
    var _handleCloseRef$curre;
    if (!enabled) {
      return;
    }
    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
      const body = getDocument(floating).body;
      body.setAttribute(safePolygonIdentifier, "");
      body.style.pointerEvents = "none";
      performedPointerEventsMutationRef.current = true;
      if (isElement(domReference) && floating) {
        var _tree$nodesRef$curren, _tree$nodesRef$curren2;
        const ref = domReference;
        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;
        if (parentFloating) {
          parentFloating.style.pointerEvents = "";
        }
        ref.style.pointerEvents = "auto";
        floating.style.pointerEvents = "auto";
        return () => {
          ref.style.pointerEvents = "";
          floating.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, dataRef, isHoverOpen]);
  index(() => {
    if (!open) {
      pointerTypeRef.current = void 0;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
  reactExports.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      clearPointerEvents();
    };
  }, [enabled, cleanupMouseMoveHandler, clearPointerEvents]);
  return reactExports.useMemo(() => {
    if (!enabled) {
      return {};
    }
    function setPointerRef(event2) {
      pointerTypeRef.current = event2.pointerType;
    }
    return {
      reference: {
        onPointerDown: setPointerRef,
        onPointerEnter: setPointerRef,
        onMouseMove() {
          if (open || restMs === 0) {
            return;
          }
          clearTimeout(restTimeoutRef.current);
          restTimeoutRef.current = setTimeout(() => {
            if (!blockMouseMoveRef.current) {
              onOpenChange(true);
            }
          }, restMs);
        }
      },
      floating: {
        onMouseEnter() {
          clearTimeout(timeoutRef.current);
        },
        onMouseLeave() {
          events.emit("dismiss", {
            type: "mouseLeave",
            data: {
              returnFocus: false
            }
          });
          closeWithDelay(false);
        }
      }
    };
  }, [events, enabled, restMs, open, onOpenChange, closeWithDelay]);
};
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  while (((_activeElement = activeElement2) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {
    var _activeElement, _activeElement$shadow;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
const getTabbableOptions = () => ({
  getShadowRoot: true,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function getTabbableIn(container2, direction) {
  const allTabbable = tabbable(container2, getTabbableOptions());
  if (direction === "prev") {
    allTabbable.reverse();
  }
  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container2)));
  const nextTabbableElements = allTabbable.slice(activeIndex + 1);
  return nextTabbableElements[0];
}
function getNextTabbable() {
  return getTabbableIn(document.body, "next");
}
function getPreviousTabbable() {
  return getTabbableIn(document.body, "prev");
}
function isOutsideEvent(event2, container2) {
  const containerElement = container2 || event2.currentTarget;
  const relatedTarget = event2.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}
function disableFocusInside(container2) {
  const tabbableElements = tabbable(container2, getTabbableOptions());
  tabbableElements.forEach((element) => {
    element.dataset.tabindex = element.getAttribute("tabindex") || "";
    element.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside(container2) {
  const elements = container2.querySelectorAll("[data-tabindex]");
  elements.forEach((element) => {
    const tabindex = element.dataset.tabindex;
    delete element.dataset.tabindex;
    if (tabindex) {
      element.setAttribute("tabindex", tabindex);
    } else {
      element.removeAttribute("tabindex");
    }
  });
}
const HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
let timeoutId;
function setActiveElementOnTab(event2) {
  if (event2.key === "Tab") {
    event2.target;
    clearTimeout(timeoutId);
  }
}
const FocusGuard = /* @__PURE__ */ reactExports.forwardRef(function FocusGuard2(props, ref) {
  const [role, setRole] = reactExports.useState();
  index(() => {
    if (isSafari()) {
      setRole("button");
    }
    document.addEventListener("keydown", setActiveElementOnTab);
    return () => {
      document.removeEventListener("keydown", setActiveElementOnTab);
    };
  }, []);
  return /* @__PURE__ */ reactExports.createElement("span", _extends$3({}, props, {
    ref,
    tabIndex: 0,
    role,
    "aria-hidden": role ? void 0 : true,
    "data-floating-ui-focus-guard": "",
    style: HIDDEN_STYLES
  }));
});
const PortalContext = /* @__PURE__ */ reactExports.createContext(null);
const useFloatingPortalNode = function(_temp) {
  let {
    id,
    enabled = true
  } = _temp === void 0 ? {} : _temp;
  const [portalEl, setPortalEl] = reactExports.useState(null);
  const uniqueId = useId();
  const portalContext = usePortalContext();
  index(() => {
    if (!enabled) {
      return;
    }
    const rootNode = id ? document.getElementById(id) : null;
    if (rootNode) {
      rootNode.setAttribute("data-floating-ui-portal", "");
      setPortalEl(rootNode);
    } else {
      const newPortalEl = document.createElement("div");
      if (id !== "") {
        newPortalEl.id = id || uniqueId;
      }
      newPortalEl.setAttribute("data-floating-ui-portal", "");
      setPortalEl(newPortalEl);
      const container2 = (portalContext == null ? void 0 : portalContext.portalNode) || document.body;
      container2.appendChild(newPortalEl);
      return () => {
        container2.removeChild(newPortalEl);
      };
    }
  }, [id, portalContext, uniqueId, enabled]);
  return portalEl;
};
const FloatingPortal = (_ref) => {
  let {
    children,
    id,
    root = null,
    preserveTabOrder = true
  } = _ref;
  const portalNode = useFloatingPortalNode({
    id,
    enabled: !root
  });
  const [focusManagerState, setFocusManagerState] = reactExports.useState(null);
  const beforeOutsideRef = reactExports.useRef(null);
  const afterOutsideRef = reactExports.useRef(null);
  const beforeInsideRef = reactExports.useRef(null);
  const afterInsideRef = reactExports.useRef(null);
  const shouldRenderGuards = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!focusManagerState && // Guards are only for non-modal focus management.
    !focusManagerState.modal && !!(root || portalNode) && preserveTabOrder
  );
  reactExports.useEffect(() => {
    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {
      return;
    }
    function onFocus(event2) {
      if (portalNode && isOutsideEvent(event2)) {
        const focusing = event2.type === "focusin";
        const manageFocus = focusing ? enableFocusInside : disableFocusInside;
        manageFocus(portalNode);
      }
    }
    portalNode.addEventListener("focusin", onFocus, true);
    portalNode.addEventListener("focusout", onFocus, true);
    return () => {
      portalNode.removeEventListener("focusin", onFocus, true);
      portalNode.removeEventListener("focusout", onFocus, true);
    };
  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);
  return /* @__PURE__ */ reactExports.createElement(PortalContext.Provider, {
    value: reactExports.useMemo(() => ({
      preserveTabOrder,
      beforeOutsideRef,
      afterOutsideRef,
      beforeInsideRef,
      afterInsideRef,
      portalNode,
      setFocusManagerState
    }), [preserveTabOrder, portalNode])
  }, shouldRenderGuards && portalNode && /* @__PURE__ */ reactExports.createElement(FocusGuard, {
    "data-type": "outside",
    ref: beforeOutsideRef,
    onFocus: (event2) => {
      if (isOutsideEvent(event2, portalNode)) {
        var _beforeInsideRef$curr;
        (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();
      } else {
        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        prevTabbable == null ? void 0 : prevTabbable.focus();
      }
    }
  }), shouldRenderGuards && portalNode && /* @__PURE__ */ reactExports.createElement("span", {
    "aria-owns": portalNode.id,
    style: HIDDEN_STYLES
  }), root ? /* @__PURE__ */ reactDomExports.createPortal(children, root) : portalNode ? /* @__PURE__ */ reactDomExports.createPortal(children, portalNode) : null, shouldRenderGuards && portalNode && /* @__PURE__ */ reactExports.createElement(FocusGuard, {
    "data-type": "outside",
    ref: afterOutsideRef,
    onFocus: (event2) => {
      if (isOutsideEvent(event2, portalNode)) {
        var _afterInsideRef$curre;
        (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();
      } else {
        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        nextTabbable == null ? void 0 : nextTabbable.focus();
        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false));
      }
    }
  }));
};
const usePortalContext = () => reactExports.useContext(PortalContext);
const useInsertionEffect = React[/* @__PURE__ */ "useInsertionEffect".toString()];
const useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEvent(callback) {
  const ref = reactExports.useRef(() => {
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return reactExports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
function useMergeRefs(refs) {
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
const useRole = function(context2, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    floatingId
  } = context2;
  const {
    enabled = true,
    role = "dialog"
  } = props;
  const referenceId = useId();
  return reactExports.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      role
    };
    if (!enabled) {
      return {};
    }
    if (role === "tooltip") {
      return {
        reference: {
          "aria-describedby": open ? floatingId : void 0
        },
        floating: floatingProps
      };
    }
    return {
      reference: {
        "aria-expanded": open ? "true" : "false",
        "aria-haspopup": role === "alertdialog" ? "dialog" : role,
        "aria-controls": open ? floatingId : void 0,
        ...role === "listbox" && {
          role: "combobox"
        },
        ...role === "menu" && {
          id: referenceId
        }
      },
      floating: {
        ...floatingProps,
        ...role === "menu" && {
          "aria-labelledby": referenceId
        }
      }
    };
  }, [enabled, role, open, floatingId, referenceId]);
};
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    open = false,
    onOpenChange: unstable_onOpenChange,
    nodeId
  } = options;
  const position = useFloating$1(options);
  const tree = useFloatingTree();
  const domReferenceRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef({});
  const events = reactExports.useState(() => createPubSub())[0];
  const floatingId = useId();
  const [domReference, setDomReference] = reactExports.useState(null);
  const setPositionReference = reactExports.useCallback((node) => {
    const positionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    position.refs.setReference(positionReference);
  }, [position.refs]);
  const setReference = reactExports.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = reactExports.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = reactExports.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const onOpenChange = useEvent(unstable_onOpenChange);
  const context2 = reactExports.useMemo(() => ({
    ...position,
    refs,
    elements,
    dataRef,
    nodeId,
    floatingId,
    events,
    open,
    onOpenChange
  }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);
  index(() => {
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context2;
    }
  });
  return reactExports.useMemo(() => ({
    ...position,
    context: context2,
    refs,
    elements,
    reference: setReference,
    positionReference: setPositionReference
  }), [position, refs, elements, context2, setReference, setPositionReference]);
}
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  return {
    ...elementKey === "floating" && {
      tabIndex: -1
    },
    ...userProps,
    ...propsList.map((value) => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.forEach((fn) => fn(...args));
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
const useInteractions = function(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const deps = propsList;
  const getReferenceProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  const getFloatingProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  const getItemProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    propsList.map((key) => key == null ? void 0 : key.item)
  );
  return reactExports.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
};
function createContext(rootName, defaultContext) {
  const Ctx = React$1.createContext(defaultContext);
  function Provider(props) {
    const { children, ...context2 } = props;
    const value = React$1.useMemo(() => context2, Object.values(context2));
    return jsxRuntimeExports.jsx(Ctx.Provider, { value, children });
  }
  function useContext(childName) {
    const context2 = React$1.useContext(Ctx);
    if (context2) {
      return context2;
    }
    throw Error(`${childName} must be rendered inside of a ${rootName} component.`);
  }
  Ctx.displayName = `${rootName}Context`;
  Provider.displayName = `${rootName}Provider`;
  return [Provider, useContext];
}
const [TooltipProvider, useTooltipContext] = createContext("Tooltip");
const TooltipTrigger = reactExports.forwardRef(function TooltipTrigger2({ children, asChild = false, ...props }, propRef) {
  const { context: context2 } = useTooltipContext("Tooltip");
  const childrenRef = (children == null ? void 0 : children.ref) ?? null;
  const ref = useMergeRefs([context2.refs.setReference, propRef, childrenRef]);
  reactExports.useLayoutEffect(() => {
    if (propRef) {
      context2.refs.setReference(propRef == null ? void 0 : propRef.current);
    }
  }, []);
  if (propRef)
    return null;
  if (asChild && reactExports.isValidElement(children)) {
    return reactExports.cloneElement(children, context2.getReferenceProps({
      ref,
      ...props,
      ...children.props
    }));
  }
  return jsxRuntimeExports.jsx("div", { ref, ...context2.getReferenceProps(props), children });
});
const tooltipContent = "_tooltipContent_17m80_3";
const bigger = "_bigger_17m80_14";
const arrow = "_arrow_17m80_26";
const s$f = {
  tooltipContent,
  bigger,
  "default": "_default_17m80_20",
  arrow
};
const TooltipContent = reactExports.forwardRef(function TooltipContent2(props, propRef) {
  const { context: context2, arrowRef, size } = useTooltipContext("Tooltip");
  const ref = useMergeRefs([context2.refs.setFloating, propRef]);
  const { children, ...rest } = props;
  return jsxRuntimeExports.jsx(FloatingPortal, { children: context2.open && jsxRuntimeExports.jsxs("div", { className: clsx(s$f.tooltipContent, s$f[size ?? "default"]), ref, style: {
    position: context2.strategy,
    top: context2.y ?? 0,
    left: context2.x ?? 0,
    visibility: context2.x == null ? "hidden" : "visible"
  }, ...context2.getFloatingProps(rest), children: [children, jsxRuntimeExports.jsx(FloatingArrow, { ref: arrowRef, context: context2.context, className: s$f.arrow, stroke: "transparent", strokeWidth: 2, height: 8, width: 16 })] }) });
});
const ARROW_HEIGHT = 8;
function useTooltip({ initialOpen = false, placement = "bottom", offset: offsetValue = 0, open: controlledOpen, onOpenChange: setControlledOpen } = {}, arrowRef) {
  const [uncontrolledOpen, setUncontrolledOpen] = reactExports.useState(initialOpen);
  const open = controlledOpen ?? uncontrolledOpen;
  const setOpen = setControlledOpen ?? setUncontrolledOpen;
  const data = useFloating({
    placement,
    open,
    onOpenChange: setOpen,
    whileElementsMounted: autoUpdate,
    middleware: [
      offset(offsetValue + ARROW_HEIGHT),
      flip({ fallbackAxisSideDirection: "start" }),
      shift({ padding: 5 }),
      arrow$2({ element: arrowRef })
    ]
  });
  const context2 = data.context;
  const hover = useHover(context2);
  const role = useRole(context2, { role: "tooltip" });
  const interactions = useInteractions([hover, role]);
  return reactExports.useMemo(() => ({
    open,
    setOpen,
    ...interactions,
    ...data
  }), [open, setOpen, interactions, data]);
}
function Tooltip({ children, ...options }) {
  const arrowRef = reactExports.useRef(null);
  const context2 = useTooltip(options, arrowRef);
  return jsxRuntimeExports.jsx(TooltipProvider, { context: context2, arrowRef, size: options.size, children });
}
const legendTitle = "_legendTitle_sgaz8_1";
const grid = "_grid_sgaz8_6";
const cell = "_cell_sgaz8_11";
const colorCell = "_colorCell_sgaz8_17";
const yStepsCell = "_yStepsCell_sgaz8_26";
const xStepsCell = "_xStepsCell_sgaz8_45";
const xStepsCellNoLabel = "_xStepsCellNoLabel_sgaz8_46";
const arrowX = "_arrowX_sgaz8_70";
const arrowY = "_arrowY_sgaz8_71";
const axisLabelX = "_axisLabelX_sgaz8_88";
const axisLabelY = "_axisLabelY_sgaz8_89";
const arrowHeadX = "_arrowHeadX_sgaz8_107";
const arrowHeadY = "_arrowHeadY_sgaz8_108";
const arrowHeadY_angle0 = "_arrowHeadY_angle0_sgaz8_123";
const styles$7 = {
  legendTitle,
  grid,
  cell,
  colorCell,
  yStepsCell,
  xStepsCell,
  xStepsCellNoLabel,
  arrowX,
  arrowY,
  axisLabelX,
  axisLabelY,
  arrowHeadX,
  arrowHeadY,
  arrowHeadY_angle0
};
function createTreads() {
  const treads = {};
  return {
    increment: (treadId) => {
      if (typeof treads[treadId] === "number") {
        treads[treadId] += 1;
      } else {
        treads[treadId] = 0;
      }
      return treads[treadId];
    }
  };
}
function fillTemplate(template, data) {
  const order = [];
  const treads = createTreads();
  template.forEach((row2, y2) => {
    row2.split(" ").forEach((cell2, x2) => {
      const position = treads.increment(cell2);
      const dataCell = data[cell2] && data[cell2][position];
      if (dataCell) {
        order.push({ ...dataCell, _position: { x: x2, y: y2 } });
      }
    });
  });
  return order;
}
function safeReverse(arr) {
  return [...arr].reverse();
}
const getCellPositionStyle = (col, row2) => ({
  gridColumn: `${col + 1} / ${col + 2}`,
  gridRow: `${row2 + 1} / ${row2 + 2}`
});
const ArrowHead = ({ className, type }) => jsxRuntimeExports.jsx("div", { className, children: type === "horizontal" ? jsxRuntimeExports.jsx("svg", { width: "6", height: "12", viewBox: "0 0 6 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsxRuntimeExports.jsx("path", { d: "M6,6L0,0l0,2.4L3.6,6L0,9.6L0,12L6,6z", fill: "currentColor" }) }) : jsxRuntimeExports.jsx("svg", { width: "12", height: "6", viewBox: "0 0 12 6", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsxRuntimeExports.jsx("path", { d: "M6,0L0,6l2.4,0L6,2.4L9.6,6L12,6L6,0z", fill: "currentColor" }) }) });
function Legend({ cells: cells2, size, axis: axis2, title, showAxisLabels = false, showSteps = true, showArrowHeads = true, onCellPointerOver, onCellPointerLeave, renderXAxisLabel, renderYAxisLabel }) {
  const TEMPLATE = reactExports.useMemo(() => [
    `y ${new Array(size + 1).fill(".").join(" ")}`,
    ...new Array(size).fill(`y ${new Array(size).fill("c").join(" ")} .`),
    `. ${new Array(size + 1).fill("x").join(" ")}`
  ], [size]);
  const gridCells = fillTemplate(TEMPLATE, {
    x: showSteps ? axis2.x.steps.map((step) => ({
      label: step.label || step.value.toFixed(1),
      className: styles$7.xStepsCell
    })) : axis2.x.steps.map((step) => ({
      label: "",
      className: styles$7.xStepsCellNoLabel
    })),
    y: showSteps ? safeReverse(axis2.y.steps).map((step) => ({
      label: step.label || step.value.toFixed(1),
      className: styles$7.yStepsCell
    })) : safeReverse(axis2.y.steps).map((step) => ({
      label: "",
      className: styles$7.yStepsCellNoLabel
    })),
    c: cells2.map((cell2, i2) => ({
      label: jsxRuntimeExports.jsx("span", { children: cell2.label }),
      className: clsx(styles$7.cell, styles$7.colorCell),
      style: { backgroundColor: cell2.color },
      ...onCellPointerOver && { onPointerOver: (e) => onCellPointerOver(e, cell2, i2) },
      ...onCellPointerLeave && { onPointerLeave: (e) => onCellPointerLeave(e, cell2, i2) }
    }))
  });
  const xAxisLabel = () => renderXAxisLabel ? renderXAxisLabel(axis2.x, styles$7.axisLabelX) : jsxRuntimeExports.jsx("div", { className: styles$7.axisLabelX, children: axis2.x.label });
  const yAxisLabel = () => renderYAxisLabel ? renderYAxisLabel(axis2.y, styles$7.axisLabelY) : jsxRuntimeExports.jsx("div", { className: styles$7.axisLabelY, children: axis2.y.label });
  return jsxRuntimeExports.jsxs("div", { children: [title && jsxRuntimeExports.jsx("div", { className: styles$7.legendTitle, children: title }), jsxRuntimeExports.jsxs("div", { className: styles$7.grid, style: {
    gridTemplateColumns: `repeat(${size + 2}, auto)`,
    gridTemplateRows: `repeat(${size + 2}, auto)`
  }, children: [showAxisLabels && axis2.x.label ? xAxisLabel() : null, showAxisLabels && axis2.y.label ? yAxisLabel() : null, jsxRuntimeExports.jsx("div", { className: styles$7.arrowX, children: showArrowHeads && jsxRuntimeExports.jsx(ArrowHead, { type: "horizontal", className: styles$7.arrowHeadX }) }), jsxRuntimeExports.jsx("div", { className: styles$7.arrowY, children: showArrowHeads && jsxRuntimeExports.jsx(ArrowHead, { type: "vertical", className: clsx({ [styles$7.arrowHeadY]: true, [styles$7.arrowHeadY_angle0]: !showAxisLabels }) }) }), gridCells.map((cell2) => jsxRuntimeExports.jsx("div", { style: Object.assign(getCellPositionStyle(cell2._position.x, cell2._position.y), cell2.style), className: clsx(cell2.className, styles$7.cell), onPointerOver: cell2.onPointerOver, onPointerLeave: cell2.onPointerLeave, children: cell2.label }, `${cell2._position.x}|${cell2._position.y}`))] })] });
}
class ConfigRepository {
  constructor() {
    __privateAdd(this, _config);
    /* -- Intercom staff -- */
    __privateAdd(this, _readSessionIntercomSetting, (key) => sessionStorage.getItem(`kontur.intercom.${key}`));
    __privateAdd(this, _setIntercomSetting, (k2, v2) => {
      const key = `kontur.intercom.${k2}`;
      v2 ? sessionStorage.setItem(key, v2) : sessionStorage.removeItem(key);
    });
  }
  set({
    baseUrl,
    initialUrl,
    initialUrlData,
    stageConfig,
    appConfig,
    baseMapUrl,
    initialUser,
    defaultLayers,
    activeLayers
  }) {
    __privateSet(this, _config, {
      baseUrl,
      initialUrl,
      initialUrlData,
      ...stageConfig,
      ...appConfig,
      mapBaseStyle: baseMapUrl,
      features: Object.keys(appConfig.features).length > 0 ? appConfig.features : stageConfig.featuresByDefault,
      initialUser,
      defaultLayers,
      activeLayers
    });
  }
  get() {
    return __privateGet(this, _config);
  }
  getIntercomSettings() {
    return {
      intercomAppId: __privateGet(this, _config).intercomAppId,
      intercomSelector: __privateGet(this, _config).intercomSelector,
      name: __privateGet(this, _readSessionIntercomSetting).call(this, "name"),
      email: __privateGet(this, _readSessionIntercomSetting).call(this, "email")
    };
  }
  updateIntercomSettings(settings) {
    Object.entries(settings).forEach(([k2, v2]) => __privateGet(this, _setIntercomSetting).call(this, k2, v2));
  }
}
_config = new WeakMap();
_readSessionIntercomSetting = new WeakMap();
_setIntercomSetting = new WeakMap();
const configRepo = new ConfigRepository();
const NAVIGATE_EVENT = "KNT_NAVIGATE_TO";
const goTo = (slug) => {
  const evt = new CustomEvent(NAVIGATE_EVENT, { detail: { payload: slug } });
  globalThis.dispatchEvent(evt);
};
const goTo$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NAVIGATE_EVENT,
  goTo
}, Symbol.toStringTag, { value: "Module" }));
function isExternalLink(href) {
  const externalProtocols = ["http://", "https://", "mailto:"];
  return externalProtocols.some((protocol) => href.startsWith(protocol));
}
function isInnerAnchorLink(href) {
  return href.indexOf("#") === 0;
}
function buildAssetUrl(asset) {
  return `${configRepo.get().apiGateway}/apps/${configRepo.get().id}/assets/${asset}`;
}
function CustomImg({
  title,
  alt,
  src
}) {
  let realSrc = src;
  if (!isExternalLink(src)) {
    realSrc = buildAssetUrl(src);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: realSrc, alt, title });
}
function CustomLink({
  children,
  href,
  title
}) {
  const handleClick = reactExports.useCallback(
    (e) => {
      if (isInnerAnchorLink(href)) {
        return;
      }
      goTo(href);
      e.preventDefault();
    },
    [href]
  );
  if (isExternalLink(href)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("a", { title, href, target: "_blank", rel: "noreferrer", className: "external", children });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("a", { title, href, onClick: handleClick, className: "internal", children });
}
function wrapContentInSection(content2) {
  const result2 = [];
  const stack = [];
  let keyCounter = 0;
  const wrapAndPushContent = (level) => {
    while (stack.length > 0 && stack[stack.length - 1].level >= level) {
      const { level: stackLevel, content: content22 } = stack.pop();
      if (content22.length > 0) {
        const wrappedContent = React$1.createElement(
          "div",
          {
            className: `wrap-h${stackLevel}`,
            key: `div-h${stackLevel}-${++keyCounter}`
          },
          content22
        );
        if (stack.length > 0) {
          stack[stack.length - 1].content.push(wrappedContent);
        } else {
          result2.push(wrappedContent);
        }
      }
    }
  };
  const processElement = (element) => {
    const headingMatch = element.type.toString().match(/^h([1-6])$/);
    if (headingMatch) {
      const level = Number.parseInt(headingMatch[1]);
      wrapAndPushContent(level);
      const clonedElement = React$1.cloneElement(element, {
        key: `heading-${++keyCounter}`
      });
      if (stack.length > 0 && level > stack[stack.length - 1].level) {
        stack[stack.length - 1].content.push(clonedElement);
      } else {
        result2.push(clonedElement);
      }
      stack.push({ level, content: [] });
    } else {
      const clonedElement = React$1.cloneElement(element, {
        key: `content-${++keyCounter}`
      });
      if (stack.length > 0) {
        stack[stack.length - 1].content.push(clonedElement);
      } else {
        result2.push(clonedElement);
      }
    }
  };
  React$1.Children.forEach(content2, (element) => {
    if (React$1.isValidElement(element)) {
      processElement(element);
    }
  });
  wrapAndPushContent(0);
  return result2;
}
function splitIntoSections(compiled) {
  const sections = [];
  let currentSection = [];
  React$1.Children.forEach(compiled, (element) => {
    if (React$1.isValidElement(element) && element.type === "hr") {
      if (currentSection.length > 0) {
        sections.push(currentSection);
        currentSection = [];
      }
    } else {
      currentSection.push(element);
    }
  });
  if (currentSection.length > 0) {
    sections.push(currentSection);
  }
  return sections;
}
function structureMarkdownContent(compiled) {
  const sections = splitIntoSections(compiled);
  return sections.map(
    (section, index2) => React$1.createElement(
      "section",
      { key: `section-${index2}` },
      wrapContentInSection(section)
    )
  );
}
const isString$1 = (obj) => typeof obj === "string";
const defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
const makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
const copy = (a2, s2, t2) => {
  a2.forEach((m2) => {
    if (s2[m2]) t2[m2] = s2[m2];
  });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
const canNotTraverseDeeper = (object) => !object || isString$1(object);
const getLastOfPath = (object, path2, Empty) => {
  const stack = !isString$1(path2) ? path2 : path2.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
const setPath = (object, path2, newValue) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path2, Object);
  if (obj !== void 0 || path2.length === 1) {
    obj[k2] = newValue;
    return;
  }
  let e = path2[path2.length - 1];
  let p2 = path2.slice(0, path2.length - 1);
  let last2 = getLastOfPath(object, p2, Object);
  while (last2.obj === void 0 && p2.length) {
    e = `${p2[p2.length - 1]}.${e}`;
    p2 = p2.slice(0, p2.length - 1);
    last2 = getLastOfPath(object, p2, Object);
    if (last2 && last2.obj && typeof last2.obj[`${last2.k}.${e}`] !== "undefined") {
      last2.obj = void 0;
    }
  }
  last2.obj[`${last2.k}.${e}`] = newValue;
};
const pushPath = (object, path2, newValue, concat2) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path2, Object);
  obj[k2] = obj[k2] || [];
  obj[k2].push(newValue);
};
const getPath = (object, path2) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path2);
  if (!obj) return void 0;
  return obj[k2];
};
const getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
};
const deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString$1(target[prop]) || target[prop] instanceof String || isString$1(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
const regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const escape = (data) => {
  if (isString$1(data)) {
    return data.replace(/[&<>"'\/]/g, (s2) => _entityMap[s2]);
  }
  return data;
};
class RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
}
const chars = [" ", ",", "?", "!", ";"];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c2) => nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0);
  if (possibleChars.length === 0) return true;
  const r2 = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c2) => c2 === "?" ? "\\?" : c2).join("|")})`);
  let matched = !r2.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r2.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
const deepFind = function(obj, path2) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return void 0;
  if (obj[path2]) return obj[path2];
  const tokens = path2.split(keySeparator);
  let current = obj;
  for (let i2 = 0; i2 < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j2 = i2; j2 < tokens.length; ++j2) {
      if (j2 !== i2) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j2];
      next = current[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j2 < tokens.length - 1) {
          continue;
        }
        i2 += j2 - i2 + 1;
        break;
      }
    }
    current = next;
  }
  return current;
};
const getCleanedCode = (code) => code && code.replace("_", "-");
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    if (console && console[type]) console[type].apply(console, args);
  }
};
class Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString$1(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
}
var baseLogger = new Logger();
class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event2) => {
      if (!this.observers[event2]) this.observers[event2] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event2].get(listener) || 0;
      this.observers[event2].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event2, listener) {
    if (!this.observers[event2]) return;
    if (!listener) {
      delete this.observers[event2];
      return;
    }
    this.observers[event2].delete(listener);
  }
  emit(event2) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event2]) {
      const cloned = Array.from(this.observers[event2].entries());
      cloned.forEach((_ref) => {
        let [observer, numTimesAdded] = _ref;
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer.apply(observer, [event2, ...args]);
        }
      });
    }
  }
}
class ResourceStore extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index2 = this.options.ns.indexOf(ns);
    if (index2 > -1) {
      this.options.ns.splice(index2, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path2;
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
    } else {
      path2 = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path2.push(...key);
        } else if (isString$1(key) && keySeparator) {
          path2.push(...key.split(keySeparator));
        } else {
          path2.push(key);
        }
      }
    }
    const result2 = getPath(this.data, path2);
    if (!result2 && !ns && !key && lng.indexOf(".") > -1) {
      lng = path2[0];
      ns = path2[1];
      key = path2.slice(2).join(".");
    }
    if (result2 || !ignoreJSONStructure || !isString$1(key)) return result2;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path2 = [lng, ns];
    if (key) path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      value = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path2, value);
    if (!options.silent) this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m2 in resources) {
      if (isString$1(resources[m2]) || Array.isArray(resources[m2])) this.addResource(lng, ns, m2, resources[m2], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path2 = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path2) || {};
    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path2, pack);
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1") return {
      ...{},
      ...this.getResource(lng, ns)
    };
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n2 = data && Object.keys(data) || [];
    return !!n2.find((v2) => data[v2] && Object.keys(data[v2]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
const checkedLoadedFor = {};
class Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved && resolved.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m2 = key.match(this.interpolator.nestingRegexp);
      if (m2 && m2.length > 0) {
        return {
          key,
          namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    if (isString$1(namespaces)) namespaces = [namespaces];
    return {
      key,
      namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object") options = {
      ...options
    };
    if (!options) options = {};
    if (keys === void 0 || keys === null) return "";
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, options);
    let res = resolved && resolved.res;
    const resUsedKey = resolved && resolved.usedKey || key;
    const resExactUsedKey = resolved && resolved.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = !isString$1(res) && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(isString$1(joinArrays) && Array.isArray(res))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r2;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r2;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(res);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m2 in res) {
          if (Object.prototype.hasOwnProperty.call(res, m2)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m2}`;
            copy2[m2] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy2[m2] === deepKey) copy2[m2] = res[m2];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString$1(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && !isString$1(options.count);
      const hasDefaultValue = Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i2 = 0; i2 < fallbackLngs.length; i2++) {
            lngs.push(fallbackLngs[i2]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l2, k2, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l2, namespace, k2, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init({
        ...options,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...options.interpolation
          }
        }
      });
      const skipOnVariables = isString$1(res) && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && !isString$1(options.replace) ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res) options.lng = this.language || resolved.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastKey && lastKey[0] === args[0] && !options.context) {
          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return _this.translate(...args, key);
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = isString$1(postProcess) ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString$1(keys)) keys = [keys];
    keys.forEach((k2) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k2, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && !isString$1(options.count);
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (isString$1(options.context) || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString$1(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
}
const capitalize$1 = (string) => string.charAt(0).toUpperCase() + string.slice(1);
class LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p2 = code.split("-");
    if (p2.length === 2) return null;
    p2.pop();
    if (p2[p2.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p2.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p2 = code.split("-");
    return this.formatLanguageCode(p2[0]);
  }
  formatLanguageCode(code) {
    if (isString$1(code) && code.indexOf("-") > -1) {
      if (typeof Intl !== "undefined" && typeof Intl.getCanonicalLocales !== "undefined") {
        try {
          let formattedCode = Intl.getCanonicalLocales(code)[0];
          if (formattedCode && this.options.lowerCaseLng) {
            formattedCode = formattedCode.toLowerCase();
          }
          if (formattedCode) return formattedCode;
        } catch (e) {
        }
      }
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p2 = code.split("-");
      if (this.options.lowerCaseLng) {
        p2 = p2.map((part) => part.toLowerCase());
      } else if (p2.length === 2) {
        p2[0] = p2[0].toLowerCase();
        p2[1] = p2[1].toUpperCase();
        if (specialCases.indexOf(p2[1].toLowerCase()) > -1) p2[1] = capitalize$1(p2[1].toLowerCase());
      } else if (p2.length === 3) {
        p2[0] = p2[0].toLowerCase();
        if (p2[1].length === 2) p2[1] = p2[1].toUpperCase();
        if (p2[0] !== "sgn" && p2[2].length === 2) p2[2] = p2[2].toUpperCase();
        if (specialCases.indexOf(p2[1].toLowerCase()) > -1) p2[1] = capitalize$1(p2[1].toLowerCase());
        if (specialCases.indexOf(p2[2].toLowerCase()) > -1) p2[2] = capitalize$1(p2[2].toLowerCase());
      }
      return p2.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString$1(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c2) => {
      if (!c2) return;
      if (this.isSupportedCode(c2)) {
        codes.push(c2);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c2}`);
      }
    };
    if (isString$1(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString$1(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
}
let sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
let _rulesPluralsTypes = {
  1: (n2) => Number(n2 > 1),
  2: (n2) => Number(n2 != 1),
  3: (n2) => 0,
  4: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  5: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5),
  6: (n2) => Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2),
  7: (n2) => Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  8: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3),
  9: (n2) => Number(n2 >= 2),
  10: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4),
  11: (n2) => Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3),
  12: (n2) => Number(n2 % 10 != 1 || n2 % 100 == 11),
  13: (n2) => Number(n2 !== 0),
  14: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3),
  15: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  16: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2),
  17: (n2) => Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1),
  18: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2),
  19: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3),
  20: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2),
  21: (n2) => Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0),
  22: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3)
};
const nonIntlVersions = ["v1", "v2", "v3"];
const intlVersions = ["v4"];
const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const createRules = () => {
  const rules = {};
  sets.forEach((set) => {
    set.lngs.forEach((l2) => {
      rules[l2] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
};
class PluralResolver {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      try {
        const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
        const type = options.ordinal ? "ordinal" : "cardinal";
        const cacheKey = JSON.stringify({
          cleanedCode,
          type
        });
        if (cacheKey in this.pluralRulesCache) {
          return this.pluralRulesCache[cacheKey];
        }
        const rule = new Intl.PluralRules(cleanedCode, {
          type
        });
        this.pluralRulesCache[cacheKey] = rule;
        return rule;
      } catch (err) {
        return;
      }
    }
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }
    return rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (!rule) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    return rule.numbers.map((number) => this.getSuffix(code, number, options));
  }
  getSuffix(code, count2) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      if (this.shouldUseIntlApi()) {
        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count2)}`;
      }
      return this.getSuffixRetroCompatible(rule, count2);
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return "";
  }
  getSuffixRetroCompatible(rule, count2) {
    const idx = rule.noAbs ? rule.plurals(count2) : rule.plurals(Math.abs(count2));
    let suffix = rule.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = "plural";
      } else if (suffix === 1) {
        suffix = "";
      }
    }
    const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
    if (this.options.compatibilityJSON === "v1") {
      if (suffix === 1) return "";
      if (typeof suffix === "number") return `_plural_${suffix.toString()}`;
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
}
const deepFindWithDefaults = function(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path2 = getPathWithDefaults(data, defaultData, key);
  if (!path2 && ignoreJSONStructure && isString$1(key)) {
    path2 = deepFind(data, key, keySeparator);
    if (path2 === void 0) path2 = deepFind(defaultData, key, keySeparator);
  }
  return path2;
};
const regexSafe = (val) => val.replace(/\$/g, "$$$$");
class Interpolator {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value) => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp && existingRegExp.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path2 = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path2, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path2;
      }
      const p2 = key.split(this.formatSeparator);
      const k2 = p2.shift().trim();
      const f2 = p2.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k2, this.options.keySeparator, this.options.ignoreJSONStructure), f2, lng, {
        ...options,
        ...data,
        interpolationkey: k2
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = isString$1(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (!isString$1(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c2 = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c2[1]}`;
      key = c2[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString$1(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r2 = match[1].split(this.formatSeparator).map((elem) => elem.trim());
        match[1] = r2.shift();
        formatters = r2;
        doReduce = true;
      }
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString$1(value)) return value;
      if (!isString$1(value)) value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (doReduce) {
        value = formatters.reduce((v2, f2) => this.format(v2, f2, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}
const parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    const optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
const createCachedFormatter = (fn) => {
  const cache = {};
  return (val, lng, options) => {
    let optForCache = options;
    if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options.interpolationkey]: void 0
      };
    }
    const key = lng + JSON.stringify(optForCache);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
};
class Formatter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => (val) => new Intl.NumberFormat(lng, {
        ...opt
      }).format(val)),
      currency: createCachedFormatter((lng, opt) => (val) => new Intl.NumberFormat(lng, {
        ...opt,
        style: "currency"
      }).format(val)),
      datetime: createCachedFormatter((lng, opt) => (val) => new Intl.DateTimeFormat(lng, {
        ...opt
      }).format(val)),
      relativetime: createCachedFormatter((lng, opt) => (val) => new Intl.RelativeTimeFormat(lng, {
        ...opt
      }).format(val, opt.range || "day")),
      list: createCachedFormatter((lng, opt) => (val) => new Intl.ListFormat(lng, {
        ...opt
      }).format(val))
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = options.interpolation.formatSeparator || ",";
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f2) => f2.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f2) => f2.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result2 = formats.reduce((mem, f2) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f2);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l2, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error2) {
          this.logger.warn(error2);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result2;
  }
}
const removePending = (q2, name) => {
  if (q2.pending[name] !== void 0) {
    delete q2.pending[name];
    q2.pendingCount--;
  }
};
class Connector extends EventEmitter {
  constructor(backend, store2, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store2;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0) ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0) pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0) pending[name] = true;
          if (toLoad[name] === void 0) toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s2 = name.split("|");
    const lng = s2[0];
    const ns = s2[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    if (err && data) this.state[name] = 0;
    const loaded = {};
    this.queue.forEach((q2) => {
      pushPath(q2.loaded, [lng], ns);
      removePending(q2, name);
      if (err) q2.errors.push(err);
      if (q2.pendingCount === 0 && !q2.done) {
        Object.keys(q2.loaded).forEach((l2) => {
          if (!loaded[l2]) loaded[l2] = {};
          const loadedKeys = q2.loaded[l2];
          if (loadedKeys.length) {
            loadedKeys.forEach((n2) => {
              if (loaded[l2][n2] === void 0) loaded[l2][n2] = true;
            });
          }
        });
        q2.done = true;
        if (q2.errors.length) {
          q2.callback(q2.errors);
        } else {
          q2.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q2) => !q2.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait: wait2,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver2 = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait2 * 2, callback);
        }, wait2);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r2 = fc(lng, ns);
        if (r2 && typeof r2.then === "function") {
          r2.then((data) => resolver2(null, data)).catch(resolver2);
        } else {
          resolver2(null, r2);
        }
      } catch (err) {
        resolver2(err);
      }
      return;
    }
    return fc(lng, ns, resolver2);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString$1(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString$1(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s2 = name.split("|");
    const lng = s2[0];
    const ns = s2[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend && this.backend.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r2;
          if (fc.length === 5) {
            r2 = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r2 = fc(languages, namespace, key, fallbackValue);
          }
          if (r2 && typeof r2.then === "function") {
            r2.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r2);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
}
const get = () => ({
  debug: false,
  initImmediate: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString$1(args[1])) ret.defaultValue = args[1];
    if (isString$1(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value) => value,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  }
});
const transformOptions = (options) => {
  if (isString$1(options.ns)) options.ns = [options.ns];
  if (isString$1(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString$1(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
};
const noop$1 = () => {
};
const bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
class I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (isString$1(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation
      };
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s2 = this.services;
      s2.logger = baseLogger;
      s2.resourceStore = this.store;
      s2.languageUtils = lu;
      s2.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s2.formatter = createClassOnDemand(formatter);
        s2.formatter.init(s2, this.options);
        this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
      }
      s2.interpolator = new Interpolator(this.options);
      s2.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
      s2.backendConnector.on("*", function(event2) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event2, ...args);
      });
      if (this.modules.languageDetector) {
        s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s2.languageDetector.init) s2.languageDetector.init(s2, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s2.i18nFormat.init) s2.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event2) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event2, ...args);
      });
      this.modules.external.forEach((m2) => {
        if (m2.init) m2.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop$1;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred2 = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred2.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred2;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1;
    let usedCallback = callback;
    const usedLng = isString$1(language) ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l2) => {
          if (l2 === "cimode") return;
          if (toLoad.indexOf(l2) < 0) toLoad.push(l2);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l2) => append(l2));
      } else {
        append(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l2) => append(l2));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred2 = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop$1;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred2.resolve();
      callback(err);
    });
    return deferred2;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l2) {
    if (!l2 || !this.languages) return;
    if (["cimode", "dev"].indexOf(l2) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred2 = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l2) => {
      this.language = l2;
      this.languages = this.services.languageUtils.toResolveHierarchy(l2);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l2);
    };
    const done = (err, l2) => {
      if (l2) {
        setLngProps(l2);
        this.translator.changeLanguage(l2);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l2);
        this.logger.log("languageChanged", l2);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred2.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback) callback(err, function() {
        return _this2.t(...arguments);
      });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const l2 = isString$1(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l2) {
        if (!this.language) {
          setLngProps(l2);
        }
        if (!this.translator.language) this.translator.changeLanguage(l2);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l2);
      }
      this.loadResources(l2, (err) => {
        done(err, l2);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred2;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      if (options.keyPrefix !== "") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k2) => `${options.keyPrefix}${keySeparator}${k2}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (isString$1(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l2, n2) => {
      const loadState = this.services.backendConnector.state[`${l2}|${n2}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred2 = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString$1(ns)) ns = [ns];
    ns.forEach((n2) => {
      if (this.options.ns.indexOf(n2) < 0) this.options.ns.push(n2);
    });
    this.loadResources((err) => {
      deferred2.resolve();
      if (callback) callback(err);
    });
    return deferred2;
  }
  loadLanguages(lngs, callback) {
    const deferred2 = defer();
    if (isString$1(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred2.resolve();
      if (callback) callback(err);
    });
    return deferred2;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m2) => {
      clone[m2] = this[m2];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      clone.store = new ResourceStore(this.store.data, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", function(event2) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone.emit(event2, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
const htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "©",
  "&#169;": "©",
  "&reg;": "®",
  "&#174;": "®",
  "&hellip;": "…",
  "&#8230;": "…",
  "&#x2F;": "/",
  "&#47;": "/"
};
const unescapeHtmlEntity = (m2) => htmlEntities[m2];
const unescape = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);
let defaultOptions$1 = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape
};
const setDefaults = (options = {}) => {
  defaultOptions$1 = {
    ...defaultOptions$1,
    ...options
  };
};
const initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults(instance2.options.react);
  }
};
const {
  slice,
  forEach
} = [];
function defaults(obj) {
  forEach.call(slice.call(arguments, 1), (source) => {
    if (source) {
      for (const prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
const serializeCookie = (name, val, options) => {
  const opt = options || {};
  opt.path = opt.path || "/";
  const value = encodeURIComponent(val);
  let str = `${name}=${value}`;
  if (opt.maxAge > 0) {
    const maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge)) throw new Error("maxAge should be a Number");
    str += `; Max-Age=${Math.floor(maxAge)}`;
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += `; Domain=${opt.domain}`;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += `; Path=${opt.path}`;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) str += "; HttpOnly";
  if (opt.secure) str += "; Secure";
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
const cookie = {
  create(name, value, minutes, domain) {
    let cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    if (minutes) {
      cookieOptions.expires = /* @__PURE__ */ new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
    }
    if (domain) cookieOptions.domain = domain;
    document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);
  },
  read(name) {
    const nameEQ = `${name}=`;
    const ca = document.cookie.split(";");
    for (let i2 = 0; i2 < ca.length; i2++) {
      let c2 = ca[i2];
      while (c2.charAt(0) === " ") c2 = c2.substring(1, c2.length);
      if (c2.indexOf(nameEQ) === 0) return c2.substring(nameEQ.length, c2.length);
    }
    return null;
  },
  remove(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  // Deconstruct the options object and extract the lookupCookie property
  lookup(_ref) {
    let {
      lookupCookie
    } = _ref;
    if (lookupCookie && typeof document !== "undefined") {
      return cookie.read(lookupCookie) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupCookie,
      cookieMinutes,
      cookieDomain,
      cookieOptions
    } = _ref2;
    if (lookupCookie && typeof document !== "undefined") {
      cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  // Deconstruct the options object and extract the lookupQuerystring property
  lookup(_ref) {
    var _a2;
    let {
      lookupQuerystring
    } = _ref;
    let found;
    if (typeof window !== "undefined") {
      let {
        search
      } = window.location;
      if (!window.location.search && ((_a2 = window.location.hash) == null ? void 0 : _a2.indexOf("?")) > -1) {
        search = window.location.hash.substring(window.location.hash.indexOf("?"));
      }
      const query = search.substring(1);
      const params = query.split("&");
      for (let i2 = 0; i2 < params.length; i2++) {
        const pos = params[i2].indexOf("=");
        if (pos > 0) {
          const key = params[i2].substring(0, pos);
          if (key === lookupQuerystring) {
            found = params[i2].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
let hasLocalStorageSupport = null;
const localStorageAvailable = () => {
  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
    const testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo");
    window.localStorage.removeItem(testKey);
  } catch (e) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
};
var localStorage$1 = {
  name: "localStorage",
  // Deconstruct the options object and extract the lookupLocalStorage property
  lookup(_ref) {
    let {
      lookupLocalStorage
    } = _ref;
    if (lookupLocalStorage && localStorageAvailable()) {
      return window.localStorage.getItem(lookupLocalStorage) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupLocalStorage property
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupLocalStorage
    } = _ref2;
    if (lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(lookupLocalStorage, lng);
    }
  }
};
let hasSessionStorageSupport = null;
const sessionStorageAvailable = () => {
  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
    const testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo");
    window.sessionStorage.removeItem(testKey);
  } catch (e) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
};
var sessionStorage$1 = {
  name: "sessionStorage",
  lookup(_ref) {
    let {
      lookupSessionStorage
    } = _ref;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      return window.sessionStorage.getItem(lookupSessionStorage) || void 0;
    }
    return void 0;
  },
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupSessionStorage
    } = _ref2;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup(options) {
    const found = [];
    if (typeof navigator !== "undefined") {
      const {
        languages,
        userLanguage,
        language
      } = navigator;
      if (languages) {
        for (let i2 = 0; i2 < languages.length; i2++) {
          found.push(languages[i2]);
        }
      }
      if (userLanguage) {
        found.push(userLanguage);
      }
      if (language) {
        found.push(language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  // Deconstruct the options object and extract the htmlTag property
  lookup(_ref) {
    let {
      htmlTag: htmlTag2
    } = _ref;
    let found;
    const internalHtmlTag = htmlTag2 || (typeof document !== "undefined" ? document.documentElement : null);
    if (internalHtmlTag && typeof internalHtmlTag.getAttribute === "function") {
      found = internalHtmlTag.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  // Deconstruct the options object and extract the lookupFromPathIndex property
  lookup(_ref) {
    var _a2;
    let {
      lookupFromPathIndex
    } = _ref;
    if (typeof window === "undefined") return void 0;
    const language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
    if (!Array.isArray(language)) return void 0;
    const index2 = typeof lookupFromPathIndex === "number" ? lookupFromPathIndex : 0;
    return (_a2 = language[index2]) == null ? void 0 : _a2.replace("/", "");
  }
};
var subdomain = {
  name: "subdomain",
  lookup(_ref) {
    var _a2, _b;
    let {
      lookupFromSubdomainIndex
    } = _ref;
    const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex === "number" ? lookupFromSubdomainIndex + 1 : 1;
    const language = typeof window !== "undefined" && ((_b = (_a2 = window.location) == null ? void 0 : _a2.hostname) == null ? void 0 : _b.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i));
    if (!language) return void 0;
    return language[internalLookupFromSubdomainIndex];
  }
};
function getDefaults() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    // cookieMinutes: 10,
    // cookieDomain: 'myDomain'
    convertDetectedLanguage: (l2) => l2
  };
}
class Browser {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.services = services || {
      languageUtils: {}
    };
    this.options = defaults(options, this.options || {}, getDefaults());
    if (typeof this.options.convertDetectedLanguage === "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1) {
      this.options.convertDetectedLanguage = (l2) => l2.replace("-", "_");
    }
    if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
    this.i18nOptions = i18nOptions;
    this.addDetector(cookie$1);
    this.addDetector(querystring);
    this.addDetector(localStorage$1);
    this.addDetector(sessionStorage$1);
    this.addDetector(navigator$1);
    this.addDetector(htmlTag);
    this.addDetector(path);
    this.addDetector(subdomain);
  }
  addDetector(detector) {
    this.detectors[detector.name] = detector;
    return this;
  }
  detect(detectionOrder) {
    if (!detectionOrder) detectionOrder = this.options.order;
    let detected = [];
    detectionOrder.forEach((detectorName) => {
      if (this.detectors[detectorName]) {
        let lookup = this.detectors[detectorName].lookup(this.options);
        if (lookup && typeof lookup === "string") lookup = [lookup];
        if (lookup) detected = detected.concat(lookup);
      }
    });
    detected = detected.map((d2) => this.options.convertDetectedLanguage(d2));
    if (this.services.languageUtils.getBestMatchFromCodes) return detected;
    return detected.length > 0 ? detected[0] : null;
  }
  cacheUserLanguage(lng, caches) {
    if (!caches) caches = this.options.caches;
    if (!caches) return;
    if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
    caches.forEach((cacheName) => {
      if (this.detectors[cacheName]) this.detectors[cacheName].cacheUserLanguage(lng, this.options);
    });
  }
}
Browser.type = "languageDetector";
const km$6 = "km";
const m$7 = "m";
const to$6 = "to";
const logout$6 = "Log out";
const save$6 = "Save";
const cancel$6 = "Cancel";
const ok = "OK";
const create$6 = "Create";
const disasters$6 = "Disasters";
const loading$6 = "Loading...";
const loading_events$6 = "Loading disasters";
const legend$6 = "Legend";
const maps$6 = "maps";
const vertical_direction$6 = "Vertical direction";
const horizontal_direction$6 = "Horizontal direction";
const legend_presentation$6 = "Legend presentation";
const layers$6 = "Layers";
const toolbar = {
  map_ruler: "Measure distance",
  locate_me: "Locate me",
  panel_title: "Toolbar",
  download: "Download",
  "delete": "Delete",
  boundary_selector: "Select admin boundary",
  create_layer: "Create layer",
  geometry_uploader: "Upload GeoJSON",
  focused_geometry_editor: "Draw or edit geometry",
  edit_in_osm: "Edit map in OSM",
  record_sensors: "Record sensors",
  tools_label: "Tools",
  selected_area_label: "Selected area",
  upload_mcda: "Upload MCDA"
};
const layer_actions = {
  tooltips: {
    erase: "Erase",
    download: "Download",
    edit: "Edit",
    hide: "Hide",
    show: "Show"
  }
};
const feed$6 = "Feed";
const deselect$6 = "Deselect";
const spinner_text$6 = "Gathering data";
const updated$6 = "Updated";
const no_data_received$6 = "No data received";
const wrong_data_received$6 = "Wrong data received";
const error$6 = "Error";
const sort_icon$6 = "Sort Icon";
const configs$6 = {
  Kontur_public_feed: "Kontur Public",
  Kontur_public_feed_description: "The feed contains real-time data about Cyclones, Droughts, Earthquakes, Floods, Volcanoes, Wildfires."
};
const errors$6 = {
  "default": "Sorry, we are having issues which will be fixed soon",
  timeout: "Request timeout",
  cannot_connect: "Cannot connect to server",
  forbidden: "Forbidden",
  not_found: "Not found",
  unknown: "Unknown",
  server_error: "Server error"
};
const categories$6 = {
  overlays: "Overlays",
  basemap: "Basemap"
};
const groups$6 = {
  layers_in_selected_area: "Layers in selected area",
  your_layers: "Your layers",
  kontur_analytics: "Kontur analytics",
  qa: "OpenStreetMap inspector",
  osmbasedmap: "OpenStreetMap based",
  other: "Other",
  elevation: "Elevation",
  photo: "Imagery",
  map: "Map"
};
const advanced_analytics_data_list$6 = {
  load_world_data: "Load World Data",
  numerator: "Numerator",
  normalized_by: "Normalized By",
  sum: "Sum",
  min: "Min",
  max: "Max",
  mean: "Mean",
  stddev: "Stddev",
  median: "Median",
  filter_numerator: "Filter Numerator",
  filter_denominator: "Filter Denominator"
};
const mcda$6 = {
  title: "Multi-criteria decision analysis",
  name: "Create MCDA",
  modal_title: "Multi-criteria decision analysis",
  modal_input_name: "Analysis name",
  modal_input_name_placeholder: "e.g., Climate change",
  modal_input_indicators: "Layer list",
  modal_input_indicators_placeholder: "Select layers",
  modal_input_indicators_no_options: "No options",
  btn_cancel: "Cancel",
  btn_save: "Save analysis",
  error_analysis_name_cannot_be_empty: "Analysis name cannot be empty",
  error_bad_layer_data: "Invalid MCDA layer data",
  error_invalid_file: "Invalid MCDA file format",
  error_invalid_parameter: "Invalid '{{parameter}}' parameter",
  error_invalid_layer_parameter: "Invalid '{{parameter}}' parameter in '{{axisName}}' layer",
  error_wrong_mcda_version: "Wrong MCDA version",
  legend_title: "Legend",
  legend_subtitle: "Hexagons are colored based on analysis layer settings. Click a hexagon to see its values.",
  layer_editor: {
    save_changes: "Save changes",
    range: "Value range",
    outliers: "Outliers",
    reverse_to_good_bad: "Reverse to Good → Bad",
    reverse_to_bad_good: "Reverse to Bad → Good",
    weight: "Weight",
    transform: "Transform",
    transformation: "Transformation",
    normalize: "Normalize",
    normalization: "Normalization",
    range_buttons: {
      full_range: "Full range",
      "3_sigma": "3σ",
      "2_sigma": "2σ",
      "1_sigma": "1σ"
    },
    outliers_options: {
      clamp: "Clamp",
      hide: "Hide",
      dont_modify: "Don't modify"
    },
    transformations: {
      no_transformation: "No transformation",
      square_root: "Square root: sign(x)⋅√|x|",
      cube_root: "Cube root: ∛x",
      log_one: "log₁₀(x - xmin + 1)",
      log_epsilon: "log₁₀(x - xmin + ε)"
    },
    no: "No",
    max_min: "Max-min",
    errors: {
      weight_cannot_be_empty: "Weight cannot be empty",
      weight_must_be_a_number: "Weight must be a valid number",
      range_from_cannot_be_bigger: "The ‘from’ value cannot be bigger than the ‘to’ value",
      range_cannot_be_empty: "Range cannot be empty",
      range_must_be_a_number: "Range must be a valid number"
    },
    tips: {
      range: "The values that will be considered the worst and the best in your analysis.",
      sentiment: "Determine the direction of sentiment for the layer's impact on the analysis:\n* **Bad → Good**: Higher values indicate a positive sentiment.\n* **Good → Bad**: Higher values indicate a negative sentiment.",
      weight: "By default, all layers contribute equally to the analysis through a weighted average. Adjusting the increased weight of a layer (2, 3, etc.) allows you to assign additional importance to it in the analysis.",
      transform: "Apply calculations to the values. Achieving a more linear distribution will provide more useful information for analysis.\n\n **Note**: Calculations are done before normalization.",
      normalize: "Adjusts values to a standardized scale. This helps compare them easily and make decisions.\n* **Standard score scaling**: This option adjusts values to a standardized scale, ensuring they are all comparable.\n* **No (for specialists only)**: Leaves values unmodified.",
      outliers: "* **Clamp**: Set values above the range to 1 and below the range to 0.\n* **Don’t modify**: Keep 0 and 1 for min and max, but allow outlier scores beyond this range.\n* **Exclude**: Exclude areas where values are out of range."
    }
  },
  bad: "Bad",
  good: "Good"
};
const event_list$6 = {
  warning_title: "Cannot filter by map view",
  warning_description: "Map is not ready yet, try later",
  bbox_filter_button: "Filter by map view",
  analytics: {
    affected_people: {
      tooltip: "Affected people",
      value: "No humanitarian impact"
    },
    settled_area_tooltip: "Settled area",
    loss_tooltip: "Estimated loss"
  },
  no_event_in_feed: "The disaster was not found in the current disaster feed",
  no_selected_disaster: "No disaster selected",
  chose_disaster: "Choose disaster",
  no_historical_disasters: "No historical disasters in this area",
  no_feed_disasters: "No disasters in this feed",
  no_disasters: "No disasters",
  severity_unknown: "Unknown",
  severity_termination: "Termination",
  severity_minor: "Minor",
  severity_moderate: "Moderate",
  severity_severe: "Severe",
  severity_extreme: "Extreme",
  open_timeline_button: "Timeline"
};
const create_layer$6 = {
  edit_layer: "Edit Layer",
  edit_features: "Edit Features",
  delete_layer: "Delete Layer",
  create_layer: "Create Layer",
  saving_layer: "Saving layer...",
  field_name: "Field name",
  layer_name: "Layer name",
  marker_icon: "Marker icon",
  type: "Type",
  select: "Select",
  short_text: "Short Text",
  long_text: "Long Text",
  link: "Link",
  image: "Image",
  fields: "Fields",
  add_field: "Add field",
  location: "Location",
  edit_feature_placeholder: "Select some feature for start edit feature properties"
};
const analytics_panel$6 = {
  header_title: "Analytics",
  error_loading: "Failed receiving data about selected area. It may be too large.",
  info_short: "Calculations are made for selected area"
};
const advanced_analytics_panel$6 = {
  header_title: "Advanced analytics",
  error: "Error while fetching advanced analytics data"
};
const advanced_analytics_empty$6 = {
  not_found: "Sorry, the requested disaster was not found",
  error: "An error occured",
  analytics_for_selected: "Analytics for selected area",
  will_be_provided: "will be provided here",
  no_analytics: "No analytics for the selected area"
};
const llm_analytics = {
  header: "AI insights",
  header_info: "📝 Fill out your [bio](/profile)  \n🌟 Save an area you know well as a reference  \n📚 Select an area you want to explore"
};
const draw_tools$6 = {
  area: "Polygon",
  line: "Line",
  point: "Point",
  finish_drawing: "Finish Drawing",
  caption: "Click on the map to begin drawing",
  no_geometry_error: "No drawn geometry to download",
  overlap_error: "Polygon should not overlap itself",
  save_features: "Save features"
};
const boundary_selector$6 = {
  title: "Focus to administrative boundary"
};
const geometry_uploader$6 = {
  title: "Focus to uploaded geometry",
  error: "Error while reading uploaded file"
};
const focus_geometry$6 = {
  title: "Focus to freehand geometry"
};
const focus_geometry_layer$6 = {
  settings: {
    name: "Selected area"
  }
};
const reference_area_layer = {
  settings: {
    name: "Reference area"
  }
};
const drawings$6 = {
  self_directions_not_supported: "Self intersections are not supported"
};
const bivariate$6 = {
  panel: {
    header: "Bivariate matrix"
  },
  matrix: {
    caption: {
      base_axis: "Base axis",
      annex_axis: "Annex axis",
      tooltip: {
        p1: "Charts involving the Base and Annex axes help establish a relationship between two data sets.",
        li1: "Annex axis - parameters that we analyse",
        li2: "Base axis - reference point in the analysis",
        b: "Ex: the best location to open a cafe",
        p2: "We can explore the number of eatery places (Annex axis) against Population density (Base axis).",
        p3: "In this scenario, we are first interested in a small number of eatery places, and the number of people in that place gives us additional information."
      }
    },
    header: {
      title: "Choose two layers to explore correlations",
      hint: "Layers and correlations are displayed for the current Selected Area"
    },
    icon: {
      population: "Value divided by Population",
      area_km2: "Value divided by Area",
      total_building_count: "Value divided by Total Buildings Estimate",
      populated_area_km2: "Value divided by Populated Area",
      one: "Without divider",
      roads: "Value divided by Total Roads Length"
    },
    progress: {
      rendering: "Rendering",
      applied: "Applied on the map"
    },
    loading_error: "Unfortunately, we cannot display the matrix. Try refreshing the page or come back later."
  },
  legend: {
    high: "High",
    low: "Low",
    medium: "Medium"
  },
  color_manager: {
    not_defined: "Not defined",
    sentiments_combinations_filter: "Sentiments combinations",
    layers_filter: "Layers",
    no_legends: "There are no legends satisfying the conditions.",
    no_data: "No Data.",
    sentiments_tab: "Sentiments",
    color_legends_tab: "Color Legends",
    layers_tab: "Layers (indicators)"
  }
};
const sidebar$6 = {
  biv_color_manager: "Сolor manager",
  edit_osm: "Edit in OpenStreetMap",
  ruler: "Ruler",
  collapse: "Collapse",
  expand: "Expand",
  icon_alt: "Application logo"
};
const login$6 = {
  email: "Email",
  password: "Password",
  login_button: "Login",
  sign_up: "Sign up",
  logging_in: "Logging in...",
  log_in: "Log in",
  forgot_password: "Forgot password?",
  description: "Please log in to change your settings",
  error: {
    email_empty: "Email cannot be empty",
    email_invalid: "Email has to be valid",
    password: "Password cannot be empty",
    connect: "Could not connect to authentication service"
  }
};
const currency = {
  usd: "USD"
};
const subscription = {
  title: "Plans & Pricing",
  price_summary: "* Billed as ${{pricePerYear}} USD once yearly",
  unauthorized_button: "Sign in to subscribe",
  current_plan_button: "Current plan",
  sales_button: "Contact sales",
  book_demo_button: "Book a demo",
  request_trial_button: "Request trial",
  errors: {
    payment_initialization: "There was an error during payment initialization. Please try again or contact our support"
  },
  success_modal: {
    title: "Success",
    thank_you_for_subscribing: "Thank you for subscribing to our platform!",
    after_the_page_refreshes: "After the page refreshes, you can start using Kontur Atlas"
  }
};
const reports$6 = {
  title: "Disaster Ninja Reports",
  no_data: "No data for this report",
  sorting: "Sorting data...",
  loading: "Loading data",
  search_location: "Search location",
  open_josm: "Open via JOSM remote control",
  josm_logo_alt: "JOSM logo",
  see_all: "See all reports",
  wrong_id: "Wrong report ID",
  description: "<0>Kontur </0> generates several reports that help validate OpenStreetMap quality. They contain links to areas on <4>osm.org </4> and links to open them in the JOSM editor with enabled remote control for editing."
};
const modes$6 = {
  map: "Map",
  about: "About",
  cookies: "Cookies",
  reports: "Reports",
  report: "Report",
  profile: "Profile",
  privacy: "Privacy",
  terms: "Terms",
  user_guide: "User guide"
};
const about$6 = {
  title: "Welcome to Disaster Ninja!",
  intro: "Do you want to be notified about ongoing disasters? Are you interested in instant population data and other analytics for any region in the world? Disaster Ninja showcases some of <2>Kontur</2>’s capabilities in addressing these needs.<br/><br/>We initially designed it as a decision support tool for humanitarian mappers. Now it has grown in functionality and use cases. Whether you work in disaster management, build a smart city, or perform research on climate change, Disaster Ninja can help you to:",
  l1: "1. Stay up to date with the latest hazard events globally.",
  p1: "The Disasters panel continually refreshes to inform you about ongoing events. It consumes data from the <2>Kontur Event Feed</2>, which you can also access via an API.",
  l2: "2. Focus on your area of interest.",
  p2: "The Drawing Tools panel allows you to draw or upload your own geometry on the map. You can also focus on a disaster-exposed area or an administrative unit — a country, city, or region.",
  l3: "3. Get analytics for the focused area.",
  p3: "The Analytics panel shows the number of people living in that area per <2>Kontur Population</2> and estimated mapping gaps in OpenStreetMap. Kontur’s customers have access to hundreds of other indicators through Advanced Analytics.",
  l4: "4. Explore data on the map and make conclusions.",
  p4: "The Layers panel gives you various options to display two indicators simultaneously on a bivariate map, e.g., population density and distance to the nearest fire station. Use the color legend to assess which areas require attention. <br/>Hint: in general, green indicates low risk / few gaps, red — high risk / many gaps.",
  p5: "In addition, you can switch to Reports in the left panel to access data on potential errors and inconsistencies in OpenStreetMap and help fix them by mapping the respective area with the JOSM editor.",
  goToMap: "Go to the map now",
  p6: "We hope you find this tool valuable. Use the chatbox on Disaster Ninja for any questions about the functionality, and we will be happy to guide you. You can also contact us by email at <1>hello@kontur.io</1> if you have feedback or suggestions on improving the tool.<br/><br/>Disaster Ninja is an open-source project. Find the code in <8>Kontur’s GitHub account</8>."
};
const profile$6 = {
  interfaceTheme: "Theme",
  interfaceLanguage: "Language",
  units: "Units",
  fullName: "Full name",
  email: "Email",
  metric: "metric",
  imperialBeta: "imperial (beta)",
  profileSettingsHeader: "Profile",
  appSettingsHeader: "Settings",
  saveButton: "Save changes",
  konturTheme: "Kontur",
  HOTTheme: "HOT",
  user_bio_placeholder: "Bio",
  user_bio_tooltip: "Tell us about yourself:\n  •  your current role\n  •  professional skills\n  •  interests\n  •  industry\n  •  objectives or challenges you tackle\nThis bio helps customize and personalize your experience.",
  defaultDisasterFeed: "Default disaster feed",
  defaultOSMeditor: "Default OpenStreetMap editor (beta)",
  successNotification: "All changes have been applied successfully",
  languageOption: {
    en: "English",
    es: "Spanish",
    ar: "Arabic",
    ko: "Korean",
    id: "Indonesian",
    de: "German",
    uk: "Ukrainian"
  },
  reference_area: {
    title: "Reference area",
    freehand_geometry: "Freehand geometry",
    to_replace_reference_area: 'To replace reference area, select an area on the map and click "Save as reference area" on toolbar.',
    select_are_on_the_map: 'Select an area on the map and click "Save as reference area" on toolbar to use it in further analysis.',
    set_the_reference_area: "Set reference area"
  }
};
const current_event$6 = {
  not_found_request: "Sorry, the requested disaster was not found"
};
const locate_me$6 = {
  get_location_error: "Error while getting location",
  feature_title: "Locate me"
};
const episode$6 = "Timeline";
const loading_episodes$6 = "Loading Episodes";
const zoom_to_world = "Zoom to the whole world";
const cookie_banner$6 = {
  header: "We value your privacy",
  body: "We use absolutely necessary cookies to provide you personalized services and optional cookies to improve {{appName}} and your experience. You can manage cookie settings or withdraw consent to optional cookies at any time.\nFor more information, please, check our [Privacy Policy](about/privacy)",
  decline_all: "Decline optional cookies",
  accept_all: "Accept optional cookies"
};
const live_sensor$6 = {
  start: "Start sensor recording",
  finish: "Stop sensor recording",
  finishMessage: "Recording has been finished",
  startMessage: "Recording has been started",
  noSensorsError: "Your device does not have the required sensors"
};
const layer_features_panel = {
  empty: "Layer features within selected area will be provided here",
  noFeatureSelected: "No layer feature selected",
  chooseFeature: "Choose layer feature",
  listInfo: "The list is filtered by selected area and sorted by project number"
};
const reference_area = {
  save_as_reference_area: "Save as reference area",
  error_couldnt_save: "Unfortunately, we could not save your reference area. Please try again.",
  selected_area_saved_as_reference_area: "Selected area has been saved as reference area in your profile"
};
const en_common = {
  km: km$6,
  m: m$7,
  to: to$6,
  logout: logout$6,
  save: save$6,
  cancel: cancel$6,
  ok,
  create: create$6,
  disasters: disasters$6,
  loading: loading$6,
  loading_events: loading_events$6,
  legend: legend$6,
  maps: maps$6,
  vertical_direction: vertical_direction$6,
  horizontal_direction: horizontal_direction$6,
  legend_presentation: legend_presentation$6,
  layers: layers$6,
  toolbar,
  layer_actions,
  feed: feed$6,
  deselect: deselect$6,
  spinner_text: spinner_text$6,
  updated: updated$6,
  no_data_received: no_data_received$6,
  wrong_data_received: wrong_data_received$6,
  error: error$6,
  sort_icon: sort_icon$6,
  configs: configs$6,
  errors: errors$6,
  categories: categories$6,
  groups: groups$6,
  advanced_analytics_data_list: advanced_analytics_data_list$6,
  mcda: mcda$6,
  event_list: event_list$6,
  create_layer: create_layer$6,
  analytics_panel: analytics_panel$6,
  advanced_analytics_panel: advanced_analytics_panel$6,
  advanced_analytics_empty: advanced_analytics_empty$6,
  llm_analytics,
  draw_tools: draw_tools$6,
  boundary_selector: boundary_selector$6,
  geometry_uploader: geometry_uploader$6,
  focus_geometry: focus_geometry$6,
  focus_geometry_layer: focus_geometry_layer$6,
  reference_area_layer,
  drawings: drawings$6,
  bivariate: bivariate$6,
  sidebar: sidebar$6,
  login: login$6,
  currency,
  subscription,
  reports: reports$6,
  modes: modes$6,
  about: about$6,
  profile: profile$6,
  current_event: current_event$6,
  locate_me: locate_me$6,
  episode: episode$6,
  loading_episodes: loading_episodes$6,
  zoom_to_world,
  cookie_banner: cookie_banner$6,
  live_sensor: live_sensor$6,
  layer_features_panel,
  reference_area
};
const km$5 = "km";
const m$6 = "m";
const to$5 = "a";
const maps$5 = "mapas";
const logout$5 = "Cierre de sesión";
const save$5 = "Guardar";
const cancel$5 = "Cancelar";
const create$5 = "Crear";
const disasters$5 = "Desastres";
const loading$5 = "Cargando...";
const loading_events$5 = "Cargando eventos";
const legend$5 = "Leyenda";
const vertical_direction$5 = "Dirección vertical";
const horizontal_direction$5 = "Dirección horizontal";
const legend_presentation$5 = "Presentación de la leyenda";
const layers$5 = "Capas";
const bivariate$5 = {
  color_manager: {
    layers_filter: "Capas",
    not_defined: "No definido",
    sentiments_combinations_filter: "Combinaciones de sentimientos",
    no_legends: "No hay leyendas que cumplan las condiciones.",
    no_data: "No hay datos.",
    sentiments_tab: "Sentimientos",
    color_legends_tab: "Leyendas de colores",
    layers_tab: "Capas (indicadores)"
  },
  panel: {
    header: "Matriz bivariada"
  },
  matrix: {
    caption: {
      base_axis: "Eje base",
      annex_axis: "Eje anexo",
      tooltip: {
        p1: "Las gráficas que incluyen los ejes base y anexo ayudan a establecer una relación entre dos conjuntos de datos.",
        li1: "Eje anexo: parámetros que analizamos",
        li2: "Eje base: punto de referencia en el análisis",
        b: "Ej.: la mejor ubicación para abrir una cafetería",
        p2: "Podemos explorar el número de locales de comida (eje anexo) frente a la densidad de población (eje base).",
        p3: "En este escenario, en primer lugar nos interesa un número reducido de locales de comida, y la cantidad de personas presentes nos da información adicional."
      }
    },
    header: {
      title: "Elija dos capas para explorar las correlaciones",
      hint: "Las capas y correlaciones se muestran para el área seleccionada actual"
    },
    icon: {
      population: "Valor dividido por la población",
      area_km2: "Valor dividido por el área",
      total_building_count: "Valor dividido por la estimación total de edificios",
      populated_area_km2: "Valor dividido por el área poblada",
      one: "Sin divisor",
      roads: "Valor dividido por la longitud total de las carreteras"
    },
    progress: {
      rendering: "Renderizado",
      applied: "Aplicado en el mapa"
    }
  },
  legend: {
    high: "Alto",
    low: "Bajo",
    medium: "Medio"
  }
};
const feed$5 = "Fuente";
const deselect$5 = "Anular la selección";
const spinner_text$5 = "Recopilación de datos";
const updated$5 = "Actualizado";
const no_data_received$5 = "No se han recibido datos";
const wrong_data_received$5 = "Se han recibido datos erróneos";
const error$5 = "Error";
const sort_icon$5 = "Icono de ordenar";
const configs$5 = {
  Kontur_public_feed: "Kontur Public",
  Kontur_public_feed_description: "El feed contiene datos en tiempo real sobre Ciclones, Sequías, Terremotos, Inundaciones, Volcanes, Incendios forestales."
};
const errors$5 = {
  "default": "Lo sentimos, estamos teniendo problemas, que pronto se solucionarán",
  timeout: "Se agotó el tiempo de espera de la solicitud",
  cannot_connect: "No se puede conectar al servidor",
  forbidden: "Prohibido",
  not_found: "No encontrado",
  unknown: "Desconocido",
  server_error: "Error del servidor"
};
const event_list$5 = {
  severity_unknown: "Desconocido",
  warning_title: "No se puede utilizar el mapa como filtro",
  warning_description: "El mapa aún no está listo, inténtelo más tarde",
  bbox_filter_button: "Usar la vista del mapa como filtro",
  analytics: {
    affected_people: {
      tooltip: "Personas afectadas",
      value: "Sin impacto humanitario"
    },
    settled_area_tooltip: "Área habitada",
    loss_tooltip: "Pérdida estimada"
  },
  no_event_in_feed: "Evento no encontrado en el feed de eventos actual",
  no_selected_disaster: "No se ha seleccionado ningún desastre",
  chose_disaster: "Seleccione el desastre"
};
const categories$5 = {
  overlays: "Superposiciones",
  basemap: "Mapa base"
};
const groups$5 = {
  layers_in_selected_area: "Capas en el área seleccionada",
  your_layers: "Sus capas",
  kontur_analytics: "Análisis de Kontur",
  qa: "Certificación de calidad",
  osmbasedmap: "Basado en OpenStreetMap",
  other: "Otros",
  elevation: "Elevación",
  photo: "Foto",
  map: "Mapa"
};
const modes$5 = {
  map: "Mapa",
  about: "Acerca de",
  reports: "Informes",
  profile: "Perfil"
};
const advanced_analytics_data_list$5 = {
  load_world_data: "Cargar datos mundiales",
  numerator: "Numerador",
  normalized_by: "Normalizado por",
  sum: "Suma",
  min: "Mín.",
  max: "Máx.",
  mean: "Media",
  stddev: "Desv. est.",
  median: "Mediana",
  filter_denominator: "Filtrar Denominador"
};
const mcda$5 = {};
const create_layer$5 = {
  edit_layer: "Editar capa",
  edit_features: "Editar características",
  delete_layer: "Eliminar capa",
  create_layer: "Crear capa",
  saving_layer: "Guardando capa...",
  field_name: "Nombre de campo",
  layer_name: "Nombre de la capa",
  marker_icon: "Icono de marcador",
  type: "Tipo",
  select: "Seleccionar",
  short_text: "Texto corto",
  long_text: "Texto largo",
  link: "Enlace",
  image: "Imagen",
  fields: "Campos",
  add_field: "Agregar campo",
  location: "Ubicación",
  edit_feature_placeholder: "Seleccione una característica para comenzar a editar las propiedades de la misma"
};
const analytics_panel$5 = {
  header_title: "Análisis",
  error_loading: "Error en la obtención de datos de análisis"
};
const advanced_analytics_panel$5 = {
  header_title: "Análisis avanzado",
  error: "Error en la obtención de datos de análisis Avanzado"
};
const advanced_analytics_empty$5 = {
  not_found: "Lo sentimos, el evento solicitado no se ha encontrado.",
  error: "¡Se produjo un error!"
};
const current_event$5 = {
  not_found_request: "Lo sentimos, el evento solicitado no se ha encontrado."
};
const draw_tools$5 = {
  area: "Área",
  line: "Línea",
  point: "Punto",
  finish_drawing: "Terminar el dibujo",
  caption: "Haga clic en el mapa para empezar a dibujar",
  no_geometry_error: "No hay geometría dibujada para descargar",
  overlap_error: "El polígono no debe superponerse sobre sí mismo",
  save_features: "Guardar características"
};
const boundary_selector$5 = {
  title: "Enfocar en el límite administrativo"
};
const geometry_uploader$5 = {
  title: "Enfocar en la geometría cargada",
  error: "Error al leer el archivo cargado"
};
const focus_geometry$5 = {
  title: "Enfocar en la geometría a mano"
};
const focus_geometry_layer$5 = {
  settings: {
    name: "Área seleccionada"
  }
};
const drawings$5 = {
  self_directions_not_supported: "¡No se admiten las autointersecciones!"
};
const sidebar$5 = {
  biv_color_manager: "Administrador de color",
  edit_osm: "Editar en OpenStreetMap",
  ruler: "Regla",
  collapse: "Contraer",
  expand: "Expandir",
  icon_alt: "Logotipo de la aplicación"
};
const login$5 = {
  email: "Correo electrónico",
  password: "Contraseña",
  login_button: "Inicio de sesión",
  sign_up: "Registrarse",
  logging_in: "Iniciando sesión...",
  log_in: "Iniciar sesión",
  description: "Acceda a su cuenta para cambiar los ajustes",
  error: {
    email_empty: "¡El correo electrónico no debe estar vacío!",
    email_invalid: "¡El correo electrónico debe ser válido!",
    password: "¡La contraseña no debe estar vacía!",
    connect: "No se pudo conectar con el servicio de autenticación"
  }
};
const profile$5 = {
  email: "Correo electrónico",
  profileSettingsHeader: "Perfil",
  interfaceTheme: "Tema",
  interfaceLanguage: "Idioma",
  units: "Unidades",
  fullName: "Nombre completo",
  metric: "métricas",
  imperialBeta: "imperiales (beta)",
  appSettingsHeader: "Ajustes",
  saveButton: "Guardar cambios",
  konturTheme: "Kontur",
  HOTTheme: "HOT",
  "userBio(about)": "Bio",
  defaultDisasterFeed: "Feed de desastres predeterminado",
  defaultOSMeditor: "Editor predeterminado de OpenStreetMap (beta)",
  successNotification: "Todos los cambios se han aplicado correctamente",
  languageOption: {
    en: "Inglés",
    es: "Español",
    ar: "Árabe",
    ko: "Сoreano",
    id: "Indonesio",
    de: "Alemán",
    uk: "Ucranio"
  }
};
const reports$5 = {
  title: "Informes de Disaster Ninja",
  no_data: "No hay datos para este informe",
  sorting: "Ordenando datos...",
  loading: "Cargando datos",
  search_location: "Buscar ubicación",
  open_josm: "Abrir a través del control remoto JOSM",
  josm_logo_alt: "Logotipo de JOSM",
  see_all: "Ver todos los informes",
  wrong_id: "ID de informe incorrecto",
  description: "<0>Kontur </0> genera una serie de informes útiles para validar la calidad de OpenStreetMap. Contienen enlaces a zonas en <4>osm.org </4> y enlaces para abrirlas en el editor JOSM con control remoto habilitado para la edición."
};
const about$5 = {
  title: "¡Bienvenido a Disaster Ninja!",
  intro: "¿Desea recibir notificaciones sobre desastres en curso? ¿Le interesan los datos de población instantáneos y otros datos analíticos de alguna región del mundo? Disaster Ninja muestra algunas de las capacidades de <2>Kontur</2> para ocuparse de estas necesidades.<br/><br/> Inicialmente la diseñamos como una herramienta de apoyo a los mapeadores de servicios humanitarios. Ahora ha ampliado sus funcionalidades y aplicaciones prácticas. Tanto si trabaja en la gestión de desastres como si construye una ciudad inteligente o realiza investigaciones sobre el cambio climático, Disaster Ninja puede ayudarle a:",
  l1: "1. Estar al día con los últimos eventos peligrosos a nivel mundial.",
  p1: "El panel de Desastres se actualiza continuamente para informarle sobre los acontecimientos en curso. Utiliza la información proporcionada por <2>Kontur Event Feed</2>, a la que también puede acceder a través de la interfaz de la aplicación.",
  l2: "2. Centrarse en su área de interés.",
  p2: "El panel de Herramientas de Dibujo le permite dibujar o subir su propia geometría en el mapa. También puede centrarse en un área o en una unidad administrativa - país, ciudad o región — expuesta a desastres.",
  l3: "3. Recibir análisis de su área de interés.",
  p3: "El panel de Análisis le muestra el número de personas que viven en la zona según <2>Kontur Population</2> y según una estimación de las zonas sin mapear en OpenStreetMap. Los clientes de Kontur tienen acceso a cientos de otros indicadores a través de Advance Analytics.",
  l4: "4. Explorar los datos del mapa y sacar sus propias conclusiones.",
  p4: "El panel Capas le ofrece varias opciones para mostrar dos indicadores en simultáneo en un mapa bivariado, p. ej:, la densidad de población y la distancia a la estación de bomberos más cercana. Utilice las leyendas de colores para evaluar qué áreas requieren atención. <br/>Consejo: en general, el verde indica riesgo bajo / pocas zonas sin mapear, el rojo — riesgo alto / muchas zonas sin mapear.",
  p5: "Además, puede cambiar a Informes en el panel de la izquierda para acceder a los datos sobre posibles errores e inconsistencias en OpenStreetMap y ayudarle a realizar correcciones mapeando la zona correspondiente con el editor JOSM.",
  goToMap: "Ir al mapa ahora",
  p6: "Esperamos que esta herramienta le resulte valiosa. Utilice el chat de Disaster Ninja si tiene alguna pregunta sobre sus funcionalidades y estaremos encantados de ayudarle. También puede contactarnos por correo electrónico en <1>hello@kontur.io</1> si tiene algún comentario o sugerencia para mejorar la herramienta.<br/><br/> Disaster Ninja es un proyecto de código abierto. Encuentre el código en la <8>cuenta de GitHub de Kontur</8>."
};
const locate_me$5 = {
  get_location_error: "Error al obtener la ubicación",
  feature_title: "Localizarme"
};
const episode$5 = "Episodio";
const loading_episodes$5 = "Cargando episodios";
const cookie_banner$5 = {};
const live_sensor$5 = {};
const es_common = {
  km: km$5,
  m: m$6,
  to: to$5,
  maps: maps$5,
  logout: logout$5,
  save: save$5,
  cancel: cancel$5,
  create: create$5,
  disasters: disasters$5,
  loading: loading$5,
  loading_events: loading_events$5,
  legend: legend$5,
  vertical_direction: vertical_direction$5,
  horizontal_direction: horizontal_direction$5,
  legend_presentation: legend_presentation$5,
  layers: layers$5,
  bivariate: bivariate$5,
  feed: feed$5,
  deselect: deselect$5,
  spinner_text: spinner_text$5,
  updated: updated$5,
  no_data_received: no_data_received$5,
  wrong_data_received: wrong_data_received$5,
  error: error$5,
  sort_icon: sort_icon$5,
  configs: configs$5,
  errors: errors$5,
  event_list: event_list$5,
  categories: categories$5,
  groups: groups$5,
  modes: modes$5,
  advanced_analytics_data_list: advanced_analytics_data_list$5,
  mcda: mcda$5,
  create_layer: create_layer$5,
  analytics_panel: analytics_panel$5,
  advanced_analytics_panel: advanced_analytics_panel$5,
  advanced_analytics_empty: advanced_analytics_empty$5,
  current_event: current_event$5,
  draw_tools: draw_tools$5,
  boundary_selector: boundary_selector$5,
  geometry_uploader: geometry_uploader$5,
  focus_geometry: focus_geometry$5,
  focus_geometry_layer: focus_geometry_layer$5,
  drawings: drawings$5,
  sidebar: sidebar$5,
  login: login$5,
  profile: profile$5,
  reports: reports$5,
  about: about$5,
  locate_me: locate_me$5,
  episode: episode$5,
  loading_episodes: loading_episodes$5,
  cookie_banner: cookie_banner$5,
  live_sensor: live_sensor$5
};
const km$4 = "كم";
const m$5 = "م";
const to$4 = "إلى";
const maps$4 = "خرائط";
const logout$4 = "تسجيل خروج";
const save$4 = "حفظ";
const cancel$4 = "إلغاء";
const create$4 = "إنشاء";
const disasters$4 = "كوارث";
const loading$4 = "جارٍ التحميل...";
const loading_events$4 = "جارٍ تحميل الأحداث";
const legend$4 = "عنوان تفسيري";
const vertical_direction$4 = "الاتجاه الرأسي";
const horizontal_direction$4 = "الاتجاه الأفقي";
const legend_presentation$4 = "عرض العنوان التفسيري";
const layers$4 = "طبقات";
const bivariate$4 = {
  color_manager: {
    layers_filter: "طبقات",
    not_defined: "غير معرف",
    sentiments_combinations_filter: "تركيبات المشاعر",
    no_legends: "لا توجد ملاحظات تفي بالشروط.",
    no_data: "لايوجد بيانات.",
    sentiments_tab: "المشاعر",
    color_legends_tab: "مؤشرات اللون",
    layers_tab: "الطبقات (المؤشرات)"
  },
  panel: {
    header: "مصفوفة ثنائية المتغير"
  },
  matrix: {
    caption: {
      base_axis: "المحور الأساسي",
      annex_axis: "المحور الملحق",
      tooltip: {
        p1: "تساعد المخططات التي تتضمن محوري القاعدة والملحق في إنشاء علاقة بين مجموعتي بيانات.",
        li1: "محور الملحق - المعلمات التي نقوم بتحليلها",
        li2: "المحور الأساسي - النقطة المرجعية في التحليل",
        b: "مثال: أفضل موقع لفتح مقهى",
        p2: "يمكننا استكشاف عدد أماكن المطاعم (المحور الملحق) مقابل الكثافة السكانية (المحور الأساسي).",
        p3: "في هذا السيناريو، نهتم أولاً بعدد صغير من أماكن تناول الطعام ويعطينا عدد الأشخاص في هذا المكان معلومات إضافية."
      }
    },
    header: {
      title: "اختر طبقتين لاستكشاف الارتباطات",
      hint: "يتم عرض الطبقات والارتباطات للمنطقة المحددة الحالية"
    },
    icon: {
      population: "القيمة مقسومة على عدد السكان",
      area_km2: "القيمة مقسومة على المنطقة",
      total_building_count: "القيمة مقسومة على تقدير إجمالي المباني",
      populated_area_km2: "القيمة مقسومة على المنطقة المأهولة",
      one: "بدون فاصل",
      roads: "القيمة مقسومة على إجمالي طول الطرق"
    },
    progress: {
      rendering: "استدعاء",
      applied: "مطبق على الخريطة"
    }
  },
  legend: {
    high: "مرتفع",
    low: "منخفض",
    medium: "متوسط"
  }
};
const feed$4 = "تغذية";
const deselect$4 = "إلغاء";
const spinner_text$4 = "جمع البيانات";
const updated$4 = "تحديث";
const no_data_received$4 = "لم تُستقبل أي بيانات";
const wrong_data_received$4 = "تم استلام بيانات خاطئة";
const error$4 = "خطأ";
const sort_icon$4 = "أيقونة الترتيب";
const configs$4 = {
  Kontur_public_feed: "Kontur Public",
  Kontur_public_feed_description: "يحتوي الموجز على بيانات فورية عن الأعاصير والجفاف والزلازل والفيضانات والبراكين وحرائق الغابات."
};
const errors$4 = {
  "default": "عذرًا، حدثت مشكلات، سيتم إصلاحها قريبًا",
  timeout: "انتهت مهلة الطلب",
  cannot_connect: "لا يمكن الاتصال بالخادم",
  forbidden: "محظور",
  not_found: "لم يتم العثور على",
  unknown: "غير معروف",
  server_error: "خطأ في الخادم"
};
const event_list$4 = {
  severity_unknown: "غير معروف",
  warning_title: "لا يمكن استخدام الخريطة كعامل تصفية",
  warning_description: "الخريطة ليست جاهزة بعد، حاول لاحقًا",
  bbox_filter_button: "استخدم عرض الخريطة كعامل تصفية",
  analytics: {
    affected_people: {
      tooltip: "الأشخاص المتأثرون",
      value: "لا أثر إنساني"
    },
    settled_area_tooltip: "منطقة مستوطنة",
    loss_tooltip: "الخسارة المقدرة"
  },
  no_event_in_feed: "لم يتم العثور على الحدث في موجز الأحداث الحالية",
  no_selected_disaster: "لم يتم اختيار كارثة",
  chose_disaster: "اختر كارثة"
};
const categories$4 = {
  overlays: "تراكميات",
  basemap: "الخريطة الأساسية"
};
const groups$4 = {
  layers_in_selected_area: "طبقات في المنطقة المختارة",
  your_layers: "طبقاتك",
  kontur_analytics: "تحليلات كونتور",
  qa: "تأكيد الجودة",
  osmbasedmap: "فتح خريطة الشارع على أساس",
  other: "آخر",
  elevation: "ارتفاع",
  photo: "صورة",
  map: "الخريطة"
};
const modes$4 = {
  map: "الخريطة",
  about: "عن",
  reports: "التقارير",
  profile: "الملف الشخصي"
};
const advanced_analytics_data_list$4 = {
  load_world_data: "تحميل بيانات العالم",
  numerator: "البسط",
  normalized_by: "تطبيع بواسطة",
  sum: "مجموع",
  min: "الحد الأدنى",
  max: "الحد الأقصى",
  mean: "المتوسط",
  stddev: "Stddev",
  median: "الوسيط",
  filter_denominator: "مقام المرشح"
};
const mcda$4 = {};
const create_layer$4 = {
  edit_layer: "تعديل الطبقة",
  edit_features: "تعديل الميزات",
  delete_layer: "حذف الطبقة",
  create_layer: "خلق الطبقة",
  saving_layer: "حفظ الطبقة...",
  field_name: "اسم المجال",
  layer_name: "اسم الطبقة",
  marker_icon: "رمز العلامة",
  type: "النوع",
  select: "تحديد",
  short_text: "نص قصير",
  long_text: "نص طويل",
  link: "رابط",
  image: "صورة",
  fields: "مجالات",
  add_field: "إضافة مجال",
  location: "موقع",
  edit_feature_placeholder: "حدد بعض الميزات لبدء تحرير خصائص الميزة"
};
const analytics_panel$4 = {
  header_title: "التحليلات",
  error_loading: "خطأ أثناء جلب بيانات التحليلات"
};
const advanced_analytics_panel$4 = {
  header_title: "تحليلات متقدمة",
  error: "خطأ أثناء جلب بيانات التحليلات المتقدمة"
};
const advanced_analytics_empty$4 = {
  not_found: "عذرًا، الحدث المطلوب غير موجود.",
  error: "حدث خطأ!"
};
const current_event$4 = {
  not_found_request: "عذرًا، الحدث المطلوب غير موجود."
};
const draw_tools$4 = {
  area: "منطقة",
  line: "خط",
  point: "نقطة",
  finish_drawing: "إنهاء الرسم",
  caption: "انقر على الخريطة لبدء الرسم",
  no_geometry_error: "لا يوجد مجسم مرسوم للتنزيل",
  overlap_error: "يجب ألا يتداخل المضلع مع نفسه",
  save_features: "حفظ الميزات"
};
const boundary_selector$4 = {
  title: "التركيز على الحدود الإدارية"
};
const geometry_uploader$4 = {
  title: "التركيز على المجسم المحمل",
  error: "خطأ أثناء قراءة الملف الذي تم تحميله"
};
const focus_geometry$4 = {
  title: "ركز على المجسم الحر"
};
const focus_geometry_layer$4 = {
  settings: {
    name: "منطقة مختارة"
  }
};
const drawings$4 = {
  self_directions_not_supported: "التقاطعات الذاتية غير مدعومة!"
};
const sidebar$4 = {
  biv_color_manager: "مدير الألوان",
  edit_osm: "التعديل في OpenStreetMap",
  ruler: "المسطرة",
  collapse: "إغلاق",
  expand: "فتح",
  icon_alt: "شعار التطبيق"
};
const login$4 = {
  email: "البريد الإلكتروني",
  password: "كلمة السر",
  login_button: "تسجيل الدخول",
  sign_up: "إنشاء حساب",
  logging_in: "جارٍ تسجيل الدخول...",
  log_in: "تسجيل الدخول",
  description: "يرجى تسجيل الدخول لتغيير إعداداتك",
  error: {
    email_empty: "يجب أن لا يكون البريد الإلكتروني فارغًا!",
    email_invalid: "يجب أن يكون البريد الإلكتروني صالحًا!",
    password: "يجب أن لا تكون كلمة السر فارغة!",
    connect: "تعذّر الوصول إلى خادم المصادقة"
  }
};
const profile$4 = {
  email: "البريد الإلكتروني",
  profileSettingsHeader: "الملف الشخصي",
  interfaceTheme: "النسق",
  interfaceLanguage: "اللغة",
  units: "الوحدات",
  fullName: "الاسم الكامل",
  metric: "المقياس",
  imperialBeta: "إمبريالي (بيتا)",
  appSettingsHeader: "الإعدادات",
  saveButton: "حفظ التغييرات",
  konturTheme: "Kontur",
  HOTTheme: "حار",
  "userBio(about)": "السيرة",
  defaultDisasterFeed: "موجز الكوارث الافتراضي",
  defaultOSMeditor: "محرر OpenStreetMap الافتراضي (بيتا)",
  successNotification: "تم تطبيق جميع التغييرات بنجاح",
  languageOption: {
    en: "الإنجليزية",
    es: "الإسبانية",
    ar: "العربية",
    ko: "الكورية",
    id: "الأندونيسية",
    de: "ألمانية",
    uk: "الأوكرانية"
  }
};
const reports$4 = {
  title: "تقارير Disaster Ninja",
  no_data: "لا توجد بيانات لهذا التقرير",
  sorting: "جارٍ ترتيب البيانات...",
  loading: "جارٍ تحميل البيانات",
  search_location: "البحث عن الموقع",
  open_josm: "الفتح من خلال وحدة تحكم JOSM عن بعد",
  josm_logo_alt: "شعار JOSM",
  see_all: "عرض جميع التقارير",
  wrong_id: "معرف التقرير خاطئ",
  description: "ينشئ <0> Kontur</0> عدة تقارير تساعد في التحقق من جودة OpenStreetMap. تحتوي هذه التقارير على روابط لمناطق على <4> osm.org </4> وروابط يمكن فتحها في محرر JOSM مع تمكين التحكم عن بعد للتحرير."
};
const about$4 = {
  title: "مرحبًا في Disaster Ninja!",
  intro: "هل تريد أن يتم إخطارك بالكوارث الجارية؟ هل أنت مهتم بالبيانات السكانية الفورية والتحليلات الأخرى لأي منطقة في العالم؟ يعرض Disaster Ninja بعض قدرات <2>Kontur</2> في تلبية هذه الاحتياجات.<br/><br/>لقد صممناه في البداية ليكون أداة دعم قرار لمصممي الخرائط الإنسانية. الآن، ازدادت وظائفه وحالات استخدامه. سواء كنت تعمل في إدارة الكوارث، أو تبني مدينة ذكية، أو تجري بحثًا عن تغير المناخ، يمكن أن يساعدك Disaster Ninja على:",
  l1: "1. البقاء على اطلاع بآخر التطورات للأحداث الخطرة على مستوى العالم.",
  p1: "يتم تحديث لوحة الكوارث باستمرار لإبلاغك بالأحداث الجارية. إنها تستهلك البيانات من <2>Kontur Event Feed</2> والتي يمكنك أيضًا الوصول إليها عبر واجهة برمجة التطبيقات.",
  l2: "2. التركيز على مجال اهتمامك.",
  p2: "تتيح لك لوحة أدوات الرسم رسم أو تحميل الشكل الهندسي الخاص بك على الخريطة. يمكنك أيضًا التركيز على منطقة معرضة للكوارث أو وحدة إدارية - بلد أو مدينة أو منطقة.",
  l3: "3. الحصول على تحليلات لمنطقة الاهتمام.",
  p3: "تعرض لوحة التحليلات عدد الأشخاص الذين يعيشون في تلك المنطقة حسب <2>Kontur Population</2> وفجوات الخرائط المقدرة في OpenStreetMap. يمكن لعملاء Kontur الوصول إلى مئات المؤشرات الأخرى من خلال التحليلات المتقدمة.",
  l4: "4. استكشاف البيانات على الخريطة والتوصل إلى استنتاجات.",
  p4: "تمنحك لوحة Layers خيارات متنوعة لعرض مؤشرين في وقت واحد على خريطة ثنائية المتغير على سبيل المثال الكثافة السكانية والمسافة إلى أقرب محطة إطفاء. استخدم وسيلة إيضاح اللون لتقييم المناطق التي تتطلب الانتباه. <br/>بشكل عام، يشير اللون الأخضر إلى مخاطر منخفضة / فجوات قليلة، والأحمر - مخاطر عالية / العديد من الفجوات.",
  p5: "بالإضافة إلى ذلك ، يمكنك التبديل إلى التقارير في اللوحة اليمنى للوصول إلى البيانات المتعلقة بالأخطاء والتناقضات المحتملة في OpenStreetMap والمساعدة في إصلاحها عن طريق رسم خريطة المنطقة المعنية باستخدام محرر JOSM.",
  goToMap: "الانتقال إلى الخريطة الآن",
  p6: "نأمل أن تجد هذه الأداة ذات قيمة. استخدم مربع الدردشة على Disaster Ninja لأية أسئلة حول وظائفه، وسنكون سعداء بإرشادك. يمكنك أيضًا التواصل معنا عبر البريد الإلكتروني<1>hello@kontur.io</1> إذا كان لديك ملاحظات أو اقتراحات بشأن تحسين الأداة.<br/><br/>يُعدّ Disaster Ninja مشروعًا مفتوح المصدر. تحقق من الكود في حساب <8>Kontur</8> على <8>GitHub</8>."
};
const locate_me$4 = {
  get_location_error: "حدث خطأ أثناء الحصول على الموقع",
  feature_title: "حدد موقعي"
};
const episode$4 = "الحلقة";
const loading_episodes$4 = "جارٍ تجميل الحلقات";
const cookie_banner$4 = {};
const live_sensor$4 = {};
const ar_common = {
  km: km$4,
  m: m$5,
  to: to$4,
  maps: maps$4,
  logout: logout$4,
  save: save$4,
  cancel: cancel$4,
  create: create$4,
  disasters: disasters$4,
  loading: loading$4,
  loading_events: loading_events$4,
  legend: legend$4,
  vertical_direction: vertical_direction$4,
  horizontal_direction: horizontal_direction$4,
  legend_presentation: legend_presentation$4,
  layers: layers$4,
  bivariate: bivariate$4,
  feed: feed$4,
  deselect: deselect$4,
  spinner_text: spinner_text$4,
  updated: updated$4,
  no_data_received: no_data_received$4,
  wrong_data_received: wrong_data_received$4,
  error: error$4,
  sort_icon: sort_icon$4,
  configs: configs$4,
  errors: errors$4,
  event_list: event_list$4,
  categories: categories$4,
  groups: groups$4,
  modes: modes$4,
  advanced_analytics_data_list: advanced_analytics_data_list$4,
  mcda: mcda$4,
  create_layer: create_layer$4,
  analytics_panel: analytics_panel$4,
  advanced_analytics_panel: advanced_analytics_panel$4,
  advanced_analytics_empty: advanced_analytics_empty$4,
  current_event: current_event$4,
  draw_tools: draw_tools$4,
  boundary_selector: boundary_selector$4,
  geometry_uploader: geometry_uploader$4,
  focus_geometry: focus_geometry$4,
  focus_geometry_layer: focus_geometry_layer$4,
  drawings: drawings$4,
  sidebar: sidebar$4,
  login: login$4,
  profile: profile$4,
  reports: reports$4,
  about: about$4,
  locate_me: locate_me$4,
  episode: episode$4,
  loading_episodes: loading_episodes$4,
  cookie_banner: cookie_banner$4,
  live_sensor: live_sensor$4
};
const km$3 = "킬로미터";
const m$4 = "미터";
const to$3 = "목적지";
const maps$3 = "지도";
const logout$3 = "로그아웃";
const save$3 = "저장";
const cancel$3 = "취소";
const create$3 = "생성";
const disasters$3 = "재난";
const loading$3 = "로딩 중...";
const loading_events$3 = "이벤트 로딩 중";
const legend$3 = "범례";
const vertical_direction$3 = "수직 방향";
const horizontal_direction$3 = "수평 방향";
const legend_presentation$3 = "범례 표시";
const layers$3 = "레이어";
const bivariate$3 = {
  color_manager: {
    layers_filter: "레이어",
    not_defined: "정의되지 않음",
    sentiments_combinations_filter: "감정 조합",
    no_legends: "조건을 충족하는 범례가 없습니다.",
    no_data: "데이터가 없습니다.",
    sentiments_tab: "감정",
    color_legends_tab: "색상 범례",
    layers_tab: "레이어(지표)"
  },
  panel: {
    header: "이변수 매트릭스"
  },
  matrix: {
    caption: {
      base_axis: "기본 축",
      annex_axis: "보조 축",
      tooltip: {
        p1: "기본 축과 보조 축이 포함된 차트를 통해 두 데이터 세트 간의 관계를 설정할 수 있습니다.",
        li1: "보조 축 - 분석 대상 매개변수",
        li2: "기본 축 - 분석의 기준점",
        b: "예: 카페 개업에 최적의 위치",
        p2: "인구 밀도(기본 축)에 대한 음식점 개수(보조 축)를 알아볼 수 있습니다.",
        p3: "이 경우에는 주로 소수의 음식점에 관심이 있는 것이며, 추가적으로 그 장소에 있는 사람 수를 알아볼 수 있습니다."
      }
    },
    header: {
      title: "상관 관계를 알아보려면 두 개의 레이어를 선택합니다.",
      hint: "레이어와 상관 관계가 현재 선택된 영역에 표시됩니다."
    },
    icon: {
      population: "인구로 나눈 값",
      area_km2: "영역으로 나눈 값",
      total_building_count: "전체 건물 추정치로 나눈 값",
      populated_area_km2: "인구 밀집 지역으로 나눈 값",
      one: "나누지 않음",
      roads: "전체 도로 길이로 나눈 값"
    },
    progress: {
      rendering: "렌더링",
      applied: "지도에 적용됨"
    }
  },
  legend: {
    high: "높음",
    low: "낮음",
    medium: "중간"
  }
};
const feed$3 = "피드";
const deselect$3 = "선택 취소";
const spinner_text$3 = "데이터 수집";
const updated$3 = "업데이트됨";
const no_data_received$3 = "수신한 데이터 없음";
const wrong_data_received$3 = "잘못된 데이터 수신";
const error$3 = "오류";
const sort_icon$3 = "정렬 아이콘";
const configs$3 = {
  Kontur_public_feed: "Kontur Public",
  Kontur_public_feed_description: "피드에는 사이클론, 가뭄, 지진, 홍수, 화산 폭발, 산불에 대한 실시간 데이터가 포함됩니다."
};
const errors$3 = {
  "default": "죄송합니다. 문제가 생겼습니다. 곧 해결될 예정입니다.",
  timeout: "요청 시간 초과",
  cannot_connect: "서버에 연결할 수 없습니다.",
  forbidden: "사용할 수 없음",
  not_found: "찾을 수 없음",
  unknown: "알 수 없음",
  server_error: "서버 오류"
};
const event_list$3 = {
  severity_unknown: "알 수 없음",
  warning_title: "지도를 필터로 사용할 수 없습니다.",
  warning_description: "아직 지도를 사용할 수 없습니다. 잠시 후 다시 시도해 주세요.",
  bbox_filter_button: "지도 보기를 필터로 사용",
  analytics: {
    affected_people: {
      tooltip: "영향을 받은 사람",
      value: "인도주의적 영향 없음"
    },
    settled_area_tooltip: "고정된 영역",
    loss_tooltip: "예상 손해"
  },
  no_event_in_feed: "현재 이벤트 피드에서 이벤트를 찾을 수 없음",
  no_selected_disaster: "선택된 재난 없음",
  chose_disaster: "재난 선택"
};
const categories$3 = {
  overlays: "오버레이",
  basemap: "백지도"
};
const groups$3 = {
  layers_in_selected_area: "선택 영역 내 레이어",
  your_layers: "레이어",
  kontur_analytics: "Kontur Analytics",
  qa: "QA",
  osmbasedmap: "OpenStreetMap 기반",
  other: "기타",
  elevation: "입면도",
  photo: "사진",
  map: "지도"
};
const modes$3 = {
  map: "지도",
  about: "정보",
  reports: "보고서",
  profile: "프로필"
};
const advanced_analytics_data_list$3 = {
  load_world_data: "전 세계 데이터 로드하기",
  numerator: "분자",
  normalized_by: "정규화 기준:",
  sum: "합계",
  min: "최소",
  max: "최대",
  mean: "평균",
  stddev: "표본 표준 편차",
  median: "중앙값",
  filter_denominator: "분모 필터"
};
const mcda$3 = {};
const create_layer$3 = {
  edit_layer: "레이어 편집",
  edit_features: "특성 편집",
  delete_layer: "레이어 삭제",
  create_layer: "레이어 생성",
  saving_layer: "레이어 저장 중...",
  field_name: "필드 이름",
  layer_name: "레이어 이름",
  marker_icon: "마커 아이콘",
  type: "유형",
  select: "선택",
  short_text: "짧은 텍스트",
  long_text: "긴 텍스트",
  link: "링크",
  image: "이미지",
  fields: "필드",
  add_field: "필드 추가",
  location: "위치",
  edit_feature_placeholder: "일부 특성을 선택하여 특성 속성 편집을 시작하세요."
};
const analytics_panel$3 = {
  header_title: "분석",
  error_loading: "분석 데이터를 가져오는 중에 오류가 발생했습니다."
};
const advanced_analytics_panel$3 = {
  header_title: "고급 분석",
  error: "고급 분석 데이터를 가져오는 중에 오류가 발생했습니다."
};
const advanced_analytics_empty$3 = {
  not_found: "죄송합니다. 요청하신 이벤트를 찾을 수 없습니다.",
  error: "오류가 발생했습니다."
};
const current_event$3 = {
  not_found_request: "죄송합니다. 요청하신 이벤트를 찾을 수 없습니다."
};
const draw_tools$3 = {
  area: "영역",
  line: "라인",
  point: "점",
  finish_drawing: "그리기 완료",
  caption: "그리기를 시작하려면 지도를 클릭하세요.",
  no_geometry_error: "다운로드할 수 있는 기하 도형이 없습니다.",
  overlap_error: "다각형은 그 자체로 겹치지 않아야 합니다.",
  save_features: "특성 저장"
};
const boundary_selector$3 = {
  title: "행정 경계에 초점 맞추기"
};
const geometry_uploader$3 = {
  title: "업로드된 기하 도형에 초점 맞추기",
  error: "업로드된 파일을 읽는 중 오류가 발생했습니다."
};
const focus_geometry$3 = {
  title: "손으로 직접 그린 기하 도형에 초점 맞추기"
};
const focus_geometry_layer$3 = {
  settings: {
    name: "선택된 영역"
  }
};
const drawings$3 = {
  self_directions_not_supported: "자체 교차는 지원되지 않습니다."
};
const sidebar$3 = {
  biv_color_manager: "색상 관리자",
  edit_osm: "OpenStreetMap에서 편집",
  ruler: "눈금자",
  collapse: "접기",
  expand: "펼치기",
  icon_alt: "애플리케이션 로고"
};
const login$3 = {
  email: "이메일",
  password: "비밀번호",
  login_button: "로그인",
  sign_up: "가입",
  logging_in: "로그인 중...",
  log_in: "로그인",
  description: "설정을 변경하려면 로그인하세요.",
  error: {
    email_empty: "이메일은 필수 입력 사항입니다.",
    email_invalid: "유효한 이메일을 사용해야 합니다.",
    password: "비밀번호는 필수 입력 사항입니다.",
    connect: "인증 서비스에 연결할 수 없습니다."
  }
};
const profile$3 = {
  email: "이메일",
  profileSettingsHeader: "프로필",
  interfaceTheme: "주제",
  interfaceLanguage: "언어",
  units: "단위",
  fullName: "전체 이름",
  metric: "미터법",
  imperialBeta: "영국식 단위(베타)",
  appSettingsHeader: "설정",
  saveButton: "변경 사항 저장",
  konturTheme: "Kontur",
  HOTTheme: "HOT",
  "userBio(about)": "Bio",
  defaultDisasterFeed: "기본 재난 피드",
  defaultOSMeditor: "기본 OpenStreetMap 편집기(베타)",
  successNotification: "모든 변경 사항이 성공적으로 적용되었습니다.",
  languageOption: {
    en: "영어",
    es: "스페인어",
    ar: "아랍어",
    ko: "한국어",
    id: "인도네시아 인",
    de: "독일 말",
    uk: "우크라이나 인"
  }
};
const reports$3 = {
  title: "Disaster Ninja 보고서",
  no_data: "이 보고서에 데이터가 없습니다.",
  sorting: "데이터 정렬 중...",
  loading: "데이터 로딩 중",
  search_location: "위치 검색",
  open_josm: "JOSM 원격 제어를 통해 열기",
  josm_logo_alt: "JOSM 로고",
  see_all: "모든 보고서 보기",
  wrong_id: "잘못된 보고서 ID",
  description: "<0>Kontur</0>는 몇 가지 보고서를 생성하여 OpenStreetMap 품질을 평가하도록 지원합니다. 보고서에는 <4>osm.org </4>의 영역으로 연결되는 링크, 원격 제어가 활성화된 JOSM 편집기에서 해당 영역을 열어 편집할 수 있는 링크가 포함되어 있습니다."
};
const about$3 = {
  title: "Disaster Ninja에 오신 것을 환영합니다!",
  intro: "현재 진행 중인 재난에 대해 알림을 받아보시겠습니까? 전 세계 모든 지역의 인구 데이터와 기타 분석 사항을 즉시 알아보고 싶으신가요? Disaster Ninja에서는 이러한 요구 사항을 해결하기 위해 몇 가지 <2>Kontur</2> 기능을 사용합니다.<br/><br/>처음에는 인도주의적인 문제를 다루기 위한 의사 결정 지원 도구로 고안되었지만, 이제는 기능과 용법이 여러 가지로 늘어났습니다. 재난 관리, 스마트 시티 구축, 기후 변화에 관한 연구 수행 등 어떤 업무를 하더라도 다음과 같은 도움을 드릴 수 있습니다.",
  l1: "1. 전 세계의 최신 위험 이벤트의 동향을 알려 드립니다.",
  p1: "재난 패널이 지속적으로 새로 고침 되어 현재 일어나는 이벤트에 대한 정보를 제공합니다. <2>Kontur 이벤트 피드</2>의 데이터를 사용하며, API를 통해서도 해당 데이터에 액세스할 수 있습니다.",
  l2: "2. 관심 영역을 집중적으로 보여 드립니다.",
  p2: "그리기 도구 패널을 사용하면 자체 기하 도형을 지도에 그리거나 업로드할 수 있습니다. 재난에 노출된 영역이나 행정 단위(예: 국가, 도시, 지역)에 초점을 맞출 수도 있습니다.",
  l3: "3. 집중 영역에 대한 분석을 제공합니다.",
  p3: "분석 패널은 <2>Kontur 인구</2>당 해당 영역에 거주하는 사람의 수와 OpenStreetMap 내 예상 매핑 갭을 보여줍니다. 그 외에도 Kontur 고객은 고급 분석을 통해 수백 가지 지표에 액세스할 수 있습니다.",
  l4: "4. 지도의 데이터를 탐색하여 결론을 내릴 수 있습니다.",
  p4: "레이어 패널을 사용하면 이변수 지도에서 두 가지 지표를 동시에 표시하는 다양한 옵션을 사용할 수 있게 됩니다(예: 인구 밀도, 가장 가까운 소방서까지의 거리). 색상 범례를 사용하여 주의가 필요한 영역을 평가하세요. <br/>힌트: 일반적으로 녹색은 저위험/적은 갭을 의미하고 빨간색은 고위험/많은 갭을 의미합니다.",
  p5: "또한, 왼쪽 패널의 보고서로 이동하여 OpenStreetMap의 잠재적인 오류 및 불일치 데이터에 액세스하고, JOSM 편집기를 통해 각 영역을 매핑하여 해당 데이터를 수정할 수도 있습니다.",
  goToMap: "지금 바로 지도로 이동하세요.",
  p6: "이 도구가 많은 도움이 되기를 바랍니다. 기능에 대해 궁금한 점은 Disaster Ninja의 챗박스를 통해 언제든지 문의해 주시면 도와 드리겠습니다. 도구 개선에 대한 피드백이나 제안 사항이 있을 경우, <1>hello@kontur.io</1> 로 이메일 주셔도 됩니다.<br/><br/>Disaster Ninja는 오픈 소스 프로젝트입니다. <8>Kontur의 GitHub 계정</8>에서 코드를 찾아보세요."
};
const locate_me$3 = {
  get_location_error: "위치를 가져오는 중에 오류가 발생했습니다.",
  feature_title: "내 위치 확인"
};
const episode$3 = "에피소드";
const loading_episodes$3 = "에피소드 로딩 중";
const cookie_banner$3 = {};
const live_sensor$3 = {};
const ko_common = {
  km: km$3,
  m: m$4,
  to: to$3,
  maps: maps$3,
  logout: logout$3,
  save: save$3,
  cancel: cancel$3,
  create: create$3,
  disasters: disasters$3,
  loading: loading$3,
  loading_events: loading_events$3,
  legend: legend$3,
  vertical_direction: vertical_direction$3,
  horizontal_direction: horizontal_direction$3,
  legend_presentation: legend_presentation$3,
  layers: layers$3,
  bivariate: bivariate$3,
  feed: feed$3,
  deselect: deselect$3,
  spinner_text: spinner_text$3,
  updated: updated$3,
  no_data_received: no_data_received$3,
  wrong_data_received: wrong_data_received$3,
  error: error$3,
  sort_icon: sort_icon$3,
  configs: configs$3,
  errors: errors$3,
  event_list: event_list$3,
  categories: categories$3,
  groups: groups$3,
  modes: modes$3,
  advanced_analytics_data_list: advanced_analytics_data_list$3,
  mcda: mcda$3,
  create_layer: create_layer$3,
  analytics_panel: analytics_panel$3,
  advanced_analytics_panel: advanced_analytics_panel$3,
  advanced_analytics_empty: advanced_analytics_empty$3,
  current_event: current_event$3,
  draw_tools: draw_tools$3,
  boundary_selector: boundary_selector$3,
  geometry_uploader: geometry_uploader$3,
  focus_geometry: focus_geometry$3,
  focus_geometry_layer: focus_geometry_layer$3,
  drawings: drawings$3,
  sidebar: sidebar$3,
  login: login$3,
  profile: profile$3,
  reports: reports$3,
  about: about$3,
  locate_me: locate_me$3,
  episode: episode$3,
  loading_episodes: loading_episodes$3,
  cookie_banner: cookie_banner$3,
  live_sensor: live_sensor$3
};
const km$2 = "km";
const m$3 = "m";
const to$2 = "ke";
const maps$2 = "peta";
const logout$2 = "Keluar";
const save$2 = "Simpan";
const cancel$2 = "Batalkan";
const create$2 = "Buat";
const disasters$2 = "Bencana";
const loading$2 = "Memuat...";
const loading_events$2 = "Memuat kejadian";
const legend$2 = "Legenda";
const vertical_direction$2 = "Arah vertikal";
const horizontal_direction$2 = "Arah horizontal";
const legend_presentation$2 = "Penyajian legenda";
const layers$2 = "Lapisan";
const bivariate$2 = {
  color_manager: {
    layers_filter: "Lapisan",
    not_defined: "Tidak terdefinisi",
    sentiments_combinations_filter: "Gabungan sentimen",
    no_legends: "Tidak ada legenda yang memenuhi kondisi ini.",
    no_data: "Tidak Ada Data.",
    sentiments_tab: "Sentimen",
    color_legends_tab: "Legenda Warna",
    layers_tab: "Lapisan (indikator)"
  },
  panel: {
    header: "Matriks Bivariat"
  },
  matrix: {
    caption: {
      base_axis: "Sumbu Dasar",
      annex_axis: "Sumbu Tambahan",
      tooltip: {
        p1: "Diagram yang mencakup sumbu Dasar dan sumbu Tambahan membantu menetapkan hubungan antara dua kumpulan data.",
        li1: "Sumbu Tambahan - parameter yang kita analisis",
        li2: "Sumbu Dasar - titik referensi dalam analisis",
        b: "Contoh: lokasi terbaik untuk membuka kafe",
        p2: "Kita dapat menyelidiki jumlah tempat makan (sumbu Tambahan) terhadap Kerapatan populasi (sumbu Dasar).",
        p3: "Dalam skenario ini, pada awalnya kita tertarik dengan beberapa tempat makan, lalu kita mendapatkan informasi tambahan dari jumlah orang di tempat itu."
      }
    },
    header: {
      title: "Pilih dua lapisan untuk memeriksa korelasi",
      hint: "Lapisan dan korelasi ditampilkan untuk Area Pilihan terkini"
    },
    icon: {
      population: "Nilai dibagi dengan Populasi",
      area_km2: "Nilai dibagi dengan Area",
      total_building_count: "Nilai dibagi dengan Perkiraan Jumlah Bangunan",
      populated_area_km2: "Nilai dibagi dengan Area Berpenduduk",
      one: "Tanpa pembagi",
      roads: "Nilai dibagi dengan Total Panjang Jalan"
    },
    progress: {
      rendering: "Merender",
      applied: "Diterapkan pada peta"
    }
  },
  legend: {
    high: "Tinggi",
    low: "Rendah",
    medium: "Sedang"
  }
};
const feed$2 = "Feed";
const deselect$2 = "Batalkan Pilihan";
const spinner_text$2 = "Mengumpulkan data";
const updated$2 = "Diperbarui";
const no_data_received$2 = "Tidak ada data yang diterima";
const wrong_data_received$2 = "Data yang diterima salah";
const error$2 = "Kesalahan";
const sort_icon$2 = "Sortir Ikon";
const configs$2 = {
  Kontur_public_feed: "Publik Kontur",
  Kontur_public_feed_description: "Feed berisi data waktu-nyata tentang Angin Topan, Kekeringan, Gempa, Banjir, Gunung Meletus, Kebakaran Hutan."
};
const errors$2 = {
  "default": "Maaf, kami mengalami masalah yang akan segera diperbaiki",
  timeout: "Waktu Permintaan Habis",
  cannot_connect: "Tidak dapat terhubung ke server",
  forbidden: "Terlarang",
  not_found: "Tidak ditemukan",
  unknown: "Tidak diketahui",
  server_error: "Kesalahan Server"
};
const event_list$2 = {
  severity_unknown: "Tidak diketahui",
  warning_title: "Tidak dapat menggunakan peta sebagai filter",
  warning_description: "Peta belum siap, coba nanti",
  bbox_filter_button: "Gunakan tampilan peta sebagai filter",
  analytics: {
    affected_people: {
      tooltip: "Orang yang Terdampak",
      value: "Tidak berdampak kemanusiaan"
    },
    settled_area_tooltip: "Area yang Ditempati",
    loss_tooltip: "Estimasi kerugian"
  },
  no_event_in_feed: "Kejadian tidak ditemukan di feed kejadian terkini",
  no_selected_disaster: "Tidak ada bencana yang dipilih",
  chose_disaster: "Pilih bencana"
};
const categories$2 = {
  overlays: "Tumpang Susun",
  basemap: "Peta Dasar"
};
const groups$2 = {
  layers_in_selected_area: "Lapisan di area pilihan",
  your_layers: "Lapisan Anda",
  kontur_analytics: "Analitik Kontur",
  qa: "QA",
  osmbasedmap: "Berbasis OpenStreetMap",
  other: "Lainnya",
  elevation: "Elevasi",
  photo: "Foto",
  map: "Peta"
};
const modes$2 = {
  map: "Peta",
  about: "Tentang",
  reports: "Laporan",
  profile: "Profil"
};
const advanced_analytics_data_list$2 = {
  load_world_data: "Memuat Data Dunia",
  numerator: "Pembilang",
  normalized_by: "Dinormalkan Dengan",
  sum: "Jumlah",
  min: "Min",
  max: "Maks",
  mean: "Rerata",
  stddev: "Simpangan baku",
  median: "Median",
  filter_denominator: "Filter Penyebut"
};
const mcda$2 = {};
const create_layer$2 = {
  edit_layer: "Edit Lapisan",
  edit_features: "Edit Fitur",
  delete_layer: "Hapus Lapisan",
  create_layer: "Buat Lapisan",
  saving_layer: "Menyimpan lapisan...",
  field_name: "Nama bidang",
  layer_name: "Nama lapisan",
  marker_icon: "Ikon penanda",
  type: "Jenis",
  select: "Pilih",
  short_text: "Teks Singkat",
  long_text: "Teks Panjang",
  link: "Tautan",
  image: "Gambar",
  fields: "Bidang",
  add_field: "Tambahkan bidang",
  location: "Lokasi",
  edit_feature_placeholder: "Pilih beberapa fitur untuk mulai mengedit properti fitur"
};
const analytics_panel$2 = {
  header_title: "Analitik",
  error_loading: "Kesalahan saat mengambil data analitik"
};
const advanced_analytics_panel$2 = {
  header_title: "Analitik tingkat lanjut",
  error: "Kesalahan saat mengambil data analitik tingkat lanjut"
};
const advanced_analytics_empty$2 = {
  not_found: "Maaf, kejadian yang diminta tidak ditemukan.",
  error: "Terjadi kesalahan!"
};
const current_event$2 = {
  not_found_request: "Maaf, kejadian yang diminta tidak ditemukan."
};
const draw_tools$2 = {
  area: "Area",
  line: "Garis",
  point: "Titik",
  finish_drawing: "Selesai Menggambar",
  caption: "Klik peta untuk mulai menggambar",
  no_geometry_error: "Tidak ada gambar geometri untuk diunduh",
  overlap_error: "Poligon tidak boleh bertumpang-tindih sendiri",
  save_features: "Simpan fitur"
};
const boundary_selector$2 = {
  title: "Fokus ke batas administratif"
};
const geometry_uploader$2 = {
  title: "Fokus ke geometri unggahan",
  error: "Kesalahan saat membaca file unggahan"
};
const focus_geometry$2 = {
  title: "Fokus ke geometri bebas"
};
const focus_geometry_layer$2 = {
  settings: {
    name: "Area Pilihan"
  }
};
const drawings$2 = {
  self_directions_not_supported: "Tidak mendukung perpotongan dengan dirinya sendiri!"
};
const sidebar$2 = {
  biv_color_manager: "Pengelola warna",
  edit_osm: "Edit di OpenStreetMap",
  ruler: "Penggaris",
  collapse: "Ciutkan",
  expand: "Bentangkan",
  icon_alt: "Logo aplikasi"
};
const login$2 = {
  email: "Email",
  password: "Kata Sandi",
  login_button: "Masuk",
  sign_up: "Daftar",
  logging_in: "Masuk...",
  log_in: "Masuk",
  description: "Masuk untuk mengubah pengaturan Anda",
  error: {
    email_empty: "Email tidak boleh kosong!",
    email_invalid: "Email harus valid!",
    password: "Kata sandi tidak boleh kosong!",
    connect: "Tidak dapat terhubung ke layanan autentikasi"
  }
};
const profile$2 = {
  email: "Email",
  profileSettingsHeader: "Profil",
  interfaceTheme: "Tema",
  interfaceLanguage: "Bahasa",
  units: "Satuan",
  fullName: "Nama Lengkap",
  metric: "metrik",
  imperialBeta: "imperial (beta)",
  appSettingsHeader: "Pengaturan",
  saveButton: "Simpan perubahan",
  konturTheme: "Kontur",
  HOTTheme: "HANGAT",
  "userBio(about)": "Bio",
  defaultDisasterFeed: "Feed bencana bawaan",
  defaultOSMeditor: "Editor OpenStreetMap bawaan (beta)",
  successNotification: "Semua perubahan telah berhasil diterapkan",
  languageOption: {
    en: "Inggris",
    es: "Spanyol",
    ar: "Arab",
    ko: "Korea",
    id: "Indonesia",
    de: "Jerman",
    uk: "Orang Ukraina"
  }
};
const reports$2 = {
  title: "Laporan Disaster Ninja",
  no_data: "Tidak ada data untuk laporan ini",
  sorting: "Menyortir data...",
  loading: "Memuat data",
  search_location: "Cari lokasi",
  open_josm: "Buka melalui kendali jarak jaruh JOSM",
  josm_logo_alt: "Logo JOSM",
  see_all: "Lihat semua laporan",
  wrong_id: "ID laporan salah",
  description: "<0>Kontur </0> menghasilkan beberapa laporan yang membantu memvalidasi kualitas OpenStreetMap. Laporan tersebut berisi tautan ke area di <4>osm.org </4> dan tautan untuk membukanya di editor JOSM dengan kendali jarak jauh untuk pengeditan yang diaktifkan."
};
const about$2 = {
  title: "Selamat datang di Disaster Ninja!",
  intro: "Apakah Anda ingin menerima kabar tentang bencana yang sedang terjadi? Anda tertarik dengan data populasi dan analitik lainnya yang tersaji seketika untuk wilayah mana pun di dunia? Disaster Ninja menampilkan beberapa kemampuan dari <2>Kontur</2> dalam mengatasi berbagai kebutuhan ini.<br/><br/>Pada awalnya, kami merancang alat ini sebagai alat bantu untuk pemetaan kemanusiaan. Kini, fungsionalitas dan kasus penggunaannya telah bertambah. Apakah Anda bekerja pada pengelolaan bencana, membangun kota cerdas, ataupun meneliti perubahan iklim, Disaster Ninja dapat membantu Anda untuk:",
  l1: "1. Selalu mendapatkan kabar terbaru tentang kejadian berbahaya terkini di seluruh dunia.",
  p1: "Panel Bencana disegarkan secara terus-menerus untuk memberi tahu Anda kejadian yang sedang berlangsung. Panel ini memakai data dari <2>Feed Kejadian Kontur</2>, yang juga dapat diakses melalui API.",
  l2: "2. Fokus pada area perhatian Anda.",
  p2: "Panel Peralatan Gambar memungkinkan Anda menggambar atau mengunggah geometri Anda sendiri pada peta. Anda juga dapat berfokus pada area yang terpapar bencana atau satuan administratif — negara, kota, atau wilayah.",
  l3: "3. Dapatkan analitik untuk area yang menjadi fokus.",
  p3: "Panel Analitik memperlihatkan jumlah orang yang tinggal di area tersebut untuk setiap <2>Populasi Kontur</2> dan perkiraan kesenjangan pemetaan di OpenStreetMap. Pelanggan Kontur memiliki akses ke ratusan indikator lainnya melalui Analitik Lanjut.",
  l4: "4. Selidiki data pada peta dan buat kesimpulan.",
  p4: "Panel Lapisan memberi Anda berbagai opsi untuk menampilkan dua indikator secara serentak pada peta bivariat, misalnya kepadatan populasi dan jarak ke stasiun pemadam kebakaran terdekat. Gunakan legenda warna untuk menilai area mana yang perlu diperhatikan. <br/>Petunjuk: secara umum, warna hijau menunjukkan risiko rendah/sedikit kesenjangan, warna merah — risiko tinggi/banyak kesenjangan.",
  p5: "Selain itu, Anda dapat beralih ke Laporan di panel kiri untuk mengakses data tentang potensi kesalahan dan inkonsistensi di OpenStreetMap serta membantu memperbaikinya dengan memetakan masing-masing area menggunakan editor JOSM.",
  goToMap: "Buka peta sekarang",
  p6: "Kami berharap agar alat ini bermanfaat bagi Anda. Gunakan kotak obrolan di Disaster Ninja untuk setiap pertanyaan tentang fungsionalitas, dan kami dengan senang hati akan memandu Anda. Anda juga dapat menghubungi kami melalui email di <1>hello@kontur.io</1> jika Anda memiliki tanggapan atau saran untuk meningkatkan alat ini.<br/><br/>Disaster Ninja adalah proyek sumber terbuka. Temukan kodenya di <8>akun GitHub Kontur</8>."
};
const locate_me$2 = {
  get_location_error: "Kesalahan saat memperoleh lokasi",
  feature_title: "Temukan saya"
};
const episode$2 = "Episode";
const loading_episodes$2 = "Memuat Episode";
const cookie_banner$2 = {};
const live_sensor$2 = {};
const id_common = {
  km: km$2,
  m: m$3,
  to: to$2,
  maps: maps$2,
  logout: logout$2,
  save: save$2,
  cancel: cancel$2,
  create: create$2,
  disasters: disasters$2,
  loading: loading$2,
  loading_events: loading_events$2,
  legend: legend$2,
  vertical_direction: vertical_direction$2,
  horizontal_direction: horizontal_direction$2,
  legend_presentation: legend_presentation$2,
  layers: layers$2,
  bivariate: bivariate$2,
  feed: feed$2,
  deselect: deselect$2,
  spinner_text: spinner_text$2,
  updated: updated$2,
  no_data_received: no_data_received$2,
  wrong_data_received: wrong_data_received$2,
  error: error$2,
  sort_icon: sort_icon$2,
  configs: configs$2,
  errors: errors$2,
  event_list: event_list$2,
  categories: categories$2,
  groups: groups$2,
  modes: modes$2,
  advanced_analytics_data_list: advanced_analytics_data_list$2,
  mcda: mcda$2,
  create_layer: create_layer$2,
  analytics_panel: analytics_panel$2,
  advanced_analytics_panel: advanced_analytics_panel$2,
  advanced_analytics_empty: advanced_analytics_empty$2,
  current_event: current_event$2,
  draw_tools: draw_tools$2,
  boundary_selector: boundary_selector$2,
  geometry_uploader: geometry_uploader$2,
  focus_geometry: focus_geometry$2,
  focus_geometry_layer: focus_geometry_layer$2,
  drawings: drawings$2,
  sidebar: sidebar$2,
  login: login$2,
  profile: profile$2,
  reports: reports$2,
  about: about$2,
  locate_me: locate_me$2,
  episode: episode$2,
  loading_episodes: loading_episodes$2,
  cookie_banner: cookie_banner$2,
  live_sensor: live_sensor$2
};
const km$1 = "km";
const m$2 = "m";
const to$1 = "bis";
const maps$1 = "Karten";
const logout$1 = "Abmelden";
const save$1 = "Speichern";
const cancel$1 = "Abbrechen";
const create$1 = "Erstellen";
const disasters$1 = "Katastrophen";
const loading$1 = "Wird geladen...";
const loading_events$1 = "Ereignisse werden geladen";
const legend$1 = "Legende";
const vertical_direction$1 = "Vertikale Richtung";
const horizontal_direction$1 = "Horizontale Richtung";
const legend_presentation$1 = "Darstellung der Legende";
const layers$1 = "Ebenen";
const bivariate$1 = {
  color_manager: {
    layers_filter: "Ebenen",
    not_defined: "Nicht definiert",
    sentiments_combinations_filter: "Stimmungs-Kombinationen",
    no_legends: "Es gibt keine Legenden, die den Kriterien entsprechen.",
    no_data: "Keine Daten.",
    sentiments_tab: "Stimmungen",
    color_legends_tab: "Farbe Legenden",
    layers_tab: "Ebenen (Indikatoren)"
  },
  panel: {
    header: "Bivariate Matrix"
  },
  matrix: {
    caption: {
      base_axis: "Basisachse",
      annex_axis: "Hilfsachse",
      tooltip: {
        p1: "Diagramme mit der Basis- und der Hilfsachse helfen, eine Beziehung zwischen zwei Datensätzen herzustellen.",
        li1: "Hilfsachse - Parameter, die wir analysieren",
        li2: "Basisachse - Referenzpunkt in der Analyse",
        b: "Beispiel: der beste Standort für die Eröffnung eines Cafés",
        p2: "Wir können die Anzahl der Lokale (Hilfsachse) gegen die Bevölkerungsdichte (Basisachse) untersuchen.",
        p3: "In diesem Szenario liegt unser Interesse zunächst auf einer kleinen Anzahl von Lokalen, wobei uns die Anzahl der Personen in diesem Ort zusätzliche Informationen liefert."
      }
    },
    header: {
      title: "Wählen Sie zwei Ebenen, um Zusammenhänge zu untersuchen",
      hint: "Die Ebenen und Zusammenhänge werden für den aktuellen ausgewählten Bereich angezeigt"
    },
    icon: {
      population: "Wert geteilt durch Einwohnerzahl",
      area_km2: "Wert geteilt durch Fläche",
      total_building_count: "Wert geteilt durch geschätzte Gesamtbebauung",
      populated_area_km2: "Wert geteilt durch bevölkerte Fläche",
      one: "Ohne Teilung",
      roads: "Wert geteilt durch die Gesamtlänge der Straßen"
    },
    progress: {
      rendering: "Übertragung",
      applied: "Wird auf die Karte angewendet"
    }
  },
  legend: {
    high: "Hoch",
    low: "Niedrig",
    medium: "Mittel"
  }
};
const feed$1 = "Feed";
const deselect$1 = "Auswahl aufheben";
const spinner_text$1 = "Daten sammeln";
const updated$1 = "Aktualisiert";
const no_data_received$1 = "Keine Daten erhalten";
const wrong_data_received$1 = "Falsche Daten empfangen";
const error$1 = "Fehler";
const sort_icon$1 = "Sortiersymbol";
const configs$1 = {
  Kontur_public_feed: "Kontur Öffentlichkeit",
  Kontur_public_feed_description: "Der Feed enthält Echtzeitdaten über Wirbelstürme, Dürren, Erdbeben, Überschwemmungen, Vulkanausbrüche und Waldbrände."
};
const errors$1 = {
  "default": "Leider gibt es derzeit ein paar Probleme, die wir in Kürze beheben werden",
  timeout: "Zeitüberschreitung der Anfrage",
  cannot_connect: "Die Verbindung zum Server kann nicht hergestellt werden",
  forbidden: "Verboten",
  not_found: "Nicht gefunden",
  unknown: "Unbekannt",
  server_error: "Serverfehler"
};
const event_list$1 = {
  severity_unknown: "Unbekannt",
  warning_title: "Die Karte kann nicht als Filter verwendet werden",
  warning_description: "Die Karte ist noch nicht bereit. Bitte versuchen Sie es später.",
  bbox_filter_button: "Kartenansicht als Filter verwenden",
  analytics: {
    affected_people: {
      tooltip: "Betroffene Menschen",
      value: "Keine humanitären Auswirkungen"
    },
    settled_area_tooltip: "Besiedeltes Gebiet",
    loss_tooltip: "Geschätzter Verlust"
  },
  no_event_in_feed: "Das Ereignis wurde nicht im aktuellen Ereignis-Feed gefunden",
  no_selected_disaster: "Keine Katastrophe ausgewählt",
  chose_disaster: "Katastrophe auswählen"
};
const categories$1 = {
  overlays: "Überlagerungen",
  basemap: "Basiskarte"
};
const groups$1 = {
  layers_in_selected_area: "Ebenen im ausgewählten Bereich",
  your_layers: "Ihre Ebenen",
  kontur_analytics: "Kontur Analytik",
  qa: "QS",
  osmbasedmap: "Basierend auf OpenStreetMap",
  other: "Andere",
  elevation: "Höhe",
  photo: "Foto",
  map: "Karte"
};
const modes$1 = {
  map: "Karte",
  about: "Über uns",
  reports: "Berichte",
  profile: "Profil"
};
const advanced_analytics_data_list$1 = {
  load_world_data: "Weltdaten laden",
  numerator: "Zähler",
  normalized_by: "Normalisiert auf",
  sum: "Summe",
  min: "Min",
  max: "Max",
  mean: "Mittelwert",
  stddev: "SD",
  median: "Median",
  filter_denominator: "Filter Nenner"
};
const mcda$1 = {};
const create_layer$1 = {
  edit_layer: "Ebene bearbeiten",
  edit_features: "Merkmale bearbeiten",
  delete_layer: "Ebene löschen",
  create_layer: "Ebene erstellen",
  saving_layer: "Ebene wird gespeichert...",
  field_name: "Feldname",
  layer_name: "Name der Ebene",
  marker_icon: "Markierungssymbol",
  type: "Typ",
  select: "Auswählen",
  short_text: "Kurzer Text",
  long_text: "Langer Text",
  link: "Link",
  image: "Bild",
  fields: "Felder",
  add_field: "Feld hinzufügen",
  location: "Standort",
  edit_feature_placeholder: "Wählen Sie einige Merkmale aus, um Merkmalseigenschaften zu bearbeiten"
};
const analytics_panel$1 = {
  header_title: "Analytik",
  error_loading: "Fehler beim Abrufen von Analysedaten"
};
const advanced_analytics_panel$1 = {
  header_title: "Erweiterte Analytik",
  error: "Fehler beim Abrufen von erweiterten Analysedaten"
};
const advanced_analytics_empty$1 = {
  not_found: "Leider wurde das gewünschte Ereignis nicht gefunden.",
  error: "Es ist ein Fehler aufgetreten!"
};
const current_event$1 = {
  not_found_request: "Leider wurde das gewünschte Ereignis nicht gefunden."
};
const draw_tools$1 = {
  area: "Gebiet",
  line: "Linie",
  point: "Punkt",
  finish_drawing: "Zeichnen beenden",
  caption: "Klicken Sie auf die Karte, um mit dem Zeichnen zu beginnen",
  no_geometry_error: "Keine gezeichnete Formen zum Herunterladen",
  overlap_error: "Das Polygon darf sich nicht überschneiden",
  save_features: "Merkmale speichern"
};
const boundary_selector$1 = {
  title: "Fokus auf die Verwaltungsgrenze"
};
const geometry_uploader$1 = {
  title: "Fokus auf die hochgeladene geometrische Form",
  error: "Fehler beim Lesen der hochgeladenen Datei"
};
const focus_geometry$1 = {
  title: "Fokus auf freihändig gezeichnete Formen"
};
const focus_geometry_layer$1 = {
  settings: {
    name: "Ausgewähltes Gebiet"
  }
};
const drawings$1 = {
  self_directions_not_supported: "Überschneidungen werden nicht unterstützt!"
};
const sidebar$1 = {
  biv_color_manager: "Farbmanager",
  edit_osm: "In OpenStreetMap bearbeiten",
  ruler: "Lineal",
  collapse: "Zusammenklappen",
  expand: "Erweitern",
  icon_alt: "Logo der Anwendung"
};
const login$1 = {
  email: "E-Mail",
  password: "Passwort",
  login_button: "Anmelden",
  sign_up: "Registrieren",
  logging_in: "Anmelden...",
  log_in: "Einloggen",
  description: "Bitte melden Sie sich an, um Ihre Einstellungen zu ändern",
  error: {
    email_empty: "E-Mail darf nicht leer sein!",
    email_invalid: "E-Mail muss gültig sein!",
    password: "Passwort darf nicht leer sein!",
    connect: "Die Verbindung zum Authentifizierungsdienst konnte nicht hergestellt werden"
  }
};
const profile$1 = {
  email: "E-Mail",
  profileSettingsHeader: "Profil",
  interfaceTheme: "Thema",
  interfaceLanguage: "Sprache",
  units: "Einheiten",
  fullName: "Vollständiger Name",
  metric: "metrisch",
  imperialBeta: "imperial (beta)",
  appSettingsHeader: "Einstellungen",
  saveButton: "Änderungen speichern",
  konturTheme: "Kontur",
  HOTTheme: "HOT",
  "userBio(about)": "Bio",
  defaultDisasterFeed: "Standardmäßige Katastrophenmeldung",
  defaultOSMeditor: "Standardmäßiger OpenStreetMap-Editor (Beta)",
  successNotification: "Alle Änderungen wurden erfolgreich übernommen",
  languageOption: {
    en: "Englisch",
    es: "Spanisch",
    ar: "Arabisch",
    ko: "Koreanisch",
    id: "Indonesisch",
    de: "Deutsch",
    uk: "Ukrainisch"
  }
};
const reports$1 = {
  title: "Disaster Ninja Berichte",
  no_data: "Keine Daten für diesen Bericht",
  sorting: "Daten werden sortiert...",
  loading: "Daten werden geladen",
  search_location: "Standort suchen",
  open_josm: "Öffnen über die JOSM-Fernsteuerung",
  josm_logo_alt: "JOSM-Logo",
  see_all: "Alle Berichte anzeigen",
  wrong_id: "Falsche Berichts-ID",
  description: "<0>Kontur </0> generiert verschiedene Berichte, die bei der Überprüfung der Qualität von OpenStreetMap helfen. Sie enthalten Links zu Gebieten auf <4>osm.org </4> und Links, um sie im JOSM-Editor mit aktivierter Fernsteuerung zur Bearbeitung öffnen zu können."
};
const about$1 = {
  title: "Willkommen bei Disaster Ninja!",
  intro: "Möchten Sie über aktuelle Katastrophen informiert werden? Sind Sie an sofortigen Bevölkerungsdaten und anderen Analysen für eine beliebige Region auf der Welt interessiert? Disaster Ninja zeigt Ihnen einige der Funktionen von <2>Kontur</2>, mit denen diese Anforderungen umgesetzt werden können.<br/><br/>Ursprünglich haben wir es als Entscheidungshilfe für Kartografen im humanitären Bereich entwickelt. Mittlerweile ist der Funktionsumfang und der Anwendungsbereich des Programms erweitert worden. Ganz gleich, ob Sie im Katastrophenmanagement tätig sind, eine intelligente Stadt bauen oder über den Klimawandel forschen, Disaster Ninja kann Ihnen dabei helfen:",
  l1: "1. Über die aktuellen Gefahrenereignisse weltweit auf dem Laufenden zu bleiben.",
  p1: "Das Bedienfeld von Disasters wird kontinuierlich aktualisiert, um Sie über aktuelle Ereignisse zu informieren. Es bezieht die Daten aus dem <2>Kontur Ereignis-Feed</2>, auf den Sie auch über eine API zugreifen können.",
  l2: "2. Den Fokus auf Ihr Interessengebiet zu legen.",
  p2: "Mit den Zeichenwerkzeugen können Sie Ihre eigene geometrische Form auf die Karte zeichnen oder hochladen. Sie können sich auch auf ein von einer Katastrophe betroffenes Gebiet oder eine Verwaltungseinheit - ein Land, eine Stadt oder eine Region - konzentrieren.",
  l3: "3. Die Analytik für den ausgewählten Bereich aufrufen.",
  p3: "Das Bedienfeld Analytik zeigt die Anzahl der in diesem Gebiet lebenden Menschen pro <2>Kontur Bevölkerung</2> und geschätzte Kartierungslücken in OpenStreetMap. Kontur-Kunden haben über Erweiterte Analytik Zugang zu Hunderten von weiteren Indikatoren.",
  l4: "4. Die Daten auf der Karte entdecken und Schlussfolgerungen ziehen.",
  p4: "Das Ebenen-Panel bietet Ihnen verschiedene Optionen, um zwei Indikatoren gleichzeitig auf einer bivariaten Karte anzuzeigen, z. B. die Bevölkerungsdichte und die Entfernung zur nächsten Feuerwache. Verwenden Sie die Farblegende, um zu beurteilen, welche Bereiche Aufmerksamkeit erfordern. <br/>Tipp: Im Allgemeinen bedeutet grün ein geringes Risiko / wenige Lücken, rot ein hohes Risiko / viele Lücken.",
  p5: "Außerdem können Sie im linken Bereich zu Berichte wechseln, um auf Daten zu potenziellen Fehlern und Unstimmigkeiten in OpenStreetMap zuzugreifen und dabei zu helfen, diese zu beheben, indem Sie das entsprechende Gebiet mit dem JOSM-Editor kartieren.",
  goToMap: "Jetzt die Karte aufrufen",
  p6: "Wir hoffen, dass dieses Tool Ihnen von Nutzen ist. Wenn Sie Fragen zur Funktionalität haben, können Sie die Chatbox auf Disaster Ninja nutzen, und wir helfen Ihnen gerne weiter. Sie können uns auch eine E-Mail an <1>hello@kontur.io</1> schreiben, wenn Sie Feedback oder Vorschläge zur Verbesserung des Tools haben.<br/><br/>Disaster Ninja ist ein Open-Source-Projekt. Sie finden den Code in <8>Konturs GitHub-Konto</8>."
};
const locate_me$1 = {
  get_location_error: "Fehler beim Abrufen des Standorts",
  feature_title: "Standort finden"
};
const episode$1 = "Episode";
const loading_episodes$1 = "Episoden werden geladen";
const cookie_banner$1 = {};
const live_sensor$1 = {};
const de_common = {
  km: km$1,
  m: m$2,
  to: to$1,
  maps: maps$1,
  logout: logout$1,
  save: save$1,
  cancel: cancel$1,
  create: create$1,
  disasters: disasters$1,
  loading: loading$1,
  loading_events: loading_events$1,
  legend: legend$1,
  vertical_direction: vertical_direction$1,
  horizontal_direction: horizontal_direction$1,
  legend_presentation: legend_presentation$1,
  layers: layers$1,
  bivariate: bivariate$1,
  feed: feed$1,
  deselect: deselect$1,
  spinner_text: spinner_text$1,
  updated: updated$1,
  no_data_received: no_data_received$1,
  wrong_data_received: wrong_data_received$1,
  error: error$1,
  sort_icon: sort_icon$1,
  configs: configs$1,
  errors: errors$1,
  event_list: event_list$1,
  categories: categories$1,
  groups: groups$1,
  modes: modes$1,
  advanced_analytics_data_list: advanced_analytics_data_list$1,
  mcda: mcda$1,
  create_layer: create_layer$1,
  analytics_panel: analytics_panel$1,
  advanced_analytics_panel: advanced_analytics_panel$1,
  advanced_analytics_empty: advanced_analytics_empty$1,
  current_event: current_event$1,
  draw_tools: draw_tools$1,
  boundary_selector: boundary_selector$1,
  geometry_uploader: geometry_uploader$1,
  focus_geometry: focus_geometry$1,
  focus_geometry_layer: focus_geometry_layer$1,
  drawings: drawings$1,
  sidebar: sidebar$1,
  login: login$1,
  profile: profile$1,
  reports: reports$1,
  about: about$1,
  locate_me: locate_me$1,
  episode: episode$1,
  loading_episodes: loading_episodes$1,
  cookie_banner: cookie_banner$1,
  live_sensor: live_sensor$1
};
const km = "км";
const m$1 = "м";
const to = "до";
const maps = "мапи";
const logout = "Вийти";
const save = "Зберегти";
const cancel = "Скасувати";
const create = "Створити";
const disasters = "Катастрофа";
const loading = "Завантаження...";
const loading_events = "Завантажуємо події";
const legend = "Легенда";
const vertical_direction = "По вертикалі";
const horizontal_direction = "По горизонталі";
const legend_presentation = "Презентація легенди";
const layers = "Шари";
const bivariate = {
  color_manager: {
    layers_filter: "Шари",
    not_defined: "Не задано",
    sentiments_combinations_filter: "Комбінація сентиментів",
    no_legends: "Немає легенд, що задовольняють умовам.",
    no_data: "Немає даних.",
    sentiments_tab: "Сентименти",
    color_legends_tab: "Легенда кольорів",
    layers_tab: "Шари (індикатори)"
  },
  panel: {
    header: "Біваріативна Матриця"
  },
  matrix: {
    caption: {
      base_axis: "Базова вісь",
      annex_axis: "Додаткова вісь",
      tooltip: {
        p1: "Діаграми, що містять базову та додаткову осі, допомагають встановити зв’язок між двома наборами даних.",
        li1: "Додаткова вісь - параметри, які ми аналізуємо",
        li2: "Базова вісь - орієнтир при аналізі",
        b: "Наприклад: найкраще місце щоб відкрити кафе",
        p2: "Ми можемо дослідити кількість закладів харчування (додаткова вісь) проти щільності населення (базова вісь).",
        p3: "У цьому сценарії нас спочатку цікавить невелика кількість закладів харчування, а кількість людей у цьому місці дає нам додаткову інформацію."
      }
    },
    header: {
      title: "Виберіть два шари, щоб дослідити їх кореляції",
      hint: "Шари та кореляції показані для виділеної області"
    },
    icon: {
      population: "Значення, поділене на кількість населення",
      area_km2: "Значення, поділене на площу",
      total_building_count: "Значення, поділене на загальну кількість будівель",
      populated_area_km2: "Значення, поділене на заселену площу",
      one: "Без знаменника",
      roads: "Значення, поділене на загальну довжину доріг"
    },
    progress: {
      rendering: "Візуалізація",
      applied: "Нанесено на карту"
    },
    loading_error: "На жаль, ми не можемо показати матрицю. Спробуйте оновити сторінку або зачекать."
  },
  legend: {
    high: "Високий",
    low: "Низький",
    medium: "Середній"
  }
};
const feed = "Стрічка";
const deselect = "Зняти вибір";
const spinner_text = "Збираємо дані";
const updated = "Оновлено";
const no_data_received = "Немає даних";
const wrong_data_received = "Отримано неправильні дані";
const error = "Помилка";
const sort_icon = "Значок сортування";
const configs = {
  Kontur_public_feed_description: "Стрічка містить дані в реальному часі про циклони, посухи, землетруси, повені, вулкани, лісові пожежі."
};
const errors = {
  "default": "Вибачте, у нас виникли проблеми, які незабаром будуть вирішені",
  timeout: "Час очікування запиту минув",
  cannot_connect: "Не вдається під'єднатися до сервера",
  forbidden: "Заборонено",
  not_found: "Не знайдено",
  unknown: "Невідомий",
  server_error: "Помилка серверу"
};
const event_list = {
  severity_unknown: "Невідомий",
  warning_title: "Не можливо використовувати карту як фільтр",
  warning_description: "Карта ще не готова, спробуйте пізніше",
  bbox_filter_button: "Використовуйте перегляд карти як фільтр",
  analytics: {
    affected_people: {
      tooltip: "Люди які постраждали",
      value: "Жодного гуманітарного впливу"
    },
    settled_area_tooltip: "Заселений район",
    loss_tooltip: "Орієнтовні збитки"
  },
  no_event_in_feed: "Подія не знайдена у вибраній стрічці подій",
  no_selected_disaster: "Катастрофа не вибрана",
  chose_disaster: "Виберіть катастрофу",
  no_historical_disasters: "Катастроф на цій території не знайдено",
  no_feed_disasters: "У стрічці немає катастроф",
  no_disasters: "Ніяких катастроф",
  severity_termination: "Припинення",
  severity_minor: "Незначний",
  severity_moderate: "Помірний",
  severity_severe: "Сильний",
  severity_extreme: "Екстримальний",
  open_timeline_button: "Відкрити темпоральну шкалу"
};
const categories = {
  overlays: "Оверлеї",
  basemap: "Базова карта"
};
const groups = {
  layers_in_selected_area: "Шари у вибраній області",
  your_layers: "Ваші шари",
  kontur_analytics: "Аналітика Kontur",
  qa: "Аналітика якості",
  osmbasedmap: "На основі OpenStreetMap",
  other: "Інше",
  elevation: "Рел'єф",
  photo: "Фото",
  map: "Мапа"
};
const modes = {
  map: "Мапа",
  about: "Про нас",
  reports: "Звіти",
  profile: "Профіль",
  privacy: "Конфіденційність"
};
const advanced_analytics_data_list = {
  load_world_data: "Завантажити дані на всю планету",
  numerator: "Чисельник",
  normalized_by: "Нормалізовано за",
  sum: "Сума",
  min: "Мін.",
  max: "Макс.",
  mean: "Середнє",
  stddev: "Стандартне відхилення",
  median: "Медіана",
  filter_numerator: "Фільтр чисельника",
  filter_denominator: "Фільтр знаменника"
};
const mcda = {};
const create_layer = {
  edit_layer: "Редагувати шар",
  edit_features: "Редагувати об'єкт",
  delete_layer: "Видалити шар",
  create_layer: "Створити шар",
  saving_layer: "Зберігаємо зміни...",
  field_name: "Назва поля",
  layer_name: "Назва шару",
  marker_icon: "Значок маркера",
  type: "Тип",
  select: "Вибрати",
  short_text: "Текст(короткий)",
  long_text: "Текст(довгий)",
  link: "Посилання",
  image: "Зображення",
  fields: "Поля",
  add_field: "Додати поле",
  location: "Позиція",
  edit_feature_placeholder: "Виберіть об’єкт для редагування його значень"
};
const analytics_panel = {
  header_title: "Аналітика",
  error_loading: "Помилка під час отримання даних аналітики"
};
const advanced_analytics_panel = {
  header_title: "Розширена аналітика",
  error: "Помилка під час отримання даних розширеної аналітики"
};
const advanced_analytics_empty = {
  not_found: "Вибачте, подію не знайдено.",
  error: "Сталася помилка!",
  analytics_for_selected: "Аналітика для обраної території",
  will_be_provided: "буде надано тут"
};
const current_event = {
  not_found_request: "Вибачте, подію не знайдено."
};
const draw_tools = {
  area: "Полігон",
  line: "Лінія",
  point: "Точка",
  finish_drawing: "Закінчити малювання",
  caption: "Натисніть на карту, щоб почати малювати",
  no_geometry_error: "Немає геометрії для завантаження",
  overlap_error: "Полігон не має перетинати сам себе",
  save_features: "Зберегти об'єкти"
};
const boundary_selector = {
  title: "Фокусувати на адміністративну одиницю"
};
const geometry_uploader = {
  title: "Фокусувати на завантажену геометрію",
  error: "Помилка під час завантаження файлу"
};
const focus_geometry = {
  title: "Фокусувати на намальовану геометрію"
};
const focus_geometry_layer = {
  settings: {
    name: "Вибраний полігон"
  }
};
const drawings = {
  self_directions_not_supported: "Самоперетин не підтримується!"
};
const sidebar = {
  biv_color_manager: "Редактор кольорів",
  edit_osm: "Редагувати в OpenStreetMap",
  ruler: "Лінійка",
  collapse: "Згорнути",
  expand: "Розгорнути",
  icon_alt: "Логотип аплікації"
};
const login = {
  email: "Електронна пошта",
  password: "Пароль",
  login_button: "Логін",
  sign_up: "Зареєструватися",
  logging_in: "Входимо...",
  log_in: "Увійти",
  description: "Увійдіть, щоб змінити налаштування",
  error: {
    email_empty: "Електронна пошта не може бути пустою!",
    email_invalid: "Електронна пошта має бути коректною!",
    password: "Пароль не може бути пустим!",
    connect: "Не вдалося під'єднатися до служби аутентифікації"
  }
};
const profile = {
  email: "Електронна пошта",
  profileSettingsHeader: "Профіль",
  interfaceTheme: "Тема",
  interfaceLanguage: "Мова",
  units: "Одиниці вимірювання",
  fullName: "Прізвище Ім'я",
  metric: "метрична система",
  imperialBeta: "англійська система (бета)",
  appSettingsHeader: "Налаштування",
  saveButton: "Зберегти зміни",
  "userBio(about)": "Про себе",
  defaultDisasterFeed: "Стрічка катастроф за замовчуванням",
  defaultOSMeditor: "Редактор OpenStreetMap за замовчуванням (бета)",
  successNotification: "Усі зміни успішно застосовано",
  languageOption: {
    en: "Англійська",
    es: "Іспанська",
    ar: "Арабська",
    ko: "Корейська",
    id: "Індонезійська",
    de: "Німецька",
    uk: "Українська"
  }
};
const reports = {
  title: "Звіти Disaster Ninja",
  no_data: "Нема даних для звіту",
  sorting: "Сортуємо дані...",
  loading: "Завантажуємо дані",
  search_location: "Знайти місцеположення",
  open_josm: "Відкрити в JOSM",
  josm_logo_alt: "Логотип JOSM",
  see_all: "Дивитися всі звіти",
  wrong_id: "Неправильний ID звіту",
  description: "<0>Kontur </0> генерує декілька звітів які допомагають перевіряти якість даних OpenStreetMap. Вони містять посилання на <4>osm.org</4> і посилання, щоб відкрити їх у редакторі JOSM для редагування."
};
const about = {
  title: "Вітаємо на Disaster Ninja!",
  intro: "Ви хочете отримувати повідомлення про катастрофи? Вас цікавлять миттєві дані про населення та інша аналітика для будь-якого регіону світу? Disaster Ninja від <2>Kontur</2> може задовольнити ці потреби.<br/><br/> Ми розробили це як інструмент підтримки прийняття рішень для гуманітарних картографів. Тепер його функціональність зросла. Незалежно від того, чи працюєте ви в сфері боротьби зі стихійними лихами, будуєте розумне місто чи проводите дослідження щодо зміни клімату, Disaster Ninja може вам допомогти:",
  l1: "1. Будьте в курсі останніх катастроф у всьому світі.",
  p1: "Панель Катастроф постійно оновлюється, щоб інформувати вас про поточні події. Дані отримані з каналу подій <2>Kontur</2>, до якого також можна отримати доступ через API.",
  l2: "2. Фокусуйтеся на вашій сфері інтересів.",
  p2: 'Панель "Інструменти малювання" дозволяє малювати або завантажувати власну геометрію на карту. Ви також можете фокусуватися на області, що постраждала від стихійного лиха, або на адміністративній одиниці — країна, район чи місто.',
  l3: "3. Отримайте аналітику для вибраної області.",
  p3: "Панель Аналітика показує кількість людей, які проживають у цьому регіоні на основі <2>населення Kontur</2> і потенційні прогалини картографування в OpenStreetMap. Клієнти Kontur мають доступ до сотень інших показників за допомогою Детальної Аналітики.",
  l4: "4. Досліджуйте дані на карті та робіть висновки.",
  p4: 'Панель "Шари" надає різні параметри для одночасного відображення двох індикаторів на карті, наприклад, щільність населення та відстань до найближчої пожежної частини. Використовуйте легенду кольорів, щоб визначити, які області потребують уваги. <br/>Підказка: загалом зелений колір означає низький ризик / мало прогалин, червоний — високий ризик / багато прогалин.',
  p5: "Крім того, ви можете перейти до звітів на лівій панелі, щоб отримати доступ до даних про потенційні помилки та невідповідності в даних OpenStreetMap і допомогти їх виправити, наприклад за допомогою редактора JOSM.",
  goToMap: "Перейти до мапи",
  p6: "Ми сподіваємося, що цей інструмент буде корисний. Використовуйте вікно чату на Disaster Ninja, щоб задати будь-які запитання щодо функціональності, і ми з радістю допоможемо вам. Ви також можете зв’язатися з нами електронною поштою <1>hello@kontur.io</1> якщо у вас є відгуки чи пропозиції щодо вдосконалення інструменту.<br/><br/> Disaster Ninja є проєктом з відкритим кодом. Дивіться код в обліковому записі GitHub <8>Kontur</8>."
};
const locate_me = {
  get_location_error: "Помилка під час визначення місцеположення",
  feature_title: "Знайти мене"
};
const episode = "Епізод";
const loading_episodes = "Завантаження епізодів";
const cookie_banner = {
  header: "Ми цінуємо вашу приватність",
  body: "Ми використовуємо абсолютно необхідні файли cookies, щоб надавати вам персоналізовані послуги, і додаткові файли cookies, щоб покращити Disaster Ninja та ваш досвід. Ви можете будь-коли змінити налаштування файлів cookies або відкликати згоду на використання додаткових файлів cookies.\nЩоб дізнатися більше, перегляньте нашу [Політику конфіденційності](about/privacy)",
  decline_all: "Відхилити файли cookies",
  accept_all: "Прийняти файли cookies"
};
const live_sensor = {
  start: "Почати запис даних з сенсорів",
  finish: "Зупинити запис даних з сенсорів",
  finishMessage: "Запис даних завершенно",
  startMessage: "Запис даних розпочато",
  noSensorsError: "Ваш пристрій не має необхідних сенсорів"
};
const uk_common = {
  km,
  m: m$1,
  to,
  maps,
  logout,
  save,
  cancel,
  create,
  disasters,
  loading,
  loading_events,
  legend,
  vertical_direction,
  horizontal_direction,
  legend_presentation,
  layers,
  bivariate,
  feed,
  deselect,
  spinner_text,
  updated,
  no_data_received,
  wrong_data_received,
  error,
  sort_icon,
  configs,
  errors,
  event_list,
  categories,
  groups,
  modes,
  advanced_analytics_data_list,
  mcda,
  create_layer,
  analytics_panel,
  advanced_analytics_panel,
  advanced_analytics_empty,
  current_event,
  draw_tools,
  boundary_selector,
  geometry_uploader,
  focus_geometry,
  focus_geometry_layer,
  drawings,
  sidebar,
  login,
  profile,
  reports,
  about,
  locate_me,
  episode,
  loading_episodes,
  cookie_banner,
  live_sensor
};
const I18N_FALLBACK_LANGUAGE = "en";
const languageResources = {
  en: { common: en_common },
  es: { common: es_common },
  ar: { common: ar_common },
  ko: { common: ko_common },
  id: { common: id_common },
  de: { common: de_common },
  uk: { common: uk_common }
};
instance.use(Browser).use(initReactI18next).init({
  fallbackLng: I18N_FALLBACK_LANGUAGE,
  debug: false,
  defaultNS: "common",
  interpolation: {
    escapeValue: false
  },
  contextSeparator: ":",
  pluralSeparator: ":",
  resources: {
    ...languageResources
  }
});
const TranslationService = {
  t: (key, options) => {
    const translation = instance.t(key, options);
    if (typeof translation === "string") return translation;
    if ((options == null ? void 0 : options.returnObjects) && typeof translation === "object") {
      return translation;
    }
    console.error(`Not supported translation result for key: ${key}`);
    return key;
  },
  getSupportedLanguage: (preferredLanguages, fallbackLanguage) => {
    for (const langCode of preferredLanguages) {
      try {
        const language = new Intl.Locale(langCode).language;
        if (language in languageResources) {
          return language;
        }
      } catch {
        console.error("Couldn't parse language code:", langCode);
      }
    }
    if (!(fallbackLanguage in languageResources)) {
      console.error(`Provided fallback language (${fallbackLanguage}) isn't supported`);
    }
    return fallbackLanguage;
  },
  instance
};
const PaymentPlanCardFooter = reactExports.memo(function PaymentPlanCardFooter2({
  planConfig,
  isUserAuthorized,
  currentSubscription,
  billingOption
}) {
  if (billingOption == null ? void 0 : billingOption.pricePerYear) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { type: "caption", children: TranslationService.t("subscription.price_summary", {
      pricePerYear: billingOption.pricePerYear.toLocaleString("en-US")
    }) });
  }
  return null;
});
const priceWrap = "_priceWrap_11z70_1";
const dollarSign = "_dollarSign_11z70_7";
const amount = "_amount_11z70_15";
const perMonth$1 = "_perMonth_11z70_21";
const s$e = {
  priceWrap,
  dollarSign,
  amount,
  perMonth: perMonth$1
};
function Price({ amount: amount2, className }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clsx(s$e.priceWrap, className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$e.dollarSign, children: "$" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$e.amount, children: amount2.toLocaleString("en-US") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$e.perMonth, children: [
      TranslationService.t("currency.usd"),
      " / mo*"
    ] })
  ] });
}
const planCard = "_planCard_hh4u9_1";
const custom = "_custom_hh4u9_29";
const premium = "_premium_hh4u9_36";
const planType = "_planType_hh4u9_63";
const initialPrice = "_initialPrice_hh4u9_83";
const price = "_price_hh4u9_89";
const hidden = "_hidden_hh4u9_93";
const perMonth = "_perMonth_hh4u9_97";
const customPlanName = "_customPlanName_hh4u9_103";
const planDescription = "_planDescription_hh4u9_110";
const buttonWrapper = "_buttonWrapper_hh4u9_119";
const subscribeButtonsWrapper = "_subscribeButtonsWrapper_hh4u9_126";
const cancelButton = "_cancelButton_hh4u9_139";
const footerWrapper = "_footerWrapper_hh4u9_144";
const linkAsButton = "_linkAsButton_hh4u9_155";
const paymentPlanButton = "_paymentPlanButton_hh4u9_180";
const s$d = {
  planCard,
  custom,
  premium,
  planType,
  initialPrice,
  price,
  hidden,
  perMonth,
  customPlanName,
  planDescription,
  buttonWrapper,
  subscribeButtonsWrapper,
  cancelButton,
  footerWrapper,
  linkAsButton,
  paymentPlanButton
};
const pricingWrap = "_pricingWrap_13ps2_1";
const pricingPlans = "_pricingPlans_13ps2_7";
const togglerSwitch = "_togglerSwitch_13ps2_12";
const withOffLabel = "_withOffLabel_13ps2_18";
const togglerLabel = "_togglerLabel_13ps2_23";
const active$1 = "_active_13ps2_29";
const note = "_note_13ps2_34";
const plans = "_plans_13ps2_44";
const ss = {
  pricingWrap,
  pricingPlans,
  togglerSwitch,
  withOffLabel,
  togglerLabel,
  active: active$1,
  note,
  plans
};
const config$2 = {
  billingMethodsDetails: [
    {
      id: "paypal",
      clientId: "AWJQJnM0O2nDEUgmMe9827bk73hjJdo3f4tPK9vwKvBVwFnDk1UGzk_Y2yeh5huiStwwdJVRmdOYWmhv"
    }
  ],
  billingCyclesDetails: [
    {
      id: "month",
      name: "Monthly",
      note: null
    },
    {
      id: "year",
      name: "Annually",
      note: "Save 5%"
    }
  ],
  plans: [
    {
      id: "kontur_atlas_edu",
      name: "Educational",
      style: "basic",
      billingCycles: [
        {
          id: "month",
          initialPricePerMonth: null,
          pricePerMonth: 100,
          pricePerYear: null,
          billingMethods: [
            {
              id: "paypal",
              billingPlanId: "P-8GA97186HP797325NM2B7D7Y"
            }
          ]
        },
        {
          id: "year",
          initialPricePerMonth: 100,
          pricePerMonth: 95,
          pricePerYear: 1140,
          billingMethods: [
            {
              id: "paypal",
              billingPlanId: "P-02L9453417504204DM2B7FDQ"
            }
          ]
        }
      ]
    },
    {
      id: "kontur_atlas_pro",
      name: "Professional",
      style: "premium",
      billingCycles: [
        {
          id: "month",
          initialPricePerMonth: null,
          pricePerMonth: 1e3,
          pricePerYear: null,
          billingMethods: [
            {
              id: "paypal",
              billingPlanId: "P-47286102F9496000PM2B7FXA"
            }
          ]
        },
        {
          id: "year",
          initialPricePerMonth: 1e3,
          pricePerMonth: 950,
          pricePerYear: 11400,
          billingMethods: [
            {
              id: "paypal",
              billingPlanId: "P-9TD56337G94931803M2B7GTI"
            }
          ]
        }
      ]
    },
    {
      id: "kontur_atlas_custom",
      name: "Custom",
      style: "custom",
      actions: ["contact_sales", "book_a_demo"]
      //
    }
  ]
};
const _plans = "# Educational\n\nFor students, hobbyists, and anyone testing the entry-level option before upgrading\n\n###### **edu**\n\n- Multi-criteria decision analyses\n- AI analytics\n- Favorite area of interest\n- Download analyses\n\n---\n\n# Professional\n\nFor GIS data analysts and managers who work with GIS on a daily basis\n\n###### **pro**\n\n- Multi-criteria decision analyses\n- AI analytics\n- Favorite area of interest\n- Download analyses\n- Customer support\n- Custom requests\n- Upload custom indicators for analytics\n\n---\n\n# Custom\n\n# Enterprise\n\nFor GIS data analysts and managers who work with GIS on a daily basis\nContact sales, book a demo or write to us at <info@kontur.io> for custom pricing and features\n\n###### **ent**\n\n- Multiple seats\n- Custom workflows\n- Custom features\n- Custom design\n- Training and onboarding\n- Support\n";
const css = `
.premium > .${s$d.planName}::before {
  content: '★';
  font-size: larger;
  padding-right: 4px;
}

.${s$d.planName} {
  font-family: var(--font-family);
  font-style: normal;
  font-weight: 600;
  font-size: 16px;
}

.${ss.pricingWrap} {
  & ul {
    list-style-type: none;
    padding-left: 0;
    & li::before {
      content: "✔";
      display: inline-block;
      margin-right: var(--double-unit);
      color: var(--strong-color);
    }
  }
}
`;
const Plans_fixture = {
  Plans: /* @__PURE__ */ jsxRuntimeExports.jsx(Plans, { markdown: _plans, styling: css, isUserAuthorized: false })
};
function Plans({ styling = "", markdown: markdown2 = _plans, isUserAuthorized = false }) {
  const [currentBillingCycleId] = useFixtureSelect("buttonType", {
    options: ["month", "year"]
  });
  const currentSubscription = {
    id: "1",
    billingPlanId: "1",
    billingSubscriptionId: "1"
  };
  const compiled = Ze(markdown2, {
    overrides: {
      a: CustomLink,
      img: CustomImg
    },
    wrapper: null
  });
  console.warn(compiled);
  const structured = splitIntoSections(compiled);
  console.warn(structured);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ss.pricingWrap, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: styling }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ss.pricingPlans, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ss.plans, children: config$2.plans.map((plan, index2) => {
      var _a2, _b, _c;
      const planContent = structured[index2];
      const planName = (_a2 = planContent.shift()) == null ? void 0 : _a2.props.children[0];
      const highlightsBlock = planContent.pop();
      planContent.pop();
      const isCustom = !plan.billingCycles;
      const styleClass = plan.style;
      const billingOption = (_b = plan.billingCycles) == null ? void 0 : _b.find(
        (option) => option.id === currentBillingCycleId
      );
      const actionsBlock = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$d.buttonWrapper, children: [
        !isUserAuthorized && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: clsx(s$d.paymentPlanButton, styleClass), children: "Sign in to subscribe" }),
        isUserAuthorized && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "[PAYPAL BUTTONS INJECTED HERE]" })
      ] });
      const priceBlock = !isCustom && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        billingOption && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: clsx(s$d.initialPrice, {
              [s$d.hidden]: billingOption.id === "month"
            }),
            children: `$${(_c = billingOption == null ? void 0 : billingOption.initialPricePerMonth) == null ? void 0 : _c.toLocaleString("en-US")} USD`
          }
        ),
        billingOption && /* @__PURE__ */ jsxRuntimeExports.jsx(Price, { className: s$d.price, amount: billingOption.pricePerMonth })
      ] });
      const footerBlock = !isCustom && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$d.footerWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        PaymentPlanCardFooter,
        {
          planConfig: plan,
          isUserAuthorized,
          currentSubscription,
          billingOption
        }
      ) });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clsx(s$d.planCard, styleClass), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$d.planName, children: planName }),
        priceBlock,
        planContent,
        actionsBlock,
        highlightsBlock,
        footerBlock
      ] }, plan.id);
    }) }) })
  ] });
}
const fixture0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Plans_fixture
}, Symbol.toStringTag, { value: "Module" }));
const mainWrap = "_mainWrap_1bp2b_1";
const content = "_content_1bp2b_11";
const s$c = {
  mainWrap,
  content,
  "app-id-9043acf9-2cf3-48ac-9656-a5d7c4b7593d": "_app-id-9043acf9-2cf3-48ac-9656-a5d7c4b7593d_1bp2b_1",
  "app-route-about": "_app-route-about_1bp2b_1"
};
function Article({
  children,
  className = "",
  id = ""
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$c.mainWrap, id, children: /* @__PURE__ */ jsxRuntimeExports.jsx("article", { className: `${s$c.content} ${className}`, children }) });
}
const _about = "# Welcome to Disaster Ninja!\n\nDo you want to be notified about ongoing disasters? Are you interested in instant population data and other analytics for any region of the world? Disaster Ninja showcases some of [Kontur](https://www.kontur.io/)’s capabilities in addressing these needs.\n\nWe initially designed it as a decision support tool for humanitarian mappers. Now it has grown in functionality and use cases. Whether you work in disaster management, build a smart city, or perform research on climate change, Disaster Ninja can help you to:\n\n### 1. Stay up to date with the latest hazard events globally\n\nThe Disasters panel continually refreshes to inform you about ongoing events. It consumes data from the [Kontur Event Feed](https://www.kontur.io/portfolio/event-feed/), which you can also access via an API.\n\n### 2. Focus on your area of interest\n\nThe Drawing Tools panel allows you to draw or upload your own geometry on the map. You can also focus on a disaster-exposed area or an administrative unit — a country, region, or city.\n\n### 3. Get analytics for the focused area\n\nThe Analytics panel shows the number of people living in that area per [Kontur Population](https://data.humdata.org/dataset/kontur-population-dataset) and estimated mapping gaps in OpenStreetMap. Kontur’s customers have access to hundreds of other indicators through Advanced Analytics.\n\n### 4. Explore data on the map and draw conclusions\n\nThe Layers panel gives you various options to display two indicators simultaneously on a bivariate map, e.g., population density and distance to the nearest fire station. Use the color legend to assess which areas require attention.\nHint: in general, green indicates low risk / few gaps, red — high risk / many gaps.\n\nIn addition, you can switch to Reports in the left panel to access data on potential errors and inconsistencies in OpenStreetMap and help fix them by mapping the respective area with the JOSM editor.\n\n### [Go to the map now ➜](/ 'map')\n\nWe hope you find this tool valuable. Use the chatbox on Disaster Ninja for any questions about the functionality, and we will be happy to guide you. You can also contact us by email at [hello@kontur.io](mailto:hello@kontur.io) if you have feedback or suggestions on improving the tool.\n\nDisaster Ninja is an open-source project. Find the code in [Kontur’s GitHub account](https://github.com/konturio).\n";
const _landing = `![Kontur Atlas](about-atlas-1.png)

# Kontur Atlas

Atlas is your GPS for big decisions. It's a tool that helps you use maps and data to figure out a wide range of things, from where to open a new store to exploring environmental sustainability.

![Geospatial Data with Ease](about-atlas-2.png)

## Geospatial Data with Ease

### Browse & Choose Data

We've got tons of info like who lives where and how people get around. Find the data that'll answer your questions.

### Make Maps

With a few clicks, Atlas turns that data into maps and visuals so it's easy to understand.

### Analyze & Decide

Use these insights to make smart decisions, like picking the perfect spot for your next big project or making concussions based on spatial patterns.

### Jump in and start exploring

Your next big opportunity is waiting to be mapped out!

## _[Get access](https://www.kontur.io/atlas)_ [Log in](/profile)

## How to Use

---

## ![Area Selection](about-atlas-3.png)

### Area Selection

To choose an area for analysis, you can use the toolbar to select an administrative unit, draw a shape manually, or import a GeoJSON file.

## ![Analytics Panel](about-atlas-4.png)

### Analytics Panel

This panel displays essential data about your selected area.

#### AI Insights

Compares your area's data with global averages, alerting you to any significant discrepancies.

#### Personalized AI Insights

Reference Area: This allows you to set a known area as a reference point for comparisons and highlights differences.
Bio: Here, you can record details like who you're working for, your analysis purpose, and key topics, helping to personalize AI conclusions.

## ![Creating Custom Analysis](about-atlas-5.png)

### Creating Custom Analysis

To create your own analysis, select the "MCDA" button in the toolbar.

#### Choosing Relevant Layers

Start by picking data layers appropriate for your requirements — this could include anything from population density to environmental risk factors.

#### Browse the map

By default, the map displays red hexagons in high-value areas and green hexagons where values are minimal. Click on any hexagon to access detailed info for that particular sector.

#### Layer Customization

Enhance your analysis by fine-tuning the range and what is bad and good of each layer. This means you can focus specifically on aspects crucial to your study.
`;
const _landingCss = "h1 {\n  font-size: 32px;\n}\n\nh2 {\n  font-size: 28px;\n}\n\nh3 {\n  font-size: 20px;\n}\n\nh4 {\n  font-size: 16px;\n}\n\nblockquote {\n  column-count: 2;\n  column-gap: 1rem;\n  margin: 0;\n}\n\nblockquote img {\n  break-inside: column;\n}\n\nblockquote h3 {\n  break-before: column;\n  margin-top: 0;\n}\n\nblockquote * {\n  padding-left: 0 !important;\n}\n\n.markdown-doc-landing section:last-child {\n  display: grid;\n  grid-template-columns: max-content auto;\n  gap: 1em;\n}\n\narticle h2 a {\n  padding: var(--unit) 24px;\n  user-select: none;\n  font: var(--font);\n  font-weight: 400;\n  border: 1px solid var(--faint-weak);\n  border-radius: var(--border-radius);\n  min-width: 128px;\n  display: inline-block;\n  text-align: center;\n  box-sizing: border-box;\n}\n\narticle h2 em a {\n  background-color: var(--accent-strong);\n  color: var(--base-weak) !important;\n}\n";
const StructuredMarkdownRender_fixture = {
  About: /* @__PURE__ */ jsxRuntimeExports.jsx(StructuredMarkdownRender, { styling: _landingCss, markdown: _about, docId: "about" }),
  Landing: /* @__PURE__ */ jsxRuntimeExports.jsx(StructuredMarkdownRender, { styling: _landingCss, markdown: _landing, docId: "landing" })
};
function StructuredMarkdownRender({ styling, markdown: markdown2, docId }) {
  const compiled = Ze(markdown2, {
    overrides: {
      a: CustomLink,
      img: CustomImg
    },
    wrapper: null
  });
  console.warn(compiled);
  const wrappedContent = structureMarkdownContent(compiled);
  console.warn(wrappedContent);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: styling }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Article, { className: `structuredmd markdown-doc-${docId}`, children: wrappedContent })
  ] });
}
const fixture1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: StructuredMarkdownRender_fixture
}, Symbol.toStringTag, { value: "Module" }));
const _configDataMock = {
  baseUrl: "/active/",
  initialUrl: "https://disaster.ninja/active/map?map=4.920/37.682/112.588&event=1c1eb9ce-2fb0-4660-ae2e-ee93d15f8874&layers=kontur_lines%2CactiveContributors%2CeventShape%2ChotProjects_outlines%2Cpopulation_density%2Cfocused-geometry",
  initialUrlData: {
    layers: ["kontur_lines", "population_density"]
  },
  apiGateway: "https://disaster.ninja/active/api",
  reportsApiGateway: "/active/reports",
  bivariateTilesRelativeUrl: "api/tiles/bivariate/v1/",
  bivariateTilesIndicatorsClass: "all",
  refreshIntervalSec: 300,
  sentryDsn: "",
  keycloakUrl: "https://keycloak01.kontur.io",
  keycloakRealm: "kontur",
  keycloakClientId: "kontur_platform",
  // intercomDefaultName: null,
  intercomAppId: "e59cl64z",
  intercomSelector: "#kontur_header_chat_btn",
  defaultFeed: "kontur-public",
  osmEditors: [
    {
      id: "josm",
      title: "JOSM",
      url: "https://www.openstreetmap.org/edit?editor=remote#map="
    },
    {
      id: "id",
      title: "iD",
      url: "https://www.openstreetmap.org/edit?editor=id&node=2188188227#map="
    },
    {
      id: "rapid",
      title: "RapiD",
      url: "https://mapwith.ai/rapid#map="
    }
  ],
  autofocusZoom: 13,
  mapBlankSpaceId: "map-view",
  mapBaseStyle: "https://prod-basemap-tileserver.k8s-01.konturlabs.com/layers/tiles/basemap/style_ninja_en.json",
  featuresByDefault: {
    events_list: true,
    current_event: true,
    reports: true,
    current_episode: true,
    episode_list: true,
    osm_edit_link: true,
    side_bar: true,
    analytics_panel: true,
    map_layers_panel: true,
    focused_geometry_layer: true,
    map_ruler: true,
    boundary_selector: true,
    draw_tools: true,
    geometry_uploader: true,
    legend_panel: true,
    // @ts-ignore
    url_store: true,
    feature_settings: true,
    layers_in_area: true,
    toasts: true,
    interactive_map: true,
    feed_selector: true,
    header: true,
    intercom: true,
    geocoder: true,
    communities: true,
    tooltip: true
  },
  id: "9043acf9-2cf3-48ac-9656-a5d7c4b7593d",
  name: "Kontur Atlas",
  description: "Kontur SAAS application",
  ownedByUser: false,
  extent: [-135, 0, 63, 62],
  sidebarIconUrl: "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/favicon.svg",
  faviconUrl: "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/favicon.svg",
  faviconPack: {
    "favicon.svg": "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/favicon.svg",
    "favicon.ico": "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/favicon.ico",
    "apple-touch-icon.png": "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/apple-touch-icon.png",
    "icon-192x192.png": "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/icon-192x192.png",
    "icon-512x512.png": "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/icon-512x512.png"
  },
  // @ts-ignore
  features: {
    side_bar: true,
    intercom: true,
    tooltip: true,
    subscription: {
      billingMethodsDetails: [
        {
          id: "paypal",
          clientId: "xxxxxxx-xxxx-xxxxxxxxxxxxxx"
        }
      ],
      billingCyclesDetails: [
        {
          id: "month",
          name: "Monthly",
          note: null
        },
        {
          id: "year",
          name: "Annually",
          note: "Save 5%"
        }
      ],
      plans: [
        {
          id: "kontur_atlas_edu",
          name: "Educational",
          style: "basic",
          billingCycles: [
            {
              id: "month",
              initialPricePerMonth: null,
              pricePerMonth: 100,
              pricePerYear: null,
              billingMethods: [
                {
                  id: "paypal",
                  billingPlanId: "P-000000000000000000000000"
                }
              ]
            },
            {
              id: "year",
              initialPricePerMonth: 100,
              pricePerMonth: 95,
              pricePerYear: 1140,
              billingMethods: [
                {
                  id: "paypal",
                  billingPlanId: "P-000000000000000000000000"
                }
              ]
            }
          ]
        },
        {
          id: "kontur_atlas_pro",
          name: "Professional",
          style: "premium",
          billingCycles: [
            {
              id: "month",
              initialPricePerMonth: null,
              pricePerMonth: 1e3,
              pricePerYear: null,
              billingMethods: [
                {
                  id: "paypal",
                  billingPlanId: "P-000000000000000000000000"
                }
              ]
            },
            {
              id: "year",
              initialPricePerMonth: 1e3,
              pricePerMonth: 950,
              pricePerYear: 11400,
              billingMethods: [
                {
                  id: "paypal",
                  billingPlanId: "P-000000000000000000000000"
                }
              ]
            }
          ]
        },
        {
          id: "kontur_atlas_custom",
          name: "Custom",
          style: "custom",
          actions: [
            {
              name: "contact_sales",
              params: {
                link: "https://calendly.com/"
              }
            },
            {
              name: "book_a_demo"
            }
          ]
        }
      ]
    },
    app_login: true,
    toasts: true,
    use_3rdparty_analytics: true,
    about_page: {
      tabId: "about",
      assetUrl: "about.md",
      subTabs: [
        {
          tabId: "terms",
          assetUrl: "terms.md"
        },
        {
          tabId: "privacy",
          assetUrl: "privacy.md"
        },
        {
          tabId: "user-guide",
          assetUrl: "user_guide.md"
        }
      ]
    }
  },
  public: true,
  initialUser: {
    username: "",
    email: "",
    fullName: "",
    language: "en",
    useMetricUnits: true,
    subscribedToKonturUpdates: false,
    bio: "",
    osmEditor: "josm",
    defaultFeed: "kontur-public",
    theme: "kontur"
  },
  defaultLayers: [
    {
      id: "kontur_lines",
      source: {
        type: "maplibre-style-url",
        urls: [
          "https://prod-basemap-tileserver.k8s-01.konturlabs.com/layers/tiles/basemap/style_ninja_en.json"
        ]
      },
      ownedByUser: false
    },
    {
      id: "population_density",
      // @ts-ignore
      source: {
        urls: [
          "https://disaster.ninja/active/api/tiles/bivariate/v1/{z}/{x}/{y}.mvt?indicatorsClass=general"
        ]
      },
      // @ts-ignore
      legend: {
        type: "simple",
        steps: [
          {
            stepName: "0 - 1.27",
            stepShape: "square",
            style: {
              color: "#F0F0D6",
              "fill-color": "#F0F0D6",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "1.27 - 2.45",
            stepShape: "square",
            style: {
              color: "#ECECC4",
              "fill-color": "#ECECC4",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "2.45 - 5.75",
            stepShape: "square",
            style: {
              color: "#EAEAB0",
              "fill-color": "#EAEAB0",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "5.75 - 12.43",
            stepShape: "square",
            style: {
              color: "#E8E89D",
              "fill-color": "#E8E89D",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "12.43 - 28.47",
            stepShape: "square",
            style: {
              color: "#E1D689",
              "fill-color": "#E1D689",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "28.47 - 66.03",
            stepShape: "square",
            style: {
              color: "#DAC075",
              "fill-color": "#DAC075",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "66.03 - 172.46",
            stepShape: "square",
            style: {
              color: "#D1A562",
              "fill-color": "#D1A562",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "172.46 - 535.67",
            stepShape: "square",
            style: {
              color: "#C98A50",
              "fill-color": "#C98A50",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "535.67 - 46200",
            stepShape: "square",
            style: {
              color: "#BF6C3F",
              "fill-color": "#BF6C3F",
              "fill-opacity": 0.8
            }
          }
        ]
      },
      ownedByUser: false
    }
  ],
  activeLayers: ["kontur_lines", "population_density"]
};
configRepo.get = () => _configDataMock;
const JSON_MIME = "application/json";
const CONTENT_TYPE_HEADER = "Content-Type";
const FETCH_ERROR = Symbol();
const CATCHER_FALLBACK = Symbol();
function extractContentType(headers = {}) {
  var _a2;
  return (_a2 = Object.entries(headers).find(([k2]) => k2.toLowerCase() === CONTENT_TYPE_HEADER.toLowerCase())) === null || _a2 === void 0 ? void 0 : _a2[1];
}
function isLikelyJsonMime(value) {
  return /^application\/.*json.*/.test(value);
}
const mix = function(one, two, mergeArrays = false) {
  return Object.entries(two).reduce((acc, [key, newValue]) => {
    const value = one[key];
    if (Array.isArray(value) && Array.isArray(newValue)) {
      acc[key] = mergeArrays ? [...value, ...newValue] : newValue;
    } else if (typeof value === "object" && typeof newValue === "object") {
      acc[key] = mix(value, newValue, mergeArrays);
    } else {
      acc[key] = newValue;
    }
    return acc;
  }, { ...one });
};
const config$1 = {
  // Default options
  options: {},
  // Error type
  errorType: "text",
  // Polyfills
  polyfills: {
    // fetch: null,
    // FormData: null,
    // URL: null,
    // URLSearchParams: null,
    // performance: null,
    // PerformanceObserver: null,
    // AbortController: null,
  },
  polyfill(p2, doThrow = true, instance2 = false, ...args) {
    const res = this.polyfills[p2] || (typeof self !== "undefined" ? self[p2] : null) || (typeof global !== "undefined" ? global[p2] : null);
    if (doThrow && !res)
      throw new Error(p2 + " is not defined");
    return instance2 && res ? new res(...args) : res;
  }
};
function setOptions(options, replace = false) {
  config$1.options = replace ? options : mix(config$1.options, options);
}
function setPolyfills(polyfills, replace = false) {
  config$1.polyfills = replace ? polyfills : mix(config$1.polyfills, polyfills);
}
function setErrorType(errorType) {
  config$1.errorType = errorType;
}
const middlewareHelper = (middlewares) => (fetchFunction) => {
  return middlewares.reduceRight((acc, curr) => curr(acc), fetchFunction) || fetchFunction;
};
class WretchError extends Error {
}
const resolver = (wretch) => {
  const sharedState = /* @__PURE__ */ Object.create(null);
  wretch = wretch._addons.reduce((w2, addon) => addon.beforeRequest && addon.beforeRequest(w2, wretch._options, sharedState) || w2, wretch);
  const { _url: url, _options: opts, _config: config2, _catchers, _resolvers: resolvers, _middlewares: middlewares, _addons: addons } = wretch;
  const catchers = new Map(_catchers);
  const finalOptions = mix(config2.options, opts);
  let finalUrl = url;
  const _fetchReq = middlewareHelper(middlewares)((url2, options) => {
    finalUrl = url2;
    return config2.polyfill("fetch")(url2, options);
  })(url, finalOptions);
  const referenceError = new Error();
  const throwingPromise = _fetchReq.catch((error2) => {
    throw { [FETCH_ERROR]: error2 };
  }).then((response) => {
    var _a2;
    if (!response.ok) {
      const err = new WretchError();
      err["cause"] = referenceError;
      err.stack = err.stack + "\nCAUSE: " + referenceError.stack;
      err.response = response;
      err.status = response.status;
      err.url = finalUrl;
      if (response.type === "opaque") {
        throw err;
      }
      const jsonErrorType = config2.errorType === "json" || ((_a2 = response.headers.get("Content-Type")) === null || _a2 === void 0 ? void 0 : _a2.split(";")[0]) === "application/json";
      const bodyPromise = !config2.errorType ? Promise.resolve(response.body) : jsonErrorType ? response.text() : response[config2.errorType]();
      return bodyPromise.then((body) => {
        err.message = typeof body === "string" ? body : response.statusText;
        if (body) {
          if (jsonErrorType && typeof body === "string") {
            err.text = body;
            err.json = JSON.parse(body);
          } else {
            err[config2.errorType] = body;
          }
        }
        throw err;
      });
    }
    return response;
  });
  const catchersWrapper = (promise) => {
    return promise.catch((err) => {
      const fetchErrorFlag = Object.prototype.hasOwnProperty.call(err, FETCH_ERROR);
      const error2 = fetchErrorFlag ? err[FETCH_ERROR] : err;
      const catcher = (error2 === null || error2 === void 0 ? void 0 : error2.status) && catchers.get(error2.status) || catchers.get(error2 === null || error2 === void 0 ? void 0 : error2.name) || fetchErrorFlag && catchers.has(FETCH_ERROR) && catchers.get(FETCH_ERROR);
      if (catcher)
        return catcher(error2, wretch);
      const catcherFallback = catchers.get(CATCHER_FALLBACK);
      if (catcherFallback)
        return catcherFallback(error2, wretch);
      throw error2;
    });
  };
  const bodyParser = (funName) => (cb) => funName ? (
    // If a callback is provided, then callback with the body result otherwise return the parsed body itself.
    catchersWrapper(throwingPromise.then((_2) => _2 && _2[funName]()).then((_2) => cb ? cb(_2) : _2))
  ) : (
    // No body parsing method - return the response
    catchersWrapper(throwingPromise.then((_2) => cb ? cb(_2) : _2))
  );
  const responseChain = {
    _wretchReq: wretch,
    _fetchReq,
    _sharedState: sharedState,
    res: bodyParser(null),
    json: bodyParser("json"),
    blob: bodyParser("blob"),
    formData: bodyParser("formData"),
    arrayBuffer: bodyParser("arrayBuffer"),
    text: bodyParser("text"),
    error(errorId, cb) {
      catchers.set(errorId, cb);
      return this;
    },
    badRequest(cb) {
      return this.error(400, cb);
    },
    unauthorized(cb) {
      return this.error(401, cb);
    },
    forbidden(cb) {
      return this.error(403, cb);
    },
    notFound(cb) {
      return this.error(404, cb);
    },
    timeout(cb) {
      return this.error(408, cb);
    },
    internalError(cb) {
      return this.error(500, cb);
    },
    fetchError(cb) {
      return this.error(FETCH_ERROR, cb);
    }
  };
  const enhancedResponseChain = addons.reduce((chain, addon) => ({
    ...chain,
    ...typeof addon.resolver === "function" ? addon.resolver(chain) : addon.resolver
  }), responseChain);
  return resolvers.reduce((chain, r2) => r2(chain, wretch), enhancedResponseChain);
};
const core = {
  _url: "",
  _options: {},
  _config: config$1,
  _catchers: /* @__PURE__ */ new Map(),
  _resolvers: [],
  _deferred: [],
  _middlewares: [],
  _addons: [],
  addon(addon) {
    return { ...this, _addons: [...this._addons, addon], ...addon.wretch };
  },
  errorType(errorType) {
    return {
      ...this,
      _config: {
        ...this._config,
        errorType
      }
    };
  },
  polyfills(polyfills, replace = false) {
    return {
      ...this,
      _config: {
        ...this._config,
        polyfills: replace ? polyfills : mix(this._config.polyfills, polyfills)
      }
    };
  },
  url(_url, replace = false) {
    if (replace)
      return { ...this, _url };
    const split = this._url.split("?");
    return {
      ...this,
      _url: split.length > 1 ? split[0] + _url + "?" + split[1] : this._url + _url
    };
  },
  options(options, replace = false) {
    return { ...this, _options: replace ? options : mix(this._options, options) };
  },
  headers(headerValues) {
    const headers = !headerValues ? {} : Array.isArray(headerValues) ? Object.fromEntries(headerValues) : "entries" in headerValues ? Object.fromEntries(headerValues.entries()) : headerValues;
    return { ...this, _options: mix(this._options, { headers }) };
  },
  accept(headerValue) {
    return this.headers({ Accept: headerValue });
  },
  content(headerValue) {
    return this.headers({ [CONTENT_TYPE_HEADER]: headerValue });
  },
  auth(headerValue) {
    return this.headers({ Authorization: headerValue });
  },
  catcher(errorId, catcher) {
    const newMap = new Map(this._catchers);
    newMap.set(errorId, catcher);
    return { ...this, _catchers: newMap };
  },
  catcherFallback(catcher) {
    return this.catcher(CATCHER_FALLBACK, catcher);
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  resolve(resolver2, clear = false) {
    return { ...this, _resolvers: clear ? [resolver2] : [...this._resolvers, resolver2] };
  },
  defer(callback, clear = false) {
    return {
      ...this,
      _deferred: clear ? [callback] : [...this._deferred, callback]
    };
  },
  middlewares(middlewares, clear = false) {
    return {
      ...this,
      _middlewares: clear ? middlewares : [...this._middlewares, ...middlewares]
    };
  },
  fetch(method = this._options.method, url = "", body = null) {
    let base = this.url(url).options({ method });
    const contentType = extractContentType(base._options.headers);
    const formDataClass = this._config.polyfill("FormData", false);
    const jsonify = typeof body === "object" && !(formDataClass && body instanceof formDataClass) && (!base._options.headers || !contentType || isLikelyJsonMime(contentType));
    base = !body ? base : jsonify ? base.json(body, contentType) : base.body(body);
    return resolver(base._deferred.reduce((acc, curr) => curr(acc, acc._url, acc._options), base));
  },
  get(url = "") {
    return this.fetch("GET", url);
  },
  delete(url = "") {
    return this.fetch("DELETE", url);
  },
  put(body, url = "") {
    return this.fetch("PUT", url, body);
  },
  post(body, url = "") {
    return this.fetch("POST", url, body);
  },
  patch(body, url = "") {
    return this.fetch("PATCH", url, body);
  },
  head(url = "") {
    return this.fetch("HEAD", url);
  },
  opts(url = "") {
    return this.fetch("OPTIONS", url);
  },
  body(contents) {
    return { ...this, _options: { ...this._options, body: contents } };
  },
  json(jsObject, contentType) {
    const currentContentType = extractContentType(this._options.headers);
    return this.content(contentType || isLikelyJsonMime(currentContentType) && currentContentType || JSON_MIME).body(JSON.stringify(jsObject));
  }
};
function factory(_url = "", _options = {}) {
  return { ...core, _url, _options };
}
factory["default"] = factory;
factory.options = setOptions;
factory.errorType = setErrorType;
factory.polyfills = setPolyfills;
factory.WretchError = WretchError;
function stringify(value) {
  return typeof value !== "undefined" ? value : "";
}
const appendQueryParams = (url, qp, replace, omitUndefinedOrNullValues, config2) => {
  let queryString2;
  if (typeof qp === "string") {
    queryString2 = qp;
  } else {
    const usp = config2.polyfill("URLSearchParams", true, true);
    for (const key in qp) {
      const value = qp[key];
      if (omitUndefinedOrNullValues && (value === null || value === void 0))
        continue;
      if (qp[key] instanceof Array) {
        for (const val of value)
          usp.append(key, stringify(val));
      } else {
        usp.append(key, stringify(value));
      }
    }
    queryString2 = usp.toString();
  }
  const split = url.split("?");
  if (!queryString2)
    return replace ? split[0] : url;
  if (replace || split.length < 2)
    return split[0] + "?" + queryString2;
  return url + "&" + queryString2;
};
const queryString = {
  wretch: {
    query(qp, replace = false, omitUndefinedOrNullValues = false) {
      return { ...this, _url: appendQueryParams(this._url, qp, replace, omitUndefinedOrNullValues, this._config) };
    }
  }
};
const wait = (sec = 1, opt = {}) => new Promise(
  (res, rej) => setTimeout(
    (opt == null ? void 0 : opt.failWithMessage) ? () => rej({ message: opt.failWithMessage }) : res,
    sec * 1e3
  )
);
function typedObjectEntries(obj) {
  return Object.entries(obj);
}
class FallbackStorage {
  constructor() {
    __publicField(this, "storage", /* @__PURE__ */ new Map());
  }
  setItem(key, value) {
    this.storage.set(key, value);
  }
  getItem(key) {
    return this.storage.get(key);
  }
  removeItem(key) {
    this.storage.delete(key);
  }
  clear() {
    this.storage.clear();
  }
  get length() {
    return this.storage.size;
  }
  key(index2) {
    return this.storage.keys()[index2] ?? null;
  }
}
class StableStorage {
  constructor(type) {
    __publicField(this, "storage");
    if (this.storageAvailable(type)) {
      this.storage = globalThis[type];
    } else {
      console.warn("Switching to in memory storage");
      this.storage = new FallbackStorage();
    }
  }
  storageAvailable(type) {
    try {
      const storage = globalThis[type];
      const x2 = "__storage_test__";
      storage.setItem(x2, x2);
      storage.removeItem(x2);
      return true;
    } catch (e) {
      console.warn(`${type} in not available.`);
    }
  }
  setItem(key, value) {
    return this.storage.setItem(key, value);
  }
  getItem(key) {
    return this.storage.getItem(key);
  }
  get length() {
    return this.storage.length;
  }
  clear() {
    return this.storage.clear();
  }
  key(index2) {
    return this.storage.key(index2);
  }
  removeItem(key) {
    return this.storage.removeItem(key);
  }
}
new StableStorage("sessionStorage");
const localStorage = new StableStorage("localStorage");
const KONTUR_DEBUG = !!localStorage.getItem("KONTUR_DEBUG");
!!localStorage.getItem("KONTUR_METRICS_DEBUG");
!!localStorage.getItem("KONTUR_WARN");
localStorage.getItem("KONTUR_TRACE_TYPE");
!!localStorage.getItem("KONTUR_TRACE_PATCH");
class ApiClientError extends Error {
  constructor(message, problem, status = 0) {
    super(message);
    __publicField(this, "problem");
    __publicField(this, "status", 0);
    this.problem = problem;
    this.status = status;
    Object.setPrototypeOf(this, ApiClientError.prototype);
  }
}
function isApiError(x2) {
  if (x2.problem) return typeof x2.problem === "object";
  return false;
}
function parseApiError(errorObj) {
  var _a2;
  if (errorObj == null ? void 0 : errorObj.json) {
    const errorData = errorObj == null ? void 0 : errorObj.json;
    if (errorData == null ? void 0 : errorData.error_description) return errorData.error_description;
    if (errorData !== null) {
      if (Array.isArray(errorData)) {
        return errorData.map(
          (errorMsg) => errorMsg.name && errorMsg.message ? `${errorMsg.name}: ${errorMsg.message}` : errorMsg
        ).join("<br/>");
      }
      if (errorData == null ? void 0 : errorData.error) return errorData["error"];
      if ((errorData == null ? void 0 : errorData.errors) && Array.isArray(errorData["errors"])) {
        return errorData["errors"].reduce((acc, errorObj2) => {
          if (errorObj2 == null ? void 0 : errorObj2.message) {
            acc.push(errorObj2["message"]);
          }
          return acc;
        }, []).join("<br/>");
      }
    }
    return String(errorData);
  }
  let res = ((_a2 = errorObj == null ? void 0 : errorObj.response) == null ? void 0 : _a2.statusText) ?? (errorObj == null ? void 0 : errorObj.message) ?? (errorObj == null ? void 0 : errorObj.text);
  if (res == null ? void 0 : res.startsWith("<html>")) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(res, "text/html");
    const title = doc.querySelector("title");
    res = title == null ? void 0 : title.innerText;
  }
  return res ?? "Unknown Error";
}
function createApiError(err) {
  var _a2;
  let errorMessage = "";
  let problem = { kind: "unknown", temporary: true };
  let status = 0;
  if (err instanceof ApiClientError) {
    return err;
  }
  if (KONTUR_DEBUG) {
    console.error(err);
  }
  if (err instanceof factory.WretchError) {
    status = err.status;
    if (status === 400) {
      problem = { kind: "bad-request" };
    } else if (status === 401) {
      problem = { kind: "unauthorized", data: (_a2 = err.json) == null ? void 0 : _a2.error };
    } else if (status === 403) {
      problem = { kind: "forbidden" };
    } else if (status === 404) {
      problem = { kind: "not-found" };
    } else if (status === 408 || status === 504) {
      errorMessage = "Server not available, please try later";
      problem = { kind: "timeout", temporary: true };
    } else if (status >= 500) {
      problem = { kind: "server", data: (err == null ? void 0 : err.json) ?? (err == null ? void 0 : err.text) };
    }
  } else if (isAbortError$1(err)) {
    problem = { kind: "canceled" };
  } else {
    problem = { kind: "client-unknown" };
  }
  if (!errorMessage) {
    errorMessage = parseApiError(err);
  }
  return new ApiClientError(errorMessage || "Unknown error", problem, status);
}
function isAbortError$1(e) {
  var _a2;
  return (e == null ? void 0 : e.name) === "AbortError" || ((_a2 = e == null ? void 0 : e.problem) == null ? void 0 : _a2.kind) === "canceled";
}
const ApiMethodTypes = {
  GET: "get",
  POST: "post",
  PUT: "put",
  PATCH: "patch",
  DELETE: "delete"
};
async function autoParseBody(res) {
  if (res.status === 204) {
    res.data = null;
    return res;
  }
  if (res.ok) {
    const contentType = res.headers.get("content-type") ?? "";
    if (contentType.includes("application/json")) {
      res.data = await res.json();
    } else {
      res.data = await res.text();
    }
  } else {
    console.debug("autoParseBody", res);
  }
  return res;
}
class ApiClient {
  /**
   * The Singleton's constructor should always be private to prevent direct
   * construction calls with the `new` operator.
   */
  constructor({ on }) {
    __publicField(this, "listeners", /* @__PURE__ */ new Map([["error", /* @__PURE__ */ new Set()]]));
    __publicField(this, "baseURL");
    __publicField(this, "authService");
    if (on) {
      typedObjectEntries(on).forEach(([event2, cb]) => this.on(event2, cb));
    }
  }
  init(cfg) {
    let baseURL = cfg.baseUrl;
    this.baseURL = baseURL;
  }
  on(event2, cb) {
    var _a2;
    (_a2 = this.listeners.get(event2)) == null ? void 0 : _a2.add(cb);
    return () => {
      var _a3;
      return (_a3 = this.listeners.get(event2)) == null ? void 0 : _a3.delete(cb);
    };
  }
  _emit(type, payload) {
    var _a2;
    (_a2 = this.listeners.get(type)) == null ? void 0 : _a2.forEach((l2) => l2(payload));
  }
  async call(method, path2, requestParams, useAuth = false, requestConfig = {}) {
    const RequestsWithBody = ["post", "put", "patch"];
    let req;
    if (path2.startsWith("http")) {
      const url = new URL(path2);
      req = factory(url.origin, { mode: "cors" }).addon(queryString).url(url.pathname);
    } else {
      req = factory(this.baseURL, { mode: "cors" }).addon(queryString).url(path2);
    }
    if (requestConfig.signal) {
      req = req.options({ signal: requestConfig.signal });
    }
    if (requestConfig.headers) {
      req = req.headers(requestConfig.headers);
    }
    let isAuthenticatedRequest = false;
    if (useAuth) {
      const token = await this.authService.getAccessToken();
      if (token) {
        isAuthenticatedRequest = true;
        req = req.auth(`Bearer ${token}`).catcher(401, async (_2, originalRequest) => {
          const token2 = await this.authService.getAccessToken();
          return originalRequest.auth(`Bearer ${token2}`).fetch().unauthorized((err) => {
            throw err;
          }).res(autoParseBody);
        });
      }
    }
    if (requestParams) {
      req = RequestsWithBody.includes(method) ? req.json(requestParams) : req.query(requestParams);
    }
    try {
      const response = await req[method]().res(autoParseBody);
      return response.data;
    } catch (err) {
      const apiError = createApiError(err);
      if (apiError.problem.kind === "canceled") {
        throw apiError;
      }
      if (isAuthenticatedRequest && apiError.problem.kind === "unauthorized") {
        try {
          const token = await this.authService.getAccessToken();
        } catch (error2) {
          __vitePreload(async () => {
            const { goTo: goTo2 } = await Promise.resolve().then(() => goTo$1);
            return { goTo: goTo2 };
          }, true ? void 0 : void 0, import.meta.url).then(({ goTo: goTo2 }) => {
            goTo2("/profile");
          });
        }
        throw apiError;
      }
      if (apiError.problem.kind === "timeout" && requestConfig.retryAfterTimeoutError) {
        if (requestConfig.retryAfterTimeoutError.times > 0) {
          if (requestConfig.retryAfterTimeoutError.delayMs) {
            await wait(requestConfig.retryAfterTimeoutError.delayMs / 1e3);
          }
          return this.call(method, path2, requestParams, useAuth, {
            ...requestConfig,
            retryAfterTimeoutError: {
              ...requestConfig.retryAfterTimeoutError,
              times: requestConfig.retryAfterTimeoutError.times - 1
            }
          });
        }
      }
      const errorsConfig = requestConfig.errorsConfig;
      if (errorsConfig && errorsConfig.messages) {
        if (typeof errorsConfig.messages !== "string") {
          if (apiError.status in errorsConfig.messages) {
            apiError.message = errorsConfig.messages[apiError.status];
          }
        } else {
          apiError.message = errorsConfig.messages;
        }
      }
      if ((errorsConfig == null ? void 0 : errorsConfig.hideErrors) !== true) {
        this._emit("error", apiError);
      }
      throw apiError;
    }
  }
  // method shortcuts
  async get(path2, requestParams, useAuth = false, requestConfig) {
    return this.call(ApiMethodTypes.GET, path2, requestParams, useAuth, requestConfig);
  }
  async post(path2, requestParams, useAuth = false, requestConfig) {
    return this.call(ApiMethodTypes.POST, path2, requestParams, useAuth, requestConfig);
  }
  async put(path2, requestParams, useAuth = false, requestConfig) {
    return this.call(ApiMethodTypes.PUT, path2, requestParams, useAuth, requestConfig);
  }
  async patch(path2, requestParams, useAuth = false, requestConfig) {
    return this.call(ApiMethodTypes.PATCH, path2, requestParams, useAuth, requestConfig);
  }
  async delete(path2, useAuth = false, requestConfig) {
    return this.call(ApiMethodTypes.DELETE, path2, void 0, useAuth, requestConfig);
  }
}
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let nanoid = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
};
const impossibleValue = Symbol(), callSafely = function(fn) {
  try {
    return fn(...[].slice.call(arguments, 1));
  } catch (err) {
    return setTimeout(() => {
      throw err;
    }), err instanceof Error ? err : err = new Error(err);
  }
};
function throwReatomError(condition, message) {
  if (condition) throw new Error(`Reatom error: ${message}`);
}
const isAtom$1 = (thing) => void 0 !== (thing == null ? void 0 : thing.__reatom), isAction$1 = (thing) => {
  var _a2;
  return true === ((_a2 = thing == null ? void 0 : thing.__reatom) == null ? void 0 : _a2.isAction);
}, isConnected = (cache) => cache.subs.size + cache.listeners.size > 0;
function assertFunction(thing) {
  throwReatomError("function" != typeof thing, `invalid "${typeof thing}", function expected`);
}
const getRootCause$1 = (cause) => null === cause.cause ? cause : getRootCause$1(cause.cause), isBrowser = () => {
  var _a2;
  return !!((_a2 = globalThis.navigator) == null ? void 0 : _a2.userAgent);
};
let CTX, initiations = 0;
const createCtx = ({ callLateEffect = callSafely, callNearEffect = callSafely, restrictMultipleContexts = isBrowser() } = {}) => {
  restrictMultipleContexts && 1 == initiations++ && console.warn("Reatom: multiple contexts detected, which is irrelevant in browser, you should use only one context");
  let caches = /* @__PURE__ */ new WeakMap(), read = (proto) => caches.get(proto), logsListeners = /* @__PURE__ */ new Set(), nearEffects = [], lateEffects = [], inTr = false, trError = null, trUpdates = [], trRollbacks = [], trLogs = [], trNearEffectsStart = 0, trLateEffectsStart = 0, effectsProcessing = false, walkNearEffects = () => {
    for (let effect of nearEffects) callNearEffect(effect, ctx);
    nearEffects = [];
  }, walkLateEffects = () => {
    if (!effectsProcessing) {
      effectsProcessing = true, walkNearEffects();
      for (let effect of lateEffects) callLateEffect(effect, ctx), nearEffects.length > 0 && walkNearEffects();
      lateEffects = [], effectsProcessing = false;
    }
  }, addPatch = ({ state, proto, pubs, subs, listeners }, cause) => (proto.actual = false, trLogs.push(proto.patch = { state, proto, cause, pubs, subs, listeners }), proto.patch), enqueueComputers = (cache) => {
    for (let subProto of cache.subs) {
      let subCache = subProto.patch ?? read(subProto);
      subProto.patch && !subProto.actual || 0 === addPatch(subCache, cache).listeners.size && enqueueComputers(subCache);
    }
  }, disconnect = (proto, pubPatch) => {
    if (pubPatch.subs.delete(proto) && (trRollbacks.push(() => pubPatch.subs.add(proto)), !isConnected(pubPatch))) {
      null !== pubPatch.proto.disconnectHooks && nearEffects.push(...pubPatch.proto.disconnectHooks);
      for (let parentParent of pubPatch.pubs) disconnect(pubPatch.proto, parentParent);
    }
  }, connect = (proto, pubPatch) => {
    if (!pubPatch.subs.has(proto)) {
      let wasConnected = isConnected(pubPatch);
      if (pubPatch.subs.add(proto), trRollbacks.push(() => pubPatch.subs.delete(proto)), !wasConnected) {
        null !== pubPatch.proto.connectHooks && nearEffects.push(...pubPatch.proto.connectHooks);
        for (let parentParentPatch of pubPatch.pubs) connect(pubPatch.proto, parentParentPatch);
      }
    }
  }, actualize = (ctx2, proto, updater) => {
    let { patch, actual } = proto, updating = void 0 !== updater;
    if (!updating && actual && (0 === patch.pubs.length || isConnected(patch))) return patch;
    let cache = patch ?? read(proto), isInt = !cache, cause = updating ? ctx2.cause : read(__root);
    if (isInt) cache = { state: proto.initState(ctx2), proto, cause, pubs: [], subs: /* @__PURE__ */ new Set(), listeners: /* @__PURE__ */ new Set() };
    else if (null === proto.computer && !updating) return cache;
    patch && !actual || (patch = addPatch(cache, cause));
    let { state } = patch, patchCtx = { get: ctx2.get, spy: void 0, schedule: ctx2.schedule, subscribe: ctx2.subscribe, cause: patch };
    try {
      proto.computer && ((patchCtx2, patch2) => {
        let { proto: proto2, pubs } = patch2, isDepsChanged = false;
        if (0 === pubs.length || pubs.some(({ proto: proto3, state: state2 }) => !Object.is(state2, (patch2.cause = actualize(patchCtx2, proto3)).state))) {
          let newPubs = [];
          if (patchCtx2.spy = ({ __reatom: depProto }, cb) => {
            if (patch2.pubs === pubs) {
              let depPatch = actualize(patchCtx2, depProto), prevDepPatch = newPubs.push(depPatch) <= pubs.length ? pubs[newPubs.length - 1] : void 0, isDepChanged = (prevDepPatch == null ? void 0 : prevDepPatch.proto) !== depPatch.proto;
              isDepsChanged || (isDepsChanged = isDepChanged);
              let state2 = depProto.isAction && !isDepChanged ? depPatch.state.slice(prevDepPatch.state.length) : depPatch.state;
              if (!cb || !isDepChanged && Object.is(state2, prevDepPatch.state)) return state2;
              if (depProto.isAction) for (const call of state2) cb(call);
              else cb(state2, isDepChanged ? void 0 : prevDepPatch == null ? void 0 : prevDepPatch.state);
            } else throwReatomError(true, "async spy");
          }, patch2.state = patch2.proto.computer(patchCtx2, patch2.state), patch2.pubs = newPubs, (isDepsChanged || pubs.length > newPubs.length) && isConnected(patch2)) {
            for (let { proto: depProto } of pubs) newPubs.every((dep) => dep.proto !== depProto) && disconnect(proto2, depProto.patch ?? read(depProto));
            for (let { proto: depProto } of newPubs) pubs.every((dep) => dep.proto !== depProto) && connect(proto2, depProto.patch ?? read(depProto));
          }
        }
      })(patchCtx, patch), updating && (patch.cause = ctx2.cause, updater(patchCtx, patch)), proto.actual = true;
    } catch (error2) {
      throw patch.error = error2;
    }
    if (!Object.is(state, patch.state) && (patch.subs.size > 0 && (updating || patch.listeners.size > 0) && enqueueComputers(patch), proto.updateHooks)) {
      let ctx3 = { get: patchCtx.get, spy: void 0, schedule: patchCtx.schedule, subscribe: patchCtx.subscribe, cause: patchCtx.cause };
      proto.updateHooks.forEach((hook) => trUpdates.push(() => hook(ctx3, patch)));
    }
    return patch;
  }, ctx = { get(atomOrCb) {
    if (throwReatomError(CTX && getRootCause$1(CTX.cause) !== read(__root), "cause collision"), isAtom$1(atomOrCb)) {
      let proto = atomOrCb.__reatom;
      if (inTr) return actualize(this, proto).state;
      let cache = read(proto);
      return void 0 === cache || null !== proto.computer && !isConnected(cache) ? this.get(() => actualize(this, proto).state) : cache.state;
    }
    if (throwReatomError(null !== trError, "tr failed"), inTr) return atomOrCb(read, actualize);
    inTr = true, trNearEffectsStart = nearEffects.length, trLateEffectsStart = lateEffects.length;
    let start = void 0 === CTX;
    start && (CTX = this);
    try {
      var result2 = atomOrCb(read, actualize);
      for (let i2 = 0; i2 < trLogs.length; i2++) {
        let { listeners, proto } = trLogs[i2];
        if (listeners.size > 0 && actualize(this, proto), trUpdates.length > 0) for (let commit of trUpdates.splice(0)) commit(this);
      }
      if (trLogs.length) for (let log of logsListeners) log(trLogs);
      for (let patch of trLogs) {
        let { proto, state } = patch;
        if (proto.isAction && (patch.state = []), patch === proto.patch) if (proto.patch = null, proto.actual = false, caches.set(proto, patch), proto.isAction) {
          if (0 === state.length) continue;
          for (let cb of patch.listeners) nearEffects.push(() => cb(state));
        } else for (let cb of patch.listeners) lateEffects.push(() => cb(read(proto).state));
      }
    } catch (e) {
      trError = e = e instanceof Error ? e : new Error(String(e));
      for (let log of logsListeners) log(trLogs, e);
      for (let cb of trRollbacks) callSafely(cb, e);
      for (let { proto } of trLogs) proto.patch = null, proto.actual = false;
      throw nearEffects.length = trNearEffectsStart, lateEffects.length = trLateEffectsStart, e;
    } finally {
      inTr = false, trError = null, trUpdates = [], trRollbacks = [], trLogs = [], trNearEffectsStart = 0, trLateEffectsStart = 0, start && (CTX = void 0);
    }
    return walkLateEffects(), result2;
  }, spy: void 0, schedule(cb, step = 1) {
    return assertFunction(cb), throwReatomError(!this, "missed context"), new Promise((res, rej) => {
      -1 === step ? inTr && trRollbacks.push(cb) : 0 === step ? inTr && trUpdates.push(() => cb(this)) : ((1 === step ? nearEffects : lateEffects).push(() => {
        try {
          let result2 = cb(this);
          return result2 instanceof Promise ? result2.then(res, rej) : res(result2), result2;
        } catch (error2) {
          throw rej(error2), error2;
        }
      }), inTr || walkLateEffects());
    });
  }, subscribe(atom2, cb = atom2) {
    if (assertFunction(cb), atom2 === cb) return logsListeners.add(cb), () => logsListeners.delete(cb);
    let { __reatom: proto } = atom2, lastState = impossibleValue, listener = (state) => Object.is(lastState, state) || cb(lastState = state), cache = read(proto);
    return void 0 !== cache && isConnected(cache) ? cache.listeners.add(listener) : this.get(() => {
      cache = actualize(this, proto, (patchCtx, patch) => {
      }), cache.listeners.add(listener), trRollbacks.push(() => proto.patch.listeners.delete(listener)), null !== proto.connectHooks && nearEffects.push(...proto.connectHooks);
      for (let pubPatch of cache.pubs) connect(proto, pubPatch);
    }), lastState === impossibleValue && listener((proto.patch ?? read(proto)).state), () => {
      if (cache.listeners.delete(listener) && !isConnected(cache)) {
        proto.disconnectHooks && nearEffects.push(...proto.disconnectHooks);
        for (let pubCache of cache.pubs) disconnect(proto, pubCache);
        inTr || (trRollbacks.length = 0, walkLateEffects());
      }
    };
  }, cause: void 0 };
  return (ctx.cause = ctx.get(() => actualize(ctx, __root))).cause = null, ctx;
};
let i = 0, __count = (name) => `${name}#${++i}`;
function pipe() {
  return [].slice.call(arguments).reduce((acc, fn) => fn(acc), this);
}
function onChange(cb) {
  var _a2;
  const hook = (ctx, patch) => cb(ctx, patch.state);
  return ((_a2 = this.__reatom).updateHooks ?? (_a2.updateHooks = /* @__PURE__ */ new Set())).add(hook), () => this.__reatom.updateHooks.delete(hook);
}
function onCall(cb) {
  return this.onChange((ctx, state) => {
    const { params, payload } = state[state.length - 1];
    cb(ctx, payload, params);
  });
}
function atom(initState, name = __count("_atom")) {
  let theAtom = (ctx, update) => ctx.get((read, actualize) => actualize(ctx, theAtom.__reatom, (patchCtx, patch) => {
    patch.state = "function" == typeof update ? update(patch.state, patchCtx) : update;
  }).state), computer = null;
  return "function" == typeof initState && (theAtom = {}, computer = initState, initState = void 0), theAtom.__reatom = { name, isAction: false, patch: null, initState: () => initState, computer, connectHooks: null, disconnectHooks: null, updateHooks: null, actual: false }, theAtom.pipe = pipe, theAtom.onChange = onChange, 0 === experimental_PLUGINS.length ? theAtom : theAtom.pipe(...experimental_PLUGINS);
}
const action = (fn, name) => {
  void 0 !== fn && "string" != typeof fn || (name = fn, fn = (ctx, v2) => v2), assertFunction(fn);
  let actionAtom = atom([], name ?? __count("_action"));
  return actionAtom.__reatom.isAction = true, actionAtom.__reatom.unstable_fn = fn, Object.assign(function() {
    var params = [].slice.call(arguments);
    let state = actionAtom(params[0], (state2, patchCtx) => (params[0] = patchCtx, [...state2, { params: params.slice(1), payload: patchCtx.cause.proto.unstable_fn(...params) }]));
    return state[state.length - 1].payload;
  }, actionAtom, { onCall });
}, experimental_PLUGINS = [], __root = atom(void 0, "root").__reatom;
function pushUnique(list2, el) {
  list2.includes(el) || list2.push(el);
}
function isString(thing) {
  return "string" == typeof thing;
}
function isObject(thing) {
  return "object" == typeof thing && null !== thing;
}
function isFunction(thing) {
  return "function" == typeof thing;
}
function isAtom(thing) {
  return isFunction(thing) && "types" in thing;
}
function isActionCreator(thing) {
  return isFunction(thing) && "type" in thing;
}
function isAction(thing) {
  return isObject(thing) && isString(thing.type) && "payload" in thing;
}
function getState(atom2, store2 = defaultStore) {
  return store2.getState(atom2);
}
const getRootCause = (cause) => null === cause.cause ? cause : getRootCause(cause.cause), spyChange = (ctx, anAtom, handler) => {
  let isChanged = false;
  return ctx.spy(anAtom, (newState, prevState) => {
    isChanged = true, handler == null ? void 0 : handler(newState, prevState);
  }), isChanged;
};
atom(null, "initializations").__reatom.initState = () => /* @__PURE__ */ new WeakMap();
let atomsCount = 0;
function createAtom$1(dependencies, reducer, options = {}) {
  let { v3atom, id = (v3atom == null ? void 0 : v3atom.__reatom.name) ?? "atom" + ++atomsCount, store: store2 = defaultStore } = isString(options) ? { id: options } : options;
  const trackedTypes = [], types = [], actionCreators = {}, externalActions = {};
  throwReatomError(!isFunction(reducer) || !isString(id), "atom arguments"), Object.entries(dependencies).forEach(([name, dep]) => {
    if (throwReatomError(!isFunction(dep), `Invalid atom dependencies (type ${typeof dep}) at ${name}`), isAtom(dep)) dep.types.forEach((type) => pushUnique(types, type));
    else {
      let type;
      if (isActionCreator(dep)) type = (externalActions[name] = dep).type;
      else {
        type = `${name}_${id}`;
        const actionCreator = function() {
          return { payload: dep(...[].slice.call(arguments)), type, targets: [atom$1], v3action: actionCreator.v3action };
        };
        actionCreator.type = type, actionCreator.dispatch = function() {
          return store2.dispatch(actionCreator(...[].slice.call(arguments)));
        }, actionCreator.v3action = action(type), actionCreators[name] = actionCreator, "_" != name[0] && (atom$1[name] = actionCreator);
      }
      pushUnique(trackedTypes, type), pushUnique(types, type);
    }
  });
  const cacheReducer = /* @__PURE__ */ function(reducer2, dependencies2, trackedTypes2, actionCreators2, externalActions2) {
    const create2 = function(name) {
      return actionCreators2[name](...[].slice.call(arguments, 1));
    };
    return (v3ctx, state) => {
      const rootCause = getRootCause(v3ctx.cause);
      ctxs.has(rootCause) || ctxs.set(rootCause, /* @__PURE__ */ new WeakMap()), ctxs.get(rootCause).has(reducer2) || ctxs.get(rootCause).set(reducer2, {});
      const ctx = ctxs.get(rootCause).get(reducer2);
      return reducer2({ create: create2, get: (name) => v3ctx.spy(dependencies2[name].v3atom), getUnlistedState: (targetAtom) => v3ctx.get(targetAtom.v3atom), onAction: (name, reaction) => {
        const ac = externalActions2[name] ?? actionCreators2[name];
        throwReatomError(void 0 === ac, "Unknown action"), spyChange(v3ctx, ac.v3action, ({ payload }) => {
          reaction(payload);
        });
      }, onChange: (name, reaction) => {
        spyChange(v3ctx, dependencies2[name].v3atom, (prev, next) => reaction(prev, next));
      }, onInit: (cb) => {
        v3ctx.get((read) => read(v3ctx.cause.proto)) || cb();
      }, schedule: (effect) => v3ctx.schedule(() => effect(getRootCause(v3ctx.cause).v2store.dispatch, ctx, []), 2), v3ctx }, state);
    };
  }(reducer, dependencies, 0, actionCreators, externalActions);
  function atom$1(transaction) {
    return transaction.v3ctx.get(atom$1.v3atom);
  }
  return atom$1.id = id, atom$1.getState = () => store2.getState(atom$1), atom$1.subscribe = (cb) => store2.subscribe(atom$1, cb), atom$1.types = types, (atom$1.v3atom = v3atom ?? atom(cacheReducer, id)).__reatom.v2atom = atom$1, atom$1;
}
const ctxs = /* @__PURE__ */ new WeakMap();
function createStore({ callSafety = callSafely, v3ctx = createCtx({ callNearEffect: callSafety, callLateEffect: callSafety }) } = {}) {
  const store2 = { dispatch: (action2) => {
    const actions = Array.isArray(action2) ? action2 : [action2];
    throwReatomError(0 == actions.length || !actions.every(isAction), "dispatch arguments"), v3ctx.get(() => {
      actions.forEach((action3) => action3.v3action(v3ctx, action3.payload)), actions.forEach(({ targets }) => targets == null ? void 0 : targets.forEach((target) => v3ctx.get(target.v3atom)));
    });
  }, getCache: (atom2) => v3ctx.get((read) => read(atom2.v3atom.__reatom)), getState: (atom2) => v3ctx.get(atom2.v3atom), subscribe: (atom2, cb) => v3ctx.subscribe(atom2.v3atom, (state) => cb(state, [])), v3ctx };
  return getRootCause(v3ctx.cause).v2store = store2, store2;
}
const defaultStore = createStore();
let f$1 = 0;
function m(n2, r2, c2 = "primitive" + ++f$1) {
  r2 ?? (r2 = { set: (e, t2) => t2, change: (e, t2) => t2(e) });
  let { decorators: o2, ...u2 } = isString(c2) ? { id: c2 } : c2;
  const a2 = createAtom$1(Object.keys(r2).reduce((e, t2) => (e[t2] = function() {
    return [].slice.call(arguments);
  }, e), {}), (e, t2 = n2) => {
    for (const n3 in r2) e.onAction(n3, (e2) => {
      t2 = r2[n3](t2, ...e2);
    });
    return t2;
  }, u2);
  return a2;
}
const AppFeature = {
  ABOUT_PAGE: "about_page",
  APP_LOGIN: "app_login",
  ANALYTICS_PANEL: "analytics_panel",
  ADVANCED_ANALYTICS_PANEL: "advanced_analytics_panel",
  EVENTS_LIST: "events_list",
  /**
   * @deprecated Use EVENTS_LIST__FEED_SELECTOR instead
   */
  FEED_SELECTOR: "feed_selector",
  EVENTS_LIST__FEED_SELECTOR: "events_list__feed_selector",
  EVENTS_LIST__BBOX_FILTER: "events_list__bbox_filter",
  MAP_LAYERS_PANEL: "map_layers_panel",
  SIDE_BAR: "side_bar",
  BIVARIATE_MANAGER: "bivariate_manager",
  CURRENT_EVENT: "current_event",
  FOCUSED_GEOMETRY_LAYER: "focused_geometry_layer",
  LAYERS_IN_AREA: "layers_in_area",
  MAP_RULER: "map_ruler",
  TOASTS: "toasts",
  BOUNDARY_SELECTOR: "boundary_selector",
  DRAW_TOOLS: "draw_tools",
  FOCUSED_GEOMETRY_EDITOR: "focused_geometry_editor",
  GEOMETRY_UPLOADER: "geometry_uploader",
  LEGEND_PANEL: "legend_panel",
  REPORTS: "reports",
  INTERACTIVE_MAP: "interactive_map",
  CURRENT_EPISODE: "current_episode",
  GEOCODER: "geocoder",
  EPISODE_LIST: "episode_list",
  COMMUNITIES: "communities",
  FEATURE_SETTINGS: "feature_settings",
  OSM_EDIT_LINK: "osm_edit_link",
  TOOLTIP: "tooltip",
  CREATE_LAYER: "create_layer",
  HEADER: "header",
  INTERCOM: "intercom",
  BIVARIATE_COLOR_MANAGER: "bivariate_color_manager",
  EPISODES_TIMELINE: "episodes_timeline",
  LOCATE_ME: "locate_me",
  USE_3RDPARTY_ANALYTICS: "use_3rdparty_analytics",
  LIVE_SENSOR: "live_sensor",
  MCDA: "mcda",
  TOOLBAR: "toolbar",
  LAYER_FEATURES_PANEL: "layer_features_panel",
  REFERENCE_AREA: "reference_area",
  LLM_ANALYTICS: "llm_analytics",
  MAP: "map",
  SUBSCRIPTION: "subscription",
  SEARCH_LOCATION: "search_locations",
  SEARCH_BAR: "search_bar",
  ADMIN_BOUNDARY_BREADCRUMBS: "admin_boundary_breadcrumbs",
  LLM_MCDA: "llm_mcda"
};
const METRICS_EVENT = "METRICS";
function dispatchMetricsEvent(name, payload) {
  if (!globalThis.CustomEvent) return;
  const evt = new CustomEvent(METRICS_EVENT, {
    detail: {
      name,
      payload
    }
  });
  globalThis.dispatchEvent(evt);
}
const store = createStore({});
const addStoreInOptions = (options) => ({
  store,
  ...typeof options === "string" ? { id: options } : options
});
const createAtom = (deps, reducer, options) => createAtom$1(deps, reducer, addStoreInOptions(options));
let count = 0;
function createSetAtom(initState = /* @__PURE__ */ new Set(), options = `set${++count}`) {
  return m(
    initState,
    {
      set: (state, el) => {
        if (state.has(el)) return state;
        return new Set(state).add(el);
      },
      delete: (state, el) => {
        const newState = state = new Set(state);
        if (!newState.delete(el)) return state;
        return newState;
      },
      clear: () => /* @__PURE__ */ new Set(),
      change: (state, cb) => cb(new Set(state))
    },
    addStoreInOptions(options)
  );
}
function createMapAtom(initState = /* @__PURE__ */ new Map(), options = `map${++count}`) {
  return m(
    initState,
    {
      set: (state, key, el) => {
        if (state.get(key) === el) return state;
        return new Map(state).set(key, el);
      },
      delete: (state, key) => {
        const newState = state = new Map(state);
        if (!newState.delete(key)) return state;
        return newState;
      },
      clear: () => /* @__PURE__ */ new Map(),
      change: (state, cb) => cb(new Map(state))
    },
    addStoreInOptions(options)
  );
}
const currentNotificationAtom = createAtom(
  {
    showNotification: (type, message, lifetimeSec) => ({ type, message, lifetimeSec }),
    removeNotification: (id) => id
  },
  ({ onAction, schedule, create: create2 }, state = []) => {
    onAction("showNotification", ({ type, message, lifetimeSec }) => {
      const id = nanoid(4);
      const onClose = () => currentNotificationAtom.removeNotification.dispatch(id);
      state = [...state, { id, type, message, lifetimeSec, onClose }];
      schedule((dispatch) => {
        setTimeout(onClose, lifetimeSec * 1e3);
      });
    });
    onAction(
      "removeNotification",
      (idToDelete) => state = state.filter(({ id }) => id !== idToDelete)
    );
    return [...state];
  },
  "[Shared state] currentNotificationAtom"
);
const _NotificationService = class _NotificationService {
  constructor() {
    __publicField(this, "defaultLifetimeSec", 10);
  }
  static getInstance() {
    if (!_NotificationService.instance) {
      throw new Error("You have to initialize api client first!");
    } else {
      return _NotificationService.instance;
    }
  }
  static init() {
    _NotificationService.instance = new _NotificationService();
  }
  error(message, lifetimeSec) {
    currentNotificationAtom.showNotification.dispatch(
      "error",
      message,
      lifetimeSec || this.defaultLifetimeSec
    );
  }
  warning(message, lifetimeSec) {
    currentNotificationAtom.showNotification.dispatch(
      "warning",
      message,
      lifetimeSec || this.defaultLifetimeSec
    );
  }
  info(message, lifetimeSec) {
    currentNotificationAtom.showNotification.dispatch(
      "info",
      message,
      lifetimeSec || this.defaultLifetimeSec
    );
  }
  success(message, lifetimeSec) {
    currentNotificationAtom.showNotification.dispatch(
      "success",
      message,
      lifetimeSec || this.defaultLifetimeSec
    );
  }
};
__publicField(_NotificationService, "instance");
let NotificationService = _NotificationService;
NotificationService.init();
const notificationServiceInstance = NotificationService.getInstance();
const apiClient = new ApiClient({
  on: {
    error: (error2) => {
      switch (error2.problem.kind) {
        default:
          notificationServiceInstance.error({
            title: "Error",
            description: error2.message
          });
      }
    }
  }
});
new ApiClient({
  on: {
    error: (error2) => {
      switch (error2.problem.kind) {
        default:
          notificationServiceInstance.error({
            title: "Error",
            description: error2.message
          });
      }
    }
  }
});
const PagesDocumentElementRenderers = {
  css: CssElement,
  md: MarkdownElement
};
function PagesDocumentRenderer({
  doc,
  wrapperComponent: WrapperComponent = Article
}) {
  const id = reactExports.useId();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(WrapperComponent, { children: doc.map((e, idx) => {
    if (PagesDocumentElementRenderers.hasOwnProperty(e.type)) {
      const Component = PagesDocumentElementRenderers[e.type];
      return Component ? /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { data: e.data }, `${id}-${idx}`) : null;
    }
    return null;
  }) });
}
function CssElement({ data }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: data });
}
function MarkdownElement({ data }) {
  const compiled = Ze(data, {
    overrides: {
      a: CustomLink,
      img: CustomImg
    },
    wrapper: null
  });
  const structuredContent = structureMarkdownContent(compiled);
  return structuredContent;
}
console.info("test app id", configRepo.get().id);
const PagesDocument_fixture = {
  "PagesDocument with custom css": /* @__PURE__ */ jsxRuntimeExports.jsx(
    PagesDocumentRenderer,
    {
      doc: [
        {
          type: "md",
          data: `
#Kontur Atlas
Atlas is your GPS for big decisions. It's a tool that helps you use maps and data to figure out a wide range of things, from where to open a new store to exploring environmental sustainability.
`
        },
        {
          type: "css",
          data: `
h1 { background-color: #f2f2f2; }
p { background-color: #BF6C3F; }
`
        }
      ]
    }
  ),
  "Links test": /* @__PURE__ */ jsxRuntimeExports.jsx(
    PagesDocumentRenderer,
    {
      doc: [
        {
          type: "md",
          data: `
[Link](https://example.com)

Controller using this email: [hello@kontur.io](mailto:hello@kontur.io) or contact address.

Controller using this email: <hello@kontur.io> or contact address.

hello@kontur.io

kancelaria@uodo.gov.pl

ng: <kancelaria@uodo.gov.pl>

http://www.youronlinechoices.com/

ng: <http://www.youronlinechoices.com/>
`
        }
      ]
    }
  )
};
const fixture2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PagesDocument_fixture
}, Symbol.toStringTag, { value: "Module" }));
const linkWidthWrap = "_linkWidthWrap_qkwt3_1";
const truncate = "_truncate_qkwt3_3";
const tail = "_tail_qkwt3_4";
const link = "_link_qkwt3_1";
const s$b = {
  linkWidthWrap,
  truncate,
  tail,
  link
};
const splitTail = (str, tailSize) => {
  const tail2 = str.slice(tailSize * -1);
  const body = str.slice(0, Math.max(0, str.length - tailSize));
  return [body, tail2];
};
const LinkRenderer = reactExports.memo(function(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: props.href, target: "_blank", rel: "noreferrer", onClick: stopPropagation, children: props.children });
});
function ShortLinkRenderer({
  children: linksArr,
  maxWidth = 190,
  truncateAmount = 12,
  href
}) {
  const passedLink = (linksArr == null ? void 0 : linksArr[0]) ?? href;
  const [leftPart, rightPart] = splitTail(passedLink, truncateAmount);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$b.linkWidthWrap, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$b.linkOverflowWrap, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "a",
    {
      className: s$b.link,
      target: "_blank",
      rel: "noreferrer",
      "data-truncate": rightPart,
      href,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: s$b.truncate, style: { maxWidth: maxWidth || "unset" }, children: leftPart }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: s$b.tail, children: rightPart })
      ]
    }
  ) }) });
}
function stopPropagation(e) {
  e.stopPropagation();
}
LinkRenderer.displayName = "LinkRenderer";
const LinkRenderer_fixture = /* @__PURE__ */ jsxRuntimeExports.jsxs("blockquote", { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
  "LinkRenderer: ",
  /* @__PURE__ */ jsxRuntimeExports.jsx(LinkRenderer, { href: "https://kontur.io", children: "kontur.io" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
  "ShortLinkRenderer short:",
  /* @__PURE__ */ jsxRuntimeExports.jsx(ShortLinkRenderer, { href: "https://kontur.io", children: ["kontur.io"] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
  "ShortLinkRenderer gdacs:",
  /* @__PURE__ */ jsxRuntimeExports.jsx(ShortLinkRenderer, { href: "https://www.gdacs.org/report.aspx?eventid=1102779&episodeid=6&eventtype=FL", children: ["gdacs.org/report.aspx?eventtype=EQ&eventid=1441158"] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
  "ShortLinkRenderer long:",
  /* @__PURE__ */ jsxRuntimeExports.jsx(ShortLinkRenderer, { href: "https://disaster.ninja/active/?layers=kontur_lines%2CactiveContributors%2CeventShape%2ChotProjects_outlines%2Cpopulation_density%2Cfocused-geometry", children: [
    "https://disaster.ninja/active/?layers=kontur_lines%2CactiveContributors%2CeventShape%2ChotProjects_outlines%2Cpopulation_density%2Cfocused-geometry"
  ] })
] });
const fixture3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: LinkRenderer_fixture
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @remix-run/router v1.20.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to2) {
    return typeof to2 === "string" ? to2 : createPath(to2);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
function createLocation(current, to2, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$2({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to2 === "string" ? parsePath(to2) : to2, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to2 && to2.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path2) {
  let parsedPath = {};
  if (path2) {
    let hashIndex = path2.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path2.substr(hashIndex);
      path2 = path2.substr(0, hashIndex);
    }
    let searchIndex = path2.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path2.substr(searchIndex);
      path2 = path2.substr(0, searchIndex);
    }
    if (path2) {
      parsedPath.pathname = path2;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action2 = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$2({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action2 = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action: action2,
        location: history.location,
        delta
      });
    }
  }
  function push(to2, state) {
    action2 = Action.Push;
    let location = createLocation(history.location, to2, state);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error2) {
      if (error2 instanceof DOMException && error2.name === "DataCloneError") {
        throw error2;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action: action2,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to2, state) {
    action2 = Action.Replace;
    let location = createLocation(history.location, to2, state);
    index2 = getIndex();
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action: action2,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to2) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to2 === "string" ? to2 : createPath(to2);
    href = href.replace(/ $/, "%20");
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action2;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to2) {
      return createHref(window2, to2);
    },
    createURL,
    encodeLocation(to2) {
      let url = createURL(to2);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.27.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends$1({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
new Promise(() => {
});
/**
 * React Router DOM v6.27.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e) {
}
const START_TRANSITION = "startTransition";
const startTransitionImpl = React[START_TRANSITION];
function BrowserRouter(_ref4) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref4;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future
  });
}
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
var c = React$1.createContext(defaultStore), o = function(n2) {
  return n2();
};
function a(n2, t2) {
  return function() {
    var r2 = t2.apply(void 0, [].slice.call(arguments));
    r2 && o(function() {
      n2.dispatch(r2);
    });
  };
}
function f(n2, t2) {
  void 0 === t2 && (t2 = []);
  var r2 = React$1.useContext(c);
  return React$1.useCallback(a(r2, n2), t2.concat(r2));
}
function s$a(n2, o2, i2) {
  var f2 = n2;
  i2 = [];
  var s2 = React$1.useContext(c);
  i2 = i2.concat([n2, s2]);
  var l2 = React$1.useState(function() {
    return getState(n2, s2);
  }), v2 = l2[0], m2 = l2[1], p2 = React$1.useRef(v2);
  p2.current = v2 = getState(n2, s2);
  var b2 = React$1.useMemo(function() {
    return Object.entries(f2).reduce(function(n3, t2) {
      var r2 = t2[0], u2 = t2[1];
      return isActionCreator(u2) && (n3[r2] = a(s2, u2)), n3;
    }, {});
  }, i2);
  return React$1.useEffect(function() {
    return s2.subscribe(n2, function(n3) {
      return Object.is(n3, p2.current) || m2(p2.current = n3);
    });
  }, i2), React$1.useDebugValue(v2), [v2, b2];
}
const currentTooltipAtom = createAtom(
  {
    setCurrentTooltip: (tooltipData) => tooltipData,
    resetCurrentTooltip: () => null,
    turnOffById: (id) => id
  },
  ({ onAction }, state = null) => {
    onAction("setCurrentTooltip", (tooltipData) => state = tooltipData);
    onAction("resetCurrentTooltip", () => state = null);
    onAction("turnOffById", (id) => {
      if ((state == null ? void 0 : state.initiatorId) === id) state = null;
    });
    return state;
  },
  "[Shared state] currentTooltipAtom"
);
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
function addClass(element, className) {
  if (element.classList) element.classList.add(className);
  else if (!hasClass(element, className)) if (typeof element.className === "string") element.className = element.className + " " + className;
  else element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
const config = {
  disabled: false
};
const TransitionGroupContext = React$1.createContext(null);
var forceReflow = function forceReflow2(node) {
  return node.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context2) {
    var _this;
    _this = _React$Component.call(this, props, context2) || this;
    var parentGroup = context2;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node) forceReflow(node);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active2 = true;
    this.nextCallback = function(event2) {
      if (active2) {
        active2 = false;
        _this4.nextCallback = null;
        callback(event2);
      }
    };
    this.nextCallback.cancel = function() {
      active2 = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React$1.cloneElement(React$1.Children.only(children), childProps))
    );
  };
  return Transition2;
}(React$1.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c2) {
    return addClass(node, c2);
  });
};
var removeClass = function removeClass2(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c2) {
    return removeClass$1(node, c2);
  });
};
var CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass2(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      if (node) forceReflow(node);
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass(node, baseClassName);
    }
    if (activeClassName) {
      removeClass(node, activeClassName);
    }
    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props;
    _this$props.classNames;
    var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return /* @__PURE__ */ React$1.createElement(Transition, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(React$1.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = {};
const fadeEnter = "_fadeEnter_1fjeq_1";
const fadeEnterActive = "_fadeEnterActive_1fjeq_5";
const fadeExit = "_fadeExit_1fjeq_10";
const fadeExitActive = "_fadeExitActive_1fjeq_14";
const s$9 = {
  fadeEnter,
  fadeEnterActive,
  fadeExit,
  fadeExitActive
};
const fadeClassNames = {
  enter: s$9.fadeEnter,
  enterActive: s$9.fadeEnterActive,
  exit: s$9.fadeExit,
  exitActive: s$9.fadeExitActive
};
const CSSTransitionWrapper = ({
  children,
  ...props
}) => {
  const nodeRef = reactExports.useRef(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CSSTransition, { ...props, nodeRef, children: children(nodeRef) });
};
function parseLinksAsTags(text) {
  if (!text) return "";
  let parsed = text;
  const regex = /(.?.?https|.?.?http)(:\/\/)([\w_-]+(?:(?:\.[\w_-]+)+))([\w.,@?^=%&:\/~+#-]*[\w@?^=%&\/~+#-])/gm;
  const matchIterable = text.matchAll(regex);
  let offset2 = 0;
  [...matchIterable].forEach((matchEntity) => {
    const [match, protocol, , domain, path2] = matchEntity;
    const matchIndex = matchEntity.index ?? 0;
    const matchLength = match.length;
    if (match.startsWith("](") || match.indexOf("[http") > -1) return;
    const linkStartIndex = match.indexOf("http");
    const fullLink = match.substring(linkStartIndex);
    const beforeLink = match.substring(0, linkStartIndex);
    const noW3domain = domain.replace("www.", "");
    const mdLinkWithPrefix = `${beforeLink}[${noW3domain}${path2 ?? ""}](${fullLink})`;
    const finalText = spliceString(parsed)(
      matchIndex + offset2,
      matchLength,
      mdLinkWithPrefix
    );
    offset2 += mdLinkWithPrefix.length - matchLength;
    parsed = finalText;
  });
  return parsed;
}
function spliceString(string) {
  return function(index2, count2, add) {
    if (index2 < 0) {
      index2 += string.length;
      if (index2 < 0) index2 = 0;
    }
    return string.slice(0, index2) + (add || "") + string.slice(index2 + count2);
  };
}
const currentLocationAtom = createAtom(
  {
    set: (location) => location
  },
  ({ onAction }, state = globalThis.location) => {
    onAction("set", (location) => state = location);
    return state;
  },
  "currentLocationAtom"
);
const closeOnLocationChangeAtom = createAtom(
  {
    currentLocationAtom
  },
  ({ onChange: onChange2, schedule, getUnlistedState }) => {
    onChange2("currentLocationAtom", (curr, prev) => {
      const tooltip = getUnlistedState(currentTooltipAtom);
      if (curr.pathname !== (prev == null ? void 0 : prev.pathname) && (tooltip == null ? void 0 : tooltip.position)) {
        schedule((dispatch) => {
          dispatch(currentTooltipAtom.resetCurrentTooltip());
        });
      }
    });
  },
  "closeOnLocationChangeAtom"
);
const markdown$1 = "_markdown_4vdv7_1";
const s$8 = {
  markdown: markdown$1
};
function PopupTooltip() {
  const [tooltip, { resetCurrentTooltip }] = s$a(currentTooltipAtom);
  s$a(closeOnLocationChangeAtom);
  const closeHandler = reactExports.useCallback(
    (e) => {
      var _a2;
      resetCurrentTooltip();
      (_a2 = tooltip == null ? void 0 : tooltip.onClose) == null ? void 0 : _a2.call(tooltip, e, resetCurrentTooltip);
    },
    [resetCurrentTooltip, tooltip]
  );
  const outerClickHandler = reactExports.useCallback(
    (e) => {
      var _a2;
      (_a2 = tooltip == null ? void 0 : tooltip.onOuterClick) == null ? void 0 : _a2.call(tooltip, e, resetCurrentTooltip);
    },
    [resetCurrentTooltip, tooltip]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CSSTransitionWrapper, { in: Boolean(tooltip), timeout: 300, classNames: fadeClassNames, children: (transitionRef) => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: tooltip && /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tooltip$1,
    {
      transitionRef,
      position: tooltip.position,
      hoverBehavior: tooltip.hoverBehavior,
      getPlacement: tooltip.position.predefinedPosition,
      classes: tooltip.popupClasses,
      onClose: closeHandler,
      onOuterClick: outerClickHandler,
      children: typeof tooltip.popup === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Markdown,
        {
          options: { overrides: { a: LinkRenderer } },
          className: s$8.markdown,
          children: parseLinksAsTags(tooltip.popup)
        }
      ) : tooltip.popup
    }
  ) }) });
}
const BIVARIATE_LEGEND_SIZE = 3;
const CORNER_POINTS_INDEXES = [
  0,
  BIVARIATE_LEGEND_SIZE - 1,
  BIVARIATE_LEGEND_SIZE * BIVARIATE_LEGEND_SIZE - BIVARIATE_LEGEND_SIZE,
  BIVARIATE_LEGEND_SIZE * BIVARIATE_LEGEND_SIZE - 1
];
const LOW = `↓${TranslationService.t("bivariate.legend.low")}`;
const HIGH = `↑${TranslationService.t("bivariate.legend.high")}`;
const MEDIUM = TranslationService.t("bivariate.legend.medium");
const isTopSide = (index2) => Array.from(Array(BIVARIATE_LEGEND_SIZE), (_2, i2) => i2).includes(index2);
const isBottomSide = (index2) => {
  const bottomRowStartIndex = BIVARIATE_LEGEND_SIZE * BIVARIATE_LEGEND_SIZE - BIVARIATE_LEGEND_SIZE;
  return Array.from(
    Array(BIVARIATE_LEGEND_SIZE),
    (_2, i2) => bottomRowStartIndex + i2
  ).includes(index2);
};
const isLeftSide = (index2) => Array.from(Array(BIVARIATE_LEGEND_SIZE), (_2, i2) => i2 * BIVARIATE_LEGEND_SIZE).includes(
  index2
);
const isRightSide = (index2) => Array.from(
  Array(BIVARIATE_LEGEND_SIZE),
  (_2, i2) => i2 * BIVARIATE_LEGEND_SIZE + (BIVARIATE_LEGEND_SIZE - 1)
).includes(index2);
const PopupTooltipWrapper = reactExports.memo(
  ({
    children,
    tooltipText,
    renderTooltip,
    tooltipId,
    hoverBehavior = true,
    popupClasses: popupClasses2
  }) => {
    const setTooltip = f(currentTooltipAtom.setCurrentTooltip);
    const resetTooltip = f(currentTooltipAtom.resetCurrentTooltip);
    const renderTextTooltip = (e) => {
      if (tooltipText) {
        setTooltip({
          popupClasses: popupClasses2,
          popup: tooltipText,
          position: { x: e.clientX, y: e.clientY },
          onOuterClick(e2, close) {
            close();
          },
          initiatorId: tooltipId,
          hoverBehavior
        });
      }
    };
    const showTooltip = (e, ...args) => {
      if (!renderTooltip) {
        renderTextTooltip(e);
      } else {
        renderTooltip(e, setTooltip, ...args);
      }
    };
    const hideTooltip = () => {
      resetTooltip();
    };
    return children({
      showTooltip,
      hideTooltip
    });
  }
);
PopupTooltipWrapper.displayName = "PopupTooltipWrapper";
function featureProp(name) {
  return ["get", name];
}
function getVariable(name) {
  return ["var", name];
}
function less(first2, second) {
  return ["<", first2, second];
}
function lessOrEqual(first2, second) {
  return ["<=", first2, second];
}
function greaterOrEqual(first2, second) {
  return [">=", first2, second];
}
function notEqual(first2, second) {
  return ["!=", first2, second];
}
function equal(first2, second) {
  return ["==", first2, second];
}
function caseFn(condition, output) {
  return [condition, output];
}
function switchFn(conditions, defaultCase) {
  return ["case", ...conditions.flat(1), defaultCase];
}
function concat(first2, second) {
  return ["concat", first2, second];
}
function addVariable(name, binding, expression) {
  return ["let", name, binding, expression];
}
function allCondition(...conditionInputs) {
  return ["all", ...conditionInputs];
}
function anyCondition(...conditionInputs) {
  return ["any", ...conditionInputs];
}
function stringsToFeatureProp(expression) {
  if (typeof expression === "string") {
    return expression === "1" ? 1 : featureProp(expression);
  } else {
    return expression.map((exp, i2) => i2 === 0 ? exp : stringsToFeatureProp(exp));
  }
}
const AT_CHAR_CODE = 64;
const getCharByIndex = (i2) => String.fromCharCode(AT_CHAR_CODE + i2);
const getConditionFunc = (currentIndex, totalBorders) => currentIndex === totalBorders - 1 ? lessOrEqual : less;
function classResolver(xValue, yValue) {
  const xAxisValue = stringsToFeatureProp(xValue.propName);
  const yAxisValue = stringsToFeatureProp(yValue.propName);
  return concat(
    switchFn(
      // cases for a, b, c ...
      xValue.borders.map(
        (border, i2, arr) => caseFn(getConditionFunc(i2, arr.length)(xAxisValue, border), getCharByIndex(i2))
      ),
      // default case required
      getCharByIndex(xValue.borders.length)
    ),
    switchFn(
      // cases for 1, 2, 3 ...
      yValue.borders.map(
        (border, i2, arr) => caseFn(getConditionFunc(i2, arr.length)(yAxisValue, border), i2)
      ),
      // default case required
      yValue.borders.length
    )
  );
}
function colorResolver(variableName, colorMap, fallbackColor) {
  return switchFn(
    Object.entries(colorMap).map(
      ([cls, color]) => (
        // color cases
        caseFn(equal(getVariable(variableName), cls), color)
      )
    ),
    fallbackColor
  );
}
function colorsMap(colors) {
  return Object.fromEntries(colors.map(({ id, color }) => [id, color]));
}
function filterSetup$1(xAxis, yAxis) {
  return anyCondition(
    notEqual(["/", featureProp(xAxis.quotient[0]), featureProp(xAxis.quotient[1])], 0),
    notEqual(["/", featureProp(yAxis.quotient[0]), featureProp(yAxis.quotient[1])], 0)
  );
}
function colorSetup(xAxis, yAxis, colors) {
  return addVariable(
    "class",
    classResolver(
      {
        propName: ["/", ...xAxis.quotient],
        borders: xAxis.steps.reduce(
          (acc, { value }) => (acc.push(value), acc),
          []
        )
      },
      {
        propName: ["/", ...yAxis.quotient],
        borders: yAxis.steps.reduce(
          (acc, { value }) => (acc.push(value), acc),
          []
        )
      }
    ),
    colorResolver("class", colors, "transparent")
  );
}
function generateBivariateStyleForAxis({
  x: x2,
  y: y2,
  colors,
  source,
  sourceLayer,
  id = "bivariate"
}) {
  const style2 = {
    id,
    type: "fill",
    layout: {},
    filter: filterSetup$1(x2, y2),
    paint: {
      "fill-color": colorSetup(x2, y2, colorsMap(colors)),
      "fill-opacity": 1,
      "fill-antialias": false
    }
  };
  if (source) {
    style2.source = source;
  }
  if (sourceLayer) {
    style2["source-layer"] = sourceLayer;
  }
  return style2;
}
function clusterize(arr, key = "id") {
  const clusterMap = arr.reduce(
    (acc, item) => {
      const clusterName = item[key].slice(0, 1);
      if (acc[clusterName]) {
        acc[clusterName].push(item);
      } else {
        acc[clusterName] = [item];
      }
      return acc;
    },
    {}
  );
  return Object.values(clusterMap);
}
function invertClusters(arr, key = "id") {
  const clusters = [...clusterize(arr, key)].reverse();
  return clusters.reduce((acc, cluster) => acc.concat(cluster), []);
}
const isErrorWithMessage = (e) => {
  return e !== null && typeof e === "object" && "message" in e;
};
const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const toCapitalizedList = (arr) => arr.map(capitalize).join(", ");
const spacesToUnderscore = (str) => str.replace(/\s+/g, "_");
const sumBy = (arr, prop) => arr.reduce((acc, item) => acc + item[prop], 0);
function isNumber(value) {
  return typeof value === "number" && isFinite(value);
}
const haveValue = (val) => val !== void 0 && val !== null;
const formatSentimentDirection = (input) => Array.isArray(input) ? toCapitalizedList(input) : capitalize(input);
const formatCustomBivariateAxisLabel = (customLabel, quotients) => {
  const units = formatBivariateAxisUnit(quotients);
  return units ? `${customLabel} (${units})` : customLabel;
};
const formatBivariateAxisLabel = (quotients) => {
  if (!quotients) return "";
  const [numerator, denominator] = quotients;
  if (!hasUnits(numerator.unit.id)) {
    return `${numerator.label} to ${denominator.label}`;
  }
  if (denominator.name === "one") {
    return `${numerator.label} (${numerator.unit.shortName})`;
  }
  if (!hasUnits(denominator.unit.id)) {
    return `${numerator.label} to ${denominator.label} (${numerator.unit.shortName})`;
  }
  return `${numerator.label} to ${denominator.label} (${numerator.unit.shortName}/${denominator.unit.shortName})`;
};
const formatBivariateAxisUnit = (quotients) => {
  if (!quotients) return null;
  const [numerator, denominator] = quotients;
  if (!hasUnits(numerator.unit.id)) {
    return null;
  }
  if (denominator.name === "one") {
    return numerator.unit.shortName;
  }
  if (!hasUnits(denominator.unit.id)) {
    return numerator.unit.shortName;
  }
  return `${numerator.unit.shortName}/${denominator.unit.shortName}`;
};
const hasUnits = (unitId) => Boolean(unitId && unitId !== "other");
const tooltipRoot = "_tooltipRoot_zjmcz_1";
const tooltipRow = "_tooltipRow_zjmcz_11";
const sentimentDirection = "_sentimentDirection_zjmcz_17";
const sentimentLabel = "_sentimentLabel_zjmcz_21";
const sentimentInfo = "_sentimentInfo_zjmcz_25";
const indicator$1 = "_indicator_zjmcz_29";
const s$7 = {
  tooltipRoot,
  tooltipRow,
  sentimentDirection,
  sentimentLabel,
  sentimentInfo,
  indicator: indicator$1
};
const CornerTooltipWrapper = ({ children, hints }) => {
  const renderTooltip = (e, setTooltip, _cell, i2) => {
    if (hints && CORNER_POINTS_INDEXES.includes(i2)) {
      setTooltip({
        popup: /* @__PURE__ */ jsxRuntimeExports.jsx(BivariateLegendCornerTooltip, { cellIndex: i2, hints }),
        position: { x: e.clientX, y: e.clientY },
        hoverBehavior: true
      });
    }
  };
  return reactExports.isValidElement(children) ? /* @__PURE__ */ jsxRuntimeExports.jsx(PopupTooltipWrapper, { renderTooltip, children: ({ showTooltip, hideTooltip }) => reactExports.cloneElement(children, {
    // @ts-expect-error - react version update should fix that
    onCellPointerOver: showTooltip,
    onCellPointerLeave: hideTooltip
  }) }) : null;
};
const BivariateLegendCornerTooltip = ({
  hints,
  cellIndex
}) => {
  var _a2, _b, _c, _d, _e2, _f;
  if (!hints) return null;
  const rows = [
    {
      label: (_a2 = hints.x) == null ? void 0 : _a2.label,
      direction: (_c = (_b = hints.x) == null ? void 0 : _b.direction) == null ? void 0 : _c[isBottomSide(cellIndex) ? 0 : 1],
      indicator: isBottomSide(cellIndex) ? LOW : HIGH
    },
    {
      label: (_d = hints.y) == null ? void 0 : _d.label,
      direction: (_f = (_e2 = hints.y) == null ? void 0 : _e2.direction) == null ? void 0 : _f[isLeftSide(cellIndex) ? 0 : 1],
      indicator: isLeftSide(cellIndex) ? LOW : HIGH
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: clsx(s$7.tooltipRoot), children: rows.map(({ label, direction, indicator: indicator2 }, i2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clsx(s$7.tooltipRow), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: clsx(s$7.indicator), children: indicator2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: clsx(s$7.sentimentInfo), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: clsx(s$7.sentimentLabel), children: [
        label,
        " "
      ] }),
      direction && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: clsx(s$7.sentimentDirection), children: formatSentimentDirection(direction) })
    ] })
  ] }, i2)) });
};
const meta = {
  hints: {
    x: {
      label: "Average NDVI, JUN 2019",
      direction: [["bad"], ["good"]]
    },
    y: {
      label: "Multi-hazard exposure PDC GRVA",
      direction: [["unimportant"], ["bad", "important"]]
    }
  }
};
const axis = {
  x: {
    label: "Multi-hazard exposure PDC GRVA to 1",
    steps: [
      {
        label: "",
        value: 0
      },
      {
        label: "",
        value: 0.48
      },
      {
        label: "",
        value: 0.62
      },
      {
        label: "",
        value: 1
      }
    ],
    quality: 0.997101882904748,
    quotient: ["mhe_index", "one"]
  },
  y: {
    label: "Average NDVI, JUN 2019 to 1",
    steps: [
      {
        label: "",
        value: -1
      },
      {
        label: "",
        value: 0.3625118070036407
      },
      {
        label: "",
        value: 0.6441754083082613
      },
      {
        label: "",
        value: 1
      }
    ],
    quality: 0.9410965072118505,
    quotient: ["avg_ndvi", "one"]
  }
};
const cells = [
  {
    label: "C1",
    color: "rgba(90,200,127,0.5)"
  },
  {
    label: "C2",
    color: "rgba(179,165,130,0.5)"
  },
  {
    label: "C3",
    color: "rgba(153,153,153,0.5)"
  },
  {
    label: "B1",
    color: "rgba(169,218,122,0.5)"
  },
  {
    label: "B2",
    color: "rgba(195,163,111,0.5)"
  },
  {
    label: "B3",
    color: "rgba(204,103,116,0.5)"
  },
  {
    label: "A1",
    color: "rgba(232,232,157,0.5)"
  },
  {
    label: "A2",
    color: "rgba(216,159,88,0.5)"
  },
  {
    label: "A3",
    color: "rgba(228,26,28,0.5)"
  }
];
function BivariateLegendFixture() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(BrowserRouter, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PopupTooltip, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CornerTooltipWrapper, { meta, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Legend,
      {
        showAxisLabels: true,
        size: BIVARIATE_LEGEND_SIZE,
        axis,
        cells
      }
    ) })
  ] });
}
const fixture4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: BivariateLegendFixture
}, Symbol.toStringTag, { value: "Module" }));
const useIsomorphicEffect = "undefined" != typeof document ? React$1.useLayoutEffect : React$1.useEffect, getComponentDebugName = (type) => {
  var _a2, _b, _c;
  let Component = (_c = (_b = (_a2 = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) == null ? void 0 : _a2.ReactCurrentOwner) == null ? void 0 : _b.current) == null ? void 0 : _c.type, name = (Component == null ? void 0 : Component.displayName) ?? (Component == null ? void 0 : Component.name);
  return name ? `Component.${name}.${type}` : `_${type}`;
};
let batch = (cb) => cb();
const reatomContext = React$1.createContext(null), useCtx = () => {
  let ctx = React$1.useContext(reatomContext);
  return throwReatomError(!ctx, "ctx is not set, you probably forgot to specify the ctx provider"), ctx;
};
const useAction = (fn, deps = [], name) => {
  throwReatomError("function" != typeof fn, 'invalid "fn"'), deps ?? (deps = []);
  let ctx = useCtx();
  deps.push(ctx), isAction$1(fn) && deps.push(fn);
  let ref = React$1.useMemo(() => {
    let theAction = isAction$1(fn) ? fn : action(function() {
      return ref.fn(...[].slice.call(arguments));
    }, getComponentDebugName("useAction"));
    return { fn, cb: function() {
      return batch(() => theAction(ctx, ...[].slice.call(arguments)));
    } };
  }, deps);
  return useIsomorphicEffect(() => {
    ref.fn = fn;
  }), ref.cb;
};
class Hsluv {
  constructor() {
    this.hex = "#000000";
    this.rgb_r = 0;
    this.rgb_g = 0;
    this.rgb_b = 0;
    this.xyz_x = 0;
    this.xyz_y = 0;
    this.xyz_z = 0;
    this.luv_l = 0;
    this.luv_u = 0;
    this.luv_v = 0;
    this.lch_l = 0;
    this.lch_c = 0;
    this.lch_h = 0;
    this.hsluv_h = 0;
    this.hsluv_s = 0;
    this.hsluv_l = 0;
    this.hpluv_h = 0;
    this.hpluv_p = 0;
    this.hpluv_l = 0;
    this.r0s = 0;
    this.r0i = 0;
    this.r1s = 0;
    this.r1i = 0;
    this.g0s = 0;
    this.g0i = 0;
    this.g1s = 0;
    this.g1i = 0;
    this.b0s = 0;
    this.b0i = 0;
    this.b1s = 0;
    this.b1i = 0;
  }
  static fromLinear(c2) {
    if (c2 <= 31308e-7) {
      return 12.92 * c2;
    } else {
      return 1.055 * Math.pow(c2, 1 / 2.4) - 0.055;
    }
  }
  static toLinear(c2) {
    if (c2 > 0.04045) {
      return Math.pow((c2 + 0.055) / 1.055, 2.4);
    } else {
      return c2 / 12.92;
    }
  }
  static yToL(Y2) {
    if (Y2 <= Hsluv.epsilon) {
      return Y2 / Hsluv.refY * Hsluv.kappa;
    } else {
      return 116 * Math.pow(Y2 / Hsluv.refY, 1 / 3) - 16;
    }
  }
  static lToY(L2) {
    if (L2 <= 8) {
      return Hsluv.refY * L2 / Hsluv.kappa;
    } else {
      return Hsluv.refY * Math.pow((L2 + 16) / 116, 3);
    }
  }
  static rgbChannelToHex(chan) {
    const c2 = Math.round(chan * 255);
    const digit2 = c2 % 16;
    const digit1 = (c2 - digit2) / 16 | 0;
    return Hsluv.hexChars.charAt(digit1) + Hsluv.hexChars.charAt(digit2);
  }
  static hexToRgbChannel(hex, offset2) {
    const digit1 = Hsluv.hexChars.indexOf(hex.charAt(offset2));
    const digit2 = Hsluv.hexChars.indexOf(hex.charAt(offset2 + 1));
    const n2 = digit1 * 16 + digit2;
    return n2 / 255;
  }
  static distanceFromOriginAngle(slope, intercept, angle) {
    const d2 = intercept / (Math.sin(angle) - slope * Math.cos(angle));
    if (d2 < 0) {
      return Infinity;
    } else {
      return d2;
    }
  }
  static distanceFromOrigin(slope, intercept) {
    return Math.abs(intercept) / Math.sqrt(Math.pow(slope, 2) + 1);
  }
  static min6(f1, f2, f3, f4, f5, f6) {
    return Math.min(f1, Math.min(f2, Math.min(f3, Math.min(f4, Math.min(f5, f6)))));
  }
  rgbToHex() {
    this.hex = "#";
    this.hex += Hsluv.rgbChannelToHex(this.rgb_r);
    this.hex += Hsluv.rgbChannelToHex(this.rgb_g);
    this.hex += Hsluv.rgbChannelToHex(this.rgb_b);
  }
  hexToRgb() {
    this.hex = this.hex.toLowerCase();
    this.rgb_r = Hsluv.hexToRgbChannel(this.hex, 1);
    this.rgb_g = Hsluv.hexToRgbChannel(this.hex, 3);
    this.rgb_b = Hsluv.hexToRgbChannel(this.hex, 5);
  }
  xyzToRgb() {
    this.rgb_r = Hsluv.fromLinear(Hsluv.m_r0 * this.xyz_x + Hsluv.m_r1 * this.xyz_y + Hsluv.m_r2 * this.xyz_z);
    this.rgb_g = Hsluv.fromLinear(Hsluv.m_g0 * this.xyz_x + Hsluv.m_g1 * this.xyz_y + Hsluv.m_g2 * this.xyz_z);
    this.rgb_b = Hsluv.fromLinear(Hsluv.m_b0 * this.xyz_x + Hsluv.m_b1 * this.xyz_y + Hsluv.m_b2 * this.xyz_z);
  }
  rgbToXyz() {
    const lr = Hsluv.toLinear(this.rgb_r);
    const lg = Hsluv.toLinear(this.rgb_g);
    const lb = Hsluv.toLinear(this.rgb_b);
    this.xyz_x = 0.41239079926595 * lr + 0.35758433938387 * lg + 0.18048078840183 * lb;
    this.xyz_y = 0.21263900587151 * lr + 0.71516867876775 * lg + 0.072192315360733 * lb;
    this.xyz_z = 0.019330818715591 * lr + 0.11919477979462 * lg + 0.95053215224966 * lb;
  }
  xyzToLuv() {
    const divider = this.xyz_x + 15 * this.xyz_y + 3 * this.xyz_z;
    let varU = 4 * this.xyz_x;
    let varV = 9 * this.xyz_y;
    if (divider !== 0) {
      varU /= divider;
      varV /= divider;
    } else {
      varU = NaN;
      varV = NaN;
    }
    this.luv_l = Hsluv.yToL(this.xyz_y);
    if (this.luv_l === 0) {
      this.luv_u = 0;
      this.luv_v = 0;
    } else {
      this.luv_u = 13 * this.luv_l * (varU - Hsluv.refU);
      this.luv_v = 13 * this.luv_l * (varV - Hsluv.refV);
    }
  }
  luvToXyz() {
    if (this.luv_l === 0) {
      this.xyz_x = 0;
      this.xyz_y = 0;
      this.xyz_z = 0;
      return;
    }
    const varU = this.luv_u / (13 * this.luv_l) + Hsluv.refU;
    const varV = this.luv_v / (13 * this.luv_l) + Hsluv.refV;
    this.xyz_y = Hsluv.lToY(this.luv_l);
    this.xyz_x = 0 - 9 * this.xyz_y * varU / ((varU - 4) * varV - varU * varV);
    this.xyz_z = (9 * this.xyz_y - 15 * varV * this.xyz_y - varV * this.xyz_x) / (3 * varV);
  }
  luvToLch() {
    this.lch_l = this.luv_l;
    this.lch_c = Math.sqrt(this.luv_u * this.luv_u + this.luv_v * this.luv_v);
    if (this.lch_c < 1e-8) {
      this.lch_h = 0;
    } else {
      const hrad = Math.atan2(this.luv_v, this.luv_u);
      this.lch_h = hrad * 180 / Math.PI;
      if (this.lch_h < 0) {
        this.lch_h = 360 + this.lch_h;
      }
    }
  }
  lchToLuv() {
    const hrad = this.lch_h / 180 * Math.PI;
    this.luv_l = this.lch_l;
    this.luv_u = Math.cos(hrad) * this.lch_c;
    this.luv_v = Math.sin(hrad) * this.lch_c;
  }
  calculateBoundingLines(l2) {
    const sub1 = Math.pow(l2 + 16, 3) / 1560896;
    const sub2 = sub1 > Hsluv.epsilon ? sub1 : l2 / Hsluv.kappa;
    const s1r = sub2 * (284517 * Hsluv.m_r0 - 94839 * Hsluv.m_r2);
    const s2r = sub2 * (838422 * Hsluv.m_r2 + 769860 * Hsluv.m_r1 + 731718 * Hsluv.m_r0);
    const s3r = sub2 * (632260 * Hsluv.m_r2 - 126452 * Hsluv.m_r1);
    const s1g = sub2 * (284517 * Hsluv.m_g0 - 94839 * Hsluv.m_g2);
    const s2g = sub2 * (838422 * Hsluv.m_g2 + 769860 * Hsluv.m_g1 + 731718 * Hsluv.m_g0);
    const s3g = sub2 * (632260 * Hsluv.m_g2 - 126452 * Hsluv.m_g1);
    const s1b = sub2 * (284517 * Hsluv.m_b0 - 94839 * Hsluv.m_b2);
    const s2b = sub2 * (838422 * Hsluv.m_b2 + 769860 * Hsluv.m_b1 + 731718 * Hsluv.m_b0);
    const s3b = sub2 * (632260 * Hsluv.m_b2 - 126452 * Hsluv.m_b1);
    this.r0s = s1r / s3r;
    this.r0i = s2r * l2 / s3r;
    this.r1s = s1r / (s3r + 126452);
    this.r1i = (s2r - 769860) * l2 / (s3r + 126452);
    this.g0s = s1g / s3g;
    this.g0i = s2g * l2 / s3g;
    this.g1s = s1g / (s3g + 126452);
    this.g1i = (s2g - 769860) * l2 / (s3g + 126452);
    this.b0s = s1b / s3b;
    this.b0i = s2b * l2 / s3b;
    this.b1s = s1b / (s3b + 126452);
    this.b1i = (s2b - 769860) * l2 / (s3b + 126452);
  }
  calcMaxChromaHpluv() {
    const r0 = Hsluv.distanceFromOrigin(this.r0s, this.r0i);
    const r1 = Hsluv.distanceFromOrigin(this.r1s, this.r1i);
    const g0 = Hsluv.distanceFromOrigin(this.g0s, this.g0i);
    const g1 = Hsluv.distanceFromOrigin(this.g1s, this.g1i);
    const b0 = Hsluv.distanceFromOrigin(this.b0s, this.b0i);
    const b1 = Hsluv.distanceFromOrigin(this.b1s, this.b1i);
    return Hsluv.min6(r0, r1, g0, g1, b0, b1);
  }
  calcMaxChromaHsluv(h2) {
    const hueRad = h2 / 360 * Math.PI * 2;
    const r0 = Hsluv.distanceFromOriginAngle(this.r0s, this.r0i, hueRad);
    const r1 = Hsluv.distanceFromOriginAngle(this.r1s, this.r1i, hueRad);
    const g0 = Hsluv.distanceFromOriginAngle(this.g0s, this.g0i, hueRad);
    const g1 = Hsluv.distanceFromOriginAngle(this.g1s, this.g1i, hueRad);
    const b0 = Hsluv.distanceFromOriginAngle(this.b0s, this.b0i, hueRad);
    const b1 = Hsluv.distanceFromOriginAngle(this.b1s, this.b1i, hueRad);
    return Hsluv.min6(r0, r1, g0, g1, b0, b1);
  }
  hsluvToLch() {
    if (this.hsluv_l > 99.9999999) {
      this.lch_l = 100;
      this.lch_c = 0;
    } else if (this.hsluv_l < 1e-8) {
      this.lch_l = 0;
      this.lch_c = 0;
    } else {
      this.lch_l = this.hsluv_l;
      this.calculateBoundingLines(this.hsluv_l);
      const max2 = this.calcMaxChromaHsluv(this.hsluv_h);
      this.lch_c = max2 / 100 * this.hsluv_s;
    }
    this.lch_h = this.hsluv_h;
  }
  lchToHsluv() {
    if (this.lch_l > 99.9999999) {
      this.hsluv_s = 0;
      this.hsluv_l = 100;
    } else if (this.lch_l < 1e-8) {
      this.hsluv_s = 0;
      this.hsluv_l = 0;
    } else {
      this.calculateBoundingLines(this.lch_l);
      const max2 = this.calcMaxChromaHsluv(this.lch_h);
      this.hsluv_s = this.lch_c / max2 * 100;
      this.hsluv_l = this.lch_l;
    }
    this.hsluv_h = this.lch_h;
  }
  hpluvToLch() {
    if (this.hpluv_l > 99.9999999) {
      this.lch_l = 100;
      this.lch_c = 0;
    } else if (this.hpluv_l < 1e-8) {
      this.lch_l = 0;
      this.lch_c = 0;
    } else {
      this.lch_l = this.hpluv_l;
      this.calculateBoundingLines(this.hpluv_l);
      const max2 = this.calcMaxChromaHpluv();
      this.lch_c = max2 / 100 * this.hpluv_p;
    }
    this.lch_h = this.hpluv_h;
  }
  lchToHpluv() {
    if (this.lch_l > 99.9999999) {
      this.hpluv_p = 0;
      this.hpluv_l = 100;
    } else if (this.lch_l < 1e-8) {
      this.hpluv_p = 0;
      this.hpluv_l = 0;
    } else {
      this.calculateBoundingLines(this.lch_l);
      const max2 = this.calcMaxChromaHpluv();
      this.hpluv_p = this.lch_c / max2 * 100;
      this.hpluv_l = this.lch_l;
    }
    this.hpluv_h = this.lch_h;
  }
  hsluvToRgb() {
    this.hsluvToLch();
    this.lchToLuv();
    this.luvToXyz();
    this.xyzToRgb();
  }
  hpluvToRgb() {
    this.hpluvToLch();
    this.lchToLuv();
    this.luvToXyz();
    this.xyzToRgb();
  }
  hsluvToHex() {
    this.hsluvToRgb();
    this.rgbToHex();
  }
  hpluvToHex() {
    this.hpluvToRgb();
    this.rgbToHex();
  }
  rgbToHsluv() {
    this.rgbToXyz();
    this.xyzToLuv();
    this.luvToLch();
    this.lchToHpluv();
    this.lchToHsluv();
  }
  rgbToHpluv() {
    this.rgbToXyz();
    this.xyzToLuv();
    this.luvToLch();
    this.lchToHpluv();
    this.lchToHpluv();
  }
  hexToHsluv() {
    this.hexToRgb();
    this.rgbToHsluv();
  }
  hexToHpluv() {
    this.hexToRgb();
    this.rgbToHpluv();
  }
}
Hsluv.hexChars = "0123456789abcdef";
Hsluv.refY = 1;
Hsluv.refU = 0.19783000664283;
Hsluv.refV = 0.46831999493879;
Hsluv.kappa = 903.2962962;
Hsluv.epsilon = 0.0088564516;
Hsluv.m_r0 = 3.240969941904521;
Hsluv.m_r1 = -1.537383177570093;
Hsluv.m_r2 = -0.498610760293;
Hsluv.m_g0 = -0.96924363628087;
Hsluv.m_g1 = 1.87596750150772;
Hsluv.m_g2 = 0.041555057407175;
Hsluv.m_b0 = 0.055630079696993;
Hsluv.m_b1 = -0.20397695888897;
Hsluv.m_b2 = 1.056971514242878;
function adaptTileUrl(url) {
  const protocolRegexp = /https?:/;
  if (protocolRegexp.test(url)) {
    url = window.location.protocol + url.replace(protocolRegexp, "");
  } else {
    const baseUrl = configRepo.get().bivariateTilesServer ?? `${window.location.protocol}${window.location.host}${configRepo.get().baseUrl}`;
    url = `${baseUrl}${url}`;
  }
  url = url.replace("{bbox}", "{bbox-epsg-3857}").replace("{proj}", "EPSG:3857").replace("{width}", "256").replace("{height}", "256").replace("{zoom}", "{z}").replace("{-y}", "{y}");
  const domains = (url.match(/{switch:(.*?)}/) || ["", ""])[1].split(",")[0];
  url = url.replace(/{switch:(.*?)}/, domains);
  return url;
}
function interpolate360(start, end) {
  return start + (((end - start) % 360 + 540) % 360 - 180) * 0.5;
}
function interpolateLinear(start, end) {
  return (start + end) / 2;
}
function interpolateHsl(start, end) {
  return [
    interpolate360(start[0], end[0]),
    interpolateLinear(start[1], end[1]),
    interpolateLinear(start[2], end[2])
  ];
}
function convertToRgbaWithOpacity(hexColor) {
  if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hexColor)) {
    let clr = hexColor.substring(1).split("");
    if (clr.length === 3) {
      clr = [clr[0], clr[0], clr[1], clr[1], clr[2], clr[2]];
    }
    const hexNum = parseInt(`0x${clr.join("")}`, 0);
    return `rgba(${[hexNum >> 16 & 255, hexNum >> 8 & 255, hexNum & 255].join(
      ","
    )},0.5)`;
  }
  throw new Error("Bad Hex");
}
function findColors(colors, crn) {
  const corner1 = (Array.isArray(crn[0]) ? [...crn[0]] : [crn[0]]).sort();
  const corner2 = (Array.isArray(crn[1]) ? [...crn[1]] : [crn[1]]).sort();
  const mergedCorner = Array.from(new Set(corner1.concat(corner2)));
  const combination = colors.combinations.find(({ corner: corner3 }) => {
    if (mergedCorner.length !== corner3.length) return false;
    for (let i2 = 0; i2 < mergedCorner.length; i2 += 1) {
      if (mergedCorner[i2] !== corner3[i2]) {
        return false;
      }
    }
    return true;
  });
  return (combination == null ? void 0 : combination.color) ? { color: combination.color } : { color: colors.fallback, isFallbackColor: true };
}
function generateColorThemeAndBivariateStyle(xNumerator, xDenominator, yNumerator, yDenominator, stats, sourceLayer) {
  var _a2, _b;
  const { indicators, colors, axis: axis2 } = stats;
  const xAxis = axis2.find(
    (ax) => ax.quotient[0] === xNumerator && ax.quotient[1] === xDenominator
  );
  const yAxis = axis2.find(
    (ax) => ax.quotient[0] === yNumerator && ax.quotient[1] === yDenominator
  );
  if (!xAxis || !yAxis) return;
  const xAxisDirection = (_a2 = indicators.find((ind) => ind.name === xNumerator)) == null ? void 0 : _a2.direction;
  const yAxisDirection = (_b = indicators.find((ind) => ind.name === yNumerator)) == null ? void 0 : _b.direction;
  if (!xAxisDirection || !yAxisDirection) return;
  const colorTheme = generateColorTheme(
    colors,
    xAxisDirection,
    yAxisDirection
  );
  const bivariateStyle = generateBivariateStyle(
    xAxis,
    yAxis,
    colorTheme,
    stats == null ? void 0 : stats.meta,
    sourceLayer
  );
  return [colorTheme, bivariateStyle];
}
const generateBivariateStyle = (xAxis, yAxis, colorTheme, meta2, sourceLayer) => generateBivariateStyleForAxis({
  id: `${xAxis.quotient.join("&")}|${yAxis.quotient.join("&")}`,
  x: xAxis,
  y: yAxis,
  colors: colorTheme,
  sourceLayer,
  source: {
    type: "vector",
    tiles: [
      `${adaptTileUrl(
        configRepo.get().bivariateTilesRelativeUrl
      )}{z}/{x}/{y}.mvt?indicatorsClass=${configRepo.get().bivariateTilesIndicatorsClass}`
    ],
    maxzoom: meta2.max_zoom,
    minzoom: 0
  }
});
const generateColorTheme = (colors, xAxisDirection, yAxisDirection) => {
  const conv = new Hsluv();
  const corner00 = findColors(colors, [xAxisDirection[0], yAxisDirection[0]]);
  const corner01 = findColors(colors, [xAxisDirection[0], yAxisDirection[1]]);
  const corner10 = findColors(colors, [xAxisDirection[1], yAxisDirection[0]]);
  const corner11 = findColors(colors, [xAxisDirection[1], yAxisDirection[1]]);
  const cornerHsl = [corner00, corner01, corner10, corner11].map((c2) => {
    conv.hex = c2.color;
    conv.hexToHsluv();
    return [conv.hsluv_h, conv.hsluv_s, conv.hsluv_l];
  });
  const midLeftHsl = interpolateHsl(cornerHsl[0], cornerHsl[1]);
  const midBottomHsl = interpolateHsl(cornerHsl[0], cornerHsl[2]);
  const midTopHsl = interpolateHsl(cornerHsl[1], cornerHsl[3]);
  const midRightHsl = interpolateHsl(cornerHsl[2], cornerHsl[3]);
  const midMidHsl = interpolateHsl(midBottomHsl, midTopHsl);
  const [A2, B1, B2, B3, C2] = [
    midLeftHsl,
    midBottomHsl,
    midMidHsl,
    midTopHsl,
    midRightHsl
  ].map(([h2, s2, l2]) => {
    conv.hsluv_h = h2;
    conv.hsluv_s = s2;
    conv.hsluv_l = l2;
    conv.hsluvToHex();
    return convertToRgbaWithOpacity(conv.hex);
  });
  const colorTheme = [
    {
      id: "A1",
      color: convertToRgbaWithOpacity(corner00.color),
      isFallbackColor: corner00.isFallbackColor
    },
    { id: "A2", color: A2 },
    {
      id: "A3",
      color: convertToRgbaWithOpacity(corner01.color),
      isFallbackColor: corner01.isFallbackColor
    },
    { id: "B1", color: B1 },
    { id: "B2", color: B2 },
    { id: "B3", color: B3 },
    {
      id: "C1",
      color: convertToRgbaWithOpacity(corner10.color),
      isFallbackColor: corner10.isFallbackColor
    },
    { id: "C2", color: C2 },
    {
      id: "C3",
      color: convertToRgbaWithOpacity(corner11.color),
      isFallbackColor: corner11.isFallbackColor
    }
  ];
  return colorTheme;
};
function generateLayerStyleFromBivariateLegend(bl, sourceLayer) {
  return generateBivariateStyleForAxis({
    id: `${bl.axis.x.quotient.join("&")}|${bl.axis.y.quotient.join("&")}`,
    x: bl.axis.x,
    y: bl.axis.y,
    colors: [...bl.steps].sort((stp1, stp2) => stp1.label > stp2.label ? 1 : -1).map((stp) => ({ id: stp.label, color: stp.color })),
    sourceLayer
  });
}
function createBivariateLegend(name, colorTheme, xNumerator, xDenominator, yNumerator, yDenominator, stats) {
  const xAxis = stats.axis.find(
    (ax) => ax.quotient[0] === xNumerator && ax.quotient[1] === xDenominator
  );
  const yAxis = stats.axis.find(
    (ax) => ax.quotient[0] === yNumerator && ax.quotient[1] === yDenominator
  );
  if (!xAxis || !yAxis) return;
  return fillBivariateLegend(name, xAxis, yAxis, colorTheme);
}
const fillBivariateLegend = (name, xAxis, yAxis, colorTheme) => ({
  name,
  axis: { x: xAxis, y: yAxis },
  type: "bivariate",
  steps: colorTheme.map(({ id, color, isFallbackColor }) => ({
    label: id,
    color,
    isFallbackColor
  }))
});
function createBivariateMeta(xNumerator, xDenominator, yNumerator, yDenominator, stats) {
  var _a2, _b, _c, _d;
  const xAxisNumeratorIndicator = stats.indicators.find((ind) => ind.name === xNumerator);
  const yAxisNumeratorIndicator = stats.indicators.find((ind) => ind.name === yNumerator);
  const xNumeratorLabel = xAxisNumeratorIndicator == null ? void 0 : xAxisNumeratorIndicator.label;
  const yNumeratorLabel = yAxisNumeratorIndicator == null ? void 0 : yAxisNumeratorIndicator.label;
  const xDenominatorLabel = (_a2 = stats.indicators.find(
    (ind) => ind.name === xDenominator
  )) == null ? void 0 : _a2.label;
  const yDenominatorLabel = (_b = stats.indicators.find(
    (ind) => ind.name === yDenominator
  )) == null ? void 0 : _b.label;
  let copyrights = [];
  if ((_c = xAxisNumeratorIndicator == null ? void 0 : xAxisNumeratorIndicator.copyrights) == null ? void 0 : _c.length) {
    copyrights = copyrights.concat(xAxisNumeratorIndicator.copyrights);
  }
  if ((_d = yAxisNumeratorIndicator == null ? void 0 : yAxisNumeratorIndicator.copyrights) == null ? void 0 : _d.length) {
    copyrights = copyrights.concat(yAxisNumeratorIndicator.copyrights);
  }
  const description = `This map shows relation of ${xNumeratorLabel} (normalized by ${xDenominatorLabel}) to the base of ${yNumeratorLabel} (normalized by ${yDenominatorLabel}).`;
  return {
    description,
    copyrights,
    hints: {
      x: {
        label: xNumeratorLabel,
        direction: xAxisNumeratorIndicator == null ? void 0 : xAxisNumeratorIndicator.direction
      },
      y: {
        label: yNumeratorLabel,
        direction: yAxisNumeratorIndicator == null ? void 0 : yAxisNumeratorIndicator.direction
      }
    }
  };
}
const fitsLegendCriteria = (step, index2, totalSteps, targetValue) => index2 !== 0 && targetValue < step.value || index2 === totalSteps - 1 && targetValue <= step.value;
function getCellLabelByValue(xSteps, ySteps, xValue, yValue) {
  const charIndex = xSteps.findIndex(
    (xStep, i2, arr) => fitsLegendCriteria(xStep, i2, arr.length, xValue)
  );
  const char = getCharByIndex(charIndex);
  const number = ySteps.findIndex(
    (yStep, i2, arr) => fitsLegendCriteria(yStep, i2, arr.length, yValue)
  );
  return char + number;
}
const layersLegendsAtom = createMapAtom(
  /* @__PURE__ */ new Map(),
  "layersLegends"
);
const layersSourcesAtom = createMapAtom(
  /* @__PURE__ */ new Map(),
  "layersSources"
);
const layersMetaAtom = createMapAtom(
  /* @__PURE__ */ new Map(),
  "layersMeta"
);
const layersSettingsAtom$1 = createMapAtom(
  /* @__PURE__ */ new Map(),
  "layersSettings"
);
const layersMenusAtom = createMapAtom(
  /* @__PURE__ */ new Map(),
  "layersMenus"
);
const createBatchedUpdateMap = () => ({
  legend: [],
  source: [],
  meta: [],
  settings: [],
  menu: []
});
const wrapInAsyncState = ([id, data]) => [
  id,
  { data, isLoading: false, error: null }
];
function createUpdateLayerActions(updates) {
  const batchedUpdates = updates.reduce((acc, { id, ...update }) => {
    Object.keys(update).forEach((key) => {
      acc[key].push([id, update[key]]);
    });
    return acc;
  }, createBatchedUpdateMap());
  const updateActions = [];
  const cleanupActions = [];
  if (batchedUpdates.legend.length) {
    const update = batchedUpdates.legend.map(wrapInAsyncState);
    updateActions.push(
      layersLegendsAtom.change((state) => {
        return new Map([...state, ...update]);
      })
    );
  }
  if (batchedUpdates.source.length) {
    const update = batchedUpdates.source.map(wrapInAsyncState);
    updateActions.push(
      layersSourcesAtom.change((state) => {
        return new Map([...state, ...update]);
      })
    );
  }
  if (batchedUpdates.meta.length) {
    const update = batchedUpdates.meta.map(wrapInAsyncState);
    updateActions.push(
      layersMetaAtom.change((state) => {
        return new Map([...state, ...update]);
      })
    );
  }
  if (batchedUpdates.settings.length) {
    const update = batchedUpdates.settings.map(wrapInAsyncState);
    updateActions.push(
      layersSettingsAtom$1.change((state) => {
        return new Map([...state, ...update]);
      })
    );
  }
  if (batchedUpdates.menu.length) {
    const update = batchedUpdates.menu;
    updateActions.push(
      layersMenusAtom.change((state) => {
        return new Map([...state, ...update]);
      })
    );
  }
  return [updateActions, cleanupActions];
}
var maplibreGl = { exports: {} };
(function(module, exports) {
  (function(global2, factory2) {
    module.exports = factory2();
  })(commonjsGlobal, function() {
    var shared, worker, maplibregl;
    function define(_2, chunk) {
      if (!shared) {
        shared = chunk;
      } else if (!worker) {
        worker = chunk;
      } else {
        var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
        var sharedChunk = {};
        shared(sharedChunk);
        maplibregl = chunk(sharedChunk);
        if (typeof window !== "undefined") {
          maplibregl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
        }
      }
    }
    define(["exports"], function(t2) {
      function e(t3, e2, r3, n3) {
        return new (r3 || (r3 = Promise))(function(i3, a3) {
          function s3(t4) {
            try {
              l3(n3.next(t4));
            } catch (t5) {
              a3(t5);
            }
          }
          function o3(t4) {
            try {
              l3(n3.throw(t4));
            } catch (t5) {
              a3(t5);
            }
          }
          function l3(t4) {
            var e3;
            t4.done ? i3(t4.value) : (e3 = t4.value, e3 instanceof r3 ? e3 : new r3(function(t5) {
              t5(e3);
            })).then(s3, o3);
          }
          l3((n3 = n3.apply(t3, e2 || [])).next());
        });
      }
      function r2(t3) {
        return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
      }
      "function" == typeof SuppressedError && SuppressedError;
      var n2 = i2;
      function i2(t3, e2) {
        this.x = t3, this.y = e2;
      }
      i2.prototype = { clone: function() {
        return new i2(this.x, this.y);
      }, add: function(t3) {
        return this.clone()._add(t3);
      }, sub: function(t3) {
        return this.clone()._sub(t3);
      }, multByPoint: function(t3) {
        return this.clone()._multByPoint(t3);
      }, divByPoint: function(t3) {
        return this.clone()._divByPoint(t3);
      }, mult: function(t3) {
        return this.clone()._mult(t3);
      }, div: function(t3) {
        return this.clone()._div(t3);
      }, rotate: function(t3) {
        return this.clone()._rotate(t3);
      }, rotateAround: function(t3, e2) {
        return this.clone()._rotateAround(t3, e2);
      }, matMult: function(t3) {
        return this.clone()._matMult(t3);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(t3) {
        return this.x === t3.x && this.y === t3.y;
      }, dist: function(t3) {
        return Math.sqrt(this.distSqr(t3));
      }, distSqr: function(t3) {
        var e2 = t3.x - this.x, r3 = t3.y - this.y;
        return e2 * e2 + r3 * r3;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(t3) {
        return Math.atan2(this.y - t3.y, this.x - t3.x);
      }, angleWith: function(t3) {
        return this.angleWithSep(t3.x, t3.y);
      }, angleWithSep: function(t3, e2) {
        return Math.atan2(this.x * e2 - this.y * t3, this.x * t3 + this.y * e2);
      }, _matMult: function(t3) {
        var e2 = t3[2] * this.x + t3[3] * this.y;
        return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e2, this;
      }, _add: function(t3) {
        return this.x += t3.x, this.y += t3.y, this;
      }, _sub: function(t3) {
        return this.x -= t3.x, this.y -= t3.y, this;
      }, _mult: function(t3) {
        return this.x *= t3, this.y *= t3, this;
      }, _div: function(t3) {
        return this.x /= t3, this.y /= t3, this;
      }, _multByPoint: function(t3) {
        return this.x *= t3.x, this.y *= t3.y, this;
      }, _divByPoint: function(t3) {
        return this.x /= t3.x, this.y /= t3.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var t3 = this.y;
        return this.y = this.x, this.x = -t3, this;
      }, _rotate: function(t3) {
        var e2 = Math.cos(t3), r3 = Math.sin(t3), n3 = r3 * this.x + e2 * this.y;
        return this.x = e2 * this.x - r3 * this.y, this.y = n3, this;
      }, _rotateAround: function(t3, e2) {
        var r3 = Math.cos(t3), n3 = Math.sin(t3), i3 = e2.y + n3 * (this.x - e2.x) + r3 * (this.y - e2.y);
        return this.x = e2.x + r3 * (this.x - e2.x) - n3 * (this.y - e2.y), this.y = i3, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, i2.convert = function(t3) {
        return t3 instanceof i2 ? t3 : Array.isArray(t3) ? new i2(t3[0], t3[1]) : t3;
      };
      var a2 = r2(n2), s2 = o2;
      function o2(t3, e2, r3, n3) {
        this.cx = 3 * t3, this.bx = 3 * (r3 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n3 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e2, this.p2x = r3, this.p2y = n3;
      }
      o2.prototype = { sampleCurveX: function(t3) {
        return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
      }, sampleCurveY: function(t3) {
        return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
      }, sampleCurveDerivativeX: function(t3) {
        return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
      }, solveCurveX: function(t3, e2) {
        if (void 0 === e2 && (e2 = 1e-6), t3 < 0) return 0;
        if (t3 > 1) return 1;
        for (var r3 = t3, n3 = 0; n3 < 8; n3++) {
          var i3 = this.sampleCurveX(r3) - t3;
          if (Math.abs(i3) < e2) return r3;
          var a3 = this.sampleCurveDerivativeX(r3);
          if (Math.abs(a3) < 1e-6) break;
          r3 -= i3 / a3;
        }
        var s3 = 0, o3 = 1;
        for (r3 = t3, n3 = 0; n3 < 20 && (i3 = this.sampleCurveX(r3), !(Math.abs(i3 - t3) < e2)); n3++) t3 > i3 ? s3 = r3 : o3 = r3, r3 = 0.5 * (o3 - s3) + s3;
        return r3;
      }, solve: function(t3, e2) {
        return this.sampleCurveY(this.solveCurveX(t3, e2));
      } };
      var l2 = r2(s2);
      let u2, c2;
      function h2() {
        return null == u2 && (u2 = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), u2;
      }
      function p2() {
        if (null == c2 && (c2 = false, h2())) {
          const t3 = 5, e2 = new OffscreenCanvas(t3, t3).getContext("2d", { willReadFrequently: true });
          if (e2) {
            for (let r4 = 0; r4 < t3 * t3; r4++) {
              const n3 = 4 * r4;
              e2.fillStyle = `rgb(${n3},${n3 + 1},${n3 + 2})`, e2.fillRect(r4 % t3, Math.floor(r4 / t3), 1, 1);
            }
            const r3 = e2.getImageData(0, 0, t3, t3).data;
            for (let e3 = 0; e3 < t3 * t3 * 4; e3++) if (e3 % 4 != 3 && r3[e3] !== e3) {
              c2 = true;
              break;
            }
          }
        }
        return c2 || false;
      }
      function f2(t3, e2, r3, n3) {
        const i3 = new l2(t3, e2, r3, n3);
        return function(t4) {
          return i3.solve(t4);
        };
      }
      const d2 = f2(0.25, 0.1, 0.25, 1);
      function y2(t3, e2, r3) {
        return Math.min(r3, Math.max(e2, t3));
      }
      function m2(t3, e2, r3) {
        const n3 = r3 - e2, i3 = ((t3 - e2) % n3 + n3) % n3 + e2;
        return i3 === e2 ? r3 : i3;
      }
      function g2(t3, ...e2) {
        for (const r3 of e2) for (const e3 in r3) t3[e3] = r3[e3];
        return t3;
      }
      let x2 = 1;
      function v2(t3, e2, r3) {
        const n3 = {};
        for (const i3 in t3) n3[i3] = e2.call(r3 || this, t3[i3], i3, t3);
        return n3;
      }
      function b2(t3, e2, r3) {
        const n3 = {};
        for (const i3 in t3) e2.call(r3 || this, t3[i3], i3, t3) && (n3[i3] = t3[i3]);
        return n3;
      }
      function w2(t3) {
        return Array.isArray(t3) ? t3.map(w2) : "object" == typeof t3 && t3 ? v2(t3, w2) : t3;
      }
      const _2 = {};
      function A2(t3) {
        _2[t3] || ("undefined" != typeof console && console.warn(t3), _2[t3] = true);
      }
      function S2(t3, e2, r3) {
        return (r3.y - t3.y) * (e2.x - t3.x) > (e2.y - t3.y) * (r3.x - t3.x);
      }
      function k2(t3) {
        let e2 = 0;
        for (let r3, n3, i3 = 0, a3 = t3.length, s3 = a3 - 1; i3 < a3; s3 = i3++) r3 = t3[i3], n3 = t3[s3], e2 += (n3.x - r3.x) * (r3.y + n3.y);
        return e2;
      }
      function I2() {
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
      }
      let z2 = null;
      function M2(t3) {
        return "undefined" != typeof ImageBitmap && t3 instanceof ImageBitmap;
      }
      const C2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function B2(t3, r3, n3, i3, a3) {
        return e(this, void 0, void 0, function* () {
          if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported");
          const e2 = new VideoFrame(t3, { timestamp: 0 });
          try {
            const s3 = null == e2 ? void 0 : e2.format;
            if (!s3 || !s3.startsWith("BGR") && !s3.startsWith("RGB")) throw new Error(`Unrecognized format ${s3}`);
            const o3 = s3.startsWith("BGR"), l3 = new Uint8ClampedArray(i3 * a3 * 4);
            if (yield e2.copyTo(l3, function(t4, e3, r4, n4, i4) {
              const a4 = 4 * Math.max(-e3, 0), s4 = (Math.max(0, r4) - r4) * n4 * 4 + a4, o4 = 4 * n4, l4 = Math.max(0, e3), u3 = Math.max(0, r4);
              return { rect: { x: l4, y: u3, width: Math.min(t4.width, e3 + n4) - l4, height: Math.min(t4.height, r4 + i4) - u3 }, layout: [{ offset: s4, stride: o4 }] };
            }(t3, r3, n3, i3, a3)), o3) for (let t4 = 0; t4 < l3.length; t4 += 4) {
              const e3 = l3[t4];
              l3[t4] = l3[t4 + 2], l3[t4 + 2] = e3;
            }
            return l3;
          } finally {
            e2.close();
          }
        });
      }
      let P2, V2, E2, F2;
      const T2 = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(t3) {
        const e2 = requestAnimationFrame(t3);
        return { cancel: () => cancelAnimationFrame(e2) };
      }, getImageData(t3, e2 = 0) {
        return this.getImageCanvasContext(t3).getImageData(-e2, -e2, t3.width + 2 * e2, t3.height + 2 * e2);
      }, getImageCanvasContext(t3) {
        const e2 = window.document.createElement("canvas"), r3 = e2.getContext("2d", { willReadFrequently: true });
        if (!r3) throw new Error("failed to create canvas 2d context");
        return e2.width = t3.width, e2.height = t3.height, r3.drawImage(t3, 0, 0, t3.width, t3.height), r3;
      }, resolveURL: (t3) => (E2 || (E2 = document.createElement("a")), E2.href = t3, E2.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (null == F2 && (F2 = matchMedia("(prefers-reduced-motion: reduce)")), F2.matches);
      } }, $2 = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
      class L2 extends Error {
        constructor(t3, e2, r3, n3) {
          super(`AJAXError: ${e2} (${t3}): ${r3}`), this.status = t3, this.statusText = e2, this.url = r3, this.body = n3;
        }
      }
      const D2 = I2() ? () => self.worker && self.worker.referrer : () => ("blob:" === window.location.protocol ? window.parent : window).location.href, O2 = (t3) => $2.REGISTERED_PROTOCOLS[t3.substring(0, t3.indexOf("://"))];
      function U2(t3, e2) {
        const r3 = new AbortController(), n3 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, cache: t3.cache, referrer: D2(), signal: r3.signal });
        let i3 = false, a3 = false;
        "json" === t3.type && n3.headers.set("Accept", "application/json");
        return a3 || fetch(n3).then((r4) => r4.ok ? ((r5) => {
          ("arrayBuffer" === t3.type || "image" === t3.type ? r5.arrayBuffer() : "json" === t3.type ? r5.json() : r5.text()).then((t4) => {
            a3 || (i3 = true, e2(null, t4, r5.headers.get("Cache-Control"), r5.headers.get("Expires")));
          }).catch((t4) => {
            a3 || e2(new Error(t4.message));
          });
        })(r4) : r4.blob().then((n4) => e2(new L2(r4.status, r4.statusText, t3.url, n4)))).catch((t4) => {
          20 !== t4.code && e2(new Error(t4.message));
        }), { cancel: () => {
          a3 = true, i3 || r3.abort();
        } };
      }
      const R2 = function(t3, e2) {
        if (/:\/\//.test(t3.url) && !/^https?:|^file:/.test(t3.url)) {
          if (I2() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t3, e2);
          if (!I2()) return (O2(t3.url) || U2)(t3, e2);
        }
        if (!(/^file:/.test(r3 = t3.url) || /^file:/.test(D2()) && !/^\w+:/.test(r3))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return U2(t3, e2);
          if (I2() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t3, e2, void 0, true);
        }
        var r3;
        return function(t4, e3) {
          const r4 = new XMLHttpRequest();
          r4.open(t4.method || "GET", t4.url, true), "arrayBuffer" !== t4.type && "image" !== t4.type || (r4.responseType = "arraybuffer");
          for (const e4 in t4.headers) r4.setRequestHeader(e4, t4.headers[e4]);
          return "json" === t4.type && (r4.responseType = "text", r4.setRequestHeader("Accept", "application/json")), r4.withCredentials = "include" === t4.credentials, r4.onerror = () => {
            e3(new Error(r4.statusText));
          }, r4.onload = () => {
            if ((r4.status >= 200 && r4.status < 300 || 0 === r4.status) && null !== r4.response) {
              let n3 = r4.response;
              if ("json" === t4.type) try {
                n3 = JSON.parse(r4.response);
              } catch (t5) {
                return e3(t5);
              }
              e3(null, n3, r4.getResponseHeader("Cache-Control"), r4.getResponseHeader("Expires"));
            } else {
              const n3 = new Blob([r4.response], { type: r4.getResponseHeader("Content-Type") });
              e3(new L2(r4.status, r4.statusText, t4.url, n3));
            }
          }, r4.send(t4.body), { cancel: () => r4.abort() };
        }(t3, e2);
      }, q2 = function(t3, e2) {
        return R2(g2(t3, { type: "arrayBuffer" }), e2);
      };
      function j2(t3) {
        if (!t3 || t3.indexOf("://") <= 0 || 0 === t3.indexOf("data:image/") || 0 === t3.indexOf("blob:")) return true;
        const e2 = new URL(t3), r3 = window.location;
        return e2.protocol === r3.protocol && e2.host === r3.host;
      }
      function N2(t3, e2, r3) {
        r3[t3] && -1 !== r3[t3].indexOf(e2) || (r3[t3] = r3[t3] || [], r3[t3].push(e2));
      }
      function Z2(t3, e2, r3) {
        if (r3 && r3[t3]) {
          const n3 = r3[t3].indexOf(e2);
          -1 !== n3 && r3[t3].splice(n3, 1);
        }
      }
      class K2 {
        constructor(t3, e2 = {}) {
          g2(this, e2), this.type = t3;
        }
      }
      class G2 extends K2 {
        constructor(t3, e2 = {}) {
          super("error", g2({ error: t3 }, e2));
        }
      }
      class J2 {
        on(t3, e2) {
          return this._listeners = this._listeners || {}, N2(t3, e2, this._listeners), this;
        }
        off(t3, e2) {
          return Z2(t3, e2, this._listeners), Z2(t3, e2, this._oneTimeListeners), this;
        }
        once(t3, e2) {
          return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, N2(t3, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t3, e3));
        }
        fire(t3, e2) {
          "string" == typeof t3 && (t3 = new K2(t3, e2 || {}));
          const r3 = t3.type;
          if (this.listens(r3)) {
            t3.target = this;
            const e3 = this._listeners && this._listeners[r3] ? this._listeners[r3].slice() : [];
            for (const r4 of e3) r4.call(this, t3);
            const n3 = this._oneTimeListeners && this._oneTimeListeners[r3] ? this._oneTimeListeners[r3].slice() : [];
            for (const e4 of n3) Z2(r3, e4, this._oneTimeListeners), e4.call(this, t3);
            const i3 = this._eventedParent;
            i3 && (g2(t3, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i3.fire(t3));
          } else t3 instanceof G2 && console.error(t3.error);
          return this;
        }
        listens(t3) {
          return this._listeners && this._listeners[t3] && this._listeners[t3].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t3] && this._oneTimeListeners[t3].length > 0 || this._eventedParent && this._eventedParent.listens(t3);
        }
        setEventedParent(t3, e2) {
          return this._eventedParent = t3, this._eventedParentData = e2, this;
        }
      }
      var X2 = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      const Y2 = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function H2(t3, e2) {
        const r3 = {};
        for (const e3 in t3) "ref" !== e3 && (r3[e3] = t3[e3]);
        return Y2.forEach((t4) => {
          t4 in e2 && (r3[t4] = e2[t4]);
        }), r3;
      }
      function W2(t3, e2) {
        if (Array.isArray(t3)) {
          if (!Array.isArray(e2) || t3.length !== e2.length) return false;
          for (let r3 = 0; r3 < t3.length; r3++) if (!W2(t3[r3], e2[r3])) return false;
          return true;
        }
        if ("object" == typeof t3 && null !== t3 && null !== e2) {
          if ("object" != typeof e2) return false;
          if (Object.keys(t3).length !== Object.keys(e2).length) return false;
          for (const r3 in t3) if (!W2(t3[r3], e2[r3])) return false;
          return true;
        }
        return t3 === e2;
      }
      const Q2 = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
      function tt(t3, e2, r3) {
        r3.push({ command: Q2.addSource, args: [t3, e2[t3]] });
      }
      function et(t3, e2, r3) {
        e2.push({ command: Q2.removeSource, args: [t3] }), r3[t3] = true;
      }
      function rt(t3, e2, r3, n3) {
        et(t3, r3, n3), tt(t3, e2, r3);
      }
      function nt(t3, e2, r3) {
        let n3;
        for (n3 in t3[r3]) if (Object.prototype.hasOwnProperty.call(t3[r3], n3) && "data" !== n3 && !W2(t3[r3][n3], e2[r3][n3])) return false;
        for (n3 in e2[r3]) if (Object.prototype.hasOwnProperty.call(e2[r3], n3) && "data" !== n3 && !W2(t3[r3][n3], e2[r3][n3])) return false;
        return true;
      }
      function it(t3, e2, r3, n3, i3, a3) {
        let s3;
        for (s3 in e2 = e2 || {}, t3 = t3 || {}) Object.prototype.hasOwnProperty.call(t3, s3) && (W2(t3[s3], e2[s3]) || r3.push({ command: a3, args: [n3, s3, e2[s3], i3] }));
        for (s3 in e2) Object.prototype.hasOwnProperty.call(e2, s3) && !Object.prototype.hasOwnProperty.call(t3, s3) && (W2(t3[s3], e2[s3]) || r3.push({ command: a3, args: [n3, s3, e2[s3], i3] }));
      }
      function at(t3) {
        return t3.id;
      }
      function st(t3, e2) {
        return t3[e2.id] = e2, t3;
      }
      class ot {
        constructor(t3, e2, r3, n3) {
          this.message = (t3 ? `${t3}: ` : "") + r3, n3 && (this.identifier = n3), null != e2 && e2.__line__ && (this.line = e2.__line__);
        }
      }
      function lt(t3, ...e2) {
        for (const r3 of e2) for (const e3 in r3) t3[e3] = r3[e3];
        return t3;
      }
      class ut extends Error {
        constructor(t3, e2) {
          super(e2), this.message = e2, this.key = t3;
        }
      }
      class ct {
        constructor(t3, e2 = []) {
          this.parent = t3, this.bindings = {};
          for (const [t4, r3] of e2) this.bindings[t4] = r3;
        }
        concat(t3) {
          return new ct(this, t3);
        }
        get(t3) {
          if (this.bindings[t3]) return this.bindings[t3];
          if (this.parent) return this.parent.get(t3);
          throw new Error(`${t3} not found in scope.`);
        }
        has(t3) {
          return !!this.bindings[t3] || !!this.parent && this.parent.has(t3);
        }
      }
      const ht = { kind: "null" }, pt = { kind: "number" }, ft = { kind: "string" }, dt = { kind: "boolean" }, yt = { kind: "color" }, mt = { kind: "object" }, gt = { kind: "value" }, xt = { kind: "collator" }, vt = { kind: "formatted" }, bt = { kind: "padding" }, wt = { kind: "resolvedImage" }, _t = { kind: "variableAnchorOffsetCollection" };
      function At(t3, e2) {
        return { kind: "array", itemType: t3, N: e2 };
      }
      function St(t3) {
        if ("array" === t3.kind) {
          const e2 = St(t3.itemType);
          return "number" == typeof t3.N ? `array<${e2}, ${t3.N}>` : "value" === t3.itemType.kind ? "array" : `array<${e2}>`;
        }
        return t3.kind;
      }
      const kt = [ht, pt, ft, dt, yt, vt, mt, At(gt), bt, wt, _t];
      function It(t3, e2) {
        if ("error" === e2.kind) return null;
        if ("array" === t3.kind) {
          if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !It(t3.itemType, e2.itemType)) && ("number" != typeof t3.N || t3.N === e2.N)) return null;
        } else {
          if (t3.kind === e2.kind) return null;
          if ("value" === t3.kind) {
            for (const t4 of kt) if (!It(t4, e2)) return null;
          }
        }
        return `Expected ${St(t3)} but found ${St(e2)} instead.`;
      }
      function zt(t3, e2) {
        return e2.some((e3) => e3.kind === t3.kind);
      }
      function Mt(t3, e2) {
        return e2.some((e3) => "null" === e3 ? null === t3 : "array" === e3 ? Array.isArray(t3) : "object" === e3 ? t3 && !Array.isArray(t3) && "object" == typeof t3 : e3 === typeof t3);
      }
      function Ct(t3, e2) {
        return "array" === t3.kind && "array" === e2.kind ? t3.itemType.kind === e2.itemType.kind && "number" == typeof t3.N : t3.kind === e2.kind;
      }
      const Bt = 0.96422, Pt = 0.82521, Vt = 4 / 29, Et = 6 / 29, Ft = 3 * Et * Et, Tt = Et * Et * Et, $t = Math.PI / 180, Lt = 180 / Math.PI;
      function Dt(t3) {
        return (t3 %= 360) < 0 && (t3 += 360), t3;
      }
      function Ot([t3, e2, r3, n3]) {
        let i3, a3;
        const s3 = Rt((0.2225045 * (t3 = Ut(t3)) + 0.7168786 * (e2 = Ut(e2)) + 0.0606169 * (r3 = Ut(r3))) / 1);
        t3 === e2 && e2 === r3 ? i3 = a3 = s3 : (i3 = Rt((0.4360747 * t3 + 0.3850649 * e2 + 0.1430804 * r3) / Bt), a3 = Rt((0.0139322 * t3 + 0.0971045 * e2 + 0.7141733 * r3) / Pt));
        const o3 = 116 * s3 - 16;
        return [o3 < 0 ? 0 : o3, 500 * (i3 - s3), 200 * (s3 - a3), n3];
      }
      function Ut(t3) {
        return t3 <= 0.04045 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
      }
      function Rt(t3) {
        return t3 > Tt ? Math.pow(t3, 1 / 3) : t3 / Ft + Vt;
      }
      function qt([t3, e2, r3, n3]) {
        let i3 = (t3 + 16) / 116, a3 = isNaN(e2) ? i3 : i3 + e2 / 500, s3 = isNaN(r3) ? i3 : i3 - r3 / 200;
        return i3 = 1 * Nt(i3), a3 = Bt * Nt(a3), s3 = Pt * Nt(s3), [jt(3.1338561 * a3 - 1.6168667 * i3 - 0.4906146 * s3), jt(-0.9787684 * a3 + 1.9161415 * i3 + 0.033454 * s3), jt(0.0719453 * a3 - 0.2289914 * i3 + 1.4052427 * s3), n3];
      }
      function jt(t3) {
        return (t3 = t3 <= 304e-5 ? 12.92 * t3 : 1.055 * Math.pow(t3, 1 / 2.4) - 0.055) < 0 ? 0 : t3 > 1 ? 1 : t3;
      }
      function Nt(t3) {
        return t3 > Et ? t3 * t3 * t3 : Ft * (t3 - Vt);
      }
      function Zt(t3) {
        return parseInt(t3.padEnd(2, t3), 16) / 255;
      }
      function Kt(t3, e2) {
        return Gt(e2 ? t3 / 100 : t3, 0, 1);
      }
      function Gt(t3, e2, r3) {
        return Math.min(Math.max(e2, t3), r3);
      }
      function Jt(t3) {
        return !t3.some(Number.isNaN);
      }
      const Xt = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      class Yt {
        constructor(t3, e2, r3, n3 = 1, i3 = true) {
          this.r = t3, this.g = e2, this.b = r3, this.a = n3, i3 || (this.r *= n3, this.g *= n3, this.b *= n3, n3 || this.overwriteGetter("rgb", [t3, e2, r3, n3]));
        }
        static parse(t3) {
          if (t3 instanceof Yt) return t3;
          if ("string" != typeof t3) return;
          const e2 = function(t4) {
            if ("transparent" === (t4 = t4.toLowerCase().trim())) return [0, 0, 0, 0];
            const e3 = Xt[t4];
            if (e3) {
              const [t5, r4, n3] = e3;
              return [t5 / 255, r4 / 255, n3 / 255, 1];
            }
            if (t4.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t4)) {
              const e4 = t4.length < 6 ? 1 : 2;
              let r4 = 1;
              return [Zt(t4.slice(r4, r4 += e4)), Zt(t4.slice(r4, r4 += e4)), Zt(t4.slice(r4, r4 += e4)), Zt(t4.slice(r4, r4 + e4) || "ff")];
            }
            if (t4.startsWith("rgb")) {
              const e4 = t4.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (e4) {
                const [t5, r4, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3] = e4, f3 = [i3 || " ", o3 || " ", c3].join("");
                if ("  " === f3 || "  /" === f3 || ",," === f3 || ",,," === f3) {
                  const t6 = [n3, s3, u3].join(""), e5 = "%%%" === t6 ? 100 : "" === t6 ? 255 : 0;
                  if (e5) {
                    const t7 = [Gt(+r4 / e5, 0, 1), Gt(+a3 / e5, 0, 1), Gt(+l3 / e5, 0, 1), h3 ? Kt(+h3, p3) : 1];
                    if (Jt(t7)) return t7;
                  }
                }
                return;
              }
            }
            const r3 = t4.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (r3) {
              const [t5, e4, n3, i3, a3, s3, o3, l3, u3] = r3, c3 = [n3 || " ", a3 || " ", o3].join("");
              if ("  " === c3 || "  /" === c3 || ",," === c3 || ",,," === c3) {
                const t6 = [+e4, Gt(+i3, 0, 100), Gt(+s3, 0, 100), l3 ? Kt(+l3, u3) : 1];
                if (Jt(t6)) return function([t7, e5, r4, n4]) {
                  function i4(n5) {
                    const i5 = (n5 + t7 / 30) % 12, a4 = e5 * Math.min(r4, 1 - r4);
                    return r4 - a4 * Math.max(-1, Math.min(i5 - 3, 9 - i5, 1));
                  }
                  return t7 = Dt(t7), e5 /= 100, r4 /= 100, [i4(0), i4(8), i4(4), n4];
                }(t6);
              }
            }
          }(t3);
          return e2 ? new Yt(...e2, false) : void 0;
        }
        get rgb() {
          const { r: t3, g: e2, b: r3, a: n3 } = this, i3 = n3 || 1 / 0;
          return this.overwriteGetter("rgb", [t3 / i3, e2 / i3, r3 / i3, n3]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(t3) {
            const [e2, r3, n3, i3] = Ot(t3), a3 = Math.sqrt(r3 * r3 + n3 * n3);
            return [Math.round(1e4 * a3) ? Dt(Math.atan2(n3, r3) * Lt) : NaN, a3, e2, i3];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", Ot(this.rgb));
        }
        overwriteGetter(t3, e2) {
          return Object.defineProperty(this, t3, { value: e2 }), e2;
        }
        toString() {
          const [t3, e2, r3, n3] = this.rgb;
          return `rgba(${[t3, e2, r3].map((t4) => Math.round(255 * t4)).join(",")},${n3})`;
        }
      }
      Yt.black = new Yt(0, 0, 0, 1), Yt.white = new Yt(1, 1, 1, 1), Yt.transparent = new Yt(0, 0, 0, 0), Yt.red = new Yt(1, 0, 0, 1);
      class Ht {
        constructor(t3, e2, r3) {
          this.sensitivity = t3 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r3, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(t3, e2) {
          return this.collator.compare(t3, e2);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class Wt {
        constructor(t3, e2, r3, n3, i3) {
          this.text = t3, this.image = e2, this.scale = r3, this.fontStack = n3, this.textColor = i3;
        }
      }
      class Qt {
        constructor(t3) {
          this.sections = t3;
        }
        static fromString(t3) {
          return new Qt([new Wt(t3, null, null, null, null)]);
        }
        isEmpty() {
          return 0 === this.sections.length || !this.sections.some((t3) => 0 !== t3.text.length || t3.image && 0 !== t3.image.name.length);
        }
        static factory(t3) {
          return t3 instanceof Qt ? t3 : Qt.fromString(t3);
        }
        toString() {
          return 0 === this.sections.length ? "" : this.sections.map((t3) => t3.text).join("");
        }
      }
      class te2 {
        constructor(t3) {
          this.values = t3.slice();
        }
        static parse(t3) {
          if (t3 instanceof te2) return t3;
          if ("number" == typeof t3) return new te2([t3, t3, t3, t3]);
          if (Array.isArray(t3) && !(t3.length < 1 || t3.length > 4)) {
            for (const e2 of t3) if ("number" != typeof e2) return;
            switch (t3.length) {
              case 1:
                t3 = [t3[0], t3[0], t3[0], t3[0]];
                break;
              case 2:
                t3 = [t3[0], t3[1], t3[0], t3[1]];
                break;
              case 3:
                t3 = [t3[0], t3[1], t3[2], t3[1]];
            }
            return new te2(t3);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      const ee2 = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
      class re2 {
        constructor(t3) {
          this.values = t3.slice();
        }
        static parse(t3) {
          if (t3 instanceof re2) return t3;
          if (Array.isArray(t3) && !(t3.length < 1) && t3.length % 2 == 0) {
            for (let e2 = 0; e2 < t3.length; e2 += 2) {
              const r3 = t3[e2], n3 = t3[e2 + 1];
              if ("string" != typeof r3 || !ee2.has(r3)) return;
              if (!Array.isArray(n3) || 2 !== n3.length || "number" != typeof n3[0] || "number" != typeof n3[1]) return;
            }
            return new re2(t3);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      class ne2 {
        constructor(t3) {
          this.name = t3.name, this.available = t3.available;
        }
        toString() {
          return this.name;
        }
        static fromString(t3) {
          return t3 ? new ne2({ name: t3, available: false }) : null;
        }
      }
      function ie2(t3, e2, r3, n3) {
        return "number" == typeof t3 && t3 >= 0 && t3 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r3 && r3 >= 0 && r3 <= 255 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid rgba value [${[t3, e2, r3, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n3 ? [t3, e2, r3, n3] : [t3, e2, r3]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function ae2(t3) {
        if (null === t3 || "string" == typeof t3 || "boolean" == typeof t3 || "number" == typeof t3 || t3 instanceof Yt || t3 instanceof Ht || t3 instanceof Qt || t3 instanceof te2 || t3 instanceof re2 || t3 instanceof ne2) return true;
        if (Array.isArray(t3)) {
          for (const e2 of t3) if (!ae2(e2)) return false;
          return true;
        }
        if ("object" == typeof t3) {
          for (const e2 in t3) if (!ae2(t3[e2])) return false;
          return true;
        }
        return false;
      }
      function se2(t3) {
        if (null === t3) return ht;
        if ("string" == typeof t3) return ft;
        if ("boolean" == typeof t3) return dt;
        if ("number" == typeof t3) return pt;
        if (t3 instanceof Yt) return yt;
        if (t3 instanceof Ht) return xt;
        if (t3 instanceof Qt) return vt;
        if (t3 instanceof te2) return bt;
        if (t3 instanceof re2) return _t;
        if (t3 instanceof ne2) return wt;
        if (Array.isArray(t3)) {
          const e2 = t3.length;
          let r3;
          for (const e3 of t3) {
            const t4 = se2(e3);
            if (r3) {
              if (r3 === t4) continue;
              r3 = gt;
              break;
            }
            r3 = t4;
          }
          return At(r3 || gt, e2);
        }
        return mt;
      }
      function oe2(t3) {
        const e2 = typeof t3;
        return null === t3 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t3) : t3 instanceof Yt || t3 instanceof Qt || t3 instanceof te2 || t3 instanceof re2 || t3 instanceof ne2 ? t3.toString() : JSON.stringify(t3);
      }
      class le2 {
        constructor(t3, e2) {
          this.type = t3, this.value = e2;
        }
        static parse(t3, e2) {
          if (2 !== t3.length) return e2.error(`'literal' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
          if (!ae2(t3[1])) return e2.error("invalid value");
          const r3 = t3[1];
          let n3 = se2(r3);
          const i3 = e2.expectedType;
          return "array" !== n3.kind || 0 !== n3.N || !i3 || "array" !== i3.kind || "number" == typeof i3.N && 0 !== i3.N || (n3 = i3), new le2(n3, r3);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }
      class ue2 {
        constructor(t3) {
          this.name = "ExpressionEvaluationError", this.message = t3;
        }
        toJSON() {
          return this.message;
        }
      }
      const ce2 = { string: ft, number: pt, boolean: dt, object: mt };
      class he2 {
        constructor(t3, e2) {
          this.type = t3, this.args = e2;
        }
        static parse(t3, e2) {
          if (t3.length < 2) return e2.error("Expected at least one argument.");
          let r3, n3 = 1;
          const i3 = t3[0];
          if ("array" === i3) {
            let i4, a4;
            if (t3.length > 2) {
              const r4 = t3[1];
              if ("string" != typeof r4 || !(r4 in ce2) || "object" === r4) return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
              i4 = ce2[r4], n3++;
            } else i4 = gt;
            if (t3.length > 3) {
              if (null !== t3[2] && ("number" != typeof t3[2] || t3[2] < 0 || t3[2] !== Math.floor(t3[2]))) return e2.error('The length argument to "array" must be a positive integer literal', 2);
              a4 = t3[2], n3++;
            }
            r3 = At(i4, a4);
          } else {
            if (!ce2[i3]) throw new Error(`Types doesn't contain name = ${i3}`);
            r3 = ce2[i3];
          }
          const a3 = [];
          for (; n3 < t3.length; n3++) {
            const r4 = e2.parse(t3[n3], n3, gt);
            if (!r4) return null;
            a3.push(r4);
          }
          return new he2(r3, a3);
        }
        evaluate(t3) {
          for (let e2 = 0; e2 < this.args.length; e2++) {
            const r3 = this.args[e2].evaluate(t3);
            if (!It(this.type, se2(r3))) return r3;
            if (e2 === this.args.length - 1) throw new ue2(`Expected value to be of type ${St(this.type)}, but found ${St(se2(r3))} instead.`);
          }
          throw new Error();
        }
        eachChild(t3) {
          this.args.forEach(t3);
        }
        outputDefined() {
          return this.args.every((t3) => t3.outputDefined());
        }
      }
      const pe2 = { "to-boolean": dt, "to-color": yt, "to-number": pt, "to-string": ft };
      class fe2 {
        constructor(t3, e2) {
          this.type = t3, this.args = e2;
        }
        static parse(t3, e2) {
          if (t3.length < 2) return e2.error("Expected at least one argument.");
          const r3 = t3[0];
          if (!pe2[r3]) throw new Error(`Can't parse ${r3} as it is not part of the known types`);
          if (("to-boolean" === r3 || "to-string" === r3) && 2 !== t3.length) return e2.error("Expected one argument.");
          const n3 = pe2[r3], i3 = [];
          for (let r4 = 1; r4 < t3.length; r4++) {
            const n4 = e2.parse(t3[r4], r4, gt);
            if (!n4) return null;
            i3.push(n4);
          }
          return new fe2(n3, i3);
        }
        evaluate(t3) {
          switch (this.type.kind) {
            case "boolean":
              return Boolean(this.args[0].evaluate(t3));
            case "color": {
              let e2, r3;
              for (const n3 of this.args) {
                if (e2 = n3.evaluate(t3), r3 = null, e2 instanceof Yt) return e2;
                if ("string" == typeof e2) {
                  const r4 = t3.parseColor(e2);
                  if (r4) return r4;
                } else if (Array.isArray(e2) && (r3 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : ie2(e2[0], e2[1], e2[2], e2[3]), !r3)) return new Yt(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
              }
              throw new ue2(r3 || `Could not parse color from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
            }
            case "padding": {
              let e2;
              for (const r3 of this.args) {
                e2 = r3.evaluate(t3);
                const n3 = te2.parse(e2);
                if (n3) return n3;
              }
              throw new ue2(`Could not parse padding from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let e2;
              for (const r3 of this.args) {
                e2 = r3.evaluate(t3);
                const n3 = re2.parse(e2);
                if (n3) return n3;
              }
              throw new ue2(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
            }
            case "number": {
              let e2 = null;
              for (const r3 of this.args) {
                if (e2 = r3.evaluate(t3), null === e2) return 0;
                const n3 = Number(e2);
                if (!isNaN(n3)) return n3;
              }
              throw new ue2(`Could not convert ${JSON.stringify(e2)} to number.`);
            }
            case "formatted":
              return Qt.fromString(oe2(this.args[0].evaluate(t3)));
            case "resolvedImage":
              return ne2.fromString(oe2(this.args[0].evaluate(t3)));
            default:
              return oe2(this.args[0].evaluate(t3));
          }
        }
        eachChild(t3) {
          this.args.forEach(t3);
        }
        outputDefined() {
          return this.args.every((t3) => t3.outputDefined());
        }
      }
      const de2 = ["Unknown", "Point", "LineString", "Polygon"];
      class ye2 {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? "number" == typeof this.feature.type ? de2[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(t3) {
          let e2 = this._parseColorCache[t3];
          return e2 || (e2 = this._parseColorCache[t3] = Yt.parse(t3)), e2;
        }
      }
      class me2 {
        constructor(t3, e2, r3 = [], n3, i3 = new ct(), a3 = []) {
          this.registry = t3, this.path = r3, this.key = r3.map((t4) => `[${t4}]`).join(""), this.scope = i3, this.errors = a3, this.expectedType = n3, this._isConstant = e2;
        }
        parse(t3, e2, r3, n3, i3 = {}) {
          return e2 ? this.concat(e2, r3, n3)._parse(t3, i3) : this._parse(t3, i3);
        }
        _parse(t3, e2) {
          function r3(t4, e3, r4) {
            return "assert" === r4 ? new he2(e3, [t4]) : "coerce" === r4 ? new fe2(e3, [t4]) : t4;
          }
          if (null !== t3 && "string" != typeof t3 && "boolean" != typeof t3 && "number" != typeof t3 || (t3 = ["literal", t3]), Array.isArray(t3)) {
            if (0 === t3.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const n3 = t3[0];
            if ("string" != typeof n3) return this.error(`Expression name must be a string, but found ${typeof n3} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const i3 = this.registry[n3];
            if (i3) {
              let n4 = i3.parse(t3, this);
              if (!n4) return null;
              if (this.expectedType) {
                const t4 = this.expectedType, i4 = n4.type;
                if ("string" !== t4.kind && "number" !== t4.kind && "boolean" !== t4.kind && "object" !== t4.kind && "array" !== t4.kind || "value" !== i4.kind) if ("color" !== t4.kind && "formatted" !== t4.kind && "resolvedImage" !== t4.kind || "value" !== i4.kind && "string" !== i4.kind) if ("padding" !== t4.kind || "value" !== i4.kind && "number" !== i4.kind && "array" !== i4.kind) if ("variableAnchorOffsetCollection" !== t4.kind || "value" !== i4.kind && "array" !== i4.kind) {
                  if (this.checkSubtype(t4, i4)) return null;
                } else n4 = r3(n4, t4, e2.typeAnnotation || "coerce");
                else n4 = r3(n4, t4, e2.typeAnnotation || "coerce");
                else n4 = r3(n4, t4, e2.typeAnnotation || "coerce");
                else n4 = r3(n4, t4, e2.typeAnnotation || "assert");
              }
              if (!(n4 instanceof le2) && "resolvedImage" !== n4.type.kind && this._isConstant(n4)) {
                const t4 = new ye2();
                try {
                  n4 = new le2(n4.type, n4.evaluate(t4));
                } catch (t5) {
                  return this.error(t5.message), null;
                }
              }
              return n4;
            }
            return this.error(`Unknown expression "${n3}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(void 0 === t3 ? "'undefined' value invalid. Use null instead." : "object" == typeof t3 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t3} instead.`);
        }
        concat(t3, e2, r3) {
          const n3 = "number" == typeof t3 ? this.path.concat(t3) : this.path, i3 = r3 ? this.scope.concat(r3) : this.scope;
          return new me2(this.registry, this._isConstant, n3, e2 || null, i3, this.errors);
        }
        error(t3, ...e2) {
          const r3 = `${this.key}${e2.map((t4) => `[${t4}]`).join("")}`;
          this.errors.push(new ut(r3, t3));
        }
        checkSubtype(t3, e2) {
          const r3 = It(t3, e2);
          return r3 && this.error(r3), r3;
        }
      }
      class ge2 {
        constructor(t3, e2, r3) {
          this.type = xt, this.locale = r3, this.caseSensitive = t3, this.diacriticSensitive = e2;
        }
        static parse(t3, e2) {
          if (2 !== t3.length) return e2.error("Expected one argument.");
          const r3 = t3[1];
          if ("object" != typeof r3 || Array.isArray(r3)) return e2.error("Collator options argument must be an object.");
          const n3 = e2.parse(void 0 !== r3["case-sensitive"] && r3["case-sensitive"], 1, dt);
          if (!n3) return null;
          const i3 = e2.parse(void 0 !== r3["diacritic-sensitive"] && r3["diacritic-sensitive"], 1, dt);
          if (!i3) return null;
          let a3 = null;
          return r3.locale && (a3 = e2.parse(r3.locale, 1, ft), !a3) ? null : new ge2(n3, i3, a3);
        }
        evaluate(t3) {
          return new Ht(this.caseSensitive.evaluate(t3), this.diacriticSensitive.evaluate(t3), this.locale ? this.locale.evaluate(t3) : null);
        }
        eachChild(t3) {
          t3(this.caseSensitive), t3(this.diacriticSensitive), this.locale && t3(this.locale);
        }
        outputDefined() {
          return false;
        }
      }
      const xe2 = 8192;
      function ve2(t3, e2) {
        t3[0] = Math.min(t3[0], e2[0]), t3[1] = Math.min(t3[1], e2[1]), t3[2] = Math.max(t3[2], e2[0]), t3[3] = Math.max(t3[3], e2[1]);
      }
      function be2(t3, e2) {
        return !(t3[0] <= e2[0] || t3[2] >= e2[2] || t3[1] <= e2[1] || t3[3] >= e2[3]);
      }
      function we2(t3, e2) {
        const r3 = (180 + t3[0]) / 360, n3 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3[1] * Math.PI / 360))) / 360, i3 = Math.pow(2, e2.z);
        return [Math.round(r3 * i3 * xe2), Math.round(n3 * i3 * xe2)];
      }
      function _e2(t3, e2, r3) {
        const n3 = t3[0] - e2[0], i3 = t3[1] - e2[1], a3 = t3[0] - r3[0], s3 = t3[1] - r3[1];
        return n3 * s3 - a3 * i3 == 0 && n3 * a3 <= 0 && i3 * s3 <= 0;
      }
      function Ae2(t3, e2) {
        let r3 = false;
        for (let s3 = 0, o3 = e2.length; s3 < o3; s3++) {
          const o4 = e2[s3];
          for (let e3 = 0, s4 = o4.length; e3 < s4 - 1; e3++) {
            if (_e2(t3, o4[e3], o4[e3 + 1])) return false;
            (i3 = o4[e3])[1] > (n3 = t3)[1] != (a3 = o4[e3 + 1])[1] > n3[1] && n3[0] < (a3[0] - i3[0]) * (n3[1] - i3[1]) / (a3[1] - i3[1]) + i3[0] && (r3 = !r3);
          }
        }
        var n3, i3, a3;
        return r3;
      }
      function Se2(t3, e2) {
        for (let r3 = 0; r3 < e2.length; r3++) if (Ae2(t3, e2[r3])) return true;
        return false;
      }
      function ke2(t3, e2, r3, n3) {
        const i3 = n3[0] - r3[0], a3 = n3[1] - r3[1], s3 = (t3[0] - r3[0]) * a3 - i3 * (t3[1] - r3[1]), o3 = (e2[0] - r3[0]) * a3 - i3 * (e2[1] - r3[1]);
        return s3 > 0 && o3 < 0 || s3 < 0 && o3 > 0;
      }
      function Ie2(t3, e2, r3) {
        for (const u3 of r3) for (let r4 = 0; r4 < u3.length - 1; ++r4) if (0 != (o3 = [(s3 = u3[r4 + 1])[0] - (a3 = u3[r4])[0], s3[1] - a3[1]])[0] * (l3 = [(i3 = e2)[0] - (n3 = t3)[0], i3[1] - n3[1]])[1] - o3[1] * l3[0] && ke2(n3, i3, a3, s3) && ke2(a3, s3, n3, i3)) return true;
        var n3, i3, a3, s3, o3, l3;
        return false;
      }
      function ze2(t3, e2) {
        for (let r3 = 0; r3 < t3.length; ++r3) if (!Ae2(t3[r3], e2)) return false;
        for (let r3 = 0; r3 < t3.length - 1; ++r3) if (Ie2(t3[r3], t3[r3 + 1], e2)) return false;
        return true;
      }
      function Me2(t3, e2) {
        for (let r3 = 0; r3 < e2.length; r3++) if (ze2(t3, e2[r3])) return true;
        return false;
      }
      function Ce2(t3, e2, r3) {
        const n3 = [];
        for (let i3 = 0; i3 < t3.length; i3++) {
          const a3 = [];
          for (let n4 = 0; n4 < t3[i3].length; n4++) {
            const s3 = we2(t3[i3][n4], r3);
            ve2(e2, s3), a3.push(s3);
          }
          n3.push(a3);
        }
        return n3;
      }
      function Be2(t3, e2, r3) {
        const n3 = [];
        for (let i3 = 0; i3 < t3.length; i3++) {
          const a3 = Ce2(t3[i3], e2, r3);
          n3.push(a3);
        }
        return n3;
      }
      function Pe2(t3, e2, r3, n3) {
        if (t3[0] < r3[0] || t3[0] > r3[2]) {
          const e3 = 0.5 * n3;
          let i3 = t3[0] - r3[0] > e3 ? -n3 : r3[0] - t3[0] > e3 ? n3 : 0;
          0 === i3 && (i3 = t3[0] - r3[2] > e3 ? -n3 : r3[2] - t3[0] > e3 ? n3 : 0), t3[0] += i3;
        }
        ve2(e2, t3);
      }
      function Ve(t3, e2, r3, n3) {
        const i3 = Math.pow(2, n3.z) * xe2, a3 = [n3.x * xe2, n3.y * xe2], s3 = [];
        for (const n4 of t3) for (const t4 of n4) {
          const n5 = [t4.x + a3[0], t4.y + a3[1]];
          Pe2(n5, e2, r3, i3), s3.push(n5);
        }
        return s3;
      }
      function Ee2(t3, e2, r3, n3) {
        const i3 = Math.pow(2, n3.z) * xe2, a3 = [n3.x * xe2, n3.y * xe2], s3 = [];
        for (const r4 of t3) {
          const t4 = [];
          for (const n4 of r4) {
            const r5 = [n4.x + a3[0], n4.y + a3[1]];
            ve2(e2, r5), t4.push(r5);
          }
          s3.push(t4);
        }
        if (e2[2] - e2[0] <= i3 / 2) {
          (o3 = e2)[0] = o3[1] = 1 / 0, o3[2] = o3[3] = -1 / 0;
          for (const t4 of s3) for (const n4 of t4) Pe2(n4, e2, r3, i3);
        }
        var o3;
        return s3;
      }
      class Fe2 {
        constructor(t3, e2) {
          this.type = dt, this.geojson = t3, this.geometries = e2;
        }
        static parse(t3, e2) {
          if (2 !== t3.length) return e2.error(`'within' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
          if (ae2(t3[1])) {
            const e3 = t3[1];
            if ("FeatureCollection" === e3.type) for (let t4 = 0; t4 < e3.features.length; ++t4) {
              const r3 = e3.features[t4].geometry.type;
              if ("Polygon" === r3 || "MultiPolygon" === r3) return new Fe2(e3, e3.features[t4].geometry);
            }
            else if ("Feature" === e3.type) {
              const t4 = e3.geometry.type;
              if ("Polygon" === t4 || "MultiPolygon" === t4) return new Fe2(e3, e3.geometry);
            } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type) return new Fe2(e3, e3);
          }
          return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t3) {
          if (null != t3.geometry() && null != t3.canonicalID()) {
            if ("Point" === t3.geometryType()) return function(t4, e2) {
              const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t4.canonicalID();
              if ("Polygon" === e2.type) {
                const a3 = Ce2(e2.coordinates, n3, i3), s3 = Ve(t4.geometry(), r3, n3, i3);
                if (!be2(r3, n3)) return false;
                for (const t5 of s3) if (!Ae2(t5, a3)) return false;
              }
              if ("MultiPolygon" === e2.type) {
                const a3 = Be2(e2.coordinates, n3, i3), s3 = Ve(t4.geometry(), r3, n3, i3);
                if (!be2(r3, n3)) return false;
                for (const t5 of s3) if (!Se2(t5, a3)) return false;
              }
              return true;
            }(t3, this.geometries);
            if ("LineString" === t3.geometryType()) return function(t4, e2) {
              const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t4.canonicalID();
              if ("Polygon" === e2.type) {
                const a3 = Ce2(e2.coordinates, n3, i3), s3 = Ee2(t4.geometry(), r3, n3, i3);
                if (!be2(r3, n3)) return false;
                for (const t5 of s3) if (!ze2(t5, a3)) return false;
              }
              if ("MultiPolygon" === e2.type) {
                const a3 = Be2(e2.coordinates, n3, i3), s3 = Ee2(t4.geometry(), r3, n3, i3);
                if (!be2(r3, n3)) return false;
                for (const t5 of s3) if (!Me2(t5, a3)) return false;
              }
              return true;
            }(t3, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }
      class Te2 {
        constructor(t3, e2) {
          this.type = e2.type, this.name = t3, this.boundExpression = e2;
        }
        static parse(t3, e2) {
          if (2 !== t3.length || "string" != typeof t3[1]) return e2.error("'var' expression requires exactly one string literal argument.");
          const r3 = t3[1];
          return e2.scope.has(r3) ? new Te2(r3, e2.scope.get(r3)) : e2.error(`Unknown variable "${r3}". Make sure "${r3}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(t3) {
          return this.boundExpression.evaluate(t3);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
      }
      class $e2 {
        constructor(t3, e2, r3, n3) {
          this.name = t3, this.type = e2, this._evaluate = r3, this.args = n3;
        }
        evaluate(t3) {
          return this._evaluate(t3, this.args);
        }
        eachChild(t3) {
          this.args.forEach(t3);
        }
        outputDefined() {
          return false;
        }
        static parse(t3, e2) {
          const r3 = t3[0], n3 = $e2.definitions[r3];
          if (!n3) return e2.error(`Unknown expression "${r3}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const i3 = Array.isArray(n3) ? n3[0] : n3.type, a3 = Array.isArray(n3) ? [[n3[1], n3[2]]] : n3.overloads, s3 = a3.filter(([e3]) => !Array.isArray(e3) || e3.length === t3.length - 1);
          let o3 = null;
          for (const [n4, a4] of s3) {
            o3 = new me2(e2.registry, Le2, e2.path, null, e2.scope);
            const s4 = [];
            let l3 = false;
            for (let e3 = 1; e3 < t3.length; e3++) {
              const r4 = t3[e3], i4 = Array.isArray(n4) ? n4[e3 - 1] : n4.type, a5 = o3.parse(r4, 1 + s4.length, i4);
              if (!a5) {
                l3 = true;
                break;
              }
              s4.push(a5);
            }
            if (!l3) if (Array.isArray(n4) && n4.length !== s4.length) o3.error(`Expected ${n4.length} arguments, but found ${s4.length} instead.`);
            else {
              for (let t4 = 0; t4 < s4.length; t4++) {
                const e3 = Array.isArray(n4) ? n4[t4] : n4.type, r4 = s4[t4];
                o3.concat(t4 + 1).checkSubtype(e3, r4.type);
              }
              if (0 === o3.errors.length) return new $e2(r3, i3, a4, s4);
            }
          }
          if (1 === s3.length) e2.errors.push(...o3.errors);
          else {
            const r4 = (s3.length ? s3 : a3).map(([t4]) => {
              return e3 = t4, Array.isArray(e3) ? `(${e3.map(St).join(", ")})` : `(${St(e3.type)}...)`;
              var e3;
            }).join(" | "), n4 = [];
            for (let r5 = 1; r5 < t3.length; r5++) {
              const i4 = e2.parse(t3[r5], 1 + n4.length);
              if (!i4) return null;
              n4.push(St(i4.type));
            }
            e2.error(`Expected arguments of type ${r4}, but found (${n4.join(", ")}) instead.`);
          }
          return null;
        }
        static register(t3, e2) {
          $e2.definitions = e2;
          for (const r3 in e2) t3[r3] = $e2;
        }
      }
      function Le2(t3) {
        if (t3 instanceof Te2) return Le2(t3.boundExpression);
        if (t3 instanceof $e2 && "error" === t3.name) return false;
        if (t3 instanceof ge2) return false;
        if (t3 instanceof Fe2) return false;
        const e2 = t3 instanceof fe2 || t3 instanceof he2;
        let r3 = true;
        return t3.eachChild((t4) => {
          r3 = e2 ? r3 && Le2(t4) : r3 && t4 instanceof le2;
        }), !!r3 && De2(t3) && Ue2(t3, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function De2(t3) {
        if (t3 instanceof $e2) {
          if ("get" === t3.name && 1 === t3.args.length) return false;
          if ("feature-state" === t3.name) return false;
          if ("has" === t3.name && 1 === t3.args.length) return false;
          if ("properties" === t3.name || "geometry-type" === t3.name || "id" === t3.name) return false;
          if (/^filter-/.test(t3.name)) return false;
        }
        if (t3 instanceof Fe2) return false;
        let e2 = true;
        return t3.eachChild((t4) => {
          e2 && !De2(t4) && (e2 = false);
        }), e2;
      }
      function Oe2(t3) {
        if (t3 instanceof $e2 && "feature-state" === t3.name) return false;
        let e2 = true;
        return t3.eachChild((t4) => {
          e2 && !Oe2(t4) && (e2 = false);
        }), e2;
      }
      function Ue2(t3, e2) {
        if (t3 instanceof $e2 && e2.indexOf(t3.name) >= 0) return false;
        let r3 = true;
        return t3.eachChild((t4) => {
          r3 && !Ue2(t4, e2) && (r3 = false);
        }), r3;
      }
      function Re2(t3, e2) {
        const r3 = t3.length - 1;
        let n3, i3, a3 = 0, s3 = r3, o3 = 0;
        for (; a3 <= s3; ) if (o3 = Math.floor((a3 + s3) / 2), n3 = t3[o3], i3 = t3[o3 + 1], n3 <= e2) {
          if (o3 === r3 || e2 < i3) return o3;
          a3 = o3 + 1;
        } else {
          if (!(n3 > e2)) throw new ue2("Input is not a number.");
          s3 = o3 - 1;
        }
        return 0;
      }
      class qe {
        constructor(t3, e2, r3) {
          this.type = t3, this.input = e2, this.labels = [], this.outputs = [];
          for (const [t4, e3] of r3) this.labels.push(t4), this.outputs.push(e3);
        }
        static parse(t3, e2) {
          if (t3.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
          if ((t3.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
          const r3 = e2.parse(t3[1], 1, pt);
          if (!r3) return null;
          const n3 = [];
          let i3 = null;
          e2.expectedType && "value" !== e2.expectedType.kind && (i3 = e2.expectedType);
          for (let r4 = 1; r4 < t3.length; r4 += 2) {
            const a3 = 1 === r4 ? -1 / 0 : t3[r4], s3 = t3[r4 + 1], o3 = r4, l3 = r4 + 1;
            if ("number" != typeof a3) return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o3);
            if (n3.length && n3[n3.length - 1][0] >= a3) return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o3);
            const u3 = e2.parse(s3, l3, i3);
            if (!u3) return null;
            i3 = i3 || u3.type, n3.push([a3, u3]);
          }
          return new qe(i3, r3, n3);
        }
        evaluate(t3) {
          const e2 = this.labels, r3 = this.outputs;
          if (1 === e2.length) return r3[0].evaluate(t3);
          const n3 = this.input.evaluate(t3);
          if (n3 <= e2[0]) return r3[0].evaluate(t3);
          const i3 = e2.length;
          return n3 >= e2[i3 - 1] ? r3[i3 - 1].evaluate(t3) : r3[Re2(e2, n3)].evaluate(t3);
        }
        eachChild(t3) {
          t3(this.input);
          for (const e2 of this.outputs) t3(e2);
        }
        outputDefined() {
          return this.outputs.every((t3) => t3.outputDefined());
        }
      }
      function je2(t3, e2, r3) {
        return t3 + r3 * (e2 - t3);
      }
      function Ne2(t3, e2, r3) {
        return t3.map((t4, n3) => je2(t4, e2[n3], r3));
      }
      const Ze2 = { number: je2, color: function(t3, e2, r3, n3 = "rgb") {
        switch (n3) {
          case "rgb": {
            const [n4, i3, a3, s3] = Ne2(t3.rgb, e2.rgb, r3);
            return new Yt(n4, i3, a3, s3, false);
          }
          case "hcl": {
            const [n4, i3, a3, s3] = t3.hcl, [o3, l3, u3, c3] = e2.hcl;
            let h3, p3;
            if (isNaN(n4) || isNaN(o3)) isNaN(n4) ? isNaN(o3) ? h3 = NaN : (h3 = o3, 1 !== a3 && 0 !== a3 || (p3 = l3)) : (h3 = n4, 1 !== u3 && 0 !== u3 || (p3 = i3));
            else {
              let t4 = o3 - n4;
              o3 > n4 && t4 > 180 ? t4 -= 360 : o3 < n4 && n4 - o3 > 180 && (t4 += 360), h3 = n4 + r3 * t4;
            }
            const [f3, d3, y3, m3] = function([t4, e3, r4, n5]) {
              return t4 = isNaN(t4) ? 0 : t4 * $t, qt([r4, Math.cos(t4) * e3, Math.sin(t4) * e3, n5]);
            }([h3, null != p3 ? p3 : je2(i3, l3, r3), je2(a3, u3, r3), je2(s3, c3, r3)]);
            return new Yt(f3, d3, y3, m3, false);
          }
          case "lab": {
            const [n4, i3, a3, s3] = qt(Ne2(t3.lab, e2.lab, r3));
            return new Yt(n4, i3, a3, s3, false);
          }
        }
      }, array: Ne2, padding: function(t3, e2, r3) {
        return new te2(Ne2(t3.values, e2.values, r3));
      }, variableAnchorOffsetCollection: function(t3, e2, r3) {
        const n3 = t3.values, i3 = e2.values;
        if (n3.length !== i3.length) throw new ue2(`Cannot interpolate values of different length. from: ${t3.toString()}, to: ${e2.toString()}`);
        const a3 = [];
        for (let t4 = 0; t4 < n3.length; t4 += 2) {
          if (n3[t4] !== i3[t4]) throw new ue2(`Cannot interpolate values containing mismatched anchors. from[${t4}]: ${n3[t4]}, to[${t4}]: ${i3[t4]}`);
          a3.push(n3[t4]);
          const [e3, s3] = n3[t4 + 1], [o3, l3] = i3[t4 + 1];
          a3.push([je2(e3, o3, r3), je2(s3, l3, r3)]);
        }
        return new re2(a3);
      } };
      class Ke {
        constructor(t3, e2, r3, n3, i3) {
          this.type = t3, this.operator = e2, this.interpolation = r3, this.input = n3, this.labels = [], this.outputs = [];
          for (const [t4, e3] of i3) this.labels.push(t4), this.outputs.push(e3);
        }
        static interpolationFactor(t3, e2, r3, n3) {
          let i3 = 0;
          if ("exponential" === t3.name) i3 = Ge2(e2, t3.base, r3, n3);
          else if ("linear" === t3.name) i3 = Ge2(e2, 1, r3, n3);
          else if ("cubic-bezier" === t3.name) {
            const a3 = t3.controlPoints;
            i3 = new l2(a3[0], a3[1], a3[2], a3[3]).solve(Ge2(e2, 1, r3, n3));
          }
          return i3;
        }
        static parse(t3, e2) {
          let [r3, n3, i3, ...a3] = t3;
          if (!Array.isArray(n3) || 0 === n3.length) return e2.error("Expected an interpolation type expression.", 1);
          if ("linear" === n3[0]) n3 = { name: "linear" };
          else if ("exponential" === n3[0]) {
            const t4 = n3[1];
            if ("number" != typeof t4) return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
            n3 = { name: "exponential", base: t4 };
          } else {
            if ("cubic-bezier" !== n3[0]) return e2.error(`Unknown interpolation type ${String(n3[0])}`, 1, 0);
            {
              const t4 = n3.slice(1);
              if (4 !== t4.length || t4.some((t5) => "number" != typeof t5 || t5 < 0 || t5 > 1)) return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              n3 = { name: "cubic-bezier", controlPoints: t4 };
            }
          }
          if (t3.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
          if ((t3.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
          if (i3 = e2.parse(i3, 2, pt), !i3) return null;
          const s3 = [];
          let o3 = null;
          "interpolate-hcl" === r3 || "interpolate-lab" === r3 ? o3 = yt : e2.expectedType && "value" !== e2.expectedType.kind && (o3 = e2.expectedType);
          for (let t4 = 0; t4 < a3.length; t4 += 2) {
            const r4 = a3[t4], n4 = a3[t4 + 1], i4 = t4 + 3, l3 = t4 + 4;
            if ("number" != typeof r4) return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i4);
            if (s3.length && s3[s3.length - 1][0] >= r4) return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i4);
            const u3 = e2.parse(n4, l3, o3);
            if (!u3) return null;
            o3 = o3 || u3.type, s3.push([r4, u3]);
          }
          return Ct(o3, pt) || Ct(o3, yt) || Ct(o3, bt) || Ct(o3, _t) || Ct(o3, At(pt)) ? new Ke(o3, r3, n3, i3, s3) : e2.error(`Type ${St(o3)} is not interpolatable.`);
        }
        evaluate(t3) {
          const e2 = this.labels, r3 = this.outputs;
          if (1 === e2.length) return r3[0].evaluate(t3);
          const n3 = this.input.evaluate(t3);
          if (n3 <= e2[0]) return r3[0].evaluate(t3);
          const i3 = e2.length;
          if (n3 >= e2[i3 - 1]) return r3[i3 - 1].evaluate(t3);
          const a3 = Re2(e2, n3), s3 = Ke.interpolationFactor(this.interpolation, n3, e2[a3], e2[a3 + 1]), o3 = r3[a3].evaluate(t3), l3 = r3[a3 + 1].evaluate(t3);
          switch (this.operator) {
            case "interpolate":
              return Ze2[this.type.kind](o3, l3, s3);
            case "interpolate-hcl":
              return Ze2.color(o3, l3, s3, "hcl");
            case "interpolate-lab":
              return Ze2.color(o3, l3, s3, "lab");
          }
        }
        eachChild(t3) {
          t3(this.input);
          for (const e2 of this.outputs) t3(e2);
        }
        outputDefined() {
          return this.outputs.every((t3) => t3.outputDefined());
        }
      }
      function Ge2(t3, e2, r3, n3) {
        const i3 = n3 - r3, a3 = t3 - r3;
        return 0 === i3 ? 0 : 1 === e2 ? a3 / i3 : (Math.pow(e2, a3) - 1) / (Math.pow(e2, i3) - 1);
      }
      class Je {
        constructor(t3, e2) {
          this.type = t3, this.args = e2;
        }
        static parse(t3, e2) {
          if (t3.length < 2) return e2.error("Expectected at least one argument.");
          let r3 = null;
          const n3 = e2.expectedType;
          n3 && "value" !== n3.kind && (r3 = n3);
          const i3 = [];
          for (const n4 of t3.slice(1)) {
            const t4 = e2.parse(n4, 1 + i3.length, r3, void 0, { typeAnnotation: "omit" });
            if (!t4) return null;
            r3 = r3 || t4.type, i3.push(t4);
          }
          if (!r3) throw new Error("No output type");
          const a3 = n3 && i3.some((t4) => It(n3, t4.type));
          return new Je(a3 ? gt : r3, i3);
        }
        evaluate(t3) {
          let e2, r3 = null, n3 = 0;
          for (const i3 of this.args) if (n3++, r3 = i3.evaluate(t3), r3 && r3 instanceof ne2 && !r3.available && (e2 || (e2 = r3.name), r3 = null, n3 === this.args.length && (r3 = e2)), null !== r3) break;
          return r3;
        }
        eachChild(t3) {
          this.args.forEach(t3);
        }
        outputDefined() {
          return this.args.every((t3) => t3.outputDefined());
        }
      }
      class Xe {
        constructor(t3, e2) {
          this.type = e2.type, this.bindings = [].concat(t3), this.result = e2;
        }
        evaluate(t3) {
          return this.result.evaluate(t3);
        }
        eachChild(t3) {
          for (const e2 of this.bindings) t3(e2[1]);
          t3(this.result);
        }
        static parse(t3, e2) {
          if (t3.length < 4) return e2.error(`Expected at least 3 arguments, but found ${t3.length - 1} instead.`);
          const r3 = [];
          for (let n4 = 1; n4 < t3.length - 1; n4 += 2) {
            const i3 = t3[n4];
            if ("string" != typeof i3) return e2.error(`Expected string, but found ${typeof i3} instead.`, n4);
            if (/[^a-zA-Z0-9_]/.test(i3)) return e2.error("Variable names must contain only alphanumeric characters or '_'.", n4);
            const a3 = e2.parse(t3[n4 + 1], n4 + 1);
            if (!a3) return null;
            r3.push([i3, a3]);
          }
          const n3 = e2.parse(t3[t3.length - 1], t3.length - 1, e2.expectedType, r3);
          return n3 ? new Xe(r3, n3) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class Ye {
        constructor(t3, e2, r3) {
          this.type = t3, this.index = e2, this.input = r3;
        }
        static parse(t3, e2) {
          if (3 !== t3.length) return e2.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
          const r3 = e2.parse(t3[1], 1, pt), n3 = e2.parse(t3[2], 2, At(e2.expectedType || gt));
          return r3 && n3 ? new Ye(n3.type.itemType, r3, n3) : null;
        }
        evaluate(t3) {
          const e2 = this.index.evaluate(t3), r3 = this.input.evaluate(t3);
          if (e2 < 0) throw new ue2(`Array index out of bounds: ${e2} < 0.`);
          if (e2 >= r3.length) throw new ue2(`Array index out of bounds: ${e2} > ${r3.length - 1}.`);
          if (e2 !== Math.floor(e2)) throw new ue2(`Array index must be an integer, but found ${e2} instead.`);
          return r3[e2];
        }
        eachChild(t3) {
          t3(this.index), t3(this.input);
        }
        outputDefined() {
          return false;
        }
      }
      class He2 {
        constructor(t3, e2) {
          this.type = dt, this.needle = t3, this.haystack = e2;
        }
        static parse(t3, e2) {
          if (3 !== t3.length) return e2.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
          const r3 = e2.parse(t3[1], 1, gt), n3 = e2.parse(t3[2], 2, gt);
          return r3 && n3 ? zt(r3.type, [dt, ft, pt, ht, gt]) ? new He2(r3, n3) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${St(r3.type)} instead`) : null;
        }
        evaluate(t3) {
          const e2 = this.needle.evaluate(t3), r3 = this.haystack.evaluate(t3);
          if (!r3) return false;
          if (!Mt(e2, ["boolean", "string", "number", "null"])) throw new ue2(`Expected first argument to be of type boolean, string, number or null, but found ${St(se2(e2))} instead.`);
          if (!Mt(r3, ["string", "array"])) throw new ue2(`Expected second argument to be of type array or string, but found ${St(se2(r3))} instead.`);
          return r3.indexOf(e2) >= 0;
        }
        eachChild(t3) {
          t3(this.needle), t3(this.haystack);
        }
        outputDefined() {
          return true;
        }
      }
      class We2 {
        constructor(t3, e2, r3) {
          this.type = pt, this.needle = t3, this.haystack = e2, this.fromIndex = r3;
        }
        static parse(t3, e2) {
          if (t3.length <= 2 || t3.length >= 5) return e2.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
          const r3 = e2.parse(t3[1], 1, gt), n3 = e2.parse(t3[2], 2, gt);
          if (!r3 || !n3) return null;
          if (!zt(r3.type, [dt, ft, pt, ht, gt])) return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${St(r3.type)} instead`);
          if (4 === t3.length) {
            const i3 = e2.parse(t3[3], 3, pt);
            return i3 ? new We2(r3, n3, i3) : null;
          }
          return new We2(r3, n3);
        }
        evaluate(t3) {
          const e2 = this.needle.evaluate(t3), r3 = this.haystack.evaluate(t3);
          if (!Mt(e2, ["boolean", "string", "number", "null"])) throw new ue2(`Expected first argument to be of type boolean, string, number or null, but found ${St(se2(e2))} instead.`);
          if (!Mt(r3, ["string", "array"])) throw new ue2(`Expected second argument to be of type array or string, but found ${St(se2(r3))} instead.`);
          if (this.fromIndex) {
            const n3 = this.fromIndex.evaluate(t3);
            return r3.indexOf(e2, n3);
          }
          return r3.indexOf(e2);
        }
        eachChild(t3) {
          t3(this.needle), t3(this.haystack), this.fromIndex && t3(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
      }
      class Qe {
        constructor(t3, e2, r3, n3, i3, a3) {
          this.inputType = t3, this.type = e2, this.input = r3, this.cases = n3, this.outputs = i3, this.otherwise = a3;
        }
        static parse(t3, e2) {
          if (t3.length < 5) return e2.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
          if (t3.length % 2 != 1) return e2.error("Expected an even number of arguments.");
          let r3, n3;
          e2.expectedType && "value" !== e2.expectedType.kind && (n3 = e2.expectedType);
          const i3 = {}, a3 = [];
          for (let s4 = 2; s4 < t3.length - 1; s4 += 2) {
            let o4 = t3[s4];
            const l3 = t3[s4 + 1];
            Array.isArray(o4) || (o4 = [o4]);
            const u3 = e2.concat(s4);
            if (0 === o4.length) return u3.error("Expected at least one branch label.");
            for (const t4 of o4) {
              if ("number" != typeof t4 && "string" != typeof t4) return u3.error("Branch labels must be numbers or strings.");
              if ("number" == typeof t4 && Math.abs(t4) > Number.MAX_SAFE_INTEGER) return u3.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if ("number" == typeof t4 && Math.floor(t4) !== t4) return u3.error("Numeric branch labels must be integer values.");
              if (r3) {
                if (u3.checkSubtype(r3, se2(t4))) return null;
              } else r3 = se2(t4);
              if (void 0 !== i3[String(t4)]) return u3.error("Branch labels must be unique.");
              i3[String(t4)] = a3.length;
            }
            const c3 = e2.parse(l3, s4, n3);
            if (!c3) return null;
            n3 = n3 || c3.type, a3.push(c3);
          }
          const s3 = e2.parse(t3[1], 1, gt);
          if (!s3) return null;
          const o3 = e2.parse(t3[t3.length - 1], t3.length - 1, n3);
          return o3 ? "value" !== s3.type.kind && e2.concat(1).checkSubtype(r3, s3.type) ? null : new Qe(r3, n3, s3, i3, a3, o3) : null;
        }
        evaluate(t3) {
          const e2 = this.input.evaluate(t3);
          return (se2(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t3);
        }
        eachChild(t3) {
          t3(this.input), this.outputs.forEach(t3), t3(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t3) => t3.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class tr {
        constructor(t3, e2, r3) {
          this.type = t3, this.branches = e2, this.otherwise = r3;
        }
        static parse(t3, e2) {
          if (t3.length < 4) return e2.error(`Expected at least 3 arguments, but found only ${t3.length - 1}.`);
          if (t3.length % 2 != 0) return e2.error("Expected an odd number of arguments.");
          let r3;
          e2.expectedType && "value" !== e2.expectedType.kind && (r3 = e2.expectedType);
          const n3 = [];
          for (let i4 = 1; i4 < t3.length - 1; i4 += 2) {
            const a3 = e2.parse(t3[i4], i4, dt);
            if (!a3) return null;
            const s3 = e2.parse(t3[i4 + 1], i4 + 1, r3);
            if (!s3) return null;
            n3.push([a3, s3]), r3 = r3 || s3.type;
          }
          const i3 = e2.parse(t3[t3.length - 1], t3.length - 1, r3);
          if (!i3) return null;
          if (!r3) throw new Error("Can't infer output type");
          return new tr(r3, n3, i3);
        }
        evaluate(t3) {
          for (const [e2, r3] of this.branches) if (e2.evaluate(t3)) return r3.evaluate(t3);
          return this.otherwise.evaluate(t3);
        }
        eachChild(t3) {
          for (const [e2, r3] of this.branches) t3(e2), t3(r3);
          t3(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t3, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class er {
        constructor(t3, e2, r3, n3) {
          this.type = t3, this.input = e2, this.beginIndex = r3, this.endIndex = n3;
        }
        static parse(t3, e2) {
          if (t3.length <= 2 || t3.length >= 5) return e2.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
          const r3 = e2.parse(t3[1], 1, gt), n3 = e2.parse(t3[2], 2, pt);
          if (!r3 || !n3) return null;
          if (!zt(r3.type, [At(gt), ft, gt])) return e2.error(`Expected first argument to be of type array or string, but found ${St(r3.type)} instead`);
          if (4 === t3.length) {
            const i3 = e2.parse(t3[3], 3, pt);
            return i3 ? new er(r3.type, r3, n3, i3) : null;
          }
          return new er(r3.type, r3, n3);
        }
        evaluate(t3) {
          const e2 = this.input.evaluate(t3), r3 = this.beginIndex.evaluate(t3);
          if (!Mt(e2, ["string", "array"])) throw new ue2(`Expected first argument to be of type array or string, but found ${St(se2(e2))} instead.`);
          if (this.endIndex) {
            const n3 = this.endIndex.evaluate(t3);
            return e2.slice(r3, n3);
          }
          return e2.slice(r3);
        }
        eachChild(t3) {
          t3(this.input), t3(this.beginIndex), this.endIndex && t3(this.endIndex);
        }
        outputDefined() {
          return false;
        }
      }
      function rr(t3, e2) {
        return "==" === t3 || "!=" === t3 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
      }
      function nr(t3, e2, r3, n3) {
        return 0 === n3.compare(e2, r3);
      }
      function ir(t3, e2, r3) {
        const n3 = "==" !== t3 && "!=" !== t3;
        return class i3 {
          constructor(t4, e3, r4) {
            this.type = dt, this.lhs = t4, this.rhs = e3, this.collator = r4, this.hasUntypedArgument = "value" === t4.type.kind || "value" === e3.type.kind;
          }
          static parse(t4, e3) {
            if (3 !== t4.length && 4 !== t4.length) return e3.error("Expected two or three arguments.");
            const r4 = t4[0];
            let a3 = e3.parse(t4[1], 1, gt);
            if (!a3) return null;
            if (!rr(r4, a3.type)) return e3.concat(1).error(`"${r4}" comparisons are not supported for type '${St(a3.type)}'.`);
            let s3 = e3.parse(t4[2], 2, gt);
            if (!s3) return null;
            if (!rr(r4, s3.type)) return e3.concat(2).error(`"${r4}" comparisons are not supported for type '${St(s3.type)}'.`);
            if (a3.type.kind !== s3.type.kind && "value" !== a3.type.kind && "value" !== s3.type.kind) return e3.error(`Cannot compare types '${St(a3.type)}' and '${St(s3.type)}'.`);
            n3 && ("value" === a3.type.kind && "value" !== s3.type.kind ? a3 = new he2(s3.type, [a3]) : "value" !== a3.type.kind && "value" === s3.type.kind && (s3 = new he2(a3.type, [s3])));
            let o3 = null;
            if (4 === t4.length) {
              if ("string" !== a3.type.kind && "string" !== s3.type.kind && "value" !== a3.type.kind && "value" !== s3.type.kind) return e3.error("Cannot use collator to compare non-string types.");
              if (o3 = e3.parse(t4[3], 3, xt), !o3) return null;
            }
            return new i3(a3, s3, o3);
          }
          evaluate(i4) {
            const a3 = this.lhs.evaluate(i4), s3 = this.rhs.evaluate(i4);
            if (n3 && this.hasUntypedArgument) {
              const e3 = se2(a3), r4 = se2(s3);
              if (e3.kind !== r4.kind || "string" !== e3.kind && "number" !== e3.kind) throw new ue2(`Expected arguments for "${t3}" to be (string, string) or (number, number), but found (${e3.kind}, ${r4.kind}) instead.`);
            }
            if (this.collator && !n3 && this.hasUntypedArgument) {
              const t4 = se2(a3), r4 = se2(s3);
              if ("string" !== t4.kind || "string" !== r4.kind) return e2(i4, a3, s3);
            }
            return this.collator ? r3(i4, a3, s3, this.collator.evaluate(i4)) : e2(i4, a3, s3);
          }
          eachChild(t4) {
            t4(this.lhs), t4(this.rhs), this.collator && t4(this.collator);
          }
          outputDefined() {
            return true;
          }
        };
      }
      const ar = ir("==", function(t3, e2, r3) {
        return e2 === r3;
      }, nr), sr = ir("!=", function(t3, e2, r3) {
        return e2 !== r3;
      }, function(t3, e2, r3, n3) {
        return !nr(0, e2, r3, n3);
      }), or = ir("<", function(t3, e2, r3) {
        return e2 < r3;
      }, function(t3, e2, r3, n3) {
        return n3.compare(e2, r3) < 0;
      }), lr = ir(">", function(t3, e2, r3) {
        return e2 > r3;
      }, function(t3, e2, r3, n3) {
        return n3.compare(e2, r3) > 0;
      }), ur = ir("<=", function(t3, e2, r3) {
        return e2 <= r3;
      }, function(t3, e2, r3, n3) {
        return n3.compare(e2, r3) <= 0;
      }), cr = ir(">=", function(t3, e2, r3) {
        return e2 >= r3;
      }, function(t3, e2, r3, n3) {
        return n3.compare(e2, r3) >= 0;
      });
      class hr {
        constructor(t3, e2, r3, n3, i3) {
          this.type = ft, this.number = t3, this.locale = e2, this.currency = r3, this.minFractionDigits = n3, this.maxFractionDigits = i3;
        }
        static parse(t3, e2) {
          if (3 !== t3.length) return e2.error("Expected two arguments.");
          const r3 = e2.parse(t3[1], 1, pt);
          if (!r3) return null;
          const n3 = t3[2];
          if ("object" != typeof n3 || Array.isArray(n3)) return e2.error("NumberFormat options argument must be an object.");
          let i3 = null;
          if (n3.locale && (i3 = e2.parse(n3.locale, 1, ft), !i3)) return null;
          let a3 = null;
          if (n3.currency && (a3 = e2.parse(n3.currency, 1, ft), !a3)) return null;
          let s3 = null;
          if (n3["min-fraction-digits"] && (s3 = e2.parse(n3["min-fraction-digits"], 1, pt), !s3)) return null;
          let o3 = null;
          return n3["max-fraction-digits"] && (o3 = e2.parse(n3["max-fraction-digits"], 1, pt), !o3) ? null : new hr(r3, i3, a3, s3, o3);
        }
        evaluate(t3) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t3) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t3) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t3) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t3) : void 0 }).format(this.number.evaluate(t3));
        }
        eachChild(t3) {
          t3(this.number), this.locale && t3(this.locale), this.currency && t3(this.currency), this.minFractionDigits && t3(this.minFractionDigits), this.maxFractionDigits && t3(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
      }
      class pr {
        constructor(t3) {
          this.type = vt, this.sections = t3;
        }
        static parse(t3, e2) {
          if (t3.length < 2) return e2.error("Expected at least one argument.");
          const r3 = t3[1];
          if (!Array.isArray(r3) && "object" == typeof r3) return e2.error("First argument must be an image or text section.");
          const n3 = [];
          let i3 = false;
          for (let r4 = 1; r4 <= t3.length - 1; ++r4) {
            const a3 = t3[r4];
            if (i3 && "object" == typeof a3 && !Array.isArray(a3)) {
              i3 = false;
              let t4 = null;
              if (a3["font-scale"] && (t4 = e2.parse(a3["font-scale"], 1, pt), !t4)) return null;
              let r5 = null;
              if (a3["text-font"] && (r5 = e2.parse(a3["text-font"], 1, At(ft)), !r5)) return null;
              let s3 = null;
              if (a3["text-color"] && (s3 = e2.parse(a3["text-color"], 1, yt), !s3)) return null;
              const o3 = n3[n3.length - 1];
              o3.scale = t4, o3.font = r5, o3.textColor = s3;
            } else {
              const a4 = e2.parse(t3[r4], 1, gt);
              if (!a4) return null;
              const s3 = a4.type.kind;
              if ("string" !== s3 && "value" !== s3 && "null" !== s3 && "resolvedImage" !== s3) return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              i3 = true, n3.push({ content: a4, scale: null, font: null, textColor: null });
            }
          }
          return new pr(n3);
        }
        evaluate(t3) {
          return new Qt(this.sections.map((e2) => {
            const r3 = e2.content.evaluate(t3);
            return se2(r3) === wt ? new Wt("", r3, null, null, null) : new Wt(oe2(r3), null, e2.scale ? e2.scale.evaluate(t3) : null, e2.font ? e2.font.evaluate(t3).join(",") : null, e2.textColor ? e2.textColor.evaluate(t3) : null);
          }));
        }
        eachChild(t3) {
          for (const e2 of this.sections) t3(e2.content), e2.scale && t3(e2.scale), e2.font && t3(e2.font), e2.textColor && t3(e2.textColor);
        }
        outputDefined() {
          return false;
        }
      }
      class fr {
        constructor(t3) {
          this.type = wt, this.input = t3;
        }
        static parse(t3, e2) {
          if (2 !== t3.length) return e2.error("Expected two arguments.");
          const r3 = e2.parse(t3[1], 1, ft);
          return r3 ? new fr(r3) : e2.error("No image name provided.");
        }
        evaluate(t3) {
          const e2 = this.input.evaluate(t3), r3 = ne2.fromString(e2);
          return r3 && t3.availableImages && (r3.available = t3.availableImages.indexOf(e2) > -1), r3;
        }
        eachChild(t3) {
          t3(this.input);
        }
        outputDefined() {
          return false;
        }
      }
      class dr {
        constructor(t3) {
          this.type = pt, this.input = t3;
        }
        static parse(t3, e2) {
          if (2 !== t3.length) return e2.error(`Expected 1 argument, but found ${t3.length - 1} instead.`);
          const r3 = e2.parse(t3[1], 1);
          return r3 ? "array" !== r3.type.kind && "string" !== r3.type.kind && "value" !== r3.type.kind ? e2.error(`Expected argument of type string or array, but found ${St(r3.type)} instead.`) : new dr(r3) : null;
        }
        evaluate(t3) {
          const e2 = this.input.evaluate(t3);
          if ("string" == typeof e2) return e2.length;
          if (Array.isArray(e2)) return e2.length;
          throw new ue2(`Expected value to be of type string or array, but found ${St(se2(e2))} instead.`);
        }
        eachChild(t3) {
          t3(this.input);
        }
        outputDefined() {
          return false;
        }
      }
      const yr = { "==": ar, "!=": sr, ">": lr, "<": or, ">=": cr, "<=": ur, array: he2, at: Ye, boolean: he2, case: tr, coalesce: Je, collator: ge2, format: pr, image: fr, in: He2, "index-of": We2, interpolate: Ke, "interpolate-hcl": Ke, "interpolate-lab": Ke, length: dr, let: Xe, literal: le2, match: Qe, number: he2, "number-format": hr, object: he2, slice: er, step: qe, string: he2, "to-boolean": fe2, "to-color": fe2, "to-number": fe2, "to-string": fe2, var: Te2, within: Fe2 };
      function mr(t3, [e2, r3, n3, i3]) {
        e2 = e2.evaluate(t3), r3 = r3.evaluate(t3), n3 = n3.evaluate(t3);
        const a3 = i3 ? i3.evaluate(t3) : 1, s3 = ie2(e2, r3, n3, a3);
        if (s3) throw new ue2(s3);
        return new Yt(e2 / 255, r3 / 255, n3 / 255, a3, false);
      }
      function gr(t3, e2) {
        return t3 in e2;
      }
      function xr(t3, e2) {
        const r3 = e2[t3];
        return void 0 === r3 ? null : r3;
      }
      function vr(t3) {
        return { type: t3 };
      }
      function br(t3) {
        return { result: "success", value: t3 };
      }
      function wr(t3) {
        return { result: "error", value: t3 };
      }
      function _r(t3) {
        return "data-driven" === t3["property-type"] || "cross-faded-data-driven" === t3["property-type"];
      }
      function Ar(t3) {
        return !!t3.expression && t3.expression.parameters.indexOf("zoom") > -1;
      }
      function Sr(t3) {
        return !!t3.expression && t3.expression.interpolated;
      }
      function kr(t3) {
        return t3 instanceof Number ? "number" : t3 instanceof String ? "string" : t3 instanceof Boolean ? "boolean" : Array.isArray(t3) ? "array" : null === t3 ? "null" : typeof t3;
      }
      function Ir(t3) {
        return "object" == typeof t3 && null !== t3 && !Array.isArray(t3);
      }
      function zr(t3) {
        return t3;
      }
      function Mr(t3, e2) {
        const r3 = "color" === e2.type, n3 = t3.stops && "object" == typeof t3.stops[0][0], i3 = n3 || !(n3 || void 0 !== t3.property), a3 = t3.type || (Sr(e2) ? "exponential" : "interval");
        if (r3 || "padding" === e2.type) {
          const n4 = r3 ? Yt.parse : te2.parse;
          (t3 = lt({}, t3)).stops && (t3.stops = t3.stops.map((t4) => [t4[0], n4(t4[1])])), t3.default = n4(t3.default ? t3.default : e2.default);
        }
        if (t3.colorSpace && "rgb" !== (s3 = t3.colorSpace) && "hcl" !== s3 && "lab" !== s3) throw new Error(`Unknown color space: "${t3.colorSpace}"`);
        var s3;
        let o3, l3, u3;
        if ("exponential" === a3) o3 = Vr;
        else if ("interval" === a3) o3 = Pr;
        else if ("categorical" === a3) {
          o3 = Br, l3 = /* @__PURE__ */ Object.create(null);
          for (const e3 of t3.stops) l3[e3[0]] = e3[1];
          u3 = typeof t3.stops[0][0];
        } else {
          if ("identity" !== a3) throw new Error(`Unknown function type "${a3}"`);
          o3 = Er;
        }
        if (n3) {
          const r4 = {}, n4 = [];
          for (let e3 = 0; e3 < t3.stops.length; e3++) {
            const i5 = t3.stops[e3], a5 = i5[0].zoom;
            void 0 === r4[a5] && (r4[a5] = { zoom: a5, type: t3.type, property: t3.property, default: t3.default, stops: [] }, n4.push(a5)), r4[a5].stops.push([i5[0].value, i5[1]]);
          }
          const i4 = [];
          for (const t4 of n4) i4.push([r4[t4].zoom, Mr(r4[t4], e2)]);
          const a4 = { name: "linear" };
          return { kind: "composite", interpolationType: a4, interpolationFactor: Ke.interpolationFactor.bind(void 0, a4), zoomStops: i4.map((t4) => t4[0]), evaluate: ({ zoom: r5 }, n5) => Vr({ stops: i4, base: t3.base }, e2, r5).evaluate(r5, n5) };
        }
        if (i3) {
          const r4 = "exponential" === a3 ? { name: "exponential", base: void 0 !== t3.base ? t3.base : 1 } : null;
          return { kind: "camera", interpolationType: r4, interpolationFactor: Ke.interpolationFactor.bind(void 0, r4), zoomStops: t3.stops.map((t4) => t4[0]), evaluate: ({ zoom: r5 }) => o3(t3, e2, r5, l3, u3) };
        }
        return { kind: "source", evaluate(r4, n4) {
          const i4 = n4 && n4.properties ? n4.properties[t3.property] : void 0;
          return void 0 === i4 ? Cr(t3.default, e2.default) : o3(t3, e2, i4, l3, u3);
        } };
      }
      function Cr(t3, e2, r3) {
        return void 0 !== t3 ? t3 : void 0 !== e2 ? e2 : void 0 !== r3 ? r3 : void 0;
      }
      function Br(t3, e2, r3, n3, i3) {
        return Cr(typeof r3 === i3 ? n3[r3] : void 0, t3.default, e2.default);
      }
      function Pr(t3, e2, r3) {
        if ("number" !== kr(r3)) return Cr(t3.default, e2.default);
        const n3 = t3.stops.length;
        if (1 === n3) return t3.stops[0][1];
        if (r3 <= t3.stops[0][0]) return t3.stops[0][1];
        if (r3 >= t3.stops[n3 - 1][0]) return t3.stops[n3 - 1][1];
        const i3 = Re2(t3.stops.map((t4) => t4[0]), r3);
        return t3.stops[i3][1];
      }
      function Vr(t3, e2, r3) {
        const n3 = void 0 !== t3.base ? t3.base : 1;
        if ("number" !== kr(r3)) return Cr(t3.default, e2.default);
        const i3 = t3.stops.length;
        if (1 === i3) return t3.stops[0][1];
        if (r3 <= t3.stops[0][0]) return t3.stops[0][1];
        if (r3 >= t3.stops[i3 - 1][0]) return t3.stops[i3 - 1][1];
        const a3 = Re2(t3.stops.map((t4) => t4[0]), r3), s3 = function(t4, e3, r4, n4) {
          const i4 = n4 - r4, a4 = t4 - r4;
          return 0 === i4 ? 0 : 1 === e3 ? a4 / i4 : (Math.pow(e3, a4) - 1) / (Math.pow(e3, i4) - 1);
        }(r3, n3, t3.stops[a3][0], t3.stops[a3 + 1][0]), o3 = t3.stops[a3][1], l3 = t3.stops[a3 + 1][1], u3 = Ze2[e2.type] || zr;
        return "function" == typeof o3.evaluate ? { evaluate(...e3) {
          const r4 = o3.evaluate.apply(void 0, e3), n4 = l3.evaluate.apply(void 0, e3);
          if (void 0 !== r4 && void 0 !== n4) return u3(r4, n4, s3, t3.colorSpace);
        } } : u3(o3, l3, s3, t3.colorSpace);
      }
      function Er(t3, e2, r3) {
        switch (e2.type) {
          case "color":
            r3 = Yt.parse(r3);
            break;
          case "formatted":
            r3 = Qt.fromString(r3.toString());
            break;
          case "resolvedImage":
            r3 = ne2.fromString(r3.toString());
            break;
          case "padding":
            r3 = te2.parse(r3);
            break;
          default:
            kr(r3) === e2.type || "enum" === e2.type && e2.values[r3] || (r3 = void 0);
        }
        return Cr(r3, t3.default, e2.default);
      }
      $e2.register(yr, { error: [{ kind: "error" }, [ft], (t3, [e2]) => {
        throw new ue2(e2.evaluate(t3));
      }], typeof: [ft, [gt], (t3, [e2]) => St(se2(e2.evaluate(t3)))], "to-rgba": [At(pt, 4), [yt], (t3, [e2]) => {
        const [r3, n3, i3, a3] = e2.evaluate(t3).rgb;
        return [255 * r3, 255 * n3, 255 * i3, a3];
      }], rgb: [yt, [pt, pt, pt], mr], rgba: [yt, [pt, pt, pt, pt], mr], has: { type: dt, overloads: [[[ft], (t3, [e2]) => gr(e2.evaluate(t3), t3.properties())], [[ft, mt], (t3, [e2, r3]) => gr(e2.evaluate(t3), r3.evaluate(t3))]] }, get: { type: gt, overloads: [[[ft], (t3, [e2]) => xr(e2.evaluate(t3), t3.properties())], [[ft, mt], (t3, [e2, r3]) => xr(e2.evaluate(t3), r3.evaluate(t3))]] }, "feature-state": [gt, [ft], (t3, [e2]) => xr(e2.evaluate(t3), t3.featureState || {})], properties: [mt, [], (t3) => t3.properties()], "geometry-type": [ft, [], (t3) => t3.geometryType()], id: [gt, [], (t3) => t3.id()], zoom: [pt, [], (t3) => t3.globals.zoom], "heatmap-density": [pt, [], (t3) => t3.globals.heatmapDensity || 0], "line-progress": [pt, [], (t3) => t3.globals.lineProgress || 0], accumulated: [gt, [], (t3) => void 0 === t3.globals.accumulated ? null : t3.globals.accumulated], "+": [pt, vr(pt), (t3, e2) => {
        let r3 = 0;
        for (const n3 of e2) r3 += n3.evaluate(t3);
        return r3;
      }], "*": [pt, vr(pt), (t3, e2) => {
        let r3 = 1;
        for (const n3 of e2) r3 *= n3.evaluate(t3);
        return r3;
      }], "-": { type: pt, overloads: [[[pt, pt], (t3, [e2, r3]) => e2.evaluate(t3) - r3.evaluate(t3)], [[pt], (t3, [e2]) => -e2.evaluate(t3)]] }, "/": [pt, [pt, pt], (t3, [e2, r3]) => e2.evaluate(t3) / r3.evaluate(t3)], "%": [pt, [pt, pt], (t3, [e2, r3]) => e2.evaluate(t3) % r3.evaluate(t3)], ln2: [pt, [], () => Math.LN2], pi: [pt, [], () => Math.PI], e: [pt, [], () => Math.E], "^": [pt, [pt, pt], (t3, [e2, r3]) => Math.pow(e2.evaluate(t3), r3.evaluate(t3))], sqrt: [pt, [pt], (t3, [e2]) => Math.sqrt(e2.evaluate(t3))], log10: [pt, [pt], (t3, [e2]) => Math.log(e2.evaluate(t3)) / Math.LN10], ln: [pt, [pt], (t3, [e2]) => Math.log(e2.evaluate(t3))], log2: [pt, [pt], (t3, [e2]) => Math.log(e2.evaluate(t3)) / Math.LN2], sin: [pt, [pt], (t3, [e2]) => Math.sin(e2.evaluate(t3))], cos: [pt, [pt], (t3, [e2]) => Math.cos(e2.evaluate(t3))], tan: [pt, [pt], (t3, [e2]) => Math.tan(e2.evaluate(t3))], asin: [pt, [pt], (t3, [e2]) => Math.asin(e2.evaluate(t3))], acos: [pt, [pt], (t3, [e2]) => Math.acos(e2.evaluate(t3))], atan: [pt, [pt], (t3, [e2]) => Math.atan(e2.evaluate(t3))], min: [pt, vr(pt), (t3, e2) => Math.min(...e2.map((e3) => e3.evaluate(t3)))], max: [pt, vr(pt), (t3, e2) => Math.max(...e2.map((e3) => e3.evaluate(t3)))], abs: [pt, [pt], (t3, [e2]) => Math.abs(e2.evaluate(t3))], round: [pt, [pt], (t3, [e2]) => {
        const r3 = e2.evaluate(t3);
        return r3 < 0 ? -Math.round(-r3) : Math.round(r3);
      }], floor: [pt, [pt], (t3, [e2]) => Math.floor(e2.evaluate(t3))], ceil: [pt, [pt], (t3, [e2]) => Math.ceil(e2.evaluate(t3))], "filter-==": [dt, [ft, gt], (t3, [e2, r3]) => t3.properties()[e2.value] === r3.value], "filter-id-==": [dt, [gt], (t3, [e2]) => t3.id() === e2.value], "filter-type-==": [dt, [ft], (t3, [e2]) => t3.geometryType() === e2.value], "filter-<": [dt, [ft, gt], (t3, [e2, r3]) => {
        const n3 = t3.properties()[e2.value], i3 = r3.value;
        return typeof n3 == typeof i3 && n3 < i3;
      }], "filter-id-<": [dt, [gt], (t3, [e2]) => {
        const r3 = t3.id(), n3 = e2.value;
        return typeof r3 == typeof n3 && r3 < n3;
      }], "filter->": [dt, [ft, gt], (t3, [e2, r3]) => {
        const n3 = t3.properties()[e2.value], i3 = r3.value;
        return typeof n3 == typeof i3 && n3 > i3;
      }], "filter-id->": [dt, [gt], (t3, [e2]) => {
        const r3 = t3.id(), n3 = e2.value;
        return typeof r3 == typeof n3 && r3 > n3;
      }], "filter-<=": [dt, [ft, gt], (t3, [e2, r3]) => {
        const n3 = t3.properties()[e2.value], i3 = r3.value;
        return typeof n3 == typeof i3 && n3 <= i3;
      }], "filter-id-<=": [dt, [gt], (t3, [e2]) => {
        const r3 = t3.id(), n3 = e2.value;
        return typeof r3 == typeof n3 && r3 <= n3;
      }], "filter->=": [dt, [ft, gt], (t3, [e2, r3]) => {
        const n3 = t3.properties()[e2.value], i3 = r3.value;
        return typeof n3 == typeof i3 && n3 >= i3;
      }], "filter-id->=": [dt, [gt], (t3, [e2]) => {
        const r3 = t3.id(), n3 = e2.value;
        return typeof r3 == typeof n3 && r3 >= n3;
      }], "filter-has": [dt, [gt], (t3, [e2]) => e2.value in t3.properties()], "filter-has-id": [dt, [], (t3) => null !== t3.id() && void 0 !== t3.id()], "filter-type-in": [dt, [At(ft)], (t3, [e2]) => e2.value.indexOf(t3.geometryType()) >= 0], "filter-id-in": [dt, [At(gt)], (t3, [e2]) => e2.value.indexOf(t3.id()) >= 0], "filter-in-small": [dt, [ft, At(gt)], (t3, [e2, r3]) => r3.value.indexOf(t3.properties()[e2.value]) >= 0], "filter-in-large": [dt, [ft, At(gt)], (t3, [e2, r3]) => function(t4, e3, r4, n3) {
        for (; r4 <= n3; ) {
          const i3 = r4 + n3 >> 1;
          if (e3[i3] === t4) return true;
          e3[i3] > t4 ? n3 = i3 - 1 : r4 = i3 + 1;
        }
        return false;
      }(t3.properties()[e2.value], r3.value, 0, r3.value.length - 1)], all: { type: dt, overloads: [[[dt, dt], (t3, [e2, r3]) => e2.evaluate(t3) && r3.evaluate(t3)], [vr(dt), (t3, e2) => {
        for (const r3 of e2) if (!r3.evaluate(t3)) return false;
        return true;
      }]] }, any: { type: dt, overloads: [[[dt, dt], (t3, [e2, r3]) => e2.evaluate(t3) || r3.evaluate(t3)], [vr(dt), (t3, e2) => {
        for (const r3 of e2) if (r3.evaluate(t3)) return true;
        return false;
      }]] }, "!": [dt, [dt], (t3, [e2]) => !e2.evaluate(t3)], "is-supported-script": [dt, [ft], (t3, [e2]) => {
        const r3 = t3.globals && t3.globals.isSupportedScript;
        return !r3 || r3(e2.evaluate(t3));
      }], upcase: [ft, [ft], (t3, [e2]) => e2.evaluate(t3).toUpperCase()], downcase: [ft, [ft], (t3, [e2]) => e2.evaluate(t3).toLowerCase()], concat: [ft, vr(gt), (t3, e2) => e2.map((e3) => oe2(e3.evaluate(t3))).join("")], "resolved-locale": [ft, [xt], (t3, [e2]) => e2.evaluate(t3).resolvedLocale()] });
      class Fr {
        constructor(t3, e2) {
          var r3;
          this.expression = t3, this._warningHistory = {}, this._evaluator = new ye2(), this._defaultValue = e2 ? "color" === (r3 = e2).type && Ir(r3.default) ? new Yt(0, 0, 0, 0) : "color" === r3.type ? Yt.parse(r3.default) || null : "padding" === r3.type ? te2.parse(r3.default) || null : "variableAnchorOffsetCollection" === r3.type ? re2.parse(r3.default) || null : void 0 === r3.default ? null : r3.default : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
        }
        evaluateWithoutErrorHandling(t3, e2, r3, n3, i3, a3) {
          return this._evaluator.globals = t3, this._evaluator.feature = e2, this._evaluator.featureState = r3, this._evaluator.canonical = n3, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = a3, this.expression.evaluate(this._evaluator);
        }
        evaluate(t3, e2, r3, n3, i3, a3) {
          this._evaluator.globals = t3, this._evaluator.feature = e2 || null, this._evaluator.featureState = r3 || null, this._evaluator.canonical = n3, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = a3 || null;
          try {
            const t4 = this.expression.evaluate(this._evaluator);
            if (null == t4 || "number" == typeof t4 && t4 != t4) return this._defaultValue;
            if (this._enumValues && !(t4 in this._enumValues)) throw new ue2(`Expected value to be one of ${Object.keys(this._enumValues).map((t5) => JSON.stringify(t5)).join(", ")}, but found ${JSON.stringify(t4)} instead.`);
            return t4;
          } catch (t4) {
            return this._warningHistory[t4.message] || (this._warningHistory[t4.message] = true, "undefined" != typeof console && console.warn(t4.message)), this._defaultValue;
          }
        }
      }
      function Tr(t3) {
        return Array.isArray(t3) && t3.length > 0 && "string" == typeof t3[0] && t3[0] in yr;
      }
      function $r(t3, e2) {
        const r3 = new me2(yr, Le2, [], e2 ? function(t4) {
          const e3 = { color: yt, string: ft, number: pt, enum: ft, boolean: dt, formatted: vt, padding: bt, resolvedImage: wt, variableAnchorOffsetCollection: _t };
          return "array" === t4.type ? At(e3[t4.value] || gt, t4.length) : e3[t4.type];
        }(e2) : void 0), n3 = r3.parse(t3, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
        return n3 ? br(new Fr(n3, e2)) : wr(r3.errors);
      }
      class Lr {
        constructor(t3, e2) {
          this.kind = t3, this._styleExpression = e2, this.isStateDependent = "constant" !== t3 && !Oe2(e2.expression);
        }
        evaluateWithoutErrorHandling(t3, e2, r3, n3, i3, a3) {
          return this._styleExpression.evaluateWithoutErrorHandling(t3, e2, r3, n3, i3, a3);
        }
        evaluate(t3, e2, r3, n3, i3, a3) {
          return this._styleExpression.evaluate(t3, e2, r3, n3, i3, a3);
        }
      }
      class Dr {
        constructor(t3, e2, r3, n3) {
          this.kind = t3, this.zoomStops = r3, this._styleExpression = e2, this.isStateDependent = "camera" !== t3 && !Oe2(e2.expression), this.interpolationType = n3;
        }
        evaluateWithoutErrorHandling(t3, e2, r3, n3, i3, a3) {
          return this._styleExpression.evaluateWithoutErrorHandling(t3, e2, r3, n3, i3, a3);
        }
        evaluate(t3, e2, r3, n3, i3, a3) {
          return this._styleExpression.evaluate(t3, e2, r3, n3, i3, a3);
        }
        interpolationFactor(t3, e2, r3) {
          return this.interpolationType ? Ke.interpolationFactor(this.interpolationType, t3, e2, r3) : 0;
        }
      }
      function Or(t3, e2) {
        const r3 = $r(t3, e2);
        if ("error" === r3.result) return r3;
        const n3 = r3.value.expression, i3 = De2(n3);
        if (!i3 && !_r(e2)) return wr([new ut("", "data expressions not supported")]);
        const a3 = Ue2(n3, ["zoom"]);
        if (!a3 && !Ar(e2)) return wr([new ut("", "zoom expressions not supported")]);
        const s3 = Rr(n3);
        return s3 || a3 ? s3 instanceof ut ? wr([s3]) : s3 instanceof Ke && !Sr(e2) ? wr([new ut("", '"interpolate" expressions cannot be used with this property')]) : br(s3 ? new Dr(i3 ? "camera" : "composite", r3.value, s3.labels, s3 instanceof Ke ? s3.interpolation : void 0) : new Lr(i3 ? "constant" : "source", r3.value)) : wr([new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class Ur {
        constructor(t3, e2) {
          this._parameters = t3, this._specification = e2, lt(this, Mr(this._parameters, this._specification));
        }
        static deserialize(t3) {
          return new Ur(t3._parameters, t3._specification);
        }
        static serialize(t3) {
          return { _parameters: t3._parameters, _specification: t3._specification };
        }
      }
      function Rr(t3) {
        let e2 = null;
        if (t3 instanceof Xe) e2 = Rr(t3.result);
        else if (t3 instanceof Je) {
          for (const r3 of t3.args) if (e2 = Rr(r3), e2) break;
        } else (t3 instanceof qe || t3 instanceof Ke) && t3.input instanceof $e2 && "zoom" === t3.input.name && (e2 = t3);
        return e2 instanceof ut || t3.eachChild((t4) => {
          const r3 = Rr(t4);
          r3 instanceof ut ? e2 = r3 : !e2 && r3 ? e2 = new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r3 && e2 !== r3 && (e2 = new ut("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e2;
      }
      function qr(t3) {
        if (true === t3 || false === t3) return true;
        if (!Array.isArray(t3) || 0 === t3.length) return false;
        switch (t3[0]) {
          case "has":
            return t3.length >= 2 && "$id" !== t3[1] && "$type" !== t3[1];
          case "in":
            return t3.length >= 3 && ("string" != typeof t3[1] || Array.isArray(t3[2]));
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return 3 !== t3.length || Array.isArray(t3[1]) || Array.isArray(t3[2]);
          case "any":
          case "all":
            for (const e2 of t3.slice(1)) if (!qr(e2) && "boolean" != typeof e2) return false;
            return true;
          default:
            return true;
        }
      }
      const jr = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
      function Nr(t3) {
        if (null == t3) return { filter: () => true, needGeometry: false };
        qr(t3) || (t3 = Gr(t3));
        const e2 = $r(t3, jr);
        if ("error" === e2.result) throw new Error(e2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
        return { filter: (t4, r3, n3) => e2.value.evaluate(t4, r3, {}, n3), needGeometry: Kr(t3) };
      }
      function Zr(t3, e2) {
        return t3 < e2 ? -1 : t3 > e2 ? 1 : 0;
      }
      function Kr(t3) {
        if (!Array.isArray(t3)) return false;
        if ("within" === t3[0]) return true;
        for (let e2 = 1; e2 < t3.length; e2++) if (Kr(t3[e2])) return true;
        return false;
      }
      function Gr(t3) {
        if (!t3) return true;
        const e2 = t3[0];
        return t3.length <= 1 ? "any" !== e2 : "==" === e2 ? Jr(t3[1], t3[2], "==") : "!=" === e2 ? Hr(Jr(t3[1], t3[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? Jr(t3[1], t3[2], e2) : "any" === e2 ? (r3 = t3.slice(1), ["any"].concat(r3.map(Gr))) : "all" === e2 ? ["all"].concat(t3.slice(1).map(Gr)) : "none" === e2 ? ["all"].concat(t3.slice(1).map(Gr).map(Hr)) : "in" === e2 ? Xr(t3[1], t3.slice(2)) : "!in" === e2 ? Hr(Xr(t3[1], t3.slice(2))) : "has" === e2 ? Yr(t3[1]) : "!has" === e2 ? Hr(Yr(t3[1])) : "within" !== e2 || t3;
        var r3;
      }
      function Jr(t3, e2, r3) {
        switch (t3) {
          case "$type":
            return [`filter-type-${r3}`, e2];
          case "$id":
            return [`filter-id-${r3}`, e2];
          default:
            return [`filter-${r3}`, t3, e2];
        }
      }
      function Xr(t3, e2) {
        if (0 === e2.length) return false;
        switch (t3) {
          case "$type":
            return ["filter-type-in", ["literal", e2]];
          case "$id":
            return ["filter-id-in", ["literal", e2]];
          default:
            return e2.length > 200 && !e2.some((t4) => typeof t4 != typeof e2[0]) ? ["filter-in-large", t3, ["literal", e2.sort(Zr)]] : ["filter-in-small", t3, ["literal", e2]];
        }
      }
      function Yr(t3) {
        switch (t3) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", t3];
        }
      }
      function Hr(t3) {
        return ["!", t3];
      }
      function Wr(t3) {
        const e2 = typeof t3;
        if ("number" === e2 || "boolean" === e2 || "string" === e2 || null == t3) return JSON.stringify(t3);
        if (Array.isArray(t3)) {
          let e3 = "[";
          for (const r4 of t3) e3 += `${Wr(r4)},`;
          return `${e3}]`;
        }
        const r3 = Object.keys(t3).sort();
        let n3 = "{";
        for (let e3 = 0; e3 < r3.length; e3++) n3 += `${JSON.stringify(r3[e3])}:${Wr(t3[r3[e3]])},`;
        return `${n3}}`;
      }
      function Qr(t3) {
        let e2 = "";
        for (const r3 of Y2) e2 += `/${Wr(t3[r3])}`;
        return e2;
      }
      function tn(t3) {
        const e2 = t3.value;
        return e2 ? [new ot(t3.key, e2, "constants have been deprecated as of v8")] : [];
      }
      function en(t3) {
        return t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean ? t3.valueOf() : t3;
      }
      function rn(t3) {
        if (Array.isArray(t3)) return t3.map(rn);
        if (t3 instanceof Object && !(t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean)) {
          const e2 = {};
          for (const r3 in t3) e2[r3] = rn(t3[r3]);
          return e2;
        }
        return en(t3);
      }
      function nn(t3) {
        const e2 = t3.key, r3 = t3.value, n3 = t3.valueSpec || {}, i3 = t3.objectElementValidators || {}, a3 = t3.style, s3 = t3.styleSpec, o3 = t3.validateSpec;
        let l3 = [];
        const u3 = kr(r3);
        if ("object" !== u3) return [new ot(e2, r3, `object expected, ${u3} found`)];
        for (const t4 in r3) {
          const u4 = t4.split(".")[0], c3 = n3[u4] || n3["*"];
          let h3;
          if (i3[u4]) h3 = i3[u4];
          else if (n3[u4]) h3 = o3;
          else if (i3["*"]) h3 = i3["*"];
          else {
            if (!n3["*"]) {
              l3.push(new ot(e2, r3[t4], `unknown property "${t4}"`));
              continue;
            }
            h3 = o3;
          }
          l3 = l3.concat(h3({ key: (e2 ? `${e2}.` : e2) + t4, value: r3[t4], valueSpec: c3, style: a3, styleSpec: s3, object: r3, objectKey: t4, validateSpec: o3 }, r3));
        }
        for (const t4 in n3) i3[t4] || n3[t4].required && void 0 === n3[t4].default && void 0 === r3[t4] && l3.push(new ot(e2, r3, `missing required property "${t4}"`));
        return l3;
      }
      function an(t3) {
        const e2 = t3.value, r3 = t3.valueSpec, n3 = t3.style, i3 = t3.styleSpec, a3 = t3.key, s3 = t3.arrayElementValidator || t3.validateSpec;
        if ("array" !== kr(e2)) return [new ot(a3, e2, `array expected, ${kr(e2)} found`)];
        if (r3.length && e2.length !== r3.length) return [new ot(a3, e2, `array length ${r3.length} expected, length ${e2.length} found`)];
        if (r3["min-length"] && e2.length < r3["min-length"]) return [new ot(a3, e2, `array length at least ${r3["min-length"]} expected, length ${e2.length} found`)];
        let o3 = { type: r3.value, values: r3.values };
        i3.$version < 7 && (o3.function = r3.function), "object" === kr(r3.value) && (o3 = r3.value);
        let l3 = [];
        for (let r4 = 0; r4 < e2.length; r4++) l3 = l3.concat(s3({ array: e2, arrayIndex: r4, value: e2[r4], valueSpec: o3, validateSpec: t3.validateSpec, style: n3, styleSpec: i3, key: `${a3}[${r4}]` }));
        return l3;
      }
      function sn(t3) {
        const e2 = t3.key, r3 = t3.value, n3 = t3.valueSpec;
        let i3 = kr(r3);
        return "number" === i3 && r3 != r3 && (i3 = "NaN"), "number" !== i3 ? [new ot(e2, r3, `number expected, ${i3} found`)] : "minimum" in n3 && r3 < n3.minimum ? [new ot(e2, r3, `${r3} is less than the minimum value ${n3.minimum}`)] : "maximum" in n3 && r3 > n3.maximum ? [new ot(e2, r3, `${r3} is greater than the maximum value ${n3.maximum}`)] : [];
      }
      function on(t3) {
        const e2 = t3.valueSpec, r3 = en(t3.value.type);
        let n3, i3, a3, s3 = {};
        const o3 = "categorical" !== r3 && void 0 === t3.value.property, l3 = !o3, u3 = "array" === kr(t3.value.stops) && "array" === kr(t3.value.stops[0]) && "object" === kr(t3.value.stops[0][0]), c3 = nn({ key: t3.key, value: t3.value, valueSpec: t3.styleSpec.function, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { stops: function(t4) {
          if ("identity" === r3) return [new ot(t4.key, t4.value, 'identity function may not have a "stops" property')];
          let e3 = [];
          const n4 = t4.value;
          return e3 = e3.concat(an({ key: t4.key, value: n4, valueSpec: t4.valueSpec, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec, arrayElementValidator: h3 })), "array" === kr(n4) && 0 === n4.length && e3.push(new ot(t4.key, n4, "array must have at least one stop")), e3;
        }, default: function(t4) {
          return t4.validateSpec({ key: t4.key, value: t4.value, valueSpec: e2, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec });
        } } });
        return "identity" === r3 && o3 && c3.push(new ot(t3.key, t3.value, 'missing required property "property"')), "identity" === r3 || t3.value.stops || c3.push(new ot(t3.key, t3.value, 'missing required property "stops"')), "exponential" === r3 && t3.valueSpec.expression && !Sr(t3.valueSpec) && c3.push(new ot(t3.key, t3.value, "exponential functions not supported")), t3.styleSpec.$version >= 8 && (l3 && !_r(t3.valueSpec) ? c3.push(new ot(t3.key, t3.value, "property functions not supported")) : o3 && !Ar(t3.valueSpec) && c3.push(new ot(t3.key, t3.value, "zoom functions not supported"))), "categorical" !== r3 && !u3 || void 0 !== t3.value.property || c3.push(new ot(t3.key, t3.value, '"property" property is required')), c3;
        function h3(t4) {
          let r4 = [];
          const n4 = t4.value, o4 = t4.key;
          if ("array" !== kr(n4)) return [new ot(o4, n4, `array expected, ${kr(n4)} found`)];
          if (2 !== n4.length) return [new ot(o4, n4, `array length 2 expected, length ${n4.length} found`)];
          if (u3) {
            if ("object" !== kr(n4[0])) return [new ot(o4, n4, `object expected, ${kr(n4[0])} found`)];
            if (void 0 === n4[0].zoom) return [new ot(o4, n4, "object stop key must have zoom")];
            if (void 0 === n4[0].value) return [new ot(o4, n4, "object stop key must have value")];
            if (a3 && a3 > en(n4[0].zoom)) return [new ot(o4, n4[0].zoom, "stop zoom values must appear in ascending order")];
            en(n4[0].zoom) !== a3 && (a3 = en(n4[0].zoom), i3 = void 0, s3 = {}), r4 = r4.concat(nn({ key: `${o4}[0]`, value: n4[0], valueSpec: { zoom: {} }, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { zoom: sn, value: p3 } }));
          } else r4 = r4.concat(p3({ key: `${o4}[0]`, value: n4[0], valueSpec: {}, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec }, n4));
          return Tr(rn(n4[1])) ? r4.concat([new ot(`${o4}[1]`, n4[1], "expressions are not allowed in function stops.")]) : r4.concat(t4.validateSpec({ key: `${o4}[1]`, value: n4[1], valueSpec: e2, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec }));
        }
        function p3(t4, a4) {
          const o4 = kr(t4.value), l4 = en(t4.value), u4 = null !== t4.value ? t4.value : a4;
          if (n3) {
            if (o4 !== n3) return [new ot(t4.key, u4, `${o4} stop domain type must match previous stop domain type ${n3}`)];
          } else n3 = o4;
          if ("number" !== o4 && "string" !== o4 && "boolean" !== o4) return [new ot(t4.key, u4, "stop domain value must be a number, string, or boolean")];
          if ("number" !== o4 && "categorical" !== r3) {
            let n4 = `number expected, ${o4} found`;
            return _r(e2) && void 0 === r3 && (n4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ot(t4.key, u4, n4)];
          }
          return "categorical" !== r3 || "number" !== o4 || isFinite(l4) && Math.floor(l4) === l4 ? "categorical" !== r3 && "number" === o4 && void 0 !== i3 && l4 < i3 ? [new ot(t4.key, u4, "stop domain values must appear in ascending order")] : (i3 = l4, "categorical" === r3 && l4 in s3 ? [new ot(t4.key, u4, "stop domain values must be unique")] : (s3[l4] = true, [])) : [new ot(t4.key, u4, `integer expected, found ${l4}`)];
        }
      }
      function ln(t3) {
        const e2 = ("property" === t3.expressionContext ? Or : $r)(rn(t3.value), t3.valueSpec);
        if ("error" === e2.result) return e2.value.map((e3) => new ot(`${t3.key}${e3.key}`, t3.value, e3.message));
        const r3 = e2.value.expression || e2.value._styleExpression.expression;
        if ("property" === t3.expressionContext && "text-font" === t3.propertyKey && !r3.outputDefined()) return [new ot(t3.key, t3.value, `Invalid data expression for "${t3.propertyKey}". Output values must be contained as literals within the expression.`)];
        if ("property" === t3.expressionContext && "layout" === t3.propertyType && !Oe2(r3)) return [new ot(t3.key, t3.value, '"feature-state" data expressions are not supported with layout properties.')];
        if ("filter" === t3.expressionContext && !Oe2(r3)) return [new ot(t3.key, t3.value, '"feature-state" data expressions are not supported with filters.')];
        if (t3.expressionContext && 0 === t3.expressionContext.indexOf("cluster")) {
          if (!Ue2(r3, ["zoom", "feature-state"])) return [new ot(t3.key, t3.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if ("cluster-initial" === t3.expressionContext && !De2(r3)) return [new ot(t3.key, t3.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function un(t3) {
        const e2 = t3.key, r3 = t3.value, n3 = t3.valueSpec, i3 = [];
        return Array.isArray(n3.values) ? -1 === n3.values.indexOf(en(r3)) && i3.push(new ot(e2, r3, `expected one of [${n3.values.join(", ")}], ${JSON.stringify(r3)} found`)) : -1 === Object.keys(n3.values).indexOf(en(r3)) && i3.push(new ot(e2, r3, `expected one of [${Object.keys(n3.values).join(", ")}], ${JSON.stringify(r3)} found`)), i3;
      }
      function cn(t3) {
        return qr(rn(t3.value)) ? ln(lt({}, t3, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : hn(t3);
      }
      function hn(t3) {
        const e2 = t3.value, r3 = t3.key;
        if ("array" !== kr(e2)) return [new ot(r3, e2, `array expected, ${kr(e2)} found`)];
        const n3 = t3.styleSpec;
        let i3, a3 = [];
        if (e2.length < 1) return [new ot(r3, e2, "filter array must have at least 1 element")];
        switch (a3 = a3.concat(un({ key: `${r3}[0]`, value: e2[0], valueSpec: n3.filter_operator, style: t3.style, styleSpec: t3.styleSpec })), en(e2[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            e2.length >= 2 && "$type" === en(e2[1]) && a3.push(new ot(r3, e2, `"$type" cannot be use with operator "${e2[0]}"`));
          case "==":
          case "!=":
            3 !== e2.length && a3.push(new ot(r3, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
          case "in":
          case "!in":
            e2.length >= 2 && (i3 = kr(e2[1]), "string" !== i3 && a3.push(new ot(`${r3}[1]`, e2[1], `string expected, ${i3} found`)));
            for (let s3 = 2; s3 < e2.length; s3++) i3 = kr(e2[s3]), "$type" === en(e2[1]) ? a3 = a3.concat(un({ key: `${r3}[${s3}]`, value: e2[s3], valueSpec: n3.geometry_type, style: t3.style, styleSpec: t3.styleSpec })) : "string" !== i3 && "number" !== i3 && "boolean" !== i3 && a3.push(new ot(`${r3}[${s3}]`, e2[s3], `string, number, or boolean expected, ${i3} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let n4 = 1; n4 < e2.length; n4++) a3 = a3.concat(hn({ key: `${r3}[${n4}]`, value: e2[n4], style: t3.style, styleSpec: t3.styleSpec }));
            break;
          case "has":
          case "!has":
            i3 = kr(e2[1]), 2 !== e2.length ? a3.push(new ot(r3, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "string" !== i3 && a3.push(new ot(`${r3}[1]`, e2[1], `string expected, ${i3} found`));
            break;
          case "within":
            i3 = kr(e2[1]), 2 !== e2.length ? a3.push(new ot(r3, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "object" !== i3 && a3.push(new ot(`${r3}[1]`, e2[1], `object expected, ${i3} found`));
        }
        return a3;
      }
      function pn(t3, e2) {
        const r3 = t3.key, n3 = t3.validateSpec, i3 = t3.style, a3 = t3.styleSpec, s3 = t3.value, o3 = t3.objectKey, l3 = a3[`${e2}_${t3.layerType}`];
        if (!l3) return [];
        const u3 = o3.match(/^(.*)-transition$/);
        if ("paint" === e2 && u3 && l3[u3[1]] && l3[u3[1]].transition) return n3({ key: r3, value: s3, valueSpec: a3.transition, style: i3, styleSpec: a3 });
        const c3 = t3.valueSpec || l3[o3];
        if (!c3) return [new ot(r3, s3, `unknown property "${o3}"`)];
        let h3;
        if ("string" === kr(s3) && _r(c3) && !c3.tokens && (h3 = /^{([^}]+)}$/.exec(s3))) return [new ot(r3, s3, `"${o3}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h3[1])} }\`.`)];
        const p3 = [];
        return "symbol" === t3.layerType && ("text-field" === o3 && i3 && !i3.glyphs && p3.push(new ot(r3, s3, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o3 && Ir(rn(s3)) && "identity" === en(s3.type) && p3.push(new ot(r3, s3, '"text-font" does not support identity functions'))), p3.concat(n3({ key: t3.key, value: s3, valueSpec: c3, style: i3, styleSpec: a3, expressionContext: "property", propertyType: e2, propertyKey: o3 }));
      }
      function fn(t3) {
        return pn(t3, "paint");
      }
      function dn(t3) {
        return pn(t3, "layout");
      }
      function yn(t3) {
        let e2 = [];
        const r3 = t3.value, n3 = t3.key, i3 = t3.style, a3 = t3.styleSpec;
        r3.type || r3.ref || e2.push(new ot(n3, r3, 'either "type" or "ref" is required'));
        let s3 = en(r3.type);
        const o3 = en(r3.ref);
        if (r3.id) {
          const a4 = en(r3.id);
          for (let s4 = 0; s4 < t3.arrayIndex; s4++) {
            const t4 = i3.layers[s4];
            en(t4.id) === a4 && e2.push(new ot(n3, r3.id, `duplicate layer id "${r3.id}", previously used at line ${t4.id.__line__}`));
          }
        }
        if ("ref" in r3) {
          let t4;
          ["type", "source", "source-layer", "filter", "layout"].forEach((t5) => {
            t5 in r3 && e2.push(new ot(n3, r3[t5], `"${t5}" is prohibited for ref layers`));
          }), i3.layers.forEach((e3) => {
            en(e3.id) === o3 && (t4 = e3);
          }), t4 ? t4.ref ? e2.push(new ot(n3, r3.ref, "ref cannot reference another ref layer")) : s3 = en(t4.type) : e2.push(new ot(n3, r3.ref, `ref layer "${o3}" not found`));
        } else if ("background" !== s3) if (r3.source) {
          const t4 = i3.sources && i3.sources[r3.source], a4 = t4 && en(t4.type);
          t4 ? "vector" === a4 && "raster" === s3 ? e2.push(new ot(n3, r3.source, `layer "${r3.id}" requires a raster source`)) : "raster-dem" !== a4 && "hillshade" === s3 ? e2.push(new ot(n3, r3.source, `layer "${r3.id}" requires a raster-dem source`)) : "raster" === a4 && "raster" !== s3 ? e2.push(new ot(n3, r3.source, `layer "${r3.id}" requires a vector source`)) : "vector" !== a4 || r3["source-layer"] ? "raster-dem" === a4 && "hillshade" !== s3 ? e2.push(new ot(n3, r3.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s3 || !r3.paint || !r3.paint["line-gradient"] || "geojson" === a4 && t4.lineMetrics || e2.push(new ot(n3, r3, `layer "${r3.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new ot(n3, r3, `layer "${r3.id}" must specify a "source-layer"`)) : e2.push(new ot(n3, r3.source, `source "${r3.source}" not found`));
        } else e2.push(new ot(n3, r3, 'missing required property "source"'));
        return e2 = e2.concat(nn({ key: n3, value: r3, valueSpec: a3.layer, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": () => [], type: () => t3.validateSpec({ key: `${n3}.type`, value: r3.type, valueSpec: a3.layer.type, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, object: r3, objectKey: "type" }), filter: cn, layout: (t4) => nn({ layer: r3, key: t4.key, value: t4.value, style: t4.style, styleSpec: t4.styleSpec, validateSpec: t4.validateSpec, objectElementValidators: { "*": (t5) => dn(lt({ layerType: s3 }, t5)) } }), paint: (t4) => nn({ layer: r3, key: t4.key, value: t4.value, style: t4.style, styleSpec: t4.styleSpec, validateSpec: t4.validateSpec, objectElementValidators: { "*": (t5) => fn(lt({ layerType: s3 }, t5)) } }) } })), e2;
      }
      function mn(t3) {
        const e2 = t3.value, r3 = t3.key, n3 = kr(e2);
        return "string" !== n3 ? [new ot(r3, e2, `string expected, ${n3} found`)] : [];
      }
      const gn = { promoteId: function({ key: t3, value: e2 }) {
        if ("string" === kr(e2)) return mn({ key: t3, value: e2 });
        {
          const r3 = [];
          for (const n3 in e2) r3.push(...mn({ key: `${t3}.${n3}`, value: e2[n3] }));
          return r3;
        }
      } };
      function xn(t3) {
        const e2 = t3.value, r3 = t3.key, n3 = t3.styleSpec, i3 = t3.style, a3 = t3.validateSpec;
        if (!e2.type) return [new ot(r3, e2, '"type" is required')];
        const s3 = en(e2.type);
        let o3;
        switch (s3) {
          case "vector":
          case "raster":
            return o3 = nn({ key: r3, value: e2, valueSpec: n3[`source_${s3.replace("-", "_")}`], style: t3.style, styleSpec: n3, objectElementValidators: gn, validateSpec: a3 }), o3;
          case "raster-dem":
            return o3 = function(t4) {
              var e3;
              const r4 = null !== (e3 = t4.sourceName) && void 0 !== e3 ? e3 : "", n4 = t4.value, i4 = t4.styleSpec, a4 = i4.source_raster_dem, s4 = t4.style;
              let o4 = [];
              const l3 = kr(n4);
              if (void 0 === n4) return o4;
              if ("object" !== l3) return o4.push(new ot("source_raster_dem", n4, `object expected, ${l3} found`)), o4;
              const u3 = "custom" === en(n4.encoding), c3 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h3 = t4.value.encoding ? `"${t4.value.encoding}"` : "Default";
              for (const e4 in n4) !u3 && c3.includes(e4) ? o4.push(new ot(e4, n4[e4], `In "${r4}": "${e4}" is only valid when "encoding" is set to "custom". ${h3} encoding found`)) : a4[e4] ? o4 = o4.concat(t4.validateSpec({ key: e4, value: n4[e4], valueSpec: a4[e4], validateSpec: t4.validateSpec, style: s4, styleSpec: i4 })) : o4.push(new ot(e4, n4[e4], `unknown property "${e4}"`));
              return o4;
            }({ sourceName: r3, value: e2, style: t3.style, styleSpec: n3, validateSpec: a3 }), o3;
          case "geojson":
            if (o3 = nn({ key: r3, value: e2, valueSpec: n3.source_geojson, style: i3, styleSpec: n3, validateSpec: a3, objectElementValidators: gn }), e2.cluster) for (const t4 in e2.clusterProperties) {
              const [n4, i4] = e2.clusterProperties[t4], s4 = "string" == typeof n4 ? [n4, ["accumulated"], ["get", t4]] : n4;
              o3.push(...ln({ key: `${r3}.${t4}.map`, value: i4, validateSpec: a3, expressionContext: "cluster-map" })), o3.push(...ln({ key: `${r3}.${t4}.reduce`, value: s4, validateSpec: a3, expressionContext: "cluster-reduce" }));
            }
            return o3;
          case "video":
            return nn({ key: r3, value: e2, valueSpec: n3.source_video, style: i3, validateSpec: a3, styleSpec: n3 });
          case "image":
            return nn({ key: r3, value: e2, valueSpec: n3.source_image, style: i3, validateSpec: a3, styleSpec: n3 });
          case "canvas":
            return [new ot(r3, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return un({ key: `${r3}.type`, value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i3, validateSpec: a3, styleSpec: n3 });
        }
      }
      function vn(t3) {
        const e2 = t3.value, r3 = t3.styleSpec, n3 = r3.light, i3 = t3.style;
        let a3 = [];
        const s3 = kr(e2);
        if (void 0 === e2) return a3;
        if ("object" !== s3) return a3 = a3.concat([new ot("light", e2, `object expected, ${s3} found`)]), a3;
        for (const s4 in e2) {
          const o3 = s4.match(/^(.*)-transition$/);
          a3 = a3.concat(o3 && n3[o3[1]] && n3[o3[1]].transition ? t3.validateSpec({ key: s4, value: e2[s4], valueSpec: r3.transition, validateSpec: t3.validateSpec, style: i3, styleSpec: r3 }) : n3[s4] ? t3.validateSpec({ key: s4, value: e2[s4], valueSpec: n3[s4], validateSpec: t3.validateSpec, style: i3, styleSpec: r3 }) : [new ot(s4, e2[s4], `unknown property "${s4}"`)]);
        }
        return a3;
      }
      function bn(t3) {
        const e2 = t3.value, r3 = t3.styleSpec, n3 = r3.terrain, i3 = t3.style;
        let a3 = [];
        const s3 = kr(e2);
        if (void 0 === e2) return a3;
        if ("object" !== s3) return a3 = a3.concat([new ot("terrain", e2, `object expected, ${s3} found`)]), a3;
        for (const s4 in e2) a3 = a3.concat(n3[s4] ? t3.validateSpec({ key: s4, value: e2[s4], valueSpec: n3[s4], validateSpec: t3.validateSpec, style: i3, styleSpec: r3 }) : [new ot(s4, e2[s4], `unknown property "${s4}"`)]);
        return a3;
      }
      function wn(t3) {
        let e2 = [];
        const r3 = t3.value, n3 = t3.key;
        if (Array.isArray(r3)) {
          const i3 = [], a3 = [];
          for (const s3 in r3) r3[s3].id && i3.includes(r3[s3].id) && e2.push(new ot(n3, r3, `all the sprites' ids must be unique, but ${r3[s3].id} is duplicated`)), i3.push(r3[s3].id), r3[s3].url && a3.includes(r3[s3].url) && e2.push(new ot(n3, r3, `all the sprites' URLs must be unique, but ${r3[s3].url} is duplicated`)), a3.push(r3[s3].url), e2 = e2.concat(nn({ key: `${n3}[${s3}]`, value: r3[s3], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t3.validateSpec }));
          return e2;
        }
        return mn({ key: n3, value: r3 });
      }
      const _n = { "*": () => [], array: an, boolean: function(t3) {
        const e2 = t3.value, r3 = t3.key, n3 = kr(e2);
        return "boolean" !== n3 ? [new ot(r3, e2, `boolean expected, ${n3} found`)] : [];
      }, number: sn, color: function(t3) {
        const e2 = t3.key, r3 = t3.value, n3 = kr(r3);
        return "string" !== n3 ? [new ot(e2, r3, `color expected, ${n3} found`)] : Yt.parse(String(r3)) ? [] : [new ot(e2, r3, `color expected, "${r3}" found`)];
      }, constants: tn, enum: un, filter: cn, function: on, layer: yn, object: nn, source: xn, light: vn, terrain: bn, string: mn, formatted: function(t3) {
        return 0 === mn(t3).length ? [] : ln(t3);
      }, resolvedImage: function(t3) {
        return 0 === mn(t3).length ? [] : ln(t3);
      }, padding: function(t3) {
        const e2 = t3.key, r3 = t3.value;
        if ("array" === kr(r3)) {
          if (r3.length < 1 || r3.length > 4) return [new ot(e2, r3, `padding requires 1 to 4 values; ${r3.length} values found`)];
          const n3 = { type: "number" };
          let i3 = [];
          for (let a3 = 0; a3 < r3.length; a3++) i3 = i3.concat(t3.validateSpec({ key: `${e2}[${a3}]`, value: r3[a3], validateSpec: t3.validateSpec, valueSpec: n3 }));
          return i3;
        }
        return sn({ key: e2, value: r3, valueSpec: {} });
      }, variableAnchorOffsetCollection: function(t3) {
        const e2 = t3.key, r3 = t3.value, n3 = kr(r3), i3 = t3.styleSpec;
        if ("array" !== n3 || r3.length < 1 || r3.length % 2 != 0) return [new ot(e2, r3, "variableAnchorOffsetCollection requires a non-empty array of even length")];
        let a3 = [];
        for (let n4 = 0; n4 < r3.length; n4 += 2) a3 = a3.concat(un({ key: `${e2}[${n4}]`, value: r3[n4], valueSpec: i3.layout_symbol["text-anchor"] })), a3 = a3.concat(an({ key: `${e2}[${n4 + 1}]`, value: r3[n4 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t3.validateSpec, style: t3.style, styleSpec: i3 }));
        return a3;
      }, sprite: wn };
      function An(t3) {
        const e2 = t3.value, r3 = t3.valueSpec, n3 = t3.styleSpec;
        return t3.validateSpec = An, r3.expression && Ir(en(e2)) ? on(t3) : r3.expression && Tr(rn(e2)) ? ln(t3) : r3.type && _n[r3.type] ? _n[r3.type](t3) : nn(lt({}, t3, { valueSpec: r3.type ? n3[r3.type] : r3 }));
      }
      function Sn(t3) {
        const e2 = t3.value, r3 = t3.key, n3 = mn(t3);
        return n3.length || (-1 === e2.indexOf("{fontstack}") && n3.push(new ot(r3, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n3.push(new ot(r3, e2, '"glyphs" url must include a "{range}" token'))), n3;
      }
      function kn(t3, e2 = X2) {
        let r3 = [];
        return r3 = r3.concat(An({ key: "", value: t3, valueSpec: e2.$root, styleSpec: e2, style: t3, validateSpec: An, objectElementValidators: { glyphs: Sn, "*": () => [] } })), t3.constants && (r3 = r3.concat(tn({ key: "constants", value: t3.constants, style: t3, styleSpec: e2, validateSpec: An }))), zn(r3);
      }
      function In(t3) {
        return function(e2) {
          return t3({ ...e2, validateSpec: An });
        };
      }
      function zn(t3) {
        return [].concat(t3).sort((t4, e2) => t4.line - e2.line);
      }
      function Mn(t3) {
        return function(...e2) {
          return zn(t3.apply(this, e2));
        };
      }
      kn.source = Mn(In(xn)), kn.sprite = Mn(In(wn)), kn.glyphs = Mn(In(Sn)), kn.light = Mn(In(vn)), kn.terrain = Mn(In(bn)), kn.layer = Mn(In(yn)), kn.filter = Mn(In(cn)), kn.paintProperty = Mn(In(fn)), kn.layoutProperty = Mn(In(dn));
      const Cn = kn, Bn = Cn.light, Pn = Cn.paintProperty, Vn = Cn.layoutProperty;
      function En(t3, e2) {
        let r3 = false;
        if (e2 && e2.length) for (const n3 of e2) t3.fire(new G2(new Error(n3.message))), r3 = true;
        return r3;
      }
      class Fn {
        constructor(t3, e2, r3) {
          const n3 = this.cells = [];
          if (t3 instanceof ArrayBuffer) {
            this.arrayBuffer = t3;
            const i4 = new Int32Array(this.arrayBuffer);
            t3 = i4[0], this.d = (e2 = i4[1]) + 2 * (r3 = i4[2]);
            for (let t4 = 0; t4 < this.d * this.d; t4++) {
              const e3 = i4[3 + t4], r4 = i4[3 + t4 + 1];
              n3.push(e3 === r4 ? null : i4.subarray(e3, r4));
            }
            const a3 = i4[3 + n3.length + 1];
            this.keys = i4.subarray(i4[3 + n3.length], a3), this.bboxes = i4.subarray(a3), this.insert = this._insertReadonly;
          } else {
            this.d = e2 + 2 * r3;
            for (let t4 = 0; t4 < this.d * this.d; t4++) n3.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = e2, this.extent = t3, this.padding = r3, this.scale = e2 / t3, this.uid = 0;
          const i3 = r3 / e2 * t3;
          this.min = -i3, this.max = t3 + i3;
        }
        insert(t3, e2, r3, n3, i3) {
          this._forEachCell(e2, r3, n3, i3, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t3), this.bboxes.push(e2), this.bboxes.push(r3), this.bboxes.push(n3), this.bboxes.push(i3);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(t3, e2, r3, n3, i3, a3) {
          this.cells[i3].push(a3);
        }
        query(t3, e2, r3, n3, i3) {
          const a3 = this.min, s3 = this.max;
          if (t3 <= a3 && e2 <= a3 && s3 <= r3 && s3 <= n3 && !i3) return Array.prototype.slice.call(this.keys);
          {
            const a4 = [];
            return this._forEachCell(t3, e2, r3, n3, this._queryCell, a4, {}, i3), a4;
          }
        }
        _queryCell(t3, e2, r3, n3, i3, a3, s3, o3) {
          const l3 = this.cells[i3];
          if (null !== l3) {
            const i4 = this.keys, u3 = this.bboxes;
            for (let c3 = 0; c3 < l3.length; c3++) {
              const h3 = l3[c3];
              if (void 0 === s3[h3]) {
                const l4 = 4 * h3;
                (o3 ? o3(u3[l4 + 0], u3[l4 + 1], u3[l4 + 2], u3[l4 + 3]) : t3 <= u3[l4 + 2] && e2 <= u3[l4 + 3] && r3 >= u3[l4 + 0] && n3 >= u3[l4 + 1]) ? (s3[h3] = true, a3.push(i4[h3])) : s3[h3] = false;
              }
            }
          }
        }
        _forEachCell(t3, e2, r3, n3, i3, a3, s3, o3) {
          const l3 = this._convertToCellCoord(t3), u3 = this._convertToCellCoord(e2), c3 = this._convertToCellCoord(r3), h3 = this._convertToCellCoord(n3);
          for (let p3 = l3; p3 <= c3; p3++) for (let l4 = u3; l4 <= h3; l4++) {
            const u4 = this.d * l4 + p3;
            if ((!o3 || o3(this._convertFromCellCoord(p3), this._convertFromCellCoord(l4), this._convertFromCellCoord(p3 + 1), this._convertFromCellCoord(l4 + 1))) && i3.call(this, t3, e2, r3, n3, u4, a3, s3, o3)) return;
          }
        }
        _convertFromCellCoord(t3) {
          return (t3 - this.padding) / this.scale;
        }
        _convertToCellCoord(t3) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t3 * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer) return this.arrayBuffer;
          const t3 = this.cells, e2 = 3 + this.cells.length + 1 + 1;
          let r3 = 0;
          for (let t4 = 0; t4 < this.cells.length; t4++) r3 += this.cells[t4].length;
          const n3 = new Int32Array(e2 + r3 + this.keys.length + this.bboxes.length);
          n3[0] = this.extent, n3[1] = this.n, n3[2] = this.padding;
          let i3 = e2;
          for (let e3 = 0; e3 < t3.length; e3++) {
            const r4 = t3[e3];
            n3[3 + e3] = i3, n3.set(r4, i3), i3 += r4.length;
          }
          return n3[3 + t3.length] = i3, n3.set(this.keys, i3), i3 += this.keys.length, n3[3 + t3.length + 1] = i3, n3.set(this.bboxes, i3), i3 += this.bboxes.length, n3.buffer;
        }
        static serialize(t3, e2) {
          const r3 = t3.toArrayBuffer();
          return e2 && e2.push(r3), { buffer: r3 };
        }
        static deserialize(t3) {
          return new Fn(t3.buffer);
        }
      }
      const Tn = {};
      function $n(t3, e2, r3 = {}) {
        if (Tn[t3]) throw new Error(`${t3} is already registered.`);
        Object.defineProperty(e2, "_classRegistryKey", { value: t3, writeable: false }), Tn[t3] = { klass: e2, omit: r3.omit || [], shallow: r3.shallow || [] };
      }
      $n("Object", Object), $n("TransferableGridIndex", Fn), $n("Color", Yt), $n("Error", Error), $n("AJAXError", L2), $n("ResolvedImage", ne2), $n("StylePropertyFunction", Ur), $n("StyleExpression", Fr, { omit: ["_evaluator"] }), $n("ZoomDependentExpression", Dr), $n("ZoomConstantExpression", Lr), $n("CompoundExpression", $e2, { omit: ["_evaluate"] });
      for (const t3 in yr) yr[t3]._classRegistryKey || $n(`Expression_${t3}`, yr[t3]);
      function Ln(t3) {
        return t3 && "undefined" != typeof ArrayBuffer && (t3 instanceof ArrayBuffer || t3.constructor && "ArrayBuffer" === t3.constructor.name);
      }
      function Dn(t3, e2) {
        if (null == t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp || t3 instanceof Blob) return t3;
        if (Ln(t3)) return e2 && e2.push(t3), t3;
        if (M2(t3)) return e2 && e2.push(t3), t3;
        if (ArrayBuffer.isView(t3)) {
          const r3 = t3;
          return e2 && e2.push(r3.buffer), r3;
        }
        if (t3 instanceof ImageData) return e2 && e2.push(t3.data.buffer), t3;
        if (Array.isArray(t3)) {
          const r3 = [];
          for (const n3 of t3) r3.push(Dn(n3, e2));
          return r3;
        }
        if ("object" == typeof t3) {
          const r3 = t3.constructor, n3 = r3._classRegistryKey;
          if (!n3) throw new Error("can't serialize object of unregistered class");
          if (!Tn[n3]) throw new Error(`${n3} is not registered.`);
          const i3 = r3.serialize ? r3.serialize(t3, e2) : {};
          if (r3.serialize) {
            if (e2 && i3 === e2[e2.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const r4 in t3) {
              if (!t3.hasOwnProperty(r4)) continue;
              if (Tn[n3].omit.indexOf(r4) >= 0) continue;
              const a3 = t3[r4];
              i3[r4] = Tn[n3].shallow.indexOf(r4) >= 0 ? a3 : Dn(a3, e2);
            }
            t3 instanceof Error && (i3.message = t3.message);
          }
          if (i3.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return "Object" !== n3 && (i3.$name = n3), i3;
        }
        throw new Error("can't serialize object of type " + typeof t3);
      }
      function On(t3) {
        if (null == t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp || t3 instanceof Blob || Ln(t3) || M2(t3) || ArrayBuffer.isView(t3) || t3 instanceof ImageData) return t3;
        if (Array.isArray(t3)) return t3.map(On);
        if ("object" == typeof t3) {
          const e2 = t3.$name || "Object";
          if (!Tn[e2]) throw new Error(`can't deserialize unregistered class ${e2}`);
          const { klass: r3 } = Tn[e2];
          if (!r3) throw new Error(`can't deserialize unregistered class ${e2}`);
          if (r3.deserialize) return r3.deserialize(t3);
          const n3 = Object.create(r3.prototype);
          for (const r4 of Object.keys(t3)) {
            if ("$name" === r4) continue;
            const i3 = t3[r4];
            n3[r4] = Tn[e2].shallow.indexOf(r4) >= 0 ? i3 : On(i3);
          }
          return n3;
        }
        throw new Error("can't deserialize object of type " + typeof t3);
      }
      class Un {
        constructor() {
          this.first = true;
        }
        update(t3, e2) {
          const r3 = Math.floor(t3);
          return this.first ? (this.first = false, this.lastIntegerZoom = r3, this.lastIntegerZoomTime = 0, this.lastZoom = t3, this.lastFloorZoom = r3, true) : (this.lastFloorZoom > r3 ? (this.lastIntegerZoom = r3 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r3 && (this.lastIntegerZoom = r3, this.lastIntegerZoomTime = e2), t3 !== this.lastZoom && (this.lastZoom = t3, this.lastFloorZoom = r3, true));
        }
      }
      const Rn = { "Latin-1 Supplement": (t3) => t3 >= 128 && t3 <= 255, Arabic: (t3) => t3 >= 1536 && t3 <= 1791, "Arabic Supplement": (t3) => t3 >= 1872 && t3 <= 1919, "Arabic Extended-A": (t3) => t3 >= 2208 && t3 <= 2303, "Hangul Jamo": (t3) => t3 >= 4352 && t3 <= 4607, "Unified Canadian Aboriginal Syllabics": (t3) => t3 >= 5120 && t3 <= 5759, Khmer: (t3) => t3 >= 6016 && t3 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t3) => t3 >= 6320 && t3 <= 6399, "General Punctuation": (t3) => t3 >= 8192 && t3 <= 8303, "Letterlike Symbols": (t3) => t3 >= 8448 && t3 <= 8527, "Number Forms": (t3) => t3 >= 8528 && t3 <= 8591, "Miscellaneous Technical": (t3) => t3 >= 8960 && t3 <= 9215, "Control Pictures": (t3) => t3 >= 9216 && t3 <= 9279, "Optical Character Recognition": (t3) => t3 >= 9280 && t3 <= 9311, "Enclosed Alphanumerics": (t3) => t3 >= 9312 && t3 <= 9471, "Geometric Shapes": (t3) => t3 >= 9632 && t3 <= 9727, "Miscellaneous Symbols": (t3) => t3 >= 9728 && t3 <= 9983, "Miscellaneous Symbols and Arrows": (t3) => t3 >= 11008 && t3 <= 11263, "CJK Radicals Supplement": (t3) => t3 >= 11904 && t3 <= 12031, "Kangxi Radicals": (t3) => t3 >= 12032 && t3 <= 12255, "Ideographic Description Characters": (t3) => t3 >= 12272 && t3 <= 12287, "CJK Symbols and Punctuation": (t3) => t3 >= 12288 && t3 <= 12351, Hiragana: (t3) => t3 >= 12352 && t3 <= 12447, Katakana: (t3) => t3 >= 12448 && t3 <= 12543, Bopomofo: (t3) => t3 >= 12544 && t3 <= 12591, "Hangul Compatibility Jamo": (t3) => t3 >= 12592 && t3 <= 12687, Kanbun: (t3) => t3 >= 12688 && t3 <= 12703, "Bopomofo Extended": (t3) => t3 >= 12704 && t3 <= 12735, "CJK Strokes": (t3) => t3 >= 12736 && t3 <= 12783, "Katakana Phonetic Extensions": (t3) => t3 >= 12784 && t3 <= 12799, "Enclosed CJK Letters and Months": (t3) => t3 >= 12800 && t3 <= 13055, "CJK Compatibility": (t3) => t3 >= 13056 && t3 <= 13311, "CJK Unified Ideographs Extension A": (t3) => t3 >= 13312 && t3 <= 19903, "Yijing Hexagram Symbols": (t3) => t3 >= 19904 && t3 <= 19967, "CJK Unified Ideographs": (t3) => t3 >= 19968 && t3 <= 40959, "Yi Syllables": (t3) => t3 >= 40960 && t3 <= 42127, "Yi Radicals": (t3) => t3 >= 42128 && t3 <= 42191, "Hangul Jamo Extended-A": (t3) => t3 >= 43360 && t3 <= 43391, "Hangul Syllables": (t3) => t3 >= 44032 && t3 <= 55215, "Hangul Jamo Extended-B": (t3) => t3 >= 55216 && t3 <= 55295, "Private Use Area": (t3) => t3 >= 57344 && t3 <= 63743, "CJK Compatibility Ideographs": (t3) => t3 >= 63744 && t3 <= 64255, "Arabic Presentation Forms-A": (t3) => t3 >= 64336 && t3 <= 65023, "Vertical Forms": (t3) => t3 >= 65040 && t3 <= 65055, "CJK Compatibility Forms": (t3) => t3 >= 65072 && t3 <= 65103, "Small Form Variants": (t3) => t3 >= 65104 && t3 <= 65135, "Arabic Presentation Forms-B": (t3) => t3 >= 65136 && t3 <= 65279, "Halfwidth and Fullwidth Forms": (t3) => t3 >= 65280 && t3 <= 65519 };
      function qn(t3) {
        for (const e2 of t3) if (Zn(e2.charCodeAt(0))) return true;
        return false;
      }
      function jn(t3) {
        for (const e2 of t3) if (!Nn(e2.charCodeAt(0))) return false;
        return true;
      }
      function Nn(t3) {
        return !(Rn.Arabic(t3) || Rn["Arabic Supplement"](t3) || Rn["Arabic Extended-A"](t3) || Rn["Arabic Presentation Forms-A"](t3) || Rn["Arabic Presentation Forms-B"](t3));
      }
      function Zn(t3) {
        return !(746 !== t3 && 747 !== t3 && (t3 < 4352 || !(Rn["Bopomofo Extended"](t3) || Rn.Bopomofo(t3) || Rn["CJK Compatibility Forms"](t3) && !(t3 >= 65097 && t3 <= 65103) || Rn["CJK Compatibility Ideographs"](t3) || Rn["CJK Compatibility"](t3) || Rn["CJK Radicals Supplement"](t3) || Rn["CJK Strokes"](t3) || !(!Rn["CJK Symbols and Punctuation"](t3) || t3 >= 12296 && t3 <= 12305 || t3 >= 12308 && t3 <= 12319 || 12336 === t3) || Rn["CJK Unified Ideographs Extension A"](t3) || Rn["CJK Unified Ideographs"](t3) || Rn["Enclosed CJK Letters and Months"](t3) || Rn["Hangul Compatibility Jamo"](t3) || Rn["Hangul Jamo Extended-A"](t3) || Rn["Hangul Jamo Extended-B"](t3) || Rn["Hangul Jamo"](t3) || Rn["Hangul Syllables"](t3) || Rn.Hiragana(t3) || Rn["Ideographic Description Characters"](t3) || Rn.Kanbun(t3) || Rn["Kangxi Radicals"](t3) || Rn["Katakana Phonetic Extensions"](t3) || Rn.Katakana(t3) && 12540 !== t3 || !(!Rn["Halfwidth and Fullwidth Forms"](t3) || 65288 === t3 || 65289 === t3 || 65293 === t3 || t3 >= 65306 && t3 <= 65310 || 65339 === t3 || 65341 === t3 || 65343 === t3 || t3 >= 65371 && t3 <= 65503 || 65507 === t3 || t3 >= 65512 && t3 <= 65519) || !(!Rn["Small Form Variants"](t3) || t3 >= 65112 && t3 <= 65118 || t3 >= 65123 && t3 <= 65126) || Rn["Unified Canadian Aboriginal Syllabics"](t3) || Rn["Unified Canadian Aboriginal Syllabics Extended"](t3) || Rn["Vertical Forms"](t3) || Rn["Yijing Hexagram Symbols"](t3) || Rn["Yi Syllables"](t3) || Rn["Yi Radicals"](t3))));
      }
      function Kn(t3) {
        return !(Zn(t3) || function(t4) {
          return !!(Rn["Latin-1 Supplement"](t4) && (167 === t4 || 169 === t4 || 174 === t4 || 177 === t4 || 188 === t4 || 189 === t4 || 190 === t4 || 215 === t4 || 247 === t4) || Rn["General Punctuation"](t4) && (8214 === t4 || 8224 === t4 || 8225 === t4 || 8240 === t4 || 8241 === t4 || 8251 === t4 || 8252 === t4 || 8258 === t4 || 8263 === t4 || 8264 === t4 || 8265 === t4 || 8273 === t4) || Rn["Letterlike Symbols"](t4) || Rn["Number Forms"](t4) || Rn["Miscellaneous Technical"](t4) && (t4 >= 8960 && t4 <= 8967 || t4 >= 8972 && t4 <= 8991 || t4 >= 8996 && t4 <= 9e3 || 9003 === t4 || t4 >= 9085 && t4 <= 9114 || t4 >= 9150 && t4 <= 9165 || 9167 === t4 || t4 >= 9169 && t4 <= 9179 || t4 >= 9186 && t4 <= 9215) || Rn["Control Pictures"](t4) && 9251 !== t4 || Rn["Optical Character Recognition"](t4) || Rn["Enclosed Alphanumerics"](t4) || Rn["Geometric Shapes"](t4) || Rn["Miscellaneous Symbols"](t4) && !(t4 >= 9754 && t4 <= 9759) || Rn["Miscellaneous Symbols and Arrows"](t4) && (t4 >= 11026 && t4 <= 11055 || t4 >= 11088 && t4 <= 11097 || t4 >= 11192 && t4 <= 11243) || Rn["CJK Symbols and Punctuation"](t4) || Rn.Katakana(t4) || Rn["Private Use Area"](t4) || Rn["CJK Compatibility Forms"](t4) || Rn["Small Form Variants"](t4) || Rn["Halfwidth and Fullwidth Forms"](t4) || 8734 === t4 || 8756 === t4 || 8757 === t4 || t4 >= 9984 && t4 <= 10087 || t4 >= 10102 && t4 <= 10131 || 65532 === t4 || 65533 === t4);
        }(t3));
      }
      function Gn(t3) {
        return t3 >= 1424 && t3 <= 2303 || Rn["Arabic Presentation Forms-A"](t3) || Rn["Arabic Presentation Forms-B"](t3);
      }
      function Jn(t3, e2) {
        return !(!e2 && Gn(t3) || t3 >= 2304 && t3 <= 3583 || t3 >= 3840 && t3 <= 4255 || Rn.Khmer(t3));
      }
      function Xn(t3) {
        for (const e2 of t3) if (Gn(e2.charCodeAt(0))) return true;
        return false;
      }
      const Yn = "deferred", Hn = "loading", Wn = "loaded";
      let Qn = null, ti = "unavailable", ei = null;
      const ri = function(t3) {
        t3 && "string" == typeof t3 && t3.indexOf("NetworkError") > -1 && (ti = "error"), Qn && Qn(t3);
      };
      function ni() {
        ii.fire(new K2("pluginStateChange", { pluginStatus: ti, pluginURL: ei }));
      }
      const ii = new J2(), ai = function() {
        return ti;
      }, si = function() {
        if (ti !== Yn || !ei) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        ti = Hn, ni(), ei && q2({ url: ei }, (t3) => {
          t3 ? ri(t3) : (ti = Wn, ni());
        });
      }, oi = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => ti === Wn || null != oi.applyArabicShaping, isLoading: () => ti === Hn, setState(t3) {
        if (!I2()) throw new Error("Cannot set the state of the rtl-text-plugin when not in the web-worker context");
        ti = t3.pluginStatus, ei = t3.pluginURL;
      }, isParsed() {
        if (!I2()) throw new Error("rtl-text-plugin is only parsed on the worker-threads");
        return null != oi.applyArabicShaping && null != oi.processBidirectionalText && null != oi.processStyledBidirectionalText;
      }, getPluginURL() {
        if (!I2()) throw new Error("rtl-text-plugin url can only be queried from the worker threads");
        return ei;
      } };
      class li {
        constructor(t3, e2) {
          this.zoom = t3, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Un(), this.transition = {});
        }
        isSupportedScript(t3) {
          return function(t4, e2) {
            for (const r3 of t4) if (!Jn(r3.charCodeAt(0), e2)) return false;
            return true;
          }(t3, oi.isLoaded());
        }
        crossFadingFactor() {
          return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const t3 = this.zoom, e2 = t3 - Math.floor(t3), r3 = this.crossFadingFactor();
          return t3 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r3 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r3) * e2 };
        }
      }
      class ui {
        constructor(t3, e2) {
          this.property = t3, this.value = e2, this.expression = function(t4, e3) {
            if (Ir(t4)) return new Ur(t4, e3);
            if (Tr(t4)) {
              const r3 = Or(t4, e3);
              if ("error" === r3.result) throw new Error(r3.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
              return r3.value;
            }
            {
              let r3 = t4;
              return "color" === e3.type && "string" == typeof t4 ? r3 = Yt.parse(t4) : "padding" !== e3.type || "number" != typeof t4 && !Array.isArray(t4) ? "variableAnchorOffsetCollection" === e3.type && Array.isArray(t4) && (r3 = re2.parse(t4)) : r3 = te2.parse(t4), { kind: "constant", evaluate: () => r3 };
            }
          }(void 0 === e2 ? t3.specification.default : e2, t3.specification);
        }
        isDataDriven() {
          return "source" === this.expression.kind || "composite" === this.expression.kind;
        }
        possiblyEvaluate(t3, e2, r3) {
          return this.property.possiblyEvaluate(this, t3, e2, r3);
        }
      }
      class ci {
        constructor(t3) {
          this.property = t3, this.value = new ui(t3, void 0);
        }
        transitioned(t3, e2) {
          return new pi(this.property, this.value, e2, g2({}, t3.transition, this.transition), t3.now);
        }
        untransitioned() {
          return new pi(this.property, this.value, null, {}, 0);
        }
      }
      class hi {
        constructor(t3) {
          this._properties = t3, this._values = Object.create(t3.defaultTransitionablePropertyValues);
        }
        getValue(t3) {
          return w2(this._values[t3].value.value);
        }
        setValue(t3, e2) {
          Object.prototype.hasOwnProperty.call(this._values, t3) || (this._values[t3] = new ci(this._values[t3].property)), this._values[t3].value = new ui(this._values[t3].property, null === e2 ? void 0 : w2(e2));
        }
        getTransition(t3) {
          return w2(this._values[t3].transition);
        }
        setTransition(t3, e2) {
          Object.prototype.hasOwnProperty.call(this._values, t3) || (this._values[t3] = new ci(this._values[t3].property)), this._values[t3].transition = w2(e2) || void 0;
        }
        serialize() {
          const t3 = {};
          for (const e2 of Object.keys(this._values)) {
            const r3 = this.getValue(e2);
            void 0 !== r3 && (t3[e2] = r3);
            const n3 = this.getTransition(e2);
            void 0 !== n3 && (t3[`${e2}-transition`] = n3);
          }
          return t3;
        }
        transitioned(t3, e2) {
          const r3 = new fi(this._properties);
          for (const n3 of Object.keys(this._values)) r3._values[n3] = this._values[n3].transitioned(t3, e2._values[n3]);
          return r3;
        }
        untransitioned() {
          const t3 = new fi(this._properties);
          for (const e2 of Object.keys(this._values)) t3._values[e2] = this._values[e2].untransitioned();
          return t3;
        }
      }
      class pi {
        constructor(t3, e2, r3, n3, i3) {
          this.property = t3, this.value = e2, this.begin = i3 + n3.delay || 0, this.end = this.begin + n3.duration || 0, t3.specification.transition && (n3.delay || n3.duration) && (this.prior = r3);
        }
        possiblyEvaluate(t3, e2, r3) {
          const n3 = t3.now || 0, i3 = this.value.possiblyEvaluate(t3, e2, r3), a3 = this.prior;
          if (a3) {
            if (n3 > this.end) return this.prior = null, i3;
            if (this.value.isDataDriven()) return this.prior = null, i3;
            if (n3 < this.begin) return a3.possiblyEvaluate(t3, e2, r3);
            {
              const s3 = (n3 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(a3.possiblyEvaluate(t3, e2, r3), i3, function(t4) {
                if (t4 <= 0) return 0;
                if (t4 >= 1) return 1;
                const e3 = t4 * t4, r4 = e3 * t4;
                return 4 * (t4 < 0.5 ? r4 : 3 * (t4 - e3) + r4 - 0.75);
              }(s3));
            }
          }
          return i3;
        }
      }
      class fi {
        constructor(t3) {
          this._properties = t3, this._values = Object.create(t3.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(t3, e2, r3) {
          const n3 = new mi(this._properties);
          for (const i3 of Object.keys(this._values)) n3._values[i3] = this._values[i3].possiblyEvaluate(t3, e2, r3);
          return n3;
        }
        hasTransition() {
          for (const t3 of Object.keys(this._values)) if (this._values[t3].prior) return true;
          return false;
        }
      }
      class di {
        constructor(t3) {
          this._properties = t3, this._values = Object.create(t3.defaultPropertyValues);
        }
        hasValue(t3) {
          return void 0 !== this._values[t3].value;
        }
        getValue(t3) {
          return w2(this._values[t3].value);
        }
        setValue(t3, e2) {
          this._values[t3] = new ui(this._values[t3].property, null === e2 ? void 0 : w2(e2));
        }
        serialize() {
          const t3 = {};
          for (const e2 of Object.keys(this._values)) {
            const r3 = this.getValue(e2);
            void 0 !== r3 && (t3[e2] = r3);
          }
          return t3;
        }
        possiblyEvaluate(t3, e2, r3) {
          const n3 = new mi(this._properties);
          for (const i3 of Object.keys(this._values)) n3._values[i3] = this._values[i3].possiblyEvaluate(t3, e2, r3);
          return n3;
        }
      }
      class yi {
        constructor(t3, e2, r3) {
          this.property = t3, this.value = e2, this.parameters = r3;
        }
        isConstant() {
          return "constant" === this.value.kind;
        }
        constantOr(t3) {
          return "constant" === this.value.kind ? this.value.value : t3;
        }
        evaluate(t3, e2, r3, n3) {
          return this.property.evaluate(this.value, this.parameters, t3, e2, r3, n3);
        }
      }
      class mi {
        constructor(t3) {
          this._properties = t3, this._values = Object.create(t3.defaultPossiblyEvaluatedValues);
        }
        get(t3) {
          return this._values[t3];
        }
      }
      class gi {
        constructor(t3) {
          this.specification = t3;
        }
        possiblyEvaluate(t3, e2) {
          if (t3.isDataDriven()) throw new Error("Value should not be data driven");
          return t3.expression.evaluate(e2);
        }
        interpolate(t3, e2, r3) {
          const n3 = Ze2[this.specification.type];
          return n3 ? n3(t3, e2, r3) : t3;
        }
      }
      class xi {
        constructor(t3, e2) {
          this.specification = t3, this.overrides = e2;
        }
        possiblyEvaluate(t3, e2, r3, n3) {
          return new yi(this, "constant" === t3.expression.kind || "camera" === t3.expression.kind ? { kind: "constant", value: t3.expression.evaluate(e2, null, {}, r3, n3) } : t3.expression, e2);
        }
        interpolate(t3, e2, r3) {
          if ("constant" !== t3.value.kind || "constant" !== e2.value.kind) return t3;
          if (void 0 === t3.value.value || void 0 === e2.value.value) return new yi(this, { kind: "constant", value: void 0 }, t3.parameters);
          const n3 = Ze2[this.specification.type];
          if (n3) {
            const i3 = n3(t3.value.value, e2.value.value, r3);
            return new yi(this, { kind: "constant", value: i3 }, t3.parameters);
          }
          return t3;
        }
        evaluate(t3, e2, r3, n3, i3, a3) {
          return "constant" === t3.kind ? t3.value : t3.evaluate(e2, r3, n3, i3, a3);
        }
      }
      class vi extends xi {
        possiblyEvaluate(t3, e2, r3, n3) {
          if (void 0 === t3.value) return new yi(this, { kind: "constant", value: void 0 }, e2);
          if ("constant" === t3.expression.kind) {
            const i3 = t3.expression.evaluate(e2, null, {}, r3, n3), a3 = "resolvedImage" === t3.property.specification.type && "string" != typeof i3 ? i3.name : i3, s3 = this._calculate(a3, a3, a3, e2);
            return new yi(this, { kind: "constant", value: s3 }, e2);
          }
          if ("camera" === t3.expression.kind) {
            const r4 = this._calculate(t3.expression.evaluate({ zoom: e2.zoom - 1 }), t3.expression.evaluate({ zoom: e2.zoom }), t3.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
            return new yi(this, { kind: "constant", value: r4 }, e2);
          }
          return new yi(this, t3.expression, e2);
        }
        evaluate(t3, e2, r3, n3, i3, a3) {
          if ("source" === t3.kind) {
            const s3 = t3.evaluate(e2, r3, n3, i3, a3);
            return this._calculate(s3, s3, s3, e2);
          }
          return "composite" === t3.kind ? this._calculate(t3.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r3, n3), t3.evaluate({ zoom: Math.floor(e2.zoom) }, r3, n3), t3.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r3, n3), e2) : t3.value;
        }
        _calculate(t3, e2, r3, n3) {
          return n3.zoom > n3.zoomHistory.lastIntegerZoom ? { from: t3, to: e2 } : { from: r3, to: e2 };
        }
        interpolate(t3) {
          return t3;
        }
      }
      class bi {
        constructor(t3) {
          this.specification = t3;
        }
        possiblyEvaluate(t3, e2, r3, n3) {
          if (void 0 !== t3.value) {
            if ("constant" === t3.expression.kind) {
              const i3 = t3.expression.evaluate(e2, null, {}, r3, n3);
              return this._calculate(i3, i3, i3, e2);
            }
            return this._calculate(t3.expression.evaluate(new li(Math.floor(e2.zoom - 1), e2)), t3.expression.evaluate(new li(Math.floor(e2.zoom), e2)), t3.expression.evaluate(new li(Math.floor(e2.zoom + 1), e2)), e2);
          }
        }
        _calculate(t3, e2, r3, n3) {
          return n3.zoom > n3.zoomHistory.lastIntegerZoom ? { from: t3, to: e2 } : { from: r3, to: e2 };
        }
        interpolate(t3) {
          return t3;
        }
      }
      class wi {
        constructor(t3) {
          this.specification = t3;
        }
        possiblyEvaluate(t3, e2, r3, n3) {
          return !!t3.expression.evaluate(e2, null, {}, r3, n3);
        }
        interpolate() {
          return false;
        }
      }
      class _i {
        constructor(t3) {
          this.properties = t3, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const e2 in t3) {
            const r3 = t3[e2];
            r3.specification.overridable && this.overridableProperties.push(e2);
            const n3 = this.defaultPropertyValues[e2] = new ui(r3, void 0), i3 = this.defaultTransitionablePropertyValues[e2] = new ci(r3);
            this.defaultTransitioningPropertyValues[e2] = i3.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n3.possiblyEvaluate({});
          }
        }
      }
      $n("DataDrivenProperty", xi), $n("DataConstantProperty", gi), $n("CrossFadedDataDrivenProperty", vi), $n("CrossFadedProperty", bi), $n("ColorRampProperty", wi);
      const Ai = "-transition";
      class Si extends J2 {
        constructor(t3, e2) {
          if (super(), this.id = t3.id, this.type = t3.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t3.type && (this.metadata = t3.metadata, this.minzoom = t3.minzoom, this.maxzoom = t3.maxzoom, "background" !== t3.type && (this.source = t3.source, this.sourceLayer = t3["source-layer"], this.filter = t3.filter), e2.layout && (this._unevaluatedLayout = new di(e2.layout)), e2.paint)) {
            this._transitionablePaint = new hi(e2.paint);
            for (const e3 in t3.paint) this.setPaintProperty(e3, t3.paint[e3], { validate: false });
            for (const e3 in t3.layout) this.setLayoutProperty(e3, t3.layout[e3], { validate: false });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new mi(e2.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(t3) {
          return "visibility" === t3 ? this.visibility : this._unevaluatedLayout.getValue(t3);
        }
        setLayoutProperty(t3, e2, r3 = {}) {
          null != e2 && this._validate(Vn, `layers.${this.id}.layout.${t3}`, t3, e2, r3) || ("visibility" !== t3 ? this._unevaluatedLayout.setValue(t3, e2) : this.visibility = e2);
        }
        getPaintProperty(t3) {
          return t3.endsWith(Ai) ? this._transitionablePaint.getTransition(t3.slice(0, -11)) : this._transitionablePaint.getValue(t3);
        }
        setPaintProperty(t3, e2, r3 = {}) {
          if (null != e2 && this._validate(Pn, `layers.${this.id}.paint.${t3}`, t3, e2, r3)) return false;
          if (t3.endsWith(Ai)) return this._transitionablePaint.setTransition(t3.slice(0, -11), e2 || void 0), false;
          {
            const r4 = this._transitionablePaint._values[t3], n3 = "cross-faded-data-driven" === r4.property.specification["property-type"], i3 = r4.value.isDataDriven(), a3 = r4.value;
            this._transitionablePaint.setValue(t3, e2), this._handleSpecialPaintPropertyUpdate(t3);
            const s3 = this._transitionablePaint._values[t3].value;
            return s3.isDataDriven() || i3 || n3 || this._handleOverridablePaintPropertyUpdate(t3, a3, s3);
          }
        }
        _handleSpecialPaintPropertyUpdate(t3) {
        }
        _handleOverridablePaintPropertyUpdate(t3, e2, r3) {
          return false;
        }
        isHidden(t3) {
          return !!(this.minzoom && t3 < this.minzoom) || !!(this.maxzoom && t3 >= this.maxzoom) || "none" === this.visibility;
        }
        updateTransitions(t3) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t3, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t3, e2) {
          t3.getCrossfadeParameters && (this._crossfadeParameters = t3.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t3, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t3, void 0, e2);
        }
        serialize() {
          const t3 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (t3.layout = t3.layout || {}, t3.layout.visibility = this.visibility), b2(t3, (t4, e2) => !(void 0 === t4 || "layout" === e2 && !Object.keys(t4).length || "paint" === e2 && !Object.keys(t4).length));
        }
        _validate(t3, e2, r3, n3, i3 = {}) {
          return (!i3 || false !== i3.validate) && En(this, t3.call(Cn, { key: e2, layerType: this.type, objectKey: r3, value: n3, styleSpec: X2, style: { glyphs: true, sprite: true } }));
        }
        is3D() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        resize() {
        }
        isStateDependent() {
          for (const t3 in this.paint._values) {
            const e2 = this.paint.get(t3);
            if (e2 instanceof yi && _r(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent) return true;
          }
          return false;
        }
      }
      const ki = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class Ii {
        constructor(t3, e2) {
          this._structArray = t3, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class zi {
        constructor() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        }
        static serialize(t3, e2) {
          return t3._trim(), e2 && (t3.isTransferred = true, e2.push(t3.arrayBuffer)), { length: t3.length, arrayBuffer: t3.arrayBuffer };
        }
        static deserialize(t3) {
          const e2 = Object.create(this.prototype);
          return e2.arrayBuffer = t3.arrayBuffer, e2.length = t3.length, e2.capacity = t3.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t3) {
          this.reserve(t3), this.length = t3;
        }
        reserve(t3) {
          if (t3 > this.capacity) {
            this.capacity = Math.max(t3, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const e2 = this.uint8;
            this._refreshViews(), e2 && this.uint8.set(e2);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function Mi(t3, e2 = 1) {
        let r3 = 0, n3 = 0;
        return { members: t3.map((t4) => {
          const i3 = ki[t4.type].BYTES_PER_ELEMENT, a3 = r3 = Ci(r3, Math.max(e2, i3)), s3 = t4.components || 1;
          return n3 = Math.max(n3, i3), r3 += i3 * s3, { name: t4.name, type: t4.type, components: s3, offset: a3 };
        }), size: Ci(r3, Math.max(n3, e2)), alignment: e2 };
      }
      function Ci(t3, e2) {
        return Math.ceil(t3 / e2) * e2;
      }
      class Bi extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2) {
          const r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, t3, e2);
        }
        emplace(t3, e2, r3) {
          const n3 = 2 * t3;
          return this.int16[n3 + 0] = e2, this.int16[n3 + 1] = r3, t3;
        }
      }
      Bi.prototype.bytesPerElement = 4, $n("StructArrayLayout2i4", Bi);
      class Pi extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3) {
          const n3 = this.length;
          return this.resize(n3 + 1), this.emplace(n3, t3, e2, r3);
        }
        emplace(t3, e2, r3, n3) {
          const i3 = 3 * t3;
          return this.int16[i3 + 0] = e2, this.int16[i3 + 1] = r3, this.int16[i3 + 2] = n3, t3;
        }
      }
      Pi.prototype.bytesPerElement = 6, $n("StructArrayLayout3i6", Pi);
      class Vi extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3) {
          const i3 = this.length;
          return this.resize(i3 + 1), this.emplace(i3, t3, e2, r3, n3);
        }
        emplace(t3, e2, r3, n3, i3) {
          const a3 = 4 * t3;
          return this.int16[a3 + 0] = e2, this.int16[a3 + 1] = r3, this.int16[a3 + 2] = n3, this.int16[a3 + 3] = i3, t3;
        }
      }
      Vi.prototype.bytesPerElement = 8, $n("StructArrayLayout4i8", Vi);
      class Ei extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i3, a3) {
          const s3 = this.length;
          return this.resize(s3 + 1), this.emplace(s3, t3, e2, r3, n3, i3, a3);
        }
        emplace(t3, e2, r3, n3, i3, a3, s3) {
          const o3 = 6 * t3;
          return this.int16[o3 + 0] = e2, this.int16[o3 + 1] = r3, this.int16[o3 + 2] = n3, this.int16[o3 + 3] = i3, this.int16[o3 + 4] = a3, this.int16[o3 + 5] = s3, t3;
        }
      }
      Ei.prototype.bytesPerElement = 12, $n("StructArrayLayout2i4i12", Ei);
      class Fi extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i3, a3) {
          const s3 = this.length;
          return this.resize(s3 + 1), this.emplace(s3, t3, e2, r3, n3, i3, a3);
        }
        emplace(t3, e2, r3, n3, i3, a3, s3) {
          const o3 = 4 * t3, l3 = 8 * t3;
          return this.int16[o3 + 0] = e2, this.int16[o3 + 1] = r3, this.uint8[l3 + 4] = n3, this.uint8[l3 + 5] = i3, this.uint8[l3 + 6] = a3, this.uint8[l3 + 7] = s3, t3;
        }
      }
      Fi.prototype.bytesPerElement = 8, $n("StructArrayLayout2i4ub8", Fi);
      class Ti extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2) {
          const r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, t3, e2);
        }
        emplace(t3, e2, r3) {
          const n3 = 2 * t3;
          return this.float32[n3 + 0] = e2, this.float32[n3 + 1] = r3, t3;
        }
      }
      Ti.prototype.bytesPerElement = 8, $n("StructArrayLayout2f8", Ti);
      class $i extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3) {
          const c3 = this.length;
          return this.resize(c3 + 1), this.emplace(c3, t3, e2, r3, n3, i3, a3, s3, o3, l3, u3);
        }
        emplace(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3) {
          const h3 = 10 * t3;
          return this.uint16[h3 + 0] = e2, this.uint16[h3 + 1] = r3, this.uint16[h3 + 2] = n3, this.uint16[h3 + 3] = i3, this.uint16[h3 + 4] = a3, this.uint16[h3 + 5] = s3, this.uint16[h3 + 6] = o3, this.uint16[h3 + 7] = l3, this.uint16[h3 + 8] = u3, this.uint16[h3 + 9] = c3, t3;
        }
      }
      $i.prototype.bytesPerElement = 20, $n("StructArrayLayout10ui20", $i);
      class Li extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3) {
          const p3 = this.length;
          return this.resize(p3 + 1), this.emplace(p3, t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3);
        }
        emplace(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3) {
          const f3 = 12 * t3;
          return this.int16[f3 + 0] = e2, this.int16[f3 + 1] = r3, this.int16[f3 + 2] = n3, this.int16[f3 + 3] = i3, this.uint16[f3 + 4] = a3, this.uint16[f3 + 5] = s3, this.uint16[f3 + 6] = o3, this.uint16[f3 + 7] = l3, this.int16[f3 + 8] = u3, this.int16[f3 + 9] = c3, this.int16[f3 + 10] = h3, this.int16[f3 + 11] = p3, t3;
        }
      }
      Li.prototype.bytesPerElement = 24, $n("StructArrayLayout4i4ui4i24", Li);
      class Di extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3) {
          const n3 = this.length;
          return this.resize(n3 + 1), this.emplace(n3, t3, e2, r3);
        }
        emplace(t3, e2, r3, n3) {
          const i3 = 3 * t3;
          return this.float32[i3 + 0] = e2, this.float32[i3 + 1] = r3, this.float32[i3 + 2] = n3, t3;
        }
      }
      Di.prototype.bytesPerElement = 12, $n("StructArrayLayout3f12", Di);
      class Oi extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t3) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t3);
        }
        emplace(t3, e2) {
          return this.uint32[1 * t3 + 0] = e2, t3;
        }
      }
      Oi.prototype.bytesPerElement = 4, $n("StructArrayLayout1ul4", Oi);
      class Ui extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i3, a3, s3, o3, l3) {
          const u3 = this.length;
          return this.resize(u3 + 1), this.emplace(u3, t3, e2, r3, n3, i3, a3, s3, o3, l3);
        }
        emplace(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3) {
          const c3 = 10 * t3, h3 = 5 * t3;
          return this.int16[c3 + 0] = e2, this.int16[c3 + 1] = r3, this.int16[c3 + 2] = n3, this.int16[c3 + 3] = i3, this.int16[c3 + 4] = a3, this.int16[c3 + 5] = s3, this.uint32[h3 + 3] = o3, this.uint16[c3 + 8] = l3, this.uint16[c3 + 9] = u3, t3;
        }
      }
      Ui.prototype.bytesPerElement = 20, $n("StructArrayLayout6i1ul2ui20", Ui);
      class Ri extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i3, a3) {
          const s3 = this.length;
          return this.resize(s3 + 1), this.emplace(s3, t3, e2, r3, n3, i3, a3);
        }
        emplace(t3, e2, r3, n3, i3, a3, s3) {
          const o3 = 6 * t3;
          return this.int16[o3 + 0] = e2, this.int16[o3 + 1] = r3, this.int16[o3 + 2] = n3, this.int16[o3 + 3] = i3, this.int16[o3 + 4] = a3, this.int16[o3 + 5] = s3, t3;
        }
      }
      Ri.prototype.bytesPerElement = 12, $n("StructArrayLayout2i2i2i12", Ri);
      class qi extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i3) {
          const a3 = this.length;
          return this.resize(a3 + 1), this.emplace(a3, t3, e2, r3, n3, i3);
        }
        emplace(t3, e2, r3, n3, i3, a3) {
          const s3 = 4 * t3, o3 = 8 * t3;
          return this.float32[s3 + 0] = e2, this.float32[s3 + 1] = r3, this.float32[s3 + 2] = n3, this.int16[o3 + 6] = i3, this.int16[o3 + 7] = a3, t3;
        }
      }
      qi.prototype.bytesPerElement = 16, $n("StructArrayLayout2f1f2i16", qi);
      class ji extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3) {
          const i3 = this.length;
          return this.resize(i3 + 1), this.emplace(i3, t3, e2, r3, n3);
        }
        emplace(t3, e2, r3, n3, i3) {
          const a3 = 12 * t3, s3 = 3 * t3;
          return this.uint8[a3 + 0] = e2, this.uint8[a3 + 1] = r3, this.float32[s3 + 1] = n3, this.float32[s3 + 2] = i3, t3;
        }
      }
      ji.prototype.bytesPerElement = 12, $n("StructArrayLayout2ub2f12", ji);
      class Ni extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3) {
          const n3 = this.length;
          return this.resize(n3 + 1), this.emplace(n3, t3, e2, r3);
        }
        emplace(t3, e2, r3, n3) {
          const i3 = 3 * t3;
          return this.uint16[i3 + 0] = e2, this.uint16[i3 + 1] = r3, this.uint16[i3 + 2] = n3, t3;
        }
      }
      Ni.prototype.bytesPerElement = 6, $n("StructArrayLayout3ui6", Ni);
      class Zi extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3) {
          const g3 = this.length;
          return this.resize(g3 + 1), this.emplace(g3, t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3);
        }
        emplace(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3, g3) {
          const x3 = 24 * t3, v3 = 12 * t3, b3 = 48 * t3;
          return this.int16[x3 + 0] = e2, this.int16[x3 + 1] = r3, this.uint16[x3 + 2] = n3, this.uint16[x3 + 3] = i3, this.uint32[v3 + 2] = a3, this.uint32[v3 + 3] = s3, this.uint32[v3 + 4] = o3, this.uint16[x3 + 10] = l3, this.uint16[x3 + 11] = u3, this.uint16[x3 + 12] = c3, this.float32[v3 + 7] = h3, this.float32[v3 + 8] = p3, this.uint8[b3 + 36] = f3, this.uint8[b3 + 37] = d3, this.uint8[b3 + 38] = y3, this.uint32[v3 + 10] = m3, this.int16[x3 + 22] = g3, t3;
        }
      }
      Zi.prototype.bytesPerElement = 48, $n("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Zi);
      class Ki extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3, g3, x3, v3, b3, w3, _3, A3, S3, k3, I3, z3) {
          const M3 = this.length;
          return this.resize(M3 + 1), this.emplace(M3, t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3, g3, x3, v3, b3, w3, _3, A3, S3, k3, I3, z3);
        }
        emplace(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3, g3, x3, v3, b3, w3, _3, A3, S3, k3, I3, z3, M3) {
          const C3 = 32 * t3, B3 = 16 * t3;
          return this.int16[C3 + 0] = e2, this.int16[C3 + 1] = r3, this.int16[C3 + 2] = n3, this.int16[C3 + 3] = i3, this.int16[C3 + 4] = a3, this.int16[C3 + 5] = s3, this.int16[C3 + 6] = o3, this.int16[C3 + 7] = l3, this.uint16[C3 + 8] = u3, this.uint16[C3 + 9] = c3, this.uint16[C3 + 10] = h3, this.uint16[C3 + 11] = p3, this.uint16[C3 + 12] = f3, this.uint16[C3 + 13] = d3, this.uint16[C3 + 14] = y3, this.uint16[C3 + 15] = m3, this.uint16[C3 + 16] = g3, this.uint16[C3 + 17] = x3, this.uint16[C3 + 18] = v3, this.uint16[C3 + 19] = b3, this.uint16[C3 + 20] = w3, this.uint16[C3 + 21] = _3, this.uint16[C3 + 22] = A3, this.uint32[B3 + 12] = S3, this.float32[B3 + 13] = k3, this.float32[B3 + 14] = I3, this.uint16[C3 + 30] = z3, this.uint16[C3 + 31] = M3, t3;
        }
      }
      Ki.prototype.bytesPerElement = 64, $n("StructArrayLayout8i15ui1ul2f2ui64", Ki);
      class Gi extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t3);
        }
        emplace(t3, e2) {
          return this.float32[1 * t3 + 0] = e2, t3;
        }
      }
      Gi.prototype.bytesPerElement = 4, $n("StructArrayLayout1f4", Gi);
      class Ji extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3) {
          const n3 = this.length;
          return this.resize(n3 + 1), this.emplace(n3, t3, e2, r3);
        }
        emplace(t3, e2, r3, n3) {
          const i3 = 3 * t3;
          return this.uint16[6 * t3 + 0] = e2, this.float32[i3 + 1] = r3, this.float32[i3 + 2] = n3, t3;
        }
      }
      Ji.prototype.bytesPerElement = 12, $n("StructArrayLayout1ui2f12", Ji);
      class Xi extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3) {
          const n3 = this.length;
          return this.resize(n3 + 1), this.emplace(n3, t3, e2, r3);
        }
        emplace(t3, e2, r3, n3) {
          const i3 = 4 * t3;
          return this.uint32[2 * t3 + 0] = e2, this.uint16[i3 + 2] = r3, this.uint16[i3 + 3] = n3, t3;
        }
      }
      Xi.prototype.bytesPerElement = 8, $n("StructArrayLayout1ul2ui8", Xi);
      class Yi extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2) {
          const r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, t3, e2);
        }
        emplace(t3, e2, r3) {
          const n3 = 2 * t3;
          return this.uint16[n3 + 0] = e2, this.uint16[n3 + 1] = r3, t3;
        }
      }
      Yi.prototype.bytesPerElement = 4, $n("StructArrayLayout2ui4", Yi);
      class Hi extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t3);
        }
        emplace(t3, e2) {
          return this.uint16[1 * t3 + 0] = e2, t3;
        }
      }
      Hi.prototype.bytesPerElement = 2, $n("StructArrayLayout1ui2", Hi);
      class Wi extends zi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3) {
          const i3 = this.length;
          return this.resize(i3 + 1), this.emplace(i3, t3, e2, r3, n3);
        }
        emplace(t3, e2, r3, n3, i3) {
          const a3 = 4 * t3;
          return this.float32[a3 + 0] = e2, this.float32[a3 + 1] = r3, this.float32[a3 + 2] = n3, this.float32[a3 + 3] = i3, t3;
        }
      }
      Wi.prototype.bytesPerElement = 16, $n("StructArrayLayout4f16", Wi);
      class Qi extends Ii {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new a2(this.anchorPointX, this.anchorPointY);
        }
      }
      Qi.prototype.size = 20;
      class ta extends Ui {
        get(t3) {
          return new Qi(this, t3);
        }
      }
      $n("CollisionBoxArray", ta);
      class ea extends Ii {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(t3) {
          this._structArray.uint8[this._pos1 + 37] = t3;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(t3) {
          this._structArray.uint8[this._pos1 + 38] = t3;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(t3) {
          this._structArray.uint32[this._pos4 + 10] = t3;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      ea.prototype.size = 48;
      class ra extends Zi {
        get(t3) {
          return new ea(this, t3);
        }
      }
      $n("PlacedSymbolArray", ra);
      class na extends Ii {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(t3) {
          this._structArray.uint32[this._pos4 + 12] = t3;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      na.prototype.size = 64;
      class ia extends Ki {
        get(t3) {
          return new na(this, t3);
        }
      }
      $n("SymbolInstanceArray", ia);
      class aa extends Gi {
        getoffsetX(t3) {
          return this.float32[1 * t3 + 0];
        }
      }
      $n("GlyphOffsetArray", aa);
      class sa extends Pi {
        getx(t3) {
          return this.int16[3 * t3 + 0];
        }
        gety(t3) {
          return this.int16[3 * t3 + 1];
        }
        gettileUnitDistanceFromAnchor(t3) {
          return this.int16[3 * t3 + 2];
        }
      }
      $n("SymbolLineVertexArray", sa);
      class oa extends Ii {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      oa.prototype.size = 12;
      class la extends Ji {
        get(t3) {
          return new oa(this, t3);
        }
      }
      $n("TextAnchorOffsetArray", la);
      class ua extends Ii {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      ua.prototype.size = 8;
      class ca extends Xi {
        get(t3) {
          return new ua(this, t3);
        }
      }
      $n("FeatureIndexArray", ca);
      class ha extends Bi {
      }
      class pa extends Bi {
      }
      class fa extends Bi {
      }
      class da extends Ei {
      }
      class ya extends Fi {
      }
      class ma extends Ti {
      }
      class ga extends $i {
      }
      class xa extends Li {
      }
      class va extends Di {
      }
      class ba extends Oi {
      }
      class wa extends Ri {
      }
      class _a2 extends ji {
      }
      class Aa extends Ni {
      }
      class Sa extends Yi {
      }
      const ka = Mi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ia } = ka;
      class za {
        constructor(t3 = []) {
          this.segments = t3;
        }
        prepareSegment(t3, e2, r3, n3) {
          let i3 = this.segments[this.segments.length - 1];
          return t3 > za.MAX_VERTEX_ARRAY_LENGTH && A2(`Max vertices per segment is ${za.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t3}`), (!i3 || i3.vertexLength + t3 > za.MAX_VERTEX_ARRAY_LENGTH || i3.sortKey !== n3) && (i3 = { vertexOffset: e2.length, primitiveOffset: r3.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n3 && (i3.sortKey = n3), this.segments.push(i3)), i3;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t3 of this.segments) for (const e2 in t3.vaos) t3.vaos[e2].destroy();
        }
        static simpleSegment(t3, e2, r3, n3) {
          return new za([{ vertexOffset: t3, primitiveOffset: e2, vertexLength: r3, primitiveLength: n3, vaos: {}, sortKey: 0 }]);
        }
      }
      function Ma(t3, e2) {
        return 256 * (t3 = y2(Math.floor(t3), 0, 255)) + y2(Math.floor(e2), 0, 255);
      }
      za.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, $n("SegmentVector", za);
      const Ca = Mi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var Ba = { exports: {} }, Pa = { exports: {} };
      Pa.exports = function(t3, e2) {
        var r3, n3, i3, a3, s3, o3, l3, u3;
        for (n3 = t3.length - (r3 = 3 & t3.length), i3 = e2, s3 = 3432918353, o3 = 461845907, u3 = 0; u3 < n3; ) l3 = 255 & t3.charCodeAt(u3) | (255 & t3.charCodeAt(++u3)) << 8 | (255 & t3.charCodeAt(++u3)) << 16 | (255 & t3.charCodeAt(++u3)) << 24, ++u3, i3 = 27492 + (65535 & (a3 = 5 * (65535 & (i3 = (i3 ^= l3 = (65535 & (l3 = (l3 = (65535 & l3) * s3 + (((l3 >>> 16) * s3 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o3 + (((l3 >>> 16) * o3 & 65535) << 16) & 4294967295) << 13 | i3 >>> 19)) + ((5 * (i3 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a3 >>> 16) & 65535) << 16);
        switch (l3 = 0, r3) {
          case 3:
            l3 ^= (255 & t3.charCodeAt(u3 + 2)) << 16;
          case 2:
            l3 ^= (255 & t3.charCodeAt(u3 + 1)) << 8;
          case 1:
            i3 ^= l3 = (65535 & (l3 = (l3 = (65535 & (l3 ^= 255 & t3.charCodeAt(u3))) * s3 + (((l3 >>> 16) * s3 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o3 + (((l3 >>> 16) * o3 & 65535) << 16) & 4294967295;
        }
        return i3 ^= t3.length, i3 = 2246822507 * (65535 & (i3 ^= i3 >>> 16)) + ((2246822507 * (i3 >>> 16) & 65535) << 16) & 4294967295, i3 = 3266489909 * (65535 & (i3 ^= i3 >>> 13)) + ((3266489909 * (i3 >>> 16) & 65535) << 16) & 4294967295, (i3 ^= i3 >>> 16) >>> 0;
      };
      var Va = Pa.exports, Ea = { exports: {} };
      Ea.exports = function(t3, e2) {
        for (var r3, n3 = t3.length, i3 = e2 ^ n3, a3 = 0; n3 >= 4; ) r3 = 1540483477 * (65535 & (r3 = 255 & t3.charCodeAt(a3) | (255 & t3.charCodeAt(++a3)) << 8 | (255 & t3.charCodeAt(++a3)) << 16 | (255 & t3.charCodeAt(++a3)) << 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16), i3 = 1540483477 * (65535 & i3) + ((1540483477 * (i3 >>> 16) & 65535) << 16) ^ (r3 = 1540483477 * (65535 & (r3 ^= r3 >>> 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16)), n3 -= 4, ++a3;
        switch (n3) {
          case 3:
            i3 ^= (255 & t3.charCodeAt(a3 + 2)) << 16;
          case 2:
            i3 ^= (255 & t3.charCodeAt(a3 + 1)) << 8;
          case 1:
            i3 = 1540483477 * (65535 & (i3 ^= 255 & t3.charCodeAt(a3))) + ((1540483477 * (i3 >>> 16) & 65535) << 16);
        }
        return i3 = 1540483477 * (65535 & (i3 ^= i3 >>> 13)) + ((1540483477 * (i3 >>> 16) & 65535) << 16), (i3 ^= i3 >>> 15) >>> 0;
      };
      var Fa = Va, Ta = Ea.exports;
      Ba.exports = Fa, Ba.exports.murmur3 = Fa, Ba.exports.murmur2 = Ta;
      var $a = r2(Ba.exports);
      class La {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = false;
        }
        add(t3, e2, r3, n3) {
          this.ids.push(Da(t3)), this.positions.push(e2, r3, n3);
        }
        getPositions(t3) {
          if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
          const e2 = Da(t3);
          let r3 = 0, n3 = this.ids.length - 1;
          for (; r3 < n3; ) {
            const t4 = r3 + n3 >> 1;
            this.ids[t4] >= e2 ? n3 = t4 : r3 = t4 + 1;
          }
          const i3 = [];
          for (; this.ids[r3] === e2; ) i3.push({ index: this.positions[3 * r3], start: this.positions[3 * r3 + 1], end: this.positions[3 * r3 + 2] }), r3++;
          return i3;
        }
        static serialize(t3, e2) {
          const r3 = new Float64Array(t3.ids), n3 = new Uint32Array(t3.positions);
          return Oa(r3, n3, 0, r3.length - 1), e2 && e2.push(r3.buffer, n3.buffer), { ids: r3, positions: n3 };
        }
        static deserialize(t3) {
          const e2 = new La();
          return e2.ids = t3.ids, e2.positions = t3.positions, e2.indexed = true, e2;
        }
      }
      function Da(t3) {
        const e2 = +t3;
        return !isNaN(e2) && e2 <= Number.MAX_SAFE_INTEGER ? e2 : $a(String(t3));
      }
      function Oa(t3, e2, r3, n3) {
        for (; r3 < n3; ) {
          const i3 = t3[r3 + n3 >> 1];
          let a3 = r3 - 1, s3 = n3 + 1;
          for (; ; ) {
            do {
              a3++;
            } while (t3[a3] < i3);
            do {
              s3--;
            } while (t3[s3] > i3);
            if (a3 >= s3) break;
            Ua(t3, a3, s3), Ua(e2, 3 * a3, 3 * s3), Ua(e2, 3 * a3 + 1, 3 * s3 + 1), Ua(e2, 3 * a3 + 2, 3 * s3 + 2);
          }
          s3 - r3 < n3 - s3 ? (Oa(t3, e2, r3, s3), r3 = s3 + 1) : (Oa(t3, e2, s3 + 1, n3), n3 = s3);
        }
      }
      function Ua(t3, e2, r3) {
        const n3 = t3[e2];
        t3[e2] = t3[r3], t3[r3] = n3;
      }
      $n("FeaturePositionMap", La);
      class Ra {
        constructor(t3, e2) {
          this.gl = t3.gl, this.location = e2;
        }
      }
      class qa extends Ra {
        constructor(t3, e2) {
          super(t3, e2), this.current = 0;
        }
        set(t3) {
          this.current !== t3 && (this.current = t3, this.gl.uniform1f(this.location, t3));
        }
      }
      class ja extends Ra {
        constructor(t3, e2) {
          super(t3, e2), this.current = [0, 0, 0, 0];
        }
        set(t3) {
          t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] && t3[3] === this.current[3] || (this.current = t3, this.gl.uniform4f(this.location, t3[0], t3[1], t3[2], t3[3]));
        }
      }
      class Na extends Ra {
        constructor(t3, e2) {
          super(t3, e2), this.current = Yt.transparent;
        }
        set(t3) {
          t3.r === this.current.r && t3.g === this.current.g && t3.b === this.current.b && t3.a === this.current.a || (this.current = t3, this.gl.uniform4f(this.location, t3.r, t3.g, t3.b, t3.a));
        }
      }
      const Za = new Float32Array(16);
      function Ka(t3) {
        return [Ma(255 * t3.r, 255 * t3.g), Ma(255 * t3.b, 255 * t3.a)];
      }
      class Ga {
        constructor(t3, e2, r3) {
          this.value = t3, this.uniformNames = e2.map((t4) => `u_${t4}`), this.type = r3;
        }
        setUniform(t3, e2, r3) {
          t3.set(r3.constantOr(this.value));
        }
        getBinding(t3, e2, r3) {
          return "color" === this.type ? new Na(t3, e2) : new qa(t3, e2);
        }
      }
      class Ja {
        constructor(t3, e2) {
          this.uniformNames = e2.map((t4) => `u_${t4}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(t3, e2) {
          this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t3.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t3.tlbr;
        }
        setUniform(t3, e2, r3, n3) {
          const i3 = "u_pattern_to" === n3 ? this.patternTo : "u_pattern_from" === n3 ? this.patternFrom : "u_pixel_ratio_to" === n3 ? this.pixelRatioTo : "u_pixel_ratio_from" === n3 ? this.pixelRatioFrom : null;
          i3 && t3.set(i3);
        }
        getBinding(t3, e2, r3) {
          return "u_pattern" === r3.substr(0, 9) ? new ja(t3, e2) : new qa(t3, e2);
        }
      }
      class Xa {
        constructor(t3, e2, r3, n3) {
          this.expression = t3, this.type = r3, this.maxValue = 0, this.paintVertexAttributes = e2.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: "color" === r3 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n3();
        }
        populatePaintArray(t3, e2, r3, n3, i3) {
          const a3 = this.paintVertexArray.length, s3 = this.expression.evaluate(new li(0), e2, {}, n3, [], i3);
          this.paintVertexArray.resize(t3), this._setPaintValue(a3, t3, s3);
        }
        updatePaintArray(t3, e2, r3, n3) {
          const i3 = this.expression.evaluate({ zoom: 0 }, r3, n3);
          this._setPaintValue(t3, e2, i3);
        }
        _setPaintValue(t3, e2, r3) {
          if ("color" === this.type) {
            const n3 = Ka(r3);
            for (let r4 = t3; r4 < e2; r4++) this.paintVertexArray.emplace(r4, n3[0], n3[1]);
          } else {
            for (let n3 = t3; n3 < e2; n3++) this.paintVertexArray.emplace(n3, r3);
            this.maxValue = Math.max(this.maxValue, Math.abs(r3));
          }
        }
        upload(t3) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Ya {
        constructor(t3, e2, r3, n3, i3, a3) {
          this.expression = t3, this.uniformNames = e2.map((t4) => `u_${t4}_t`), this.type = r3, this.useIntegerZoom = n3, this.zoom = i3, this.maxValue = 0, this.paintVertexAttributes = e2.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: "color" === r3 ? 4 : 2, offset: 0 })), this.paintVertexArray = new a3();
        }
        populatePaintArray(t3, e2, r3, n3, i3) {
          const a3 = this.expression.evaluate(new li(this.zoom), e2, {}, n3, [], i3), s3 = this.expression.evaluate(new li(this.zoom + 1), e2, {}, n3, [], i3), o3 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t3), this._setPaintValue(o3, t3, a3, s3);
        }
        updatePaintArray(t3, e2, r3, n3) {
          const i3 = this.expression.evaluate({ zoom: this.zoom }, r3, n3), a3 = this.expression.evaluate({ zoom: this.zoom + 1 }, r3, n3);
          this._setPaintValue(t3, e2, i3, a3);
        }
        _setPaintValue(t3, e2, r3, n3) {
          if ("color" === this.type) {
            const i3 = Ka(r3), a3 = Ka(n3);
            for (let r4 = t3; r4 < e2; r4++) this.paintVertexArray.emplace(r4, i3[0], i3[1], a3[0], a3[1]);
          } else {
            for (let i3 = t3; i3 < e2; i3++) this.paintVertexArray.emplace(i3, r3, n3);
            this.maxValue = Math.max(this.maxValue, Math.abs(r3), Math.abs(n3));
          }
        }
        upload(t3) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t3, e2) {
          const r3 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n3 = y2(this.expression.interpolationFactor(r3, this.zoom, this.zoom + 1), 0, 1);
          t3.set(n3);
        }
        getBinding(t3, e2, r3) {
          return new qa(t3, e2);
        }
      }
      class Ha {
        constructor(t3, e2, r3, n3, i3, a3) {
          this.expression = t3, this.type = e2, this.useIntegerZoom = r3, this.zoom = n3, this.layerId = a3, this.zoomInPaintVertexArray = new i3(), this.zoomOutPaintVertexArray = new i3();
        }
        populatePaintArray(t3, e2, r3) {
          const n3 = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(t3), this.zoomOutPaintVertexArray.resize(t3), this._setPaintValues(n3, t3, e2.patterns && e2.patterns[this.layerId], r3);
        }
        updatePaintArray(t3, e2, r3, n3, i3) {
          this._setPaintValues(t3, e2, r3.patterns && r3.patterns[this.layerId], i3);
        }
        _setPaintValues(t3, e2, r3, n3) {
          if (!n3 || !r3) return;
          const { min: i3, mid: a3, max: s3 } = r3, o3 = n3[i3], l3 = n3[a3], u3 = n3[s3];
          if (o3 && l3 && u3) for (let r4 = t3; r4 < e2; r4++) this.zoomInPaintVertexArray.emplace(r4, l3.tl[0], l3.tl[1], l3.br[0], l3.br[1], o3.tl[0], o3.tl[1], o3.br[0], o3.br[1], l3.pixelRatio, o3.pixelRatio), this.zoomOutPaintVertexArray.emplace(r4, l3.tl[0], l3.tl[1], l3.br[0], l3.br[1], u3.tl[0], u3.tl[1], u3.br[0], u3.br[1], l3.pixelRatio, u3.pixelRatio);
        }
        upload(t3) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t3.createVertexBuffer(this.zoomInPaintVertexArray, Ca.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t3.createVertexBuffer(this.zoomOutPaintVertexArray, Ca.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class Wa {
        constructor(t3, e2, r3) {
          this.binders = {}, this._buffers = [];
          const n3 = [];
          for (const i3 in t3.paint._values) {
            if (!r3(i3)) continue;
            const a3 = t3.paint.get(i3);
            if (!(a3 instanceof yi && _r(a3.property.specification))) continue;
            const s3 = ts(i3, t3.type), o3 = a3.value, l3 = a3.property.specification.type, u3 = a3.property.useIntegerZoom, c3 = a3.property.specification["property-type"], h3 = "cross-faded" === c3 || "cross-faded-data-driven" === c3;
            if ("constant" === o3.kind) this.binders[i3] = h3 ? new Ja(o3.value, s3) : new Ga(o3.value, s3, l3), n3.push(`/u_${i3}`);
            else if ("source" === o3.kind || h3) {
              const r4 = es(i3, l3, "source");
              this.binders[i3] = h3 ? new Ha(o3, l3, u3, e2, r4, t3.id) : new Xa(o3, s3, l3, r4), n3.push(`/a_${i3}`);
            } else {
              const t4 = es(i3, l3, "composite");
              this.binders[i3] = new Ya(o3, s3, l3, u3, e2, t4), n3.push(`/z_${i3}`);
            }
          }
          this.cacheKey = n3.sort().join("");
        }
        getMaxValue(t3) {
          const e2 = this.binders[t3];
          return e2 instanceof Xa || e2 instanceof Ya ? e2.maxValue : 0;
        }
        populatePaintArrays(t3, e2, r3, n3, i3) {
          for (const a3 in this.binders) {
            const s3 = this.binders[a3];
            (s3 instanceof Xa || s3 instanceof Ya || s3 instanceof Ha) && s3.populatePaintArray(t3, e2, r3, n3, i3);
          }
        }
        setConstantPatternPositions(t3, e2) {
          for (const r3 in this.binders) {
            const n3 = this.binders[r3];
            n3 instanceof Ja && n3.setConstantPatternPositions(t3, e2);
          }
        }
        updatePaintArrays(t3, e2, r3, n3, i3) {
          let a3 = false;
          for (const s3 in t3) {
            const o3 = e2.getPositions(s3);
            for (const e3 of o3) {
              const o4 = r3.feature(e3.index);
              for (const r4 in this.binders) {
                const l3 = this.binders[r4];
                if ((l3 instanceof Xa || l3 instanceof Ya || l3 instanceof Ha) && true === l3.expression.isStateDependent) {
                  const u3 = n3.paint.get(r4);
                  l3.expression = u3.value, l3.updatePaintArray(e3.start, e3.end, o4, t3[s3], i3), a3 = true;
                }
              }
            }
          }
          return a3;
        }
        defines() {
          const t3 = [];
          for (const e2 in this.binders) {
            const r3 = this.binders[e2];
            (r3 instanceof Ga || r3 instanceof Ja) && t3.push(...r3.uniformNames.map((t4) => `#define HAS_UNIFORM_${t4}`));
          }
          return t3;
        }
        getBinderAttributes() {
          const t3 = [];
          for (const e2 in this.binders) {
            const r3 = this.binders[e2];
            if (r3 instanceof Xa || r3 instanceof Ya) for (let e3 = 0; e3 < r3.paintVertexAttributes.length; e3++) t3.push(r3.paintVertexAttributes[e3].name);
            else if (r3 instanceof Ha) for (let e3 = 0; e3 < Ca.members.length; e3++) t3.push(Ca.members[e3].name);
          }
          return t3;
        }
        getBinderUniforms() {
          const t3 = [];
          for (const e2 in this.binders) {
            const r3 = this.binders[e2];
            if (r3 instanceof Ga || r3 instanceof Ja || r3 instanceof Ya) for (const e3 of r3.uniformNames) t3.push(e3);
          }
          return t3;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t3, e2) {
          const r3 = [];
          for (const n3 in this.binders) {
            const i3 = this.binders[n3];
            if (i3 instanceof Ga || i3 instanceof Ja || i3 instanceof Ya) {
              for (const a3 of i3.uniformNames) if (e2[a3]) {
                const s3 = i3.getBinding(t3, e2[a3], a3);
                r3.push({ name: a3, property: n3, binding: s3 });
              }
            }
          }
          return r3;
        }
        setUniforms(t3, e2, r3, n3) {
          for (const { name: t4, property: i3, binding: a3 } of e2) this.binders[i3].setUniform(a3, n3, r3.get(i3), t4);
        }
        updatePaintBuffers(t3) {
          this._buffers = [];
          for (const e2 in this.binders) {
            const r3 = this.binders[e2];
            if (t3 && r3 instanceof Ha) {
              const e3 = 2 === t3.fromScale ? r3.zoomInPaintVertexBuffer : r3.zoomOutPaintVertexBuffer;
              e3 && this._buffers.push(e3);
            } else (r3 instanceof Xa || r3 instanceof Ya) && r3.paintVertexBuffer && this._buffers.push(r3.paintVertexBuffer);
          }
        }
        upload(t3) {
          for (const e2 in this.binders) {
            const r3 = this.binders[e2];
            (r3 instanceof Xa || r3 instanceof Ya || r3 instanceof Ha) && r3.upload(t3);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t3 in this.binders) {
            const e2 = this.binders[t3];
            (e2 instanceof Xa || e2 instanceof Ya || e2 instanceof Ha) && e2.destroy();
          }
        }
      }
      class Qa {
        constructor(t3, e2, r3 = () => true) {
          this.programConfigurations = {};
          for (const n3 of t3) this.programConfigurations[n3.id] = new Wa(n3, e2, r3);
          this.needsUpload = false, this._featureMap = new La(), this._bufferOffset = 0;
        }
        populatePaintArrays(t3, e2, r3, n3, i3, a3) {
          for (const r4 in this.programConfigurations) this.programConfigurations[r4].populatePaintArrays(t3, e2, n3, i3, a3);
          void 0 !== e2.id && this._featureMap.add(e2.id, r3, this._bufferOffset, t3), this._bufferOffset = t3, this.needsUpload = true;
        }
        updatePaintArrays(t3, e2, r3, n3) {
          for (const i3 of r3) this.needsUpload = this.programConfigurations[i3.id].updatePaintArrays(t3, this._featureMap, e2, i3, n3) || this.needsUpload;
        }
        get(t3) {
          return this.programConfigurations[t3];
        }
        upload(t3) {
          if (this.needsUpload) {
            for (const e2 in this.programConfigurations) this.programConfigurations[e2].upload(t3);
            this.needsUpload = false;
          }
        }
        destroy() {
          for (const t3 in this.programConfigurations) this.programConfigurations[t3].destroy();
        }
      }
      function ts(t3, e2) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t3] || [t3.replace(`${e2}-`, "").replace(/-/g, "_")];
      }
      function es(t3, e2, r3) {
        const n3 = { color: { source: Ti, composite: Wi }, number: { source: Gi, composite: Ti } }, i3 = function(t4) {
          return { "line-pattern": { source: ga, composite: ga }, "fill-pattern": { source: ga, composite: ga }, "fill-extrusion-pattern": { source: ga, composite: ga } }[t4];
        }(t3);
        return i3 && i3[r3] || n3[e2][r3];
      }
      $n("ConstantBinder", Ga), $n("CrossFadedConstantBinder", Ja), $n("SourceExpressionBinder", Xa), $n("CrossFadedCompositeBinder", Ha), $n("CompositeExpressionBinder", Ya), $n("ProgramConfiguration", Wa, { omit: ["_buffers"] }), $n("ProgramConfigurationSet", Qa);
      const rs = 8192, ns = Math.pow(2, 14) - 1, is = -ns - 1;
      function as(t3) {
        const e2 = rs / t3.extent, r3 = t3.loadGeometry();
        for (let t4 = 0; t4 < r3.length; t4++) {
          const n3 = r3[t4];
          for (let t5 = 0; t5 < n3.length; t5++) {
            const r4 = n3[t5], i3 = Math.round(r4.x * e2), a3 = Math.round(r4.y * e2);
            r4.x = y2(i3, is, ns), r4.y = y2(a3, is, ns), (i3 < r4.x || i3 > r4.x + 1 || a3 < r4.y || a3 > r4.y + 1) && A2("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return r3;
      }
      function ss2(t3, e2) {
        return { type: t3.type, id: t3.id, properties: t3.properties, geometry: e2 ? as(t3) : [] };
      }
      function os(t3, e2, r3, n3, i3) {
        t3.emplaceBack(2 * e2 + (n3 + 1) / 2, 2 * r3 + (i3 + 1) / 2);
      }
      class ls {
        constructor(t3) {
          this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.layoutVertexArray = new pa(), this.indexArray = new Aa(), this.segments = new za(), this.programConfigurations = new Qa(t3.layers, t3.zoom), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
        }
        populate(t3, e2, r3) {
          const n3 = this.layers[0], i3 = [];
          let a3 = null, s3 = false;
          "circle" === n3.type && (a3 = n3.layout.get("circle-sort-key"), s3 = !a3.isConstant());
          for (const { feature: e3, id: n4, index: o3, sourceLayerIndex: l3 } of t3) {
            const t4 = this.layers[0]._featureFilter.needGeometry, u3 = ss2(e3, t4);
            if (!this.layers[0]._featureFilter.filter(new li(this.zoom), u3, r3)) continue;
            const c3 = s3 ? a3.evaluate(u3, {}, r3) : void 0, h3 = { id: n4, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t4 ? u3.geometry : as(e3), patterns: {}, sortKey: c3 };
            i3.push(h3);
          }
          s3 && i3.sort((t4, e3) => t4.sortKey - e3.sortKey);
          for (const n4 of i3) {
            const { geometry: i4, index: a4, sourceLayerIndex: s4 } = n4, o3 = t3[a4].feature;
            this.addFeature(n4, i4, a4, r3), e2.featureIndex.insert(o3, i4, a4, s4, this.index);
          }
        }
        update(t3, e2, r3) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e2, this.stateDependentLayers, r3);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t3) {
          this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Ia), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t3, e2, r3, n3) {
          for (const r4 of e2) for (const e3 of r4) {
            const r5 = e3.x, n4 = e3.y;
            if (r5 < 0 || r5 >= rs || n4 < 0 || n4 >= rs) continue;
            const i3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t3.sortKey), a3 = i3.vertexLength;
            os(this.layoutVertexArray, r5, n4, -1, -1), os(this.layoutVertexArray, r5, n4, 1, -1), os(this.layoutVertexArray, r5, n4, 1, 1), os(this.layoutVertexArray, r5, n4, -1, 1), this.indexArray.emplaceBack(a3, a3 + 1, a3 + 2), this.indexArray.emplaceBack(a3, a3 + 3, a3 + 2), i3.vertexLength += 4, i3.primitiveLength += 2;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, {}, n3);
        }
      }
      function us(t3, e2) {
        for (let r3 = 0; r3 < t3.length; r3++) if (xs(e2, t3[r3])) return true;
        for (let r3 = 0; r3 < e2.length; r3++) if (xs(t3, e2[r3])) return true;
        return !!fs(t3, e2);
      }
      function cs(t3, e2, r3) {
        return !!xs(t3, e2) || !!ys(e2, t3, r3);
      }
      function hs(t3, e2) {
        if (1 === t3.length) return gs(e2, t3[0]);
        for (let r3 = 0; r3 < e2.length; r3++) {
          const n3 = e2[r3];
          for (let e3 = 0; e3 < n3.length; e3++) if (xs(t3, n3[e3])) return true;
        }
        for (let r3 = 0; r3 < t3.length; r3++) if (gs(e2, t3[r3])) return true;
        for (let r3 = 0; r3 < e2.length; r3++) if (fs(t3, e2[r3])) return true;
        return false;
      }
      function ps(t3, e2, r3) {
        if (t3.length > 1) {
          if (fs(t3, e2)) return true;
          for (let n3 = 0; n3 < e2.length; n3++) if (ys(e2[n3], t3, r3)) return true;
        }
        for (let n3 = 0; n3 < t3.length; n3++) if (ys(t3[n3], e2, r3)) return true;
        return false;
      }
      function fs(t3, e2) {
        if (0 === t3.length || 0 === e2.length) return false;
        for (let r3 = 0; r3 < t3.length - 1; r3++) {
          const n3 = t3[r3], i3 = t3[r3 + 1];
          for (let t4 = 0; t4 < e2.length - 1; t4++) if (ds(n3, i3, e2[t4], e2[t4 + 1])) return true;
        }
        return false;
      }
      function ds(t3, e2, r3, n3) {
        return S2(t3, r3, n3) !== S2(e2, r3, n3) && S2(t3, e2, r3) !== S2(t3, e2, n3);
      }
      function ys(t3, e2, r3) {
        const n3 = r3 * r3;
        if (1 === e2.length) return t3.distSqr(e2[0]) < n3;
        for (let r4 = 1; r4 < e2.length; r4++) if (ms(t3, e2[r4 - 1], e2[r4]) < n3) return true;
        return false;
      }
      function ms(t3, e2, r3) {
        const n3 = e2.distSqr(r3);
        if (0 === n3) return t3.distSqr(e2);
        const i3 = ((t3.x - e2.x) * (r3.x - e2.x) + (t3.y - e2.y) * (r3.y - e2.y)) / n3;
        return t3.distSqr(i3 < 0 ? e2 : i3 > 1 ? r3 : r3.sub(e2)._mult(i3)._add(e2));
      }
      function gs(t3, e2) {
        let r3, n3, i3, a3 = false;
        for (let s3 = 0; s3 < t3.length; s3++) {
          r3 = t3[s3];
          for (let t4 = 0, s4 = r3.length - 1; t4 < r3.length; s4 = t4++) n3 = r3[t4], i3 = r3[s4], n3.y > e2.y != i3.y > e2.y && e2.x < (i3.x - n3.x) * (e2.y - n3.y) / (i3.y - n3.y) + n3.x && (a3 = !a3);
        }
        return a3;
      }
      function xs(t3, e2) {
        let r3 = false;
        for (let n3 = 0, i3 = t3.length - 1; n3 < t3.length; i3 = n3++) {
          const a3 = t3[n3], s3 = t3[i3];
          a3.y > e2.y != s3.y > e2.y && e2.x < (s3.x - a3.x) * (e2.y - a3.y) / (s3.y - a3.y) + a3.x && (r3 = !r3);
        }
        return r3;
      }
      function vs(t3, e2, r3) {
        const n3 = r3[0], i3 = r3[2];
        if (t3.x < n3.x && e2.x < n3.x || t3.x > i3.x && e2.x > i3.x || t3.y < n3.y && e2.y < n3.y || t3.y > i3.y && e2.y > i3.y) return false;
        const a3 = S2(t3, e2, r3[0]);
        return a3 !== S2(t3, e2, r3[1]) || a3 !== S2(t3, e2, r3[2]) || a3 !== S2(t3, e2, r3[3]);
      }
      function bs(t3, e2, r3) {
        const n3 = e2.paint.get(t3).value;
        return "constant" === n3.kind ? n3.value : r3.programConfigurations.get(e2.id).getMaxValue(t3);
      }
      function ws(t3) {
        return Math.sqrt(t3[0] * t3[0] + t3[1] * t3[1]);
      }
      function _s(t3, e2, r3, n3, i3) {
        if (!e2[0] && !e2[1]) return t3;
        const s3 = a2.convert(e2)._mult(i3);
        "viewport" === r3 && s3._rotate(-n3);
        const o3 = [];
        for (let e3 = 0; e3 < t3.length; e3++) o3.push(t3[e3].sub(s3));
        return o3;
      }
      let As, Ss;
      $n("CircleBucket", ls, { omit: ["layers"] });
      var ks = { get paint() {
        return Ss = Ss || new _i({ "circle-radius": new xi(X2.paint_circle["circle-radius"]), "circle-color": new xi(X2.paint_circle["circle-color"]), "circle-blur": new xi(X2.paint_circle["circle-blur"]), "circle-opacity": new xi(X2.paint_circle["circle-opacity"]), "circle-translate": new gi(X2.paint_circle["circle-translate"]), "circle-translate-anchor": new gi(X2.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new gi(X2.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new gi(X2.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new xi(X2.paint_circle["circle-stroke-width"]), "circle-stroke-color": new xi(X2.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new xi(X2.paint_circle["circle-stroke-opacity"]) });
      }, get layout() {
        return As = As || new _i({ "circle-sort-key": new xi(X2.layout_circle["circle-sort-key"]) });
      } }, Is = 1e-6, zs = "undefined" != typeof Float32Array ? Float32Array : Array;
      function Ms(t3) {
        return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
      }
      function Cs(t3, e2, r3) {
        var n3 = e2[0], i3 = e2[1], a3 = e2[2], s3 = e2[3], o3 = e2[4], l3 = e2[5], u3 = e2[6], c3 = e2[7], h3 = e2[8], p3 = e2[9], f3 = e2[10], d3 = e2[11], y3 = e2[12], m3 = e2[13], g3 = e2[14], x3 = e2[15], v3 = r3[0], b3 = r3[1], w3 = r3[2], _3 = r3[3];
        return t3[0] = v3 * n3 + b3 * o3 + w3 * h3 + _3 * y3, t3[1] = v3 * i3 + b3 * l3 + w3 * p3 + _3 * m3, t3[2] = v3 * a3 + b3 * u3 + w3 * f3 + _3 * g3, t3[3] = v3 * s3 + b3 * c3 + w3 * d3 + _3 * x3, t3[4] = (v3 = r3[4]) * n3 + (b3 = r3[5]) * o3 + (w3 = r3[6]) * h3 + (_3 = r3[7]) * y3, t3[5] = v3 * i3 + b3 * l3 + w3 * p3 + _3 * m3, t3[6] = v3 * a3 + b3 * u3 + w3 * f3 + _3 * g3, t3[7] = v3 * s3 + b3 * c3 + w3 * d3 + _3 * x3, t3[8] = (v3 = r3[8]) * n3 + (b3 = r3[9]) * o3 + (w3 = r3[10]) * h3 + (_3 = r3[11]) * y3, t3[9] = v3 * i3 + b3 * l3 + w3 * p3 + _3 * m3, t3[10] = v3 * a3 + b3 * u3 + w3 * f3 + _3 * g3, t3[11] = v3 * s3 + b3 * c3 + w3 * d3 + _3 * x3, t3[12] = (v3 = r3[12]) * n3 + (b3 = r3[13]) * o3 + (w3 = r3[14]) * h3 + (_3 = r3[15]) * y3, t3[13] = v3 * i3 + b3 * l3 + w3 * p3 + _3 * m3, t3[14] = v3 * a3 + b3 * u3 + w3 * f3 + _3 * g3, t3[15] = v3 * s3 + b3 * c3 + w3 * d3 + _3 * x3, t3;
      }
      Math.hypot || (Math.hypot = function() {
        for (var t3 = 0, e2 = arguments.length; e2--; ) t3 += arguments[e2] * arguments[e2];
        return Math.sqrt(t3);
      });
      var Bs, Ps = Cs;
      function Vs(t3, e2, r3) {
        var n3 = e2[0], i3 = e2[1], a3 = e2[2], s3 = e2[3];
        return t3[0] = r3[0] * n3 + r3[4] * i3 + r3[8] * a3 + r3[12] * s3, t3[1] = r3[1] * n3 + r3[5] * i3 + r3[9] * a3 + r3[13] * s3, t3[2] = r3[2] * n3 + r3[6] * i3 + r3[10] * a3 + r3[14] * s3, t3[3] = r3[3] * n3 + r3[7] * i3 + r3[11] * a3 + r3[15] * s3, t3;
      }
      Bs = new zs(4), zs != Float32Array && (Bs[0] = 0, Bs[1] = 0, Bs[2] = 0, Bs[3] = 0);
      class Es extends Si {
        constructor(t3) {
          super(t3, ks);
        }
        createBucket(t3) {
          return new ls(t3);
        }
        queryRadius(t3) {
          const e2 = t3;
          return bs("circle-radius", this, e2) + bs("circle-stroke-width", this, e2) + ws(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t3, e2, r3, n3, i3, a3, s3, o3) {
          const l3 = _s(t3, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a3.angle, s3), u3 = this.paint.get("circle-radius").evaluate(e2, r3) + this.paint.get("circle-stroke-width").evaluate(e2, r3), c3 = "map" === this.paint.get("circle-pitch-alignment"), h3 = c3 ? l3 : function(t4, e3) {
            return t4.map((t5) => Fs(t5, e3));
          }(l3, o3), p3 = c3 ? u3 * s3 : u3;
          for (const t4 of n3) for (const e3 of t4) {
            const t5 = c3 ? e3 : Fs(e3, o3);
            let r4 = p3;
            const n4 = Vs([], [e3.x, e3.y, 0, 1], o3);
            if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r4 *= n4[3] / a3.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r4 *= a3.cameraToCenterDistance / n4[3]), cs(h3, t5, r4)) return true;
          }
          return false;
        }
      }
      function Fs(t3, e2) {
        const r3 = Vs([], [t3.x, t3.y, 0, 1], e2);
        return new a2(r3[0] / r3[3], r3[1] / r3[3]);
      }
      class Ts extends ls {
      }
      let $s;
      $n("HeatmapBucket", Ts, { omit: ["layers"] });
      var Ls = { get paint() {
        return $s = $s || new _i({ "heatmap-radius": new xi(X2.paint_heatmap["heatmap-radius"]), "heatmap-weight": new xi(X2.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new gi(X2.paint_heatmap["heatmap-intensity"]), "heatmap-color": new wi(X2.paint_heatmap["heatmap-color"]), "heatmap-opacity": new gi(X2.paint_heatmap["heatmap-opacity"]) });
      } };
      function Ds(t3, { width: e2, height: r3 }, n3, i3) {
        if (i3) {
          if (i3 instanceof Uint8ClampedArray) i3 = new Uint8Array(i3.buffer);
          else if (i3.length !== e2 * r3 * n3) throw new RangeError(`mismatched image size. expected: ${i3.length} but got: ${e2 * r3 * n3}`);
        } else i3 = new Uint8Array(e2 * r3 * n3);
        return t3.width = e2, t3.height = r3, t3.data = i3, t3;
      }
      function Os(t3, { width: e2, height: r3 }, n3) {
        if (e2 === t3.width && r3 === t3.height) return;
        const i3 = Ds({}, { width: e2, height: r3 }, n3);
        Us(t3, i3, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t3.width, e2), height: Math.min(t3.height, r3) }, n3), t3.width = e2, t3.height = r3, t3.data = i3.data;
      }
      function Us(t3, e2, r3, n3, i3, a3) {
        if (0 === i3.width || 0 === i3.height) return e2;
        if (i3.width > t3.width || i3.height > t3.height || r3.x > t3.width - i3.width || r3.y > t3.height - i3.height) throw new RangeError("out of range source coordinates for image copy");
        if (i3.width > e2.width || i3.height > e2.height || n3.x > e2.width - i3.width || n3.y > e2.height - i3.height) throw new RangeError("out of range destination coordinates for image copy");
        const s3 = t3.data, o3 = e2.data;
        if (s3 === o3) throw new Error("srcData equals dstData, so image is already copied");
        for (let l3 = 0; l3 < i3.height; l3++) {
          const u3 = ((r3.y + l3) * t3.width + r3.x) * a3, c3 = ((n3.y + l3) * e2.width + n3.x) * a3;
          for (let t4 = 0; t4 < i3.width * a3; t4++) o3[c3 + t4] = s3[u3 + t4];
        }
        return e2;
      }
      class Rs {
        constructor(t3, e2) {
          Ds(this, t3, 1, e2);
        }
        resize(t3) {
          Os(this, t3, 1);
        }
        clone() {
          return new Rs({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t3, e2, r3, n3, i3) {
          Us(t3, e2, r3, n3, i3, 1);
        }
      }
      class qs {
        constructor(t3, e2) {
          Ds(this, t3, 4, e2);
        }
        resize(t3) {
          Os(this, t3, 4);
        }
        replace(t3, e2) {
          e2 ? this.data.set(t3) : this.data = t3 instanceof Uint8ClampedArray ? new Uint8Array(t3.buffer) : t3;
        }
        clone() {
          return new qs({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t3, e2, r3, n3, i3) {
          Us(t3, e2, r3, n3, i3, 4);
        }
      }
      function js(t3) {
        const e2 = {}, r3 = t3.resolution || 256, n3 = t3.clips ? t3.clips.length : 1, i3 = t3.image || new qs({ width: r3, height: n3 });
        if (Math.log(r3) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r3}`);
        const a3 = (r4, n4, a4) => {
          e2[t3.evaluationKey] = a4;
          const s3 = t3.expression.evaluate(e2);
          i3.data[r4 + n4 + 0] = Math.floor(255 * s3.r / s3.a), i3.data[r4 + n4 + 1] = Math.floor(255 * s3.g / s3.a), i3.data[r4 + n4 + 2] = Math.floor(255 * s3.b / s3.a), i3.data[r4 + n4 + 3] = Math.floor(255 * s3.a);
        };
        if (t3.clips) for (let e3 = 0, i4 = 0; e3 < n3; ++e3, i4 += 4 * r3) for (let n4 = 0, s3 = 0; n4 < r3; n4++, s3 += 4) {
          const o3 = n4 / (r3 - 1), { start: l3, end: u3 } = t3.clips[e3];
          a3(i4, s3, l3 * (1 - o3) + u3 * o3);
        }
        else for (let t4 = 0, e3 = 0; t4 < r3; t4++, e3 += 4) a3(0, e3, t4 / (r3 - 1));
        return i3;
      }
      $n("AlphaImage", Rs), $n("RGBAImage", qs);
      class Ns extends Si {
        createBucket(t3) {
          return new Ts(t3);
        }
        constructor(t3) {
          super(t3, Ls), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t3) {
          "heatmap-color" === t3 && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = js({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
        }
      }
      let Zs;
      var Ks = { get paint() {
        return Zs = Zs || new _i({ "hillshade-illumination-direction": new gi(X2.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new gi(X2.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new gi(X2.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new gi(X2.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new gi(X2.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new gi(X2.paint_hillshade["hillshade-accent-color"]) });
      } };
      class Gs extends Si {
        constructor(t3) {
          super(t3, Ks);
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
        }
      }
      const Js = Mi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Xs } = Js;
      var Ys = { exports: {} };
      function Hs(t3, e2, r3) {
        r3 = r3 || 2;
        var n3, i3, a3, s3, o3, l3, u3, c3 = e2 && e2.length, h3 = c3 ? e2[0] * r3 : t3.length, p3 = Ws(t3, 0, h3, r3, true), f3 = [];
        if (!p3 || p3.next === p3.prev) return f3;
        if (c3 && (p3 = function(t4, e3, r4, n4) {
          var i4, a4, s4, o4 = [];
          for (i4 = 0, a4 = e3.length; i4 < a4; i4++) (s4 = Ws(t4, e3[i4] * n4, i4 < a4 - 1 ? e3[i4 + 1] * n4 : t4.length, n4, false)) === s4.next && (s4.steiner = true), o4.push(uo(s4));
          for (o4.sort(ao), i4 = 0; i4 < o4.length; i4++) r4 = so(o4[i4], r4);
          return r4;
        }(t3, e2, p3, r3)), t3.length > 80 * r3) {
          n3 = a3 = t3[0], i3 = s3 = t3[1];
          for (var d3 = r3; d3 < h3; d3 += r3) (o3 = t3[d3]) < n3 && (n3 = o3), (l3 = t3[d3 + 1]) < i3 && (i3 = l3), o3 > a3 && (a3 = o3), l3 > s3 && (s3 = l3);
          u3 = 0 !== (u3 = Math.max(a3 - n3, s3 - i3)) ? 32767 / u3 : 0;
        }
        return to2(p3, f3, r3, n3, i3, u3, 0), f3;
      }
      function Ws(t3, e2, r3, n3, i3) {
        var a3, s3;
        if (i3 === Ao(t3, e2, r3, n3) > 0) for (a3 = e2; a3 < r3; a3 += n3) s3 = bo(a3, t3[a3], t3[a3 + 1], s3);
        else for (a3 = r3 - n3; a3 >= e2; a3 -= n3) s3 = bo(a3, t3[a3], t3[a3 + 1], s3);
        return s3 && fo(s3, s3.next) && (wo(s3), s3 = s3.next), s3;
      }
      function Qs(t3, e2) {
        if (!t3) return t3;
        e2 || (e2 = t3);
        var r3, n3 = t3;
        do {
          if (r3 = false, n3.steiner || !fo(n3, n3.next) && 0 !== po(n3.prev, n3, n3.next)) n3 = n3.next;
          else {
            if (wo(n3), (n3 = e2 = n3.prev) === n3.next) break;
            r3 = true;
          }
        } while (r3 || n3 !== e2);
        return e2;
      }
      function to2(t3, e2, r3, n3, i3, a3, s3) {
        if (t3) {
          !s3 && a3 && function(t4, e3, r4, n4) {
            var i4 = t4;
            do {
              0 === i4.z && (i4.z = lo(i4.x, i4.y, e3, r4, n4)), i4.prevZ = i4.prev, i4.nextZ = i4.next, i4 = i4.next;
            } while (i4 !== t4);
            i4.prevZ.nextZ = null, i4.prevZ = null, function(t5) {
              var e4, r5, n5, i5, a4, s4, o4, l4, u4 = 1;
              do {
                for (r5 = t5, t5 = null, a4 = null, s4 = 0; r5; ) {
                  for (s4++, n5 = r5, o4 = 0, e4 = 0; e4 < u4 && (o4++, n5 = n5.nextZ); e4++) ;
                  for (l4 = u4; o4 > 0 || l4 > 0 && n5; ) 0 !== o4 && (0 === l4 || !n5 || r5.z <= n5.z) ? (i5 = r5, r5 = r5.nextZ, o4--) : (i5 = n5, n5 = n5.nextZ, l4--), a4 ? a4.nextZ = i5 : t5 = i5, i5.prevZ = a4, a4 = i5;
                  r5 = n5;
                }
                a4.nextZ = null, u4 *= 2;
              } while (s4 > 1);
            }(i4);
          }(t3, n3, i3, a3);
          for (var o3, l3, u3 = t3; t3.prev !== t3.next; ) if (o3 = t3.prev, l3 = t3.next, a3 ? ro(t3, n3, i3, a3) : eo(t3)) e2.push(o3.i / r3 | 0), e2.push(t3.i / r3 | 0), e2.push(l3.i / r3 | 0), wo(t3), t3 = l3.next, u3 = l3.next;
          else if ((t3 = l3) === u3) {
            s3 ? 1 === s3 ? to2(t3 = no(Qs(t3), e2, r3), e2, r3, n3, i3, a3, 2) : 2 === s3 && io(t3, e2, r3, n3, i3, a3) : to2(Qs(t3), e2, r3, n3, i3, a3, 1);
            break;
          }
        }
      }
      function eo(t3) {
        var e2 = t3.prev, r3 = t3, n3 = t3.next;
        if (po(e2, r3, n3) >= 0) return false;
        for (var i3 = e2.x, a3 = r3.x, s3 = n3.x, o3 = e2.y, l3 = r3.y, u3 = n3.y, c3 = i3 < a3 ? i3 < s3 ? i3 : s3 : a3 < s3 ? a3 : s3, h3 = o3 < l3 ? o3 < u3 ? o3 : u3 : l3 < u3 ? l3 : u3, p3 = i3 > a3 ? i3 > s3 ? i3 : s3 : a3 > s3 ? a3 : s3, f3 = o3 > l3 ? o3 > u3 ? o3 : u3 : l3 > u3 ? l3 : u3, d3 = n3.next; d3 !== e2; ) {
          if (d3.x >= c3 && d3.x <= p3 && d3.y >= h3 && d3.y <= f3 && co(i3, o3, a3, l3, s3, u3, d3.x, d3.y) && po(d3.prev, d3, d3.next) >= 0) return false;
          d3 = d3.next;
        }
        return true;
      }
      function ro(t3, e2, r3, n3) {
        var i3 = t3.prev, a3 = t3, s3 = t3.next;
        if (po(i3, a3, s3) >= 0) return false;
        for (var o3 = i3.x, l3 = a3.x, u3 = s3.x, c3 = i3.y, h3 = a3.y, p3 = s3.y, f3 = o3 < l3 ? o3 < u3 ? o3 : u3 : l3 < u3 ? l3 : u3, d3 = c3 < h3 ? c3 < p3 ? c3 : p3 : h3 < p3 ? h3 : p3, y3 = o3 > l3 ? o3 > u3 ? o3 : u3 : l3 > u3 ? l3 : u3, m3 = c3 > h3 ? c3 > p3 ? c3 : p3 : h3 > p3 ? h3 : p3, g3 = lo(f3, d3, e2, r3, n3), x3 = lo(y3, m3, e2, r3, n3), v3 = t3.prevZ, b3 = t3.nextZ; v3 && v3.z >= g3 && b3 && b3.z <= x3; ) {
          if (v3.x >= f3 && v3.x <= y3 && v3.y >= d3 && v3.y <= m3 && v3 !== i3 && v3 !== s3 && co(o3, c3, l3, h3, u3, p3, v3.x, v3.y) && po(v3.prev, v3, v3.next) >= 0) return false;
          if (v3 = v3.prevZ, b3.x >= f3 && b3.x <= y3 && b3.y >= d3 && b3.y <= m3 && b3 !== i3 && b3 !== s3 && co(o3, c3, l3, h3, u3, p3, b3.x, b3.y) && po(b3.prev, b3, b3.next) >= 0) return false;
          b3 = b3.nextZ;
        }
        for (; v3 && v3.z >= g3; ) {
          if (v3.x >= f3 && v3.x <= y3 && v3.y >= d3 && v3.y <= m3 && v3 !== i3 && v3 !== s3 && co(o3, c3, l3, h3, u3, p3, v3.x, v3.y) && po(v3.prev, v3, v3.next) >= 0) return false;
          v3 = v3.prevZ;
        }
        for (; b3 && b3.z <= x3; ) {
          if (b3.x >= f3 && b3.x <= y3 && b3.y >= d3 && b3.y <= m3 && b3 !== i3 && b3 !== s3 && co(o3, c3, l3, h3, u3, p3, b3.x, b3.y) && po(b3.prev, b3, b3.next) >= 0) return false;
          b3 = b3.nextZ;
        }
        return true;
      }
      function no(t3, e2, r3) {
        var n3 = t3;
        do {
          var i3 = n3.prev, a3 = n3.next.next;
          !fo(i3, a3) && yo(i3, n3, n3.next, a3) && xo(i3, a3) && xo(a3, i3) && (e2.push(i3.i / r3 | 0), e2.push(n3.i / r3 | 0), e2.push(a3.i / r3 | 0), wo(n3), wo(n3.next), n3 = t3 = a3), n3 = n3.next;
        } while (n3 !== t3);
        return Qs(n3);
      }
      function io(t3, e2, r3, n3, i3, a3) {
        var s3 = t3;
        do {
          for (var o3 = s3.next.next; o3 !== s3.prev; ) {
            if (s3.i !== o3.i && ho(s3, o3)) {
              var l3 = vo(s3, o3);
              return s3 = Qs(s3, s3.next), l3 = Qs(l3, l3.next), to2(s3, e2, r3, n3, i3, a3, 0), void to2(l3, e2, r3, n3, i3, a3, 0);
            }
            o3 = o3.next;
          }
          s3 = s3.next;
        } while (s3 !== t3);
      }
      function ao(t3, e2) {
        return t3.x - e2.x;
      }
      function so(t3, e2) {
        var r3 = function(t4, e3) {
          var r4, n4 = e3, i3 = t4.x, a3 = t4.y, s3 = -1 / 0;
          do {
            if (a3 <= n4.y && a3 >= n4.next.y && n4.next.y !== n4.y) {
              var o3 = n4.x + (a3 - n4.y) * (n4.next.x - n4.x) / (n4.next.y - n4.y);
              if (o3 <= i3 && o3 > s3 && (s3 = o3, r4 = n4.x < n4.next.x ? n4 : n4.next, o3 === i3)) return r4;
            }
            n4 = n4.next;
          } while (n4 !== e3);
          if (!r4) return null;
          var l3, u3 = r4, c3 = r4.x, h3 = r4.y, p3 = 1 / 0;
          n4 = r4;
          do {
            i3 >= n4.x && n4.x >= c3 && i3 !== n4.x && co(a3 < h3 ? i3 : s3, a3, c3, h3, a3 < h3 ? s3 : i3, a3, n4.x, n4.y) && (l3 = Math.abs(a3 - n4.y) / (i3 - n4.x), xo(n4, t4) && (l3 < p3 || l3 === p3 && (n4.x > r4.x || n4.x === r4.x && oo(r4, n4))) && (r4 = n4, p3 = l3)), n4 = n4.next;
          } while (n4 !== u3);
          return r4;
        }(t3, e2);
        if (!r3) return e2;
        var n3 = vo(r3, t3);
        return Qs(n3, n3.next), Qs(r3, r3.next);
      }
      function oo(t3, e2) {
        return po(t3.prev, t3, e2.prev) < 0 && po(e2.next, t3, t3.next) < 0;
      }
      function lo(t3, e2, r3, n3, i3) {
        return (t3 = 1431655765 & ((t3 = 858993459 & ((t3 = 252645135 & ((t3 = 16711935 & ((t3 = (t3 - r3) * i3 | 0) | t3 << 8)) | t3 << 4)) | t3 << 2)) | t3 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n3) * i3 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
      }
      function uo(t3) {
        var e2 = t3, r3 = t3;
        do {
          (e2.x < r3.x || e2.x === r3.x && e2.y < r3.y) && (r3 = e2), e2 = e2.next;
        } while (e2 !== t3);
        return r3;
      }
      function co(t3, e2, r3, n3, i3, a3, s3, o3) {
        return (i3 - s3) * (e2 - o3) >= (t3 - s3) * (a3 - o3) && (t3 - s3) * (n3 - o3) >= (r3 - s3) * (e2 - o3) && (r3 - s3) * (a3 - o3) >= (i3 - s3) * (n3 - o3);
      }
      function ho(t3, e2) {
        return t3.next.i !== e2.i && t3.prev.i !== e2.i && !function(t4, e3) {
          var r3 = t4;
          do {
            if (r3.i !== t4.i && r3.next.i !== t4.i && r3.i !== e3.i && r3.next.i !== e3.i && yo(r3, r3.next, t4, e3)) return true;
            r3 = r3.next;
          } while (r3 !== t4);
          return false;
        }(t3, e2) && (xo(t3, e2) && xo(e2, t3) && function(t4, e3) {
          var r3 = t4, n3 = false, i3 = (t4.x + e3.x) / 2, a3 = (t4.y + e3.y) / 2;
          do {
            r3.y > a3 != r3.next.y > a3 && r3.next.y !== r3.y && i3 < (r3.next.x - r3.x) * (a3 - r3.y) / (r3.next.y - r3.y) + r3.x && (n3 = !n3), r3 = r3.next;
          } while (r3 !== t4);
          return n3;
        }(t3, e2) && (po(t3.prev, t3, e2.prev) || po(t3, e2.prev, e2)) || fo(t3, e2) && po(t3.prev, t3, t3.next) > 0 && po(e2.prev, e2, e2.next) > 0);
      }
      function po(t3, e2, r3) {
        return (e2.y - t3.y) * (r3.x - e2.x) - (e2.x - t3.x) * (r3.y - e2.y);
      }
      function fo(t3, e2) {
        return t3.x === e2.x && t3.y === e2.y;
      }
      function yo(t3, e2, r3, n3) {
        var i3 = go(po(t3, e2, r3)), a3 = go(po(t3, e2, n3)), s3 = go(po(r3, n3, t3)), o3 = go(po(r3, n3, e2));
        return i3 !== a3 && s3 !== o3 || !(0 !== i3 || !mo(t3, r3, e2)) || !(0 !== a3 || !mo(t3, n3, e2)) || !(0 !== s3 || !mo(r3, t3, n3)) || !(0 !== o3 || !mo(r3, e2, n3));
      }
      function mo(t3, e2, r3) {
        return e2.x <= Math.max(t3.x, r3.x) && e2.x >= Math.min(t3.x, r3.x) && e2.y <= Math.max(t3.y, r3.y) && e2.y >= Math.min(t3.y, r3.y);
      }
      function go(t3) {
        return t3 > 0 ? 1 : t3 < 0 ? -1 : 0;
      }
      function xo(t3, e2) {
        return po(t3.prev, t3, t3.next) < 0 ? po(t3, e2, t3.next) >= 0 && po(t3, t3.prev, e2) >= 0 : po(t3, e2, t3.prev) < 0 || po(t3, t3.next, e2) < 0;
      }
      function vo(t3, e2) {
        var r3 = new _o(t3.i, t3.x, t3.y), n3 = new _o(e2.i, e2.x, e2.y), i3 = t3.next, a3 = e2.prev;
        return t3.next = e2, e2.prev = t3, r3.next = i3, i3.prev = r3, n3.next = r3, r3.prev = n3, a3.next = n3, n3.prev = a3, n3;
      }
      function bo(t3, e2, r3, n3) {
        var i3 = new _o(t3, e2, r3);
        return n3 ? (i3.next = n3.next, i3.prev = n3, n3.next.prev = i3, n3.next = i3) : (i3.prev = i3, i3.next = i3), i3;
      }
      function wo(t3) {
        t3.next.prev = t3.prev, t3.prev.next = t3.next, t3.prevZ && (t3.prevZ.nextZ = t3.nextZ), t3.nextZ && (t3.nextZ.prevZ = t3.prevZ);
      }
      function _o(t3, e2, r3) {
        this.i = t3, this.x = e2, this.y = r3, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      function Ao(t3, e2, r3, n3) {
        for (var i3 = 0, a3 = e2, s3 = r3 - n3; a3 < r3; a3 += n3) i3 += (t3[s3] - t3[a3]) * (t3[a3 + 1] + t3[s3 + 1]), s3 = a3;
        return i3;
      }
      Ys.exports = Hs, Ys.exports.default = Hs, Hs.deviation = function(t3, e2, r3, n3) {
        var i3 = e2 && e2.length, a3 = Math.abs(Ao(t3, 0, i3 ? e2[0] * r3 : t3.length, r3));
        if (i3) for (var s3 = 0, o3 = e2.length; s3 < o3; s3++) a3 -= Math.abs(Ao(t3, e2[s3] * r3, s3 < o3 - 1 ? e2[s3 + 1] * r3 : t3.length, r3));
        var l3 = 0;
        for (s3 = 0; s3 < n3.length; s3 += 3) {
          var u3 = n3[s3] * r3, c3 = n3[s3 + 1] * r3, h3 = n3[s3 + 2] * r3;
          l3 += Math.abs((t3[u3] - t3[h3]) * (t3[c3 + 1] - t3[u3 + 1]) - (t3[u3] - t3[c3]) * (t3[h3 + 1] - t3[u3 + 1]));
        }
        return 0 === a3 && 0 === l3 ? 0 : Math.abs((l3 - a3) / a3);
      }, Hs.flatten = function(t3) {
        for (var e2 = t3[0][0].length, r3 = { vertices: [], holes: [], dimensions: e2 }, n3 = 0, i3 = 0; i3 < t3.length; i3++) {
          for (var a3 = 0; a3 < t3[i3].length; a3++) for (var s3 = 0; s3 < e2; s3++) r3.vertices.push(t3[i3][a3][s3]);
          i3 > 0 && r3.holes.push(n3 += t3[i3 - 1].length);
        }
        return r3;
      };
      var So = r2(Ys.exports);
      function ko(t3, e2, r3, n3, i3) {
        Io(t3, e2, r3, n3 || t3.length - 1, i3 || Mo);
      }
      function Io(t3, e2, r3, n3, i3) {
        for (; n3 > r3; ) {
          if (n3 - r3 > 600) {
            var a3 = n3 - r3 + 1, s3 = e2 - r3 + 1, o3 = Math.log(a3), l3 = 0.5 * Math.exp(2 * o3 / 3), u3 = 0.5 * Math.sqrt(o3 * l3 * (a3 - l3) / a3) * (s3 - a3 / 2 < 0 ? -1 : 1);
            Io(t3, e2, Math.max(r3, Math.floor(e2 - s3 * l3 / a3 + u3)), Math.min(n3, Math.floor(e2 + (a3 - s3) * l3 / a3 + u3)), i3);
          }
          var c3 = t3[e2], h3 = r3, p3 = n3;
          for (zo(t3, r3, e2), i3(t3[n3], c3) > 0 && zo(t3, r3, n3); h3 < p3; ) {
            for (zo(t3, h3, p3), h3++, p3--; i3(t3[h3], c3) < 0; ) h3++;
            for (; i3(t3[p3], c3) > 0; ) p3--;
          }
          0 === i3(t3[r3], c3) ? zo(t3, r3, p3) : zo(t3, ++p3, n3), p3 <= e2 && (r3 = p3 + 1), e2 <= p3 && (n3 = p3 - 1);
        }
      }
      function zo(t3, e2, r3) {
        var n3 = t3[e2];
        t3[e2] = t3[r3], t3[r3] = n3;
      }
      function Mo(t3, e2) {
        return t3 < e2 ? -1 : t3 > e2 ? 1 : 0;
      }
      function Co(t3, e2) {
        const r3 = t3.length;
        if (r3 <= 1) return [t3];
        const n3 = [];
        let i3, a3;
        for (let e3 = 0; e3 < r3; e3++) {
          const r4 = k2(t3[e3]);
          0 !== r4 && (t3[e3].area = Math.abs(r4), void 0 === a3 && (a3 = r4 < 0), a3 === r4 < 0 ? (i3 && n3.push(i3), i3 = [t3[e3]]) : i3.push(t3[e3]));
        }
        if (i3 && n3.push(i3), e2 > 1) for (let t4 = 0; t4 < n3.length; t4++) n3[t4].length <= e2 || (ko(n3[t4], e2, 1, n3[t4].length - 1, Bo), n3[t4] = n3[t4].slice(0, e2));
        return n3;
      }
      function Bo(t3, e2) {
        return e2.area - t3.area;
      }
      function Po(t3, e2, r3) {
        const n3 = r3.patternDependencies;
        let i3 = false;
        for (const r4 of e2) {
          const e3 = r4.paint.get(`${t3}-pattern`);
          e3.isConstant() || (i3 = true);
          const a3 = e3.constantOr(null);
          a3 && (i3 = true, n3[a3.to] = true, n3[a3.from] = true);
        }
        return i3;
      }
      function Vo(t3, e2, r3, n3, i3) {
        const a3 = i3.patternDependencies;
        for (const s3 of e2) {
          const e3 = s3.paint.get(`${t3}-pattern`).value;
          if ("constant" !== e3.kind) {
            let t4 = e3.evaluate({ zoom: n3 - 1 }, r3, {}, i3.availableImages), o3 = e3.evaluate({ zoom: n3 }, r3, {}, i3.availableImages), l3 = e3.evaluate({ zoom: n3 + 1 }, r3, {}, i3.availableImages);
            t4 = t4 && t4.name ? t4.name : t4, o3 = o3 && o3.name ? o3.name : o3, l3 = l3 && l3.name ? l3.name : l3, a3[t4] = true, a3[o3] = true, a3[l3] = true, r3.patterns[s3.id] = { min: t4, mid: o3, max: l3 };
          }
        }
        return r3;
      }
      class Eo {
        constructor(t3) {
          this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new fa(), this.indexArray = new Aa(), this.indexArray2 = new Sa(), this.programConfigurations = new Qa(t3.layers, t3.zoom), this.segments = new za(), this.segments2 = new za(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
        }
        populate(t3, e2, r3) {
          this.hasPattern = Po("fill", this.layers, e2);
          const n3 = this.layers[0].layout.get("fill-sort-key"), i3 = !n3.isConstant(), a3 = [];
          for (const { feature: s3, id: o3, index: l3, sourceLayerIndex: u3 } of t3) {
            const t4 = this.layers[0]._featureFilter.needGeometry, c3 = ss2(s3, t4);
            if (!this.layers[0]._featureFilter.filter(new li(this.zoom), c3, r3)) continue;
            const h3 = i3 ? n3.evaluate(c3, {}, r3, e2.availableImages) : void 0, p3 = { id: o3, properties: s3.properties, type: s3.type, sourceLayerIndex: u3, index: l3, geometry: t4 ? c3.geometry : as(s3), patterns: {}, sortKey: h3 };
            a3.push(p3);
          }
          i3 && a3.sort((t4, e3) => t4.sortKey - e3.sortKey);
          for (const n4 of a3) {
            const { geometry: i4, index: a4, sourceLayerIndex: s3 } = n4;
            if (this.hasPattern) {
              const t4 = Vo("fill", this.layers, n4, this.zoom, e2);
              this.patternFeatures.push(t4);
            } else this.addFeature(n4, i4, a4, r3, {});
            e2.featureIndex.insert(t3[a4].feature, i4, a4, s3, this.index);
          }
        }
        update(t3, e2, r3) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e2, this.stateDependentLayers, r3);
        }
        addFeatures(t3, e2, r3) {
          for (const t4 of this.patternFeatures) this.addFeature(t4, t4.geometry, t4.index, e2, r3);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t3) {
          this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Xs), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.indexBuffer2 = t3.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t3), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(t3, e2, r3, n3, i3) {
          for (const t4 of Co(e2, 500)) {
            let e3 = 0;
            for (const r5 of t4) e3 += r5.length;
            const r4 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n4 = r4.vertexLength, i4 = [], a3 = [];
            for (const e4 of t4) {
              if (0 === e4.length) continue;
              e4 !== t4[0] && a3.push(i4.length / 2);
              const r5 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n5 = r5.vertexLength;
              this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n5 + e4.length - 1, n5), i4.push(e4[0].x), i4.push(e4[0].y);
              for (let t5 = 1; t5 < e4.length; t5++) this.layoutVertexArray.emplaceBack(e4[t5].x, e4[t5].y), this.indexArray2.emplaceBack(n5 + t5 - 1, n5 + t5), i4.push(e4[t5].x), i4.push(e4[t5].y);
              r5.vertexLength += e4.length, r5.primitiveLength += e4.length;
            }
            const s3 = So(i4, a3);
            for (let t5 = 0; t5 < s3.length; t5 += 3) this.indexArray.emplaceBack(n4 + s3[t5], n4 + s3[t5 + 1], n4 + s3[t5 + 2]);
            r4.vertexLength += e3, r4.primitiveLength += s3.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i3, n3);
        }
      }
      let Fo, To;
      $n("FillBucket", Eo, { omit: ["layers", "patternFeatures"] });
      var $o = { get paint() {
        return To = To || new _i({ "fill-antialias": new gi(X2.paint_fill["fill-antialias"]), "fill-opacity": new xi(X2.paint_fill["fill-opacity"]), "fill-color": new xi(X2.paint_fill["fill-color"]), "fill-outline-color": new xi(X2.paint_fill["fill-outline-color"]), "fill-translate": new gi(X2.paint_fill["fill-translate"]), "fill-translate-anchor": new gi(X2.paint_fill["fill-translate-anchor"]), "fill-pattern": new vi(X2.paint_fill["fill-pattern"]) });
      }, get layout() {
        return Fo = Fo || new _i({ "fill-sort-key": new xi(X2.layout_fill["fill-sort-key"]) });
      } };
      class Lo extends Si {
        constructor(t3) {
          super(t3, $o);
        }
        recalculate(t3, e2) {
          super.recalculate(t3, e2);
          const r3 = this.paint._values["fill-outline-color"];
          "constant" === r3.value.kind && void 0 === r3.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t3) {
          return new Eo(t3);
        }
        queryRadius() {
          return ws(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t3, e2, r3, n3, i3, a3, s3) {
          return hs(_s(t3, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a3.angle, s3), n3);
        }
        isTileClipped() {
          return true;
        }
      }
      const Do = Mi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Oo = Mi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Uo } = Do;
      var Ro = {}, qo = n2, jo = No;
      function No(t3, e2, r3, n3, i3) {
        this.properties = {}, this.extent = r3, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = n3, this._values = i3, t3.readFields(Zo, this, e2);
      }
      function Zo(t3, e2, r3) {
        1 == t3 ? e2.id = r3.readVarint() : 2 == t3 ? function(t4, e3) {
          for (var r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
            var n3 = e3._keys[t4.readVarint()], i3 = e3._values[t4.readVarint()];
            e3.properties[n3] = i3;
          }
        }(r3, e2) : 3 == t3 ? e2.type = r3.readVarint() : 4 == t3 && (e2._geometry = r3.pos);
      }
      function Ko(t3) {
        for (var e2, r3, n3 = 0, i3 = 0, a3 = t3.length, s3 = a3 - 1; i3 < a3; s3 = i3++) n3 += ((r3 = t3[s3]).x - (e2 = t3[i3]).x) * (e2.y + r3.y);
        return n3;
      }
      No.types = ["Unknown", "Point", "LineString", "Polygon"], No.prototype.loadGeometry = function() {
        var t3 = this._pbf;
        t3.pos = this._geometry;
        for (var e2, r3 = t3.readVarint() + t3.pos, n3 = 1, i3 = 0, a3 = 0, s3 = 0, o3 = []; t3.pos < r3; ) {
          if (i3 <= 0) {
            var l3 = t3.readVarint();
            n3 = 7 & l3, i3 = l3 >> 3;
          }
          if (i3--, 1 === n3 || 2 === n3) a3 += t3.readSVarint(), s3 += t3.readSVarint(), 1 === n3 && (e2 && o3.push(e2), e2 = []), e2.push(new qo(a3, s3));
          else {
            if (7 !== n3) throw new Error("unknown command " + n3);
            e2 && e2.push(e2[0].clone());
          }
        }
        return e2 && o3.push(e2), o3;
      }, No.prototype.bbox = function() {
        var t3 = this._pbf;
        t3.pos = this._geometry;
        for (var e2 = t3.readVarint() + t3.pos, r3 = 1, n3 = 0, i3 = 0, a3 = 0, s3 = 1 / 0, o3 = -1 / 0, l3 = 1 / 0, u3 = -1 / 0; t3.pos < e2; ) {
          if (n3 <= 0) {
            var c3 = t3.readVarint();
            r3 = 7 & c3, n3 = c3 >> 3;
          }
          if (n3--, 1 === r3 || 2 === r3) (i3 += t3.readSVarint()) < s3 && (s3 = i3), i3 > o3 && (o3 = i3), (a3 += t3.readSVarint()) < l3 && (l3 = a3), a3 > u3 && (u3 = a3);
          else if (7 !== r3) throw new Error("unknown command " + r3);
        }
        return [s3, l3, o3, u3];
      }, No.prototype.toGeoJSON = function(t3, e2, r3) {
        var n3, i3, a3 = this.extent * Math.pow(2, r3), s3 = this.extent * t3, o3 = this.extent * e2, l3 = this.loadGeometry(), u3 = No.types[this.type];
        function c3(t4) {
          for (var e3 = 0; e3 < t4.length; e3++) {
            var r4 = t4[e3];
            t4[e3] = [360 * (r4.x + s3) / a3 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r4.y + o3) / a3) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var h3 = [];
            for (n3 = 0; n3 < l3.length; n3++) h3[n3] = l3[n3][0];
            c3(l3 = h3);
            break;
          case 2:
            for (n3 = 0; n3 < l3.length; n3++) c3(l3[n3]);
            break;
          case 3:
            for (l3 = function(t4) {
              var e3 = t4.length;
              if (e3 <= 1) return [t4];
              for (var r4, n4, i4 = [], a4 = 0; a4 < e3; a4++) {
                var s4 = Ko(t4[a4]);
                0 !== s4 && (void 0 === n4 && (n4 = s4 < 0), n4 === s4 < 0 ? (r4 && i4.push(r4), r4 = [t4[a4]]) : r4.push(t4[a4]));
              }
              return r4 && i4.push(r4), i4;
            }(l3), n3 = 0; n3 < l3.length; n3++) for (i3 = 0; i3 < l3[n3].length; i3++) c3(l3[n3][i3]);
        }
        1 === l3.length ? l3 = l3[0] : u3 = "Multi" + u3;
        var p3 = { type: "Feature", geometry: { type: u3, coordinates: l3 }, properties: this.properties };
        return "id" in this && (p3.id = this.id), p3;
      };
      var Go = jo, Jo = Xo;
      function Xo(t3, e2) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields(Yo, this, e2), this.length = this._features.length;
      }
      function Yo(t3, e2, r3) {
        15 === t3 ? e2.version = r3.readVarint() : 1 === t3 ? e2.name = r3.readString() : 5 === t3 ? e2.extent = r3.readVarint() : 2 === t3 ? e2._features.push(r3.pos) : 3 === t3 ? e2._keys.push(r3.readString()) : 4 === t3 && e2._values.push(function(t4) {
          for (var e3 = null, r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
            var n3 = t4.readVarint() >> 3;
            e3 = 1 === n3 ? t4.readString() : 2 === n3 ? t4.readFloat() : 3 === n3 ? t4.readDouble() : 4 === n3 ? t4.readVarint64() : 5 === n3 ? t4.readVarint() : 6 === n3 ? t4.readSVarint() : 7 === n3 ? t4.readBoolean() : null;
          }
          return e3;
        }(r3));
      }
      Xo.prototype.feature = function(t3) {
        if (t3 < 0 || t3 >= this._features.length) throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[t3];
        var e2 = this._pbf.readVarint() + this._pbf.pos;
        return new Go(this._pbf, e2, this.extent, this._keys, this._values);
      };
      var Ho = Jo;
      function Wo(t3, e2, r3) {
        if (3 === t3) {
          var n3 = new Ho(r3, r3.readVarint() + r3.pos);
          n3.length && (e2[n3.name] = n3);
        }
      }
      Ro.VectorTile = function(t3, e2) {
        this.layers = t3.readFields(Wo, {}, e2);
      }, Ro.VectorTileFeature = jo, Ro.VectorTileLayer = Jo;
      const Qo = Ro.VectorTileFeature.types, tl = Math.pow(2, 13);
      function el(t3, e2, r3, n3, i3, a3, s3, o3) {
        t3.emplaceBack(e2, r3, 2 * Math.floor(n3 * tl) + s3, i3 * tl * 2, a3 * tl * 2, Math.round(o3));
      }
      class rl {
        constructor(t3) {
          this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.layoutVertexArray = new da(), this.centroidVertexArray = new ha(), this.indexArray = new Aa(), this.programConfigurations = new Qa(t3.layers, t3.zoom), this.segments = new za(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
        }
        populate(t3, e2, r3) {
          this.features = [], this.hasPattern = Po("fill-extrusion", this.layers, e2);
          for (const { feature: n3, id: i3, index: a3, sourceLayerIndex: s3 } of t3) {
            const t4 = this.layers[0]._featureFilter.needGeometry, o3 = ss2(n3, t4);
            if (!this.layers[0]._featureFilter.filter(new li(this.zoom), o3, r3)) continue;
            const l3 = { id: i3, sourceLayerIndex: s3, index: a3, geometry: t4 ? o3.geometry : as(n3), properties: n3.properties, type: n3.type, patterns: {} };
            this.hasPattern ? this.features.push(Vo("fill-extrusion", this.layers, l3, this.zoom, e2)) : this.addFeature(l3, l3.geometry, a3, r3, {}), e2.featureIndex.insert(n3, l3.geometry, a3, s3, this.index, true);
          }
        }
        addFeatures(t3, e2, r3) {
          for (const t4 of this.features) {
            const { geometry: n3 } = t4;
            this.addFeature(t4, n3, t4.index, e2, r3);
          }
        }
        update(t3, e2, r3) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e2, this.stateDependentLayers, r3);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t3) {
          this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Uo), this.centroidVertexBuffer = t3.createVertexBuffer(this.centroidVertexArray, Oo.members, true), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(t3, e2, r3, n3, i3) {
          const a3 = { x: 0, y: 0, vertexCount: 0 };
          for (const r4 of Co(e2, 500)) {
            let e3 = 0;
            for (const t4 of r4) e3 += t4.length;
            let n4 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const t4 of r4) {
              if (0 === t4.length) continue;
              if (il(t4)) continue;
              let e4 = 0;
              for (let r5 = 0; r5 < t4.length; r5++) {
                const i5 = t4[r5];
                if (r5 >= 1) {
                  const s4 = t4[r5 - 1];
                  if (!nl(i5, s4)) {
                    n4.vertexLength + 4 > za.MAX_VERTEX_ARRAY_LENGTH && (n4 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const t5 = i5.sub(s4)._perp()._unit(), r6 = s4.dist(i5);
                    e4 + r6 > 32768 && (e4 = 0), el(this.layoutVertexArray, i5.x, i5.y, t5.x, t5.y, 0, 0, e4), el(this.layoutVertexArray, i5.x, i5.y, t5.x, t5.y, 0, 1, e4), a3.x += 2 * i5.x, a3.y += 2 * i5.y, a3.vertexCount += 2, e4 += r6, el(this.layoutVertexArray, s4.x, s4.y, t5.x, t5.y, 0, 0, e4), el(this.layoutVertexArray, s4.x, s4.y, t5.x, t5.y, 0, 1, e4), a3.x += 2 * s4.x, a3.y += 2 * s4.y, a3.vertexCount += 2;
                    const o4 = n4.vertexLength;
                    this.indexArray.emplaceBack(o4, o4 + 2, o4 + 1), this.indexArray.emplaceBack(o4 + 1, o4 + 2, o4 + 3), n4.vertexLength += 4, n4.primitiveLength += 2;
                  }
                }
              }
            }
            if (n4.vertexLength + e3 > za.MAX_VERTEX_ARRAY_LENGTH && (n4 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray)), "Polygon" !== Qo[t3.type]) continue;
            const i4 = [], s3 = [], o3 = n4.vertexLength;
            for (const t4 of r4) if (0 !== t4.length) {
              t4 !== r4[0] && s3.push(i4.length / 2);
              for (let e4 = 0; e4 < t4.length; e4++) {
                const r5 = t4[e4];
                el(this.layoutVertexArray, r5.x, r5.y, 0, 0, 1, 1, 0), a3.x += r5.x, a3.y += r5.y, a3.vertexCount += 1, i4.push(r5.x), i4.push(r5.y);
              }
            }
            const l3 = So(i4, s3);
            for (let t4 = 0; t4 < l3.length; t4 += 3) this.indexArray.emplaceBack(o3 + l3[t4], o3 + l3[t4 + 2], o3 + l3[t4 + 1]);
            n4.primitiveLength += l3.length / 3, n4.vertexLength += e3;
          }
          for (let t4 = 0; t4 < a3.vertexCount; t4++) this.centroidVertexArray.emplaceBack(Math.floor(a3.x / a3.vertexCount), Math.floor(a3.y / a3.vertexCount));
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i3, n3);
        }
      }
      function nl(t3, e2) {
        return t3.x === e2.x && (t3.x < 0 || t3.x > rs) || t3.y === e2.y && (t3.y < 0 || t3.y > rs);
      }
      function il(t3) {
        return t3.every((t4) => t4.x < 0) || t3.every((t4) => t4.x > rs) || t3.every((t4) => t4.y < 0) || t3.every((t4) => t4.y > rs);
      }
      let al;
      $n("FillExtrusionBucket", rl, { omit: ["layers", "features"] });
      var sl = { get paint() {
        return al = al || new _i({ "fill-extrusion-opacity": new gi(X2["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new xi(X2["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new gi(X2["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new gi(X2["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new vi(X2["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new xi(X2["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new xi(X2["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new gi(X2["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
      } };
      class ol extends Si {
        constructor(t3) {
          super(t3, sl);
        }
        createBucket(t3) {
          return new rl(t3);
        }
        queryRadius() {
          return ws(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return true;
        }
        queryIntersectsFeature(t3, e2, r3, n3, i3, s3, o3, l3) {
          const u3 = _s(t3, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s3.angle, o3), c3 = this.paint.get("fill-extrusion-height").evaluate(e2, r3), h3 = this.paint.get("fill-extrusion-base").evaluate(e2, r3), p3 = function(t4, e3, r4, n4) {
            const i4 = [];
            for (const r5 of t4) {
              const t5 = [r5.x, r5.y, 0, 1];
              Vs(t5, t5, e3), i4.push(new a2(t5[0] / t5[3], t5[1] / t5[3]));
            }
            return i4;
          }(u3, l3), f3 = function(t4, e3, r4, n4) {
            const i4 = [], s4 = [], o4 = n4[8] * e3, l4 = n4[9] * e3, u4 = n4[10] * e3, c4 = n4[11] * e3, h4 = n4[8] * r4, p4 = n4[9] * r4, f4 = n4[10] * r4, d3 = n4[11] * r4;
            for (const e4 of t4) {
              const t5 = [], r5 = [];
              for (const i5 of e4) {
                const e5 = i5.x, s5 = i5.y, y3 = n4[0] * e5 + n4[4] * s5 + n4[12], m3 = n4[1] * e5 + n4[5] * s5 + n4[13], g3 = n4[2] * e5 + n4[6] * s5 + n4[14], x3 = n4[3] * e5 + n4[7] * s5 + n4[15], v3 = g3 + u4, b3 = x3 + c4, w3 = y3 + h4, _3 = m3 + p4, A3 = g3 + f4, S3 = x3 + d3, k3 = new a2((y3 + o4) / b3, (m3 + l4) / b3);
                k3.z = v3 / b3, t5.push(k3);
                const I3 = new a2(w3 / S3, _3 / S3);
                I3.z = A3 / S3, r5.push(I3);
              }
              i4.push(t5), s4.push(r5);
            }
            return [i4, s4];
          }(n3, h3, c3, l3);
          return function(t4, e3, r4) {
            let n4 = 1 / 0;
            hs(r4, e3) && (n4 = ul(r4, e3[0]));
            for (let i4 = 0; i4 < e3.length; i4++) {
              const a3 = e3[i4], s4 = t4[i4];
              for (let t5 = 0; t5 < a3.length - 1; t5++) {
                const e4 = a3[t5], i5 = [e4, a3[t5 + 1], s4[t5 + 1], s4[t5], e4];
                us(r4, i5) && (n4 = Math.min(n4, ul(r4, i5)));
              }
            }
            return n4 !== 1 / 0 && n4;
          }(f3[0], f3[1], p3);
        }
      }
      function ll(t3, e2) {
        return t3.x * e2.x + t3.y * e2.y;
      }
      function ul(t3, e2) {
        if (1 === t3.length) {
          let r3 = 0;
          const n3 = e2[r3++];
          let i3;
          for (; !i3 || n3.equals(i3); ) if (i3 = e2[r3++], !i3) return 1 / 0;
          for (; r3 < e2.length; r3++) {
            const a3 = e2[r3], s3 = t3[0], o3 = i3.sub(n3), l3 = a3.sub(n3), u3 = s3.sub(n3), c3 = ll(o3, o3), h3 = ll(o3, l3), p3 = ll(l3, l3), f3 = ll(u3, o3), d3 = ll(u3, l3), y3 = c3 * p3 - h3 * h3, m3 = (p3 * f3 - h3 * d3) / y3, g3 = (c3 * d3 - h3 * f3) / y3, x3 = n3.z * (1 - m3 - g3) + i3.z * m3 + a3.z * g3;
            if (isFinite(x3)) return x3;
          }
          return 1 / 0;
        }
        {
          let t4 = 1 / 0;
          for (const r3 of e2) t4 = Math.min(t4, r3.z);
          return t4;
        }
      }
      const cl = Mi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: hl } = cl, pl = Mi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: fl } = pl, dl = Ro.VectorTileFeature.types, yl = Math.cos(Math.PI / 180 * 37.5), ml = Math.pow(2, 14) / 0.5;
      class gl {
        constructor(t3) {
          this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t4) => {
            this.gradients[t4.id] = {};
          }), this.layoutVertexArray = new ya(), this.layoutVertexArray2 = new ma(), this.indexArray = new Aa(), this.programConfigurations = new Qa(t3.layers, t3.zoom), this.segments = new za(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
        }
        populate(t3, e2, r3) {
          this.hasPattern = Po("line", this.layers, e2);
          const n3 = this.layers[0].layout.get("line-sort-key"), i3 = !n3.isConstant(), a3 = [];
          for (const { feature: e3, id: s3, index: o3, sourceLayerIndex: l3 } of t3) {
            const t4 = this.layers[0]._featureFilter.needGeometry, u3 = ss2(e3, t4);
            if (!this.layers[0]._featureFilter.filter(new li(this.zoom), u3, r3)) continue;
            const c3 = i3 ? n3.evaluate(u3, {}, r3) : void 0, h3 = { id: s3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t4 ? u3.geometry : as(e3), patterns: {}, sortKey: c3 };
            a3.push(h3);
          }
          i3 && a3.sort((t4, e3) => t4.sortKey - e3.sortKey);
          for (const n4 of a3) {
            const { geometry: i4, index: a4, sourceLayerIndex: s3 } = n4;
            if (this.hasPattern) {
              const t4 = Vo("line", this.layers, n4, this.zoom, e2);
              this.patternFeatures.push(t4);
            } else this.addFeature(n4, i4, a4, r3, {});
            e2.featureIndex.insert(t3[a4].feature, i4, a4, s3, this.index);
          }
        }
        update(t3, e2, r3) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e2, this.stateDependentLayers, r3);
        }
        addFeatures(t3, e2, r3) {
          for (const t4 of this.patternFeatures) this.addFeature(t4, t4.geometry, t4.index, e2, r3);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t3) {
          this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t3.createVertexBuffer(this.layoutVertexArray2, fl)), this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, hl), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t3) {
          if (t3.properties && Object.prototype.hasOwnProperty.call(t3.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t3.properties, "mapbox_clip_end")) return { start: +t3.properties.mapbox_clip_start, end: +t3.properties.mapbox_clip_end };
        }
        addFeature(t3, e2, r3, n3, i3) {
          const a3 = this.layers[0].layout, s3 = a3.get("line-join").evaluate(t3, {}), o3 = a3.get("line-cap"), l3 = a3.get("line-miter-limit"), u3 = a3.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t3);
          for (const r4 of e2) this.addLine(r4, t3, s3, o3, l3, u3);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i3, n3);
        }
        addLine(t3, e2, r3, n3, i3, a3) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let e3 = 0; e3 < t3.length - 1; e3++) this.totalDistance += t3[e3].dist(t3[e3 + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const s3 = "Polygon" === dl[e2.type];
          let o3 = t3.length;
          for (; o3 >= 2 && t3[o3 - 1].equals(t3[o3 - 2]); ) o3--;
          let l3 = 0;
          for (; l3 < o3 - 1 && t3[l3].equals(t3[l3 + 1]); ) l3++;
          if (o3 < (s3 ? 3 : 2)) return;
          "bevel" === r3 && (i3 = 1.05);
          const u3 = this.overscaling <= 16 ? 15 * rs / (512 * this.overscaling) : 0, c3 = this.segments.prepareSegment(10 * o3, this.layoutVertexArray, this.indexArray);
          let h3, p3, f3, d3, y3;
          this.e1 = this.e2 = -1, s3 && (h3 = t3[o3 - 2], y3 = t3[l3].sub(h3)._unit()._perp());
          for (let e3 = l3; e3 < o3; e3++) {
            if (f3 = e3 === o3 - 1 ? s3 ? t3[l3 + 1] : void 0 : t3[e3 + 1], f3 && t3[e3].equals(f3)) continue;
            y3 && (d3 = y3), h3 && (p3 = h3), h3 = t3[e3], y3 = f3 ? f3.sub(h3)._unit()._perp() : d3, d3 = d3 || y3;
            let m3 = d3.add(y3);
            0 === m3.x && 0 === m3.y || m3._unit();
            const g3 = d3.x * y3.x + d3.y * y3.y, x3 = m3.x * y3.x + m3.y * y3.y, v3 = 0 !== x3 ? 1 / x3 : 1 / 0, b3 = 2 * Math.sqrt(2 - 2 * x3), w3 = x3 < yl && p3 && f3, _3 = d3.x * y3.y - d3.y * y3.x > 0;
            if (w3 && e3 > l3) {
              const t4 = h3.dist(p3);
              if (t4 > 2 * u3) {
                const e4 = h3.sub(h3.sub(p3)._mult(u3 / t4)._round());
                this.updateDistance(p3, e4), this.addCurrentVertex(e4, d3, 0, 0, c3), p3 = e4;
              }
            }
            const A3 = p3 && f3;
            let S3 = A3 ? r3 : s3 ? "butt" : n3;
            if (A3 && "round" === S3 && (v3 < a3 ? S3 = "miter" : v3 <= 2 && (S3 = "fakeround")), "miter" === S3 && v3 > i3 && (S3 = "bevel"), "bevel" === S3 && (v3 > 2 && (S3 = "flipbevel"), v3 < i3 && (S3 = "miter")), p3 && this.updateDistance(p3, h3), "miter" === S3) m3._mult(v3), this.addCurrentVertex(h3, m3, 0, 0, c3);
            else if ("flipbevel" === S3) {
              if (v3 > 100) m3 = y3.mult(-1);
              else {
                const t4 = v3 * d3.add(y3).mag() / d3.sub(y3).mag();
                m3._perp()._mult(t4 * (_3 ? -1 : 1));
              }
              this.addCurrentVertex(h3, m3, 0, 0, c3), this.addCurrentVertex(h3, m3.mult(-1), 0, 0, c3);
            } else if ("bevel" === S3 || "fakeround" === S3) {
              const t4 = -Math.sqrt(v3 * v3 - 1), e4 = _3 ? t4 : 0, r4 = _3 ? 0 : t4;
              if (p3 && this.addCurrentVertex(h3, d3, e4, r4, c3), "fakeround" === S3) {
                const t5 = Math.round(180 * b3 / Math.PI / 20);
                for (let e5 = 1; e5 < t5; e5++) {
                  let r5 = e5 / t5;
                  if (0.5 !== r5) {
                    const t6 = r5 - 0.5;
                    r5 += r5 * t6 * (r5 - 1) * ((1.0904 + g3 * (g3 * (3.55645 - 1.43519 * g3) - 3.2452)) * t6 * t6 + (0.848013 + g3 * (0.215638 * g3 - 1.06021)));
                  }
                  const n4 = y3.sub(d3)._mult(r5)._add(d3)._unit()._mult(_3 ? -1 : 1);
                  this.addHalfVertex(h3, n4.x, n4.y, false, _3, 0, c3);
                }
              }
              f3 && this.addCurrentVertex(h3, y3, -e4, -r4, c3);
            } else if ("butt" === S3) this.addCurrentVertex(h3, m3, 0, 0, c3);
            else if ("square" === S3) {
              const t4 = p3 ? 1 : -1;
              this.addCurrentVertex(h3, m3, t4, t4, c3);
            } else "round" === S3 && (p3 && (this.addCurrentVertex(h3, d3, 0, 0, c3), this.addCurrentVertex(h3, d3, 1, 1, c3, true)), f3 && (this.addCurrentVertex(h3, y3, -1, -1, c3, true), this.addCurrentVertex(h3, y3, 0, 0, c3)));
            if (w3 && e3 < o3 - 1) {
              const t4 = h3.dist(f3);
              if (t4 > 2 * u3) {
                const e4 = h3.add(f3.sub(h3)._mult(u3 / t4)._round());
                this.updateDistance(h3, e4), this.addCurrentVertex(e4, y3, 0, 0, c3), h3 = e4;
              }
            }
          }
        }
        addCurrentVertex(t3, e2, r3, n3, i3, a3 = false) {
          const s3 = e2.y * n3 - e2.x, o3 = -e2.y - e2.x * n3;
          this.addHalfVertex(t3, e2.x + e2.y * r3, e2.y - e2.x * r3, a3, false, r3, i3), this.addHalfVertex(t3, s3, o3, a3, true, -n3, i3), this.distance > ml / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t3, e2, r3, n3, i3, a3));
        }
        addHalfVertex({ x: t3, y: e2 }, r3, n3, i3, a3, s3, o3) {
          const l3 = 0.5 * (this.lineClips ? this.scaledDistance * (ml - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((t3 << 1) + (i3 ? 1 : 0), (e2 << 1) + (a3 ? 1 : 0), Math.round(63 * r3) + 128, Math.round(63 * n3) + 128, 1 + (0 === s3 ? 0 : s3 < 0 ? -1 : 1) | (63 & l3) << 2, l3 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const u3 = o3.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u3), o3.primitiveLength++), a3 ? this.e2 = u3 : this.e1 = u3;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(t3, e2) {
          this.distance += t3.dist(e2), this.updateScaledDistance();
        }
      }
      let xl, vl;
      $n("LineBucket", gl, { omit: ["layers", "patternFeatures"] });
      var bl = { get paint() {
        return vl = vl || new _i({ "line-opacity": new xi(X2.paint_line["line-opacity"]), "line-color": new xi(X2.paint_line["line-color"]), "line-translate": new gi(X2.paint_line["line-translate"]), "line-translate-anchor": new gi(X2.paint_line["line-translate-anchor"]), "line-width": new xi(X2.paint_line["line-width"]), "line-gap-width": new xi(X2.paint_line["line-gap-width"]), "line-offset": new xi(X2.paint_line["line-offset"]), "line-blur": new xi(X2.paint_line["line-blur"]), "line-dasharray": new bi(X2.paint_line["line-dasharray"]), "line-pattern": new vi(X2.paint_line["line-pattern"]), "line-gradient": new wi(X2.paint_line["line-gradient"]) });
      }, get layout() {
        return xl = xl || new _i({ "line-cap": new gi(X2.layout_line["line-cap"]), "line-join": new xi(X2.layout_line["line-join"]), "line-miter-limit": new gi(X2.layout_line["line-miter-limit"]), "line-round-limit": new gi(X2.layout_line["line-round-limit"]), "line-sort-key": new xi(X2.layout_line["line-sort-key"]) });
      } };
      class wl extends xi {
        possiblyEvaluate(t3, e2) {
          return e2 = new li(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t3, e2);
        }
        evaluate(t3, e2, r3, n3) {
          return e2 = g2({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t3, e2, r3, n3);
        }
      }
      let _l;
      class Al extends Si {
        constructor(t3) {
          super(t3, bl), this.gradientVersion = 0, _l || (_l = new wl(bl.paint.properties["line-width"].specification), _l.useIntegerZoom = true);
        }
        _handleSpecialPaintPropertyUpdate(t3) {
          if ("line-gradient" === t3) {
            const t4 = this.gradientExpression();
            this.stepInterpolant = !!function(t5) {
              return void 0 !== t5._styleExpression;
            }(t4) && t4._styleExpression.expression instanceof qe, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(t3, e2) {
          super.recalculate(t3, e2), this.paint._values["line-floorwidth"] = _l.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t3);
        }
        createBucket(t3) {
          return new gl(t3);
        }
        queryRadius(t3) {
          const e2 = t3, r3 = Sl(bs("line-width", this, e2), bs("line-gap-width", this, e2)), n3 = bs("line-offset", this, e2);
          return r3 / 2 + Math.abs(n3) + ws(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t3, e2, r3, n3, i3, s3, o3) {
          const l3 = _s(t3, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s3.angle, o3), u3 = o3 / 2 * Sl(this.paint.get("line-width").evaluate(e2, r3), this.paint.get("line-gap-width").evaluate(e2, r3)), c3 = this.paint.get("line-offset").evaluate(e2, r3);
          return c3 && (n3 = function(t4, e3) {
            const r4 = [];
            for (let n4 = 0; n4 < t4.length; n4++) {
              const i4 = t4[n4], s4 = [];
              for (let t5 = 0; t5 < i4.length; t5++) {
                const r5 = i4[t5 - 1], n5 = i4[t5], o4 = i4[t5 + 1], l4 = 0 === t5 ? new a2(0, 0) : n5.sub(r5)._unit()._perp(), u4 = t5 === i4.length - 1 ? new a2(0, 0) : o4.sub(n5)._unit()._perp(), c4 = l4._add(u4)._unit(), h3 = c4.x * u4.x + c4.y * u4.y;
                0 !== h3 && c4._mult(1 / h3), s4.push(c4._mult(e3)._add(n5));
              }
              r4.push(s4);
            }
            return r4;
          }(n3, c3 * o3)), function(t4, e3, r4) {
            for (let n4 = 0; n4 < e3.length; n4++) {
              const i4 = e3[n4];
              if (t4.length >= 3) {
                for (let e4 = 0; e4 < i4.length; e4++) if (xs(t4, i4[e4])) return true;
              }
              if (ps(t4, i4, r4)) return true;
            }
            return false;
          }(l3, n3, u3);
        }
        isTileClipped() {
          return true;
        }
      }
      function Sl(t3, e2) {
        return e2 > 0 ? e2 + 2 * t3 : t3;
      }
      const kl = Mi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Il = Mi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      Mi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const zl = Mi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
      Mi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const Ml = Mi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Cl = Mi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function Bl(t3, e2, r3) {
        return t3.sections.forEach((t4) => {
          t4.text = function(t5, e3, r4) {
            const n3 = e3.layout.get("text-transform").evaluate(r4, {});
            return "uppercase" === n3 ? t5 = t5.toLocaleUpperCase() : "lowercase" === n3 && (t5 = t5.toLocaleLowerCase()), oi.applyArabicShaping && (t5 = oi.applyArabicShaping(t5)), t5;
          }(t4.text, e2, r3);
        }), t3;
      }
      Mi([{ name: "triangle", components: 3, type: "Uint16" }]), Mi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Mi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Mi([{ type: "Float32", name: "offsetX" }]), Mi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Mi([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
      const Pl = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
      var Vl = 24, El = $l, Fl = function(t3, e2, r3, n3, i3) {
        var a3, s3, o3 = 8 * i3 - n3 - 1, l3 = (1 << o3) - 1, u3 = l3 >> 1, c3 = -7, h3 = i3 - 1, p3 = -1, f3 = t3[e2 + h3];
        for (h3 += p3, a3 = f3 & (1 << -c3) - 1, f3 >>= -c3, c3 += o3; c3 > 0; a3 = 256 * a3 + t3[e2 + h3], h3 += p3, c3 -= 8) ;
        for (s3 = a3 & (1 << -c3) - 1, a3 >>= -c3, c3 += n3; c3 > 0; s3 = 256 * s3 + t3[e2 + h3], h3 += p3, c3 -= 8) ;
        if (0 === a3) a3 = 1 - u3;
        else {
          if (a3 === l3) return s3 ? NaN : 1 / 0 * (f3 ? -1 : 1);
          s3 += Math.pow(2, n3), a3 -= u3;
        }
        return (f3 ? -1 : 1) * s3 * Math.pow(2, a3 - n3);
      }, Tl = function(t3, e2, r3, n3, i3, a3) {
        var s3, o3, l3, u3 = 8 * a3 - i3 - 1, c3 = (1 << u3) - 1, h3 = c3 >> 1, p3 = 23 === i3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f3 = 0, d3 = 1, y3 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
        for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o3 = isNaN(e2) ? 1 : 0, s3 = c3) : (s3 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l3 = Math.pow(2, -s3)) < 1 && (s3--, l3 *= 2), (e2 += s3 + h3 >= 1 ? p3 / l3 : p3 * Math.pow(2, 1 - h3)) * l3 >= 2 && (s3++, l3 /= 2), s3 + h3 >= c3 ? (o3 = 0, s3 = c3) : s3 + h3 >= 1 ? (o3 = (e2 * l3 - 1) * Math.pow(2, i3), s3 += h3) : (o3 = e2 * Math.pow(2, h3 - 1) * Math.pow(2, i3), s3 = 0)); i3 >= 8; t3[r3 + f3] = 255 & o3, f3 += d3, o3 /= 256, i3 -= 8) ;
        for (s3 = s3 << i3 | o3, u3 += i3; u3 > 0; t3[r3 + f3] = 255 & s3, f3 += d3, s3 /= 256, u3 -= 8) ;
        t3[r3 + f3 - d3] |= 128 * y3;
      };
      function $l(t3) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      $l.Varint = 0, $l.Fixed64 = 1, $l.Bytes = 2, $l.Fixed32 = 5;
      var Ll = 4294967296, Dl = 1 / Ll, Ol = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
      function Ul(t3) {
        return t3.type === $l.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
      }
      function Rl(t3, e2, r3) {
        return r3 ? 4294967296 * e2 + (t3 >>> 0) : 4294967296 * (e2 >>> 0) + (t3 >>> 0);
      }
      function ql(t3, e2, r3) {
        var n3 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
        r3.realloc(n3);
        for (var i3 = r3.pos - 1; i3 >= t3; i3--) r3.buf[i3 + n3] = r3.buf[i3];
      }
      function jl(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++) e2.writeVarint(t3[r3]);
      }
      function Nl(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++) e2.writeSVarint(t3[r3]);
      }
      function Zl(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++) e2.writeFloat(t3[r3]);
      }
      function Kl(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++) e2.writeDouble(t3[r3]);
      }
      function Gl(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++) e2.writeBoolean(t3[r3]);
      }
      function Jl(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++) e2.writeFixed32(t3[r3]);
      }
      function Xl(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++) e2.writeSFixed32(t3[r3]);
      }
      function Yl(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++) e2.writeFixed64(t3[r3]);
      }
      function Hl(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++) e2.writeSFixed64(t3[r3]);
      }
      function Wl(t3, e2) {
        return (t3[e2] | t3[e2 + 1] << 8 | t3[e2 + 2] << 16) + 16777216 * t3[e2 + 3];
      }
      function Ql(t3, e2, r3) {
        t3[r3] = e2, t3[r3 + 1] = e2 >>> 8, t3[r3 + 2] = e2 >>> 16, t3[r3 + 3] = e2 >>> 24;
      }
      function tu(t3, e2) {
        return (t3[e2] | t3[e2 + 1] << 8 | t3[e2 + 2] << 16) + (t3[e2 + 3] << 24);
      }
      $l.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(t3, e2, r3) {
        for (r3 = r3 || this.length; this.pos < r3; ) {
          var n3 = this.readVarint(), i3 = n3 >> 3, a3 = this.pos;
          this.type = 7 & n3, t3(i3, e2, this), this.pos === a3 && this.skip(n3);
        }
        return e2;
      }, readMessage: function(t3, e2) {
        return this.readFields(t3, e2, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var t3 = Wl(this.buf, this.pos);
        return this.pos += 4, t3;
      }, readSFixed32: function() {
        var t3 = tu(this.buf, this.pos);
        return this.pos += 4, t3;
      }, readFixed64: function() {
        var t3 = Wl(this.buf, this.pos) + Wl(this.buf, this.pos + 4) * Ll;
        return this.pos += 8, t3;
      }, readSFixed64: function() {
        var t3 = Wl(this.buf, this.pos) + tu(this.buf, this.pos + 4) * Ll;
        return this.pos += 8, t3;
      }, readFloat: function() {
        var t3 = Fl(this.buf, this.pos, true, 23, 4);
        return this.pos += 4, t3;
      }, readDouble: function() {
        var t3 = Fl(this.buf, this.pos, true, 52, 8);
        return this.pos += 8, t3;
      }, readVarint: function(t3) {
        var e2, r3, n3 = this.buf;
        return e2 = 127 & (r3 = n3[this.pos++]), r3 < 128 ? e2 : (e2 |= (127 & (r3 = n3[this.pos++])) << 7, r3 < 128 ? e2 : (e2 |= (127 & (r3 = n3[this.pos++])) << 14, r3 < 128 ? e2 : (e2 |= (127 & (r3 = n3[this.pos++])) << 21, r3 < 128 ? e2 : function(t4, e3, r4) {
          var n4, i3, a3 = r4.buf;
          if (n4 = (112 & (i3 = a3[r4.pos++])) >> 4, i3 < 128) return Rl(t4, n4, e3);
          if (n4 |= (127 & (i3 = a3[r4.pos++])) << 3, i3 < 128) return Rl(t4, n4, e3);
          if (n4 |= (127 & (i3 = a3[r4.pos++])) << 10, i3 < 128) return Rl(t4, n4, e3);
          if (n4 |= (127 & (i3 = a3[r4.pos++])) << 17, i3 < 128) return Rl(t4, n4, e3);
          if (n4 |= (127 & (i3 = a3[r4.pos++])) << 24, i3 < 128) return Rl(t4, n4, e3);
          if (n4 |= (1 & (i3 = a3[r4.pos++])) << 31, i3 < 128) return Rl(t4, n4, e3);
          throw new Error("Expected varint not more than 10 bytes");
        }(e2 |= (15 & (r3 = n3[this.pos])) << 28, t3, this))));
      }, readVarint64: function() {
        return this.readVarint(true);
      }, readSVarint: function() {
        var t3 = this.readVarint();
        return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var t3 = this.readVarint() + this.pos, e2 = this.pos;
        return this.pos = t3, t3 - e2 >= 12 && Ol ? function(t4, e3, r3) {
          return Ol.decode(t4.subarray(e3, r3));
        }(this.buf, e2, t3) : function(t4, e3, r3) {
          for (var n3 = "", i3 = e3; i3 < r3; ) {
            var a3, s3, o3, l3 = t4[i3], u3 = null, c3 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
            if (i3 + c3 > r3) break;
            1 === c3 ? l3 < 128 && (u3 = l3) : 2 === c3 ? 128 == (192 & (a3 = t4[i3 + 1])) && (u3 = (31 & l3) << 6 | 63 & a3) <= 127 && (u3 = null) : 3 === c3 ? (s3 = t4[i3 + 2], 128 == (192 & (a3 = t4[i3 + 1])) && 128 == (192 & s3) && ((u3 = (15 & l3) << 12 | (63 & a3) << 6 | 63 & s3) <= 2047 || u3 >= 55296 && u3 <= 57343) && (u3 = null)) : 4 === c3 && (s3 = t4[i3 + 2], o3 = t4[i3 + 3], 128 == (192 & (a3 = t4[i3 + 1])) && 128 == (192 & s3) && 128 == (192 & o3) && ((u3 = (15 & l3) << 18 | (63 & a3) << 12 | (63 & s3) << 6 | 63 & o3) <= 65535 || u3 >= 1114112) && (u3 = null)), null === u3 ? (u3 = 65533, c3 = 1) : u3 > 65535 && (u3 -= 65536, n3 += String.fromCharCode(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), n3 += String.fromCharCode(u3), i3 += c3;
          }
          return n3;
        }(this.buf, e2, t3);
      }, readBytes: function() {
        var t3 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t3);
        return this.pos = t3, e2;
      }, readPackedVarint: function(t3, e2) {
        if (this.type !== $l.Bytes) return t3.push(this.readVarint(e2));
        var r3 = Ul(this);
        for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readVarint(e2));
        return t3;
      }, readPackedSVarint: function(t3) {
        if (this.type !== $l.Bytes) return t3.push(this.readSVarint());
        var e2 = Ul(this);
        for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readSVarint());
        return t3;
      }, readPackedBoolean: function(t3) {
        if (this.type !== $l.Bytes) return t3.push(this.readBoolean());
        var e2 = Ul(this);
        for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readBoolean());
        return t3;
      }, readPackedFloat: function(t3) {
        if (this.type !== $l.Bytes) return t3.push(this.readFloat());
        var e2 = Ul(this);
        for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readFloat());
        return t3;
      }, readPackedDouble: function(t3) {
        if (this.type !== $l.Bytes) return t3.push(this.readDouble());
        var e2 = Ul(this);
        for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readDouble());
        return t3;
      }, readPackedFixed32: function(t3) {
        if (this.type !== $l.Bytes) return t3.push(this.readFixed32());
        var e2 = Ul(this);
        for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readFixed32());
        return t3;
      }, readPackedSFixed32: function(t3) {
        if (this.type !== $l.Bytes) return t3.push(this.readSFixed32());
        var e2 = Ul(this);
        for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readSFixed32());
        return t3;
      }, readPackedFixed64: function(t3) {
        if (this.type !== $l.Bytes) return t3.push(this.readFixed64());
        var e2 = Ul(this);
        for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readFixed64());
        return t3;
      }, readPackedSFixed64: function(t3) {
        if (this.type !== $l.Bytes) return t3.push(this.readSFixed64());
        var e2 = Ul(this);
        for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readSFixed64());
        return t3;
      }, skip: function(t3) {
        var e2 = 7 & t3;
        if (e2 === $l.Varint) for (; this.buf[this.pos++] > 127; ) ;
        else if (e2 === $l.Bytes) this.pos = this.readVarint() + this.pos;
        else if (e2 === $l.Fixed32) this.pos += 4;
        else {
          if (e2 !== $l.Fixed64) throw new Error("Unimplemented type: " + e2);
          this.pos += 8;
        }
      }, writeTag: function(t3, e2) {
        this.writeVarint(t3 << 3 | e2);
      }, realloc: function(t3) {
        for (var e2 = this.length || 16; e2 < this.pos + t3; ) e2 *= 2;
        if (e2 !== this.length) {
          var r3 = new Uint8Array(e2);
          r3.set(this.buf), this.buf = r3, this.length = e2;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(t3) {
        this.realloc(4), Ql(this.buf, t3, this.pos), this.pos += 4;
      }, writeSFixed32: function(t3) {
        this.realloc(4), Ql(this.buf, t3, this.pos), this.pos += 4;
      }, writeFixed64: function(t3) {
        this.realloc(8), Ql(this.buf, -1 & t3, this.pos), Ql(this.buf, Math.floor(t3 * Dl), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(t3) {
        this.realloc(8), Ql(this.buf, -1 & t3, this.pos), Ql(this.buf, Math.floor(t3 * Dl), this.pos + 4), this.pos += 8;
      }, writeVarint: function(t3) {
        (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e2) {
          var r3, n3;
          if (t4 >= 0 ? (r3 = t4 % 4294967296 | 0, n3 = t4 / 4294967296 | 0) : (n3 = ~(-t4 / 4294967296), 4294967295 ^ (r3 = ~(-t4 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, n3 = n3 + 1 | 0)), t4 >= 18446744073709552e3 || t4 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
          e2.realloc(10), function(t5, e3, r4) {
            r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, r4.buf[r4.pos] = 127 & (t5 >>>= 7);
          }(r3, 0, e2), function(t5, e3) {
            var r4 = (7 & t5) << 4;
            e3.buf[e3.pos++] |= r4 | ((t5 >>>= 3) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5)))));
          }(n3, e2);
        }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
      }, writeSVarint: function(t3) {
        this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
      }, writeBoolean: function(t3) {
        this.writeVarint(Boolean(t3));
      }, writeString: function(t3) {
        t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
        var e2 = this.pos;
        this.pos = function(t4, e3, r4) {
          for (var n3, i3, a3 = 0; a3 < e3.length; a3++) {
            if ((n3 = e3.charCodeAt(a3)) > 55295 && n3 < 57344) {
              if (!i3) {
                n3 > 56319 || a3 + 1 === e3.length ? (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189) : i3 = n3;
                continue;
              }
              if (n3 < 56320) {
                t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = n3;
                continue;
              }
              n3 = i3 - 55296 << 10 | n3 - 56320 | 65536, i3 = null;
            } else i3 && (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = null);
            n3 < 128 ? t4[r4++] = n3 : (n3 < 2048 ? t4[r4++] = n3 >> 6 | 192 : (n3 < 65536 ? t4[r4++] = n3 >> 12 | 224 : (t4[r4++] = n3 >> 18 | 240, t4[r4++] = n3 >> 12 & 63 | 128), t4[r4++] = n3 >> 6 & 63 | 128), t4[r4++] = 63 & n3 | 128);
          }
          return r4;
        }(this.buf, t3, this.pos);
        var r3 = this.pos - e2;
        r3 >= 128 && ql(e2, r3, this), this.pos = e2 - 1, this.writeVarint(r3), this.pos += r3;
      }, writeFloat: function(t3) {
        this.realloc(4), Tl(this.buf, t3, this.pos, true, 23, 4), this.pos += 4;
      }, writeDouble: function(t3) {
        this.realloc(8), Tl(this.buf, t3, this.pos, true, 52, 8), this.pos += 8;
      }, writeBytes: function(t3) {
        var e2 = t3.length;
        this.writeVarint(e2), this.realloc(e2);
        for (var r3 = 0; r3 < e2; r3++) this.buf[this.pos++] = t3[r3];
      }, writeRawMessage: function(t3, e2) {
        this.pos++;
        var r3 = this.pos;
        t3(e2, this);
        var n3 = this.pos - r3;
        n3 >= 128 && ql(r3, n3, this), this.pos = r3 - 1, this.writeVarint(n3), this.pos += n3;
      }, writeMessage: function(t3, e2, r3) {
        this.writeTag(t3, $l.Bytes), this.writeRawMessage(e2, r3);
      }, writePackedVarint: function(t3, e2) {
        e2.length && this.writeMessage(t3, jl, e2);
      }, writePackedSVarint: function(t3, e2) {
        e2.length && this.writeMessage(t3, Nl, e2);
      }, writePackedBoolean: function(t3, e2) {
        e2.length && this.writeMessage(t3, Gl, e2);
      }, writePackedFloat: function(t3, e2) {
        e2.length && this.writeMessage(t3, Zl, e2);
      }, writePackedDouble: function(t3, e2) {
        e2.length && this.writeMessage(t3, Kl, e2);
      }, writePackedFixed32: function(t3, e2) {
        e2.length && this.writeMessage(t3, Jl, e2);
      }, writePackedSFixed32: function(t3, e2) {
        e2.length && this.writeMessage(t3, Xl, e2);
      }, writePackedFixed64: function(t3, e2) {
        e2.length && this.writeMessage(t3, Yl, e2);
      }, writePackedSFixed64: function(t3, e2) {
        e2.length && this.writeMessage(t3, Hl, e2);
      }, writeBytesField: function(t3, e2) {
        this.writeTag(t3, $l.Bytes), this.writeBytes(e2);
      }, writeFixed32Field: function(t3, e2) {
        this.writeTag(t3, $l.Fixed32), this.writeFixed32(e2);
      }, writeSFixed32Field: function(t3, e2) {
        this.writeTag(t3, $l.Fixed32), this.writeSFixed32(e2);
      }, writeFixed64Field: function(t3, e2) {
        this.writeTag(t3, $l.Fixed64), this.writeFixed64(e2);
      }, writeSFixed64Field: function(t3, e2) {
        this.writeTag(t3, $l.Fixed64), this.writeSFixed64(e2);
      }, writeVarintField: function(t3, e2) {
        this.writeTag(t3, $l.Varint), this.writeVarint(e2);
      }, writeSVarintField: function(t3, e2) {
        this.writeTag(t3, $l.Varint), this.writeSVarint(e2);
      }, writeStringField: function(t3, e2) {
        this.writeTag(t3, $l.Bytes), this.writeString(e2);
      }, writeFloatField: function(t3, e2) {
        this.writeTag(t3, $l.Fixed32), this.writeFloat(e2);
      }, writeDoubleField: function(t3, e2) {
        this.writeTag(t3, $l.Fixed64), this.writeDouble(e2);
      }, writeBooleanField: function(t3, e2) {
        this.writeVarintField(t3, Boolean(e2));
      } };
      var eu = r2(El);
      const ru = 3;
      function nu(t3, e2, r3) {
        1 === t3 && r3.readMessage(iu, e2);
      }
      function iu(t3, e2, r3) {
        if (3 === t3) {
          const { id: t4, bitmap: n3, width: i3, height: a3, left: s3, top: o3, advance: l3 } = r3.readMessage(au, {});
          e2.push({ id: t4, bitmap: new Rs({ width: i3 + 2 * ru, height: a3 + 2 * ru }, n3), metrics: { width: i3, height: a3, left: s3, top: o3, advance: l3 } });
        }
      }
      function au(t3, e2, r3) {
        1 === t3 ? e2.id = r3.readVarint() : 2 === t3 ? e2.bitmap = r3.readBytes() : 3 === t3 ? e2.width = r3.readVarint() : 4 === t3 ? e2.height = r3.readVarint() : 5 === t3 ? e2.left = r3.readSVarint() : 6 === t3 ? e2.top = r3.readSVarint() : 7 === t3 && (e2.advance = r3.readVarint());
      }
      const su = ru;
      function ou(t3) {
        let e2 = 0, r3 = 0;
        for (const n4 of t3) e2 += n4.w * n4.h, r3 = Math.max(r3, n4.w);
        t3.sort((t4, e3) => e3.h - t4.h);
        const n3 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r3), h: 1 / 0 }];
        let i3 = 0, a3 = 0;
        for (const e3 of t3) for (let t4 = n3.length - 1; t4 >= 0; t4--) {
          const r4 = n3[t4];
          if (!(e3.w > r4.w || e3.h > r4.h)) {
            if (e3.x = r4.x, e3.y = r4.y, a3 = Math.max(a3, e3.y + e3.h), i3 = Math.max(i3, e3.x + e3.w), e3.w === r4.w && e3.h === r4.h) {
              const e4 = n3.pop();
              t4 < n3.length && (n3[t4] = e4);
            } else e3.h === r4.h ? (r4.x += e3.w, r4.w -= e3.w) : e3.w === r4.w ? (r4.y += e3.h, r4.h -= e3.h) : (n3.push({ x: r4.x + e3.w, y: r4.y, w: r4.w - e3.w, h: e3.h }), r4.y += e3.h, r4.h -= e3.h);
            break;
          }
        }
        return { w: i3, h: a3, fill: e2 / (i3 * a3) || 0 };
      }
      const lu = 1;
      class uu {
        constructor(t3, { pixelRatio: e2, version: r3, stretchX: n3, stretchY: i3, content: a3 }) {
          this.paddedRect = t3, this.pixelRatio = e2, this.stretchX = n3, this.stretchY = i3, this.content = a3, this.version = r3;
        }
        get tl() {
          return [this.paddedRect.x + lu, this.paddedRect.y + lu];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - lu, this.paddedRect.y + this.paddedRect.h - lu];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * lu) / this.pixelRatio, (this.paddedRect.h - 2 * lu) / this.pixelRatio];
        }
      }
      class cu {
        constructor(t3, e2) {
          const r3 = {}, n3 = {};
          this.haveRenderCallbacks = [];
          const i3 = [];
          this.addImages(t3, r3, i3), this.addImages(e2, n3, i3);
          const { w: a3, h: s3 } = ou(i3), o3 = new qs({ width: a3 || 1, height: s3 || 1 });
          for (const e3 in t3) {
            const n4 = t3[e3], i4 = r3[e3].paddedRect;
            qs.copy(n4.data, o3, { x: 0, y: 0 }, { x: i4.x + lu, y: i4.y + lu }, n4.data);
          }
          for (const t4 in e2) {
            const r4 = e2[t4], i4 = n3[t4].paddedRect, a4 = i4.x + lu, s4 = i4.y + lu, l3 = r4.data.width, u3 = r4.data.height;
            qs.copy(r4.data, o3, { x: 0, y: 0 }, { x: a4, y: s4 }, r4.data), qs.copy(r4.data, o3, { x: 0, y: u3 - 1 }, { x: a4, y: s4 - 1 }, { width: l3, height: 1 }), qs.copy(r4.data, o3, { x: 0, y: 0 }, { x: a4, y: s4 + u3 }, { width: l3, height: 1 }), qs.copy(r4.data, o3, { x: l3 - 1, y: 0 }, { x: a4 - 1, y: s4 }, { width: 1, height: u3 }), qs.copy(r4.data, o3, { x: 0, y: 0 }, { x: a4 + l3, y: s4 }, { width: 1, height: u3 });
          }
          this.image = o3, this.iconPositions = r3, this.patternPositions = n3;
        }
        addImages(t3, e2, r3) {
          for (const n3 in t3) {
            const i3 = t3[n3], a3 = { x: 0, y: 0, w: i3.data.width + 2 * lu, h: i3.data.height + 2 * lu };
            r3.push(a3), e2[n3] = new uu(a3, i3), i3.hasRenderCallback && this.haveRenderCallbacks.push(n3);
          }
        }
        patchUpdatedImages(t3, e2) {
          t3.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const r3 in t3.updatedImages) this.patchUpdatedImage(this.iconPositions[r3], t3.getImage(r3), e2), this.patchUpdatedImage(this.patternPositions[r3], t3.getImage(r3), e2);
        }
        patchUpdatedImage(t3, e2, r3) {
          if (!t3 || !e2) return;
          if (t3.version === e2.version) return;
          t3.version = e2.version;
          const [n3, i3] = t3.tl;
          r3.update(e2.data, void 0, { x: n3, y: i3 });
        }
      }
      var hu;
      $n("ImagePosition", uu), $n("ImageAtlas", cu), t2.ai = void 0, (hu = t2.ai || (t2.ai = {}))[hu.none = 0] = "none", hu[hu.horizontal = 1] = "horizontal", hu[hu.vertical = 2] = "vertical", hu[hu.horizontalOnly = 3] = "horizontalOnly";
      const pu = -17;
      class fu {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(t3, e2) {
          const r3 = new fu();
          return r3.scale = t3 || 1, r3.fontStack = e2, r3;
        }
        static forImage(t3) {
          const e2 = new fu();
          return e2.imageName = t3, e2;
        }
      }
      class du {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(t3, e2) {
          const r3 = new du();
          for (let n3 = 0; n3 < t3.sections.length; n3++) {
            const i3 = t3.sections[n3];
            i3.image ? r3.addImageSection(i3) : r3.addTextSection(i3, e2);
          }
          return r3;
        }
        length() {
          return this.text.length;
        }
        getSection(t3) {
          return this.sections[this.sectionIndex[t3]];
        }
        getSectionIndex(t3) {
          return this.sectionIndex[t3];
        }
        getCharCode(t3) {
          return this.text.charCodeAt(t3);
        }
        verticalizePunctuation() {
          this.text = function(t3) {
            let e2 = "";
            for (let r3 = 0; r3 < t3.length; r3++) {
              const n3 = t3.charCodeAt(r3 + 1) || null, i3 = t3.charCodeAt(r3 - 1) || null;
              e2 += n3 && Kn(n3) && !Pl[t3[r3 + 1]] || i3 && Kn(i3) && !Pl[t3[r3 - 1]] || !Pl[t3[r3]] ? t3[r3] : Pl[t3[r3]];
            }
            return e2;
          }(this.text);
        }
        trim() {
          let t3 = 0;
          for (let e3 = 0; e3 < this.text.length && mu[this.text.charCodeAt(e3)]; e3++) t3++;
          let e2 = this.text.length;
          for (let r3 = this.text.length - 1; r3 >= 0 && r3 >= t3 && mu[this.text.charCodeAt(r3)]; r3--) e2--;
          this.text = this.text.substring(t3, e2), this.sectionIndex = this.sectionIndex.slice(t3, e2);
        }
        substring(t3, e2) {
          const r3 = new du();
          return r3.text = this.text.substring(t3, e2), r3.sectionIndex = this.sectionIndex.slice(t3, e2), r3.sections = this.sections, r3;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t3, e2) => Math.max(t3, this.sections[e2].scale), 0);
        }
        addTextSection(t3, e2) {
          this.text += t3.text, this.sections.push(fu.forText(t3.scale, t3.fontStack || e2));
          const r3 = this.sections.length - 1;
          for (let e3 = 0; e3 < t3.text.length; ++e3) this.sectionIndex.push(r3);
        }
        addImageSection(t3) {
          const e2 = t3.image ? t3.image.name : "";
          if (0 === e2.length) return void A2("Can't add FormattedSection with an empty image.");
          const r3 = this.getNextImageSectionCharCode();
          r3 ? (this.text += String.fromCharCode(r3), this.sections.push(fu.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : A2("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function yu(e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3) {
        const g3 = du.fromFeature(e2, a3);
        let x3;
        p3 === t2.ai.vertical && g3.verticalizePunctuation();
        const { processBidirectionalText: v3, processStyledBidirectionalText: b3 } = oi;
        if (v3 && 1 === g3.sections.length) {
          x3 = [];
          const t3 = v3(g3.toString(), Au(g3, c3, s3, r3, i3, d3, y3));
          for (const e3 of t3) {
            const t4 = new du();
            t4.text = e3, t4.sections = g3.sections;
            for (let r4 = 0; r4 < e3.length; r4++) t4.sectionIndex.push(0);
            x3.push(t4);
          }
        } else if (b3) {
          x3 = [];
          const t3 = b3(g3.text, g3.sectionIndex, Au(g3, c3, s3, r3, i3, d3, y3));
          for (const e3 of t3) {
            const t4 = new du();
            t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = g3.sections, x3.push(t4);
          }
        } else x3 = function(t3, e3) {
          const r4 = [], n4 = t3.text;
          let i4 = 0;
          for (const n5 of e3) r4.push(t3.substring(i4, n5)), i4 = n5;
          return i4 < n4.length && r4.push(t3.substring(i4, n4.length)), r4;
        }(g3, Au(g3, c3, s3, r3, i3, d3, y3));
        const w3 = [], _3 = { positionedLines: w3, text: g3.toString(), top: h3[1], bottom: h3[1], left: h3[0], right: h3[0], writingMode: p3, iconsInText: false, verticalizable: false };
        return function(e3, r4, n4, i4, a4, s4, o4, l4, u4, c4, h4, p4) {
          let f4 = 0, d4 = pu, y4 = 0, m4 = 0;
          const g4 = "right" === l4 ? 1 : "left" === l4 ? 0 : 0.5;
          let x4 = 0;
          for (const o5 of a4) {
            o5.trim();
            const a5 = o5.getMaxScale(), l5 = (a5 - 1) * Vl, b5 = { positionedGlyphs: [], lineOffset: 0 };
            e3.positionedLines[x4] = b5;
            const w5 = b5.positionedGlyphs;
            let _5 = 0;
            if (!o5.length()) {
              d4 += s4, ++x4;
              continue;
            }
            for (let s5 = 0; s5 < o5.length(); s5++) {
              const y5 = o5.getSection(s5), m5 = o5.getSectionIndex(s5), g5 = o5.getCharCode(s5);
              let x5 = 0, b6 = null, A4 = null, S3 = null, k3 = Vl;
              const I3 = !(u4 === t2.ai.horizontal || !h4 && !Zn(g5) || h4 && (mu[g5] || (v4 = g5, Rn.Arabic(v4) || Rn["Arabic Supplement"](v4) || Rn["Arabic Extended-A"](v4) || Rn["Arabic Presentation Forms-A"](v4) || Rn["Arabic Presentation Forms-B"](v4))));
              if (y5.imageName) {
                const t3 = i4[y5.imageName];
                if (!t3) continue;
                S3 = y5.imageName, e3.iconsInText = e3.iconsInText || true, A4 = t3.paddedRect;
                const r5 = t3.displaySize;
                y5.scale = y5.scale * Vl / p4, b6 = { width: r5[0], height: r5[1], left: lu, top: -su, advance: I3 ? r5[1] : r5[0] }, x5 = l5 + (Vl - r5[1] * y5.scale), k3 = b6.advance;
                const n5 = I3 ? r5[0] * y5.scale - Vl * a5 : r5[1] * y5.scale - Vl * a5;
                n5 > 0 && n5 > _5 && (_5 = n5);
              } else {
                const t3 = n4[y5.fontStack], e4 = t3 && t3[g5];
                if (e4 && e4.rect) A4 = e4.rect, b6 = e4.metrics;
                else {
                  const t4 = r4[y5.fontStack], e5 = t4 && t4[g5];
                  if (!e5) continue;
                  b6 = e5.metrics;
                }
                x5 = (a5 - y5.scale) * Vl;
              }
              I3 ? (e3.verticalizable = true, w5.push({ glyph: g5, imageName: S3, x: f4, y: d4 + x5, vertical: I3, scale: y5.scale, fontStack: y5.fontStack, sectionIndex: m5, metrics: b6, rect: A4 }), f4 += k3 * y5.scale + c4) : (w5.push({ glyph: g5, imageName: S3, x: f4, y: d4 + x5, vertical: I3, scale: y5.scale, fontStack: y5.fontStack, sectionIndex: m5, metrics: b6, rect: A4 }), f4 += b6.advance * y5.scale + c4);
            }
            0 !== w5.length && (y4 = Math.max(f4 - c4, y4), ku(w5, 0, w5.length - 1, g4, _5)), f4 = 0;
            const A3 = s4 * a5 + _5;
            b5.lineOffset = Math.max(_5, l5), d4 += A3, m4 = Math.max(A3, m4), ++x4;
          }
          var v4;
          const b4 = d4 - pu, { horizontalAlign: w4, verticalAlign: _4 } = Su(o4);
          (function(t3, e4, r5, n5, i5, a5, s5, o5, l5) {
            const u5 = (e4 - r5) * i5;
            let c5 = 0;
            c5 = a5 !== s5 ? -o5 * n5 - pu : (-n5 * l5 + 0.5) * s5;
            for (const e5 of t3) for (const t4 of e5.positionedGlyphs) t4.x += u5, t4.y += c5;
          })(e3.positionedLines, g4, w4, _4, y4, m4, s4, b4, a4.length), e3.top += -_4 * b4, e3.bottom = e3.top + b4, e3.left += -w4 * y4, e3.right = e3.left + y4;
        }(_3, r3, n3, i3, x3, o3, l3, u3, p3, c3, f3, m3), !function(t3) {
          for (const e3 of t3) if (0 !== e3.positionedGlyphs.length) return false;
          return true;
        }(w3) && _3;
      }
      const mu = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, gu = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
      function xu(t3, e2, r3, n3, i3, a3) {
        if (e2.imageName) {
          const t4 = n3[e2.imageName];
          return t4 ? t4.displaySize[0] * e2.scale * Vl / a3 + i3 : 0;
        }
        {
          const n4 = r3[e2.fontStack], a4 = n4 && n4[t3];
          return a4 ? a4.metrics.advance * e2.scale + i3 : 0;
        }
      }
      function vu(t3, e2, r3, n3) {
        const i3 = Math.pow(t3 - e2, 2);
        return n3 ? t3 < e2 ? i3 / 2 : 2 * i3 : i3 + Math.abs(r3) * r3;
      }
      function bu(t3, e2, r3) {
        let n3 = 0;
        return 10 === t3 && (n3 -= 1e4), r3 && (n3 += 150), 40 !== t3 && 65288 !== t3 || (n3 += 50), 41 !== e2 && 65289 !== e2 || (n3 += 50), n3;
      }
      function wu(t3, e2, r3, n3, i3, a3) {
        let s3 = null, o3 = vu(e2, r3, i3, a3);
        for (const t4 of n3) {
          const n4 = vu(e2 - t4.x, r3, i3, a3) + t4.badness;
          n4 <= o3 && (s3 = t4, o3 = n4);
        }
        return { index: t3, x: e2, priorBreak: s3, badness: o3 };
      }
      function _u(t3) {
        return t3 ? _u(t3.priorBreak).concat(t3.index) : [];
      }
      function Au(t3, e2, r3, n3, i3, a3, s3) {
        if ("point" !== a3) return [];
        if (!t3) return [];
        const o3 = [], l3 = function(t4, e3, r4, n4, i4, a4) {
          let s4 = 0;
          for (let r5 = 0; r5 < t4.length(); r5++) {
            const o4 = t4.getSection(r5);
            s4 += xu(t4.getCharCode(r5), o4, n4, i4, e3, a4);
          }
          return s4 / Math.max(1, Math.ceil(s4 / r4));
        }(t3, e2, r3, n3, i3, s3), u3 = t3.text.indexOf("​") >= 0;
        let c3 = 0;
        for (let r4 = 0; r4 < t3.length(); r4++) {
          const a4 = t3.getSection(r4), p3 = t3.getCharCode(r4);
          if (mu[p3] || (c3 += xu(p3, a4, n3, i3, e2, s3)), r4 < t3.length() - 1) {
            const e3 = !((h3 = p3) < 11904 || !(Rn["Bopomofo Extended"](h3) || Rn.Bopomofo(h3) || Rn["CJK Compatibility Forms"](h3) || Rn["CJK Compatibility Ideographs"](h3) || Rn["CJK Compatibility"](h3) || Rn["CJK Radicals Supplement"](h3) || Rn["CJK Strokes"](h3) || Rn["CJK Symbols and Punctuation"](h3) || Rn["CJK Unified Ideographs Extension A"](h3) || Rn["CJK Unified Ideographs"](h3) || Rn["Enclosed CJK Letters and Months"](h3) || Rn["Halfwidth and Fullwidth Forms"](h3) || Rn.Hiragana(h3) || Rn["Ideographic Description Characters"](h3) || Rn["Kangxi Radicals"](h3) || Rn["Katakana Phonetic Extensions"](h3) || Rn.Katakana(h3) || Rn["Vertical Forms"](h3) || Rn["Yi Radicals"](h3) || Rn["Yi Syllables"](h3)));
            (gu[p3] || e3 || a4.imageName) && o3.push(wu(r4 + 1, c3, l3, o3, bu(p3, t3.getCharCode(r4 + 1), e3 && u3), false));
          }
        }
        var h3;
        return _u(wu(t3.length(), c3, l3, o3, 0, true));
      }
      function Su(t3) {
        let e2 = 0.5, r3 = 0.5;
        switch (t3) {
          case "right":
          case "top-right":
          case "bottom-right":
            e2 = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e2 = 0;
        }
        switch (t3) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            r3 = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            r3 = 0;
        }
        return { horizontalAlign: e2, verticalAlign: r3 };
      }
      function ku(t3, e2, r3, n3, i3) {
        if (!n3 && !i3) return;
        const a3 = t3[r3], s3 = (t3[r3].x + a3.metrics.advance * a3.scale) * n3;
        for (let n4 = e2; n4 <= r3; n4++) t3[n4].x -= s3, t3[n4].y += i3;
      }
      function Iu(t3, e2, r3) {
        const { horizontalAlign: n3, verticalAlign: i3 } = Su(r3), a3 = e2[0] - t3.displaySize[0] * n3, s3 = e2[1] - t3.displaySize[1] * i3;
        return { image: t3, top: s3, bottom: s3 + t3.displaySize[1], left: a3, right: a3 + t3.displaySize[0] };
      }
      function zu(t3, e2, r3, n3, i3, a3) {
        const s3 = t3.image;
        let o3;
        if (s3.content) {
          const t4 = s3.content, e3 = s3.pixelRatio || 1;
          o3 = [t4[0] / e3, t4[1] / e3, s3.displaySize[0] - t4[2] / e3, s3.displaySize[1] - t4[3] / e3];
        }
        const l3 = e2.left * a3, u3 = e2.right * a3;
        let c3, h3, p3, f3;
        "width" === r3 || "both" === r3 ? (f3 = i3[0] + l3 - n3[3], h3 = i3[0] + u3 + n3[1]) : (f3 = i3[0] + (l3 + u3 - s3.displaySize[0]) / 2, h3 = f3 + s3.displaySize[0]);
        const d3 = e2.top * a3, y3 = e2.bottom * a3;
        return "height" === r3 || "both" === r3 ? (c3 = i3[1] + d3 - n3[0], p3 = i3[1] + y3 + n3[2]) : (c3 = i3[1] + (d3 + y3 - s3.displaySize[1]) / 2, p3 = c3 + s3.displaySize[1]), { image: s3, top: c3, right: h3, bottom: p3, left: f3, collisionPadding: o3 };
      }
      const Mu = 255, Cu = 128, Bu = Mu * Cu;
      function Pu(t3, e2) {
        const { expression: r3 } = e2;
        if ("constant" === r3.kind) return { kind: "constant", layoutSize: r3.evaluate(new li(t3 + 1)) };
        if ("source" === r3.kind) return { kind: "source" };
        {
          const { zoomStops: e3, interpolationType: n3 } = r3;
          let i3 = 0;
          for (; i3 < e3.length && e3[i3] <= t3; ) i3++;
          i3 = Math.max(0, i3 - 1);
          let a3 = i3;
          for (; a3 < e3.length && e3[a3] < t3 + 1; ) a3++;
          a3 = Math.min(e3.length - 1, a3);
          const s3 = e3[i3], o3 = e3[a3];
          return "composite" === r3.kind ? { kind: "composite", minZoom: s3, maxZoom: o3, interpolationType: n3 } : { kind: "camera", minZoom: s3, maxZoom: o3, minSize: r3.evaluate(new li(s3)), maxSize: r3.evaluate(new li(o3)), interpolationType: n3 };
        }
      }
      function Vu(t3, e2, r3) {
        let n3 = "never";
        const i3 = t3.get(e2);
        return i3 ? n3 = i3 : t3.get(r3) && (n3 = "always"), n3;
      }
      const Eu = Ro.VectorTileFeature.types, Fu = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Tu(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3) {
        const f3 = o3 ? Math.min(Bu, Math.round(o3[0])) : 0, d3 = o3 ? Math.min(Bu, Math.round(o3[1])) : 0;
        t3.emplaceBack(e2, r3, Math.round(32 * n3), Math.round(32 * i3), a3, s3, (f3 << 1) + (l3 ? 1 : 0), d3, 16 * u3, 16 * c3, 256 * h3, 256 * p3);
      }
      function $u(t3, e2, r3) {
        t3.emplaceBack(e2.x, e2.y, r3), t3.emplaceBack(e2.x, e2.y, r3), t3.emplaceBack(e2.x, e2.y, r3), t3.emplaceBack(e2.x, e2.y, r3);
      }
      function Lu(t3) {
        for (const e2 of t3.sections) if (Xn(e2.text)) return true;
        return false;
      }
      class Du {
        constructor(t3) {
          this.layoutVertexArray = new xa(), this.indexArray = new Aa(), this.programConfigurations = t3, this.segments = new za(), this.dynamicLayoutVertexArray = new va(), this.opacityVertexArray = new ba(), this.hasVisibleVertices = false, this.placedSymbolArray = new ra();
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
        }
        upload(t3, e2, r3, n3) {
          this.isEmpty() || (r3 && (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, kl.members), this.indexBuffer = t3.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t3.createVertexBuffer(this.dynamicLayoutVertexArray, Il.members, true), this.opacityVertexBuffer = t3.createVertexBuffer(this.opacityVertexArray, Fu, true), this.opacityVertexBuffer.itemSize = 1), (r3 || n3) && this.programConfigurations.upload(t3));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      $n("SymbolBuffers", Du);
      class Ou {
        constructor(t3, e2, r3) {
          this.layoutVertexArray = new t3(), this.layoutAttributes = e2, this.indexArray = new r3(), this.segments = new za(), this.collisionVertexArray = new _a2();
        }
        upload(t3) {
          this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t3.createVertexBuffer(this.collisionVertexArray, zl.members, true);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      $n("CollisionBuffers", Ou);
      class Uu {
        constructor(e2) {
          this.collisionBoxArray = e2.collisionBoxArray, this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = e2.index, this.pixelRatio = e2.pixelRatio, this.sourceLayerIndex = e2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Ms([]), this.placementViewportMatrix = Ms([]);
          const r3 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = Pu(this.zoom, r3["text-size"]), this.iconSizeData = Pu(this.zoom, r3["icon-size"]);
          const n3 = this.layers[0].layout, i3 = n3.get("symbol-sort-key"), a3 = n3.get("symbol-z-order");
          this.canOverlap = "never" !== Vu(n3, "text-overlap", "text-allow-overlap") || "never" !== Vu(n3, "icon-overlap", "icon-allow-overlap") || n3.get("text-ignore-placement") || n3.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== a3 && !i3.isConstant(), this.sortFeaturesByY = ("viewport-y" === a3 || "auto" === a3 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n3.get("symbol-placement") && (this.writingModes = n3.get("text-writing-mode").map((e3) => t2.ai[e3])), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = e2.sourceID;
        }
        createArrays() {
          this.text = new Du(new Qa(this.layers, this.zoom, (t3) => /^text/.test(t3))), this.icon = new Du(new Qa(this.layers, this.zoom, (t3) => /^icon/.test(t3))), this.glyphOffsetArray = new aa(), this.lineVertexArray = new sa(), this.symbolInstances = new ia(), this.textAnchorOffsets = new la();
        }
        calculateGlyphDependencies(t3, e2, r3, n3, i3) {
          for (let a3 = 0; a3 < t3.length; a3++) if (e2[t3.charCodeAt(a3)] = true, (r3 || n3) && i3) {
            const r4 = Pl[t3.charAt(a3)];
            r4 && (e2[r4.charCodeAt(0)] = true);
          }
        }
        populate(e2, r3, n3) {
          const i3 = this.layers[0], a3 = i3.layout, s3 = a3.get("text-font"), o3 = a3.get("text-field"), l3 = a3.get("icon-image"), u3 = ("constant" !== o3.value.kind || o3.value.value instanceof Qt && !o3.value.value.isEmpty() || o3.value.value.toString().length > 0) && ("constant" !== s3.value.kind || s3.value.value.length > 0), c3 = "constant" !== l3.value.kind || !!l3.value.value || Object.keys(l3.parameters).length > 0, h3 = a3.get("symbol-sort-key");
          if (this.features = [], !u3 && !c3) return;
          const p3 = r3.iconDependencies, f3 = r3.glyphDependencies, d3 = r3.availableImages, y3 = new li(this.zoom);
          for (const { feature: r4, id: o4, index: l4, sourceLayerIndex: m3 } of e2) {
            const e3 = i3._featureFilter.needGeometry, g3 = ss2(r4, e3);
            if (!i3._featureFilter.filter(y3, g3, n3)) continue;
            let x3, v3;
            if (e3 || (g3.geometry = as(r4)), u3) {
              const t3 = i3.getValueAndResolveTokens("text-field", g3, n3, d3), e4 = Qt.factory(t3);
              Lu(e4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === ai() || this.hasRTLText && oi.isParsed()) && (x3 = Bl(e4, i3, g3));
            }
            if (c3) {
              const t3 = i3.getValueAndResolveTokens("icon-image", g3, n3, d3);
              v3 = t3 instanceof ne2 ? t3 : ne2.fromString(t3);
            }
            if (!x3 && !v3) continue;
            const b3 = this.sortFeaturesByKey ? h3.evaluate(g3, {}, n3) : void 0;
            if (this.features.push({ id: o4, text: x3, icon: v3, index: l4, sourceLayerIndex: m3, geometry: g3.geometry, properties: r4.properties, type: Eu[r4.type], sortKey: b3 }), v3 && (p3[v3.name] = true), x3) {
              const e4 = s3.evaluate(g3, {}, n3).join(","), r5 = "viewport" !== a3.get("text-rotation-alignment") && "point" !== a3.get("symbol-placement");
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t2.ai.vertical) >= 0;
              for (const t3 of x3.sections) if (t3.image) p3[t3.image.name] = true;
              else {
                const n4 = qn(x3.toString()), i4 = t3.fontStack || e4, a4 = f3[i4] = f3[i4] || {};
                this.calculateGlyphDependencies(t3.text, a4, r5, this.allowVerticalPlacement, n4);
              }
            }
          }
          "line" === a3.get("symbol-placement") && (this.features = function(t3) {
            const e3 = {}, r4 = {}, n4 = [];
            let i4 = 0;
            function a4(e4) {
              n4.push(t3[e4]), i4++;
            }
            function s4(t4, e4, i5) {
              const a5 = r4[t4];
              return delete r4[t4], r4[e4] = a5, n4[a5].geometry[0].pop(), n4[a5].geometry[0] = n4[a5].geometry[0].concat(i5[0]), a5;
            }
            function o4(t4, r5, i5) {
              const a5 = e3[r5];
              return delete e3[r5], e3[t4] = a5, n4[a5].geometry[0].shift(), n4[a5].geometry[0] = i5[0].concat(n4[a5].geometry[0]), a5;
            }
            function l4(t4, e4, r5) {
              const n5 = r5 ? e4[0][e4[0].length - 1] : e4[0][0];
              return `${t4}:${n5.x}:${n5.y}`;
            }
            for (let u4 = 0; u4 < t3.length; u4++) {
              const c4 = t3[u4], h4 = c4.geometry, p4 = c4.text ? c4.text.toString() : null;
              if (!p4) {
                a4(u4);
                continue;
              }
              const f4 = l4(p4, h4), d4 = l4(p4, h4, true);
              if (f4 in r4 && d4 in e3 && r4[f4] !== e3[d4]) {
                const t4 = o4(f4, d4, h4), i5 = s4(f4, d4, n4[t4].geometry);
                delete e3[f4], delete r4[d4], r4[l4(p4, n4[i5].geometry, true)] = i5, n4[t4].geometry = null;
              } else f4 in r4 ? s4(f4, d4, h4) : d4 in e3 ? o4(f4, d4, h4) : (a4(u4), e3[f4] = i4 - 1, r4[d4] = i4 - 1);
            }
            return n4.filter((t4) => t4.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((t3, e3) => t3.sortKey - e3.sortKey);
        }
        update(t3, e2, r3) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t3, e2, this.layers, r3), this.icon.programConfigurations.updatePaintArrays(t3, e2, this.layers, r3));
        }
        isEmpty() {
          return 0 === this.symbolInstances.length && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t3) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t3), this.iconCollisionBox.upload(t3)), this.text.upload(t3, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t3, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t3, e2) {
          const r3 = this.lineVertexArray.length;
          if (void 0 !== t3.segment) {
            let r4 = t3.dist(e2[t3.segment + 1]), n3 = t3.dist(e2[t3.segment]);
            const i3 = {};
            for (let n4 = t3.segment + 1; n4 < e2.length; n4++) i3[n4] = { x: e2[n4].x, y: e2[n4].y, tileUnitDistanceFromAnchor: r4 }, n4 < e2.length - 1 && (r4 += e2[n4 + 1].dist(e2[n4]));
            for (let r5 = t3.segment || 0; r5 >= 0; r5--) i3[r5] = { x: e2[r5].x, y: e2[r5].y, tileUnitDistanceFromAnchor: n3 }, r5 > 0 && (n3 += e2[r5 - 1].dist(e2[r5]));
            for (let t4 = 0; t4 < e2.length; t4++) {
              const e3 = i3[t4];
              this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: r3, lineLength: this.lineVertexArray.length - r3 };
        }
        addSymbols(e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3) {
          const f3 = e2.indexArray, d3 = e2.layoutVertexArray, y3 = e2.segments.prepareSegment(4 * r3.length, d3, f3, this.canOverlap ? s3.sortKey : void 0), m3 = this.glyphOffsetArray.length, g3 = y3.vertexLength, x3 = this.allowVerticalPlacement && o3 === t2.ai.vertical ? Math.PI / 2 : 0, v3 = s3.text && s3.text.sections;
          for (let t3 = 0; t3 < r3.length; t3++) {
            const { tl: i4, tr: a4, bl: o4, br: u4, tex: c4, pixelOffsetTL: h4, pixelOffsetBR: m4, minFontScaleX: g4, minFontScaleY: b3, glyphOffset: w3, isSDF: _3, sectionIndex: A3 } = r3[t3], S3 = y3.vertexLength, k3 = w3[1];
            Tu(d3, l3.x, l3.y, i4.x, k3 + i4.y, c4.x, c4.y, n3, _3, h4.x, h4.y, g4, b3), Tu(d3, l3.x, l3.y, a4.x, k3 + a4.y, c4.x + c4.w, c4.y, n3, _3, m4.x, h4.y, g4, b3), Tu(d3, l3.x, l3.y, o4.x, k3 + o4.y, c4.x, c4.y + c4.h, n3, _3, h4.x, m4.y, g4, b3), Tu(d3, l3.x, l3.y, u4.x, k3 + u4.y, c4.x + c4.w, c4.y + c4.h, n3, _3, m4.x, m4.y, g4, b3), $u(e2.dynamicLayoutVertexArray, l3, x3), f3.emplaceBack(S3, S3 + 1, S3 + 2), f3.emplaceBack(S3 + 1, S3 + 2, S3 + 3), y3.vertexLength += 4, y3.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w3[0]), t3 !== r3.length - 1 && A3 === r3[t3 + 1].sectionIndex || e2.programConfigurations.populatePaintArrays(d3.length, s3, s3.index, {}, p3, v3 && v3[A3]);
          }
          e2.placedSymbolArray.emplaceBack(l3.x, l3.y, m3, this.glyphOffsetArray.length - m3, g3, u3, c3, l3.segment, n3 ? n3[0] : 0, n3 ? n3[1] : 0, i3[0], i3[1], o3, 0, false, 0, h3);
        }
        _addCollisionDebugVertex(t3, e2, r3, n3, i3, a3) {
          return e2.emplaceBack(0, 0), t3.emplaceBack(r3.x, r3.y, n3, i3, Math.round(a3.x), Math.round(a3.y));
        }
        addCollisionDebugVertices(t3, e2, r3, n3, i3, s3, o3) {
          const l3 = i3.segments.prepareSegment(4, i3.layoutVertexArray, i3.indexArray), u3 = l3.vertexLength, c3 = i3.layoutVertexArray, h3 = i3.collisionVertexArray, p3 = o3.anchorX, f3 = o3.anchorY;
          this._addCollisionDebugVertex(c3, h3, s3, p3, f3, new a2(t3, e2)), this._addCollisionDebugVertex(c3, h3, s3, p3, f3, new a2(r3, e2)), this._addCollisionDebugVertex(c3, h3, s3, p3, f3, new a2(r3, n3)), this._addCollisionDebugVertex(c3, h3, s3, p3, f3, new a2(t3, n3)), l3.vertexLength += 4;
          const d3 = i3.indexArray;
          d3.emplaceBack(u3, u3 + 1), d3.emplaceBack(u3 + 1, u3 + 2), d3.emplaceBack(u3 + 2, u3 + 3), d3.emplaceBack(u3 + 3, u3), l3.primitiveLength += 4;
        }
        addDebugCollisionBoxes(t3, e2, r3, n3) {
          for (let i3 = t3; i3 < e2; i3++) {
            const t4 = this.collisionBoxArray.get(i3);
            this.addCollisionDebugVertices(t4.x1, t4.y1, t4.x2, t4.y2, n3 ? this.textCollisionBox : this.iconCollisionBox, t4.anchorPoint, r3);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Ou(wa, Ml.members, Sa), this.iconCollisionBox = new Ou(wa, Ml.members, Sa);
          for (let t3 = 0; t3 < this.symbolInstances.length; t3++) {
            const e2 = this.symbolInstances.get(t3);
            this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
          }
        }
        _deserializeCollisionBoxesForSymbol(t3, e2, r3, n3, i3, a3, s3, o3, l3) {
          const u3 = {};
          for (let n4 = e2; n4 < r3; n4++) {
            const e3 = t3.get(n4);
            u3.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, anchorPointX: e3.anchorPointX, anchorPointY: e3.anchorPointY }, u3.textFeatureIndex = e3.featureIndex;
            break;
          }
          for (let e3 = n3; e3 < i3; e3++) {
            const r4 = t3.get(e3);
            u3.verticalTextBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, anchorPointX: r4.anchorPointX, anchorPointY: r4.anchorPointY }, u3.verticalTextFeatureIndex = r4.featureIndex;
            break;
          }
          for (let e3 = a3; e3 < s3; e3++) {
            const r4 = t3.get(e3);
            u3.iconBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, anchorPointX: r4.anchorPointX, anchorPointY: r4.anchorPointY }, u3.iconFeatureIndex = r4.featureIndex;
            break;
          }
          for (let e3 = o3; e3 < l3; e3++) {
            const r4 = t3.get(e3);
            u3.verticalIconBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, anchorPointX: r4.anchorPointX, anchorPointY: r4.anchorPointY }, u3.verticalIconFeatureIndex = r4.featureIndex;
            break;
          }
          return u3;
        }
        deserializeCollisionBoxes(t3) {
          this.collisionArrays = [];
          for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
            const r3 = this.symbolInstances.get(e2);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t3, r3.textBoxStartIndex, r3.textBoxEndIndex, r3.verticalTextBoxStartIndex, r3.verticalTextBoxEndIndex, r3.iconBoxStartIndex, r3.iconBoxEndIndex, r3.verticalIconBoxStartIndex, r3.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(t3, e2) {
          const r3 = t3.placedSymbolArray.get(e2), n3 = r3.vertexStartIndex + 4 * r3.numGlyphs;
          for (let e3 = r3.vertexStartIndex; e3 < n3; e3 += 4) t3.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t3.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
        }
        getSortedSymbolIndexes(t3) {
          if (this.sortedAngle === t3 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
          const e2 = Math.sin(t3), r3 = Math.cos(t3), n3 = [], i3 = [], a3 = [];
          for (let t4 = 0; t4 < this.symbolInstances.length; ++t4) {
            a3.push(t4);
            const s3 = this.symbolInstances.get(t4);
            n3.push(0 | Math.round(e2 * s3.anchorX + r3 * s3.anchorY)), i3.push(s3.featureIndex);
          }
          return a3.sort((t4, e3) => n3[t4] - n3[e3] || i3[e3] - i3[t4]), a3;
        }
        addToSortKeyRanges(t3, e2) {
          const r3 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          r3 && r3.sortKey === e2 ? r3.symbolInstanceEnd = t3 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t3, symbolInstanceEnd: t3 + 1 });
        }
        sortFeatures(t3) {
          if (this.sortFeaturesByY && this.sortedAngle !== t3 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t3), this.sortedAngle = t3, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const t4 of this.symbolInstanceIndexes) {
              const e2 = this.symbolInstances.get(t4);
              this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach((t5, e3, r3) => {
                t5 >= 0 && r3.indexOf(t5) === e3 && this.addIndicesForPlacedSymbol(this.text, t5);
              }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let Ru, qu;
      $n("SymbolBucket", Uu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Uu.MAX_GLYPHS = 65535, Uu.addDynamicAttributes = $u;
      var ju = { get paint() {
        return qu = qu || new _i({ "icon-opacity": new xi(X2.paint_symbol["icon-opacity"]), "icon-color": new xi(X2.paint_symbol["icon-color"]), "icon-halo-color": new xi(X2.paint_symbol["icon-halo-color"]), "icon-halo-width": new xi(X2.paint_symbol["icon-halo-width"]), "icon-halo-blur": new xi(X2.paint_symbol["icon-halo-blur"]), "icon-translate": new gi(X2.paint_symbol["icon-translate"]), "icon-translate-anchor": new gi(X2.paint_symbol["icon-translate-anchor"]), "text-opacity": new xi(X2.paint_symbol["text-opacity"]), "text-color": new xi(X2.paint_symbol["text-color"], { runtimeType: yt, getOverride: (t3) => t3.textColor, hasOverride: (t3) => !!t3.textColor }), "text-halo-color": new xi(X2.paint_symbol["text-halo-color"]), "text-halo-width": new xi(X2.paint_symbol["text-halo-width"]), "text-halo-blur": new xi(X2.paint_symbol["text-halo-blur"]), "text-translate": new gi(X2.paint_symbol["text-translate"]), "text-translate-anchor": new gi(X2.paint_symbol["text-translate-anchor"]) });
      }, get layout() {
        return Ru = Ru || new _i({ "symbol-placement": new gi(X2.layout_symbol["symbol-placement"]), "symbol-spacing": new gi(X2.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new gi(X2.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new xi(X2.layout_symbol["symbol-sort-key"]), "symbol-z-order": new gi(X2.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new gi(X2.layout_symbol["icon-allow-overlap"]), "icon-overlap": new gi(X2.layout_symbol["icon-overlap"]), "icon-ignore-placement": new gi(X2.layout_symbol["icon-ignore-placement"]), "icon-optional": new gi(X2.layout_symbol["icon-optional"]), "icon-rotation-alignment": new gi(X2.layout_symbol["icon-rotation-alignment"]), "icon-size": new xi(X2.layout_symbol["icon-size"]), "icon-text-fit": new gi(X2.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new gi(X2.layout_symbol["icon-text-fit-padding"]), "icon-image": new xi(X2.layout_symbol["icon-image"]), "icon-rotate": new xi(X2.layout_symbol["icon-rotate"]), "icon-padding": new xi(X2.layout_symbol["icon-padding"]), "icon-keep-upright": new gi(X2.layout_symbol["icon-keep-upright"]), "icon-offset": new xi(X2.layout_symbol["icon-offset"]), "icon-anchor": new xi(X2.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new gi(X2.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new gi(X2.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new gi(X2.layout_symbol["text-rotation-alignment"]), "text-field": new xi(X2.layout_symbol["text-field"]), "text-font": new xi(X2.layout_symbol["text-font"]), "text-size": new xi(X2.layout_symbol["text-size"]), "text-max-width": new xi(X2.layout_symbol["text-max-width"]), "text-line-height": new gi(X2.layout_symbol["text-line-height"]), "text-letter-spacing": new xi(X2.layout_symbol["text-letter-spacing"]), "text-justify": new xi(X2.layout_symbol["text-justify"]), "text-radial-offset": new xi(X2.layout_symbol["text-radial-offset"]), "text-variable-anchor": new gi(X2.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new xi(X2.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new xi(X2.layout_symbol["text-anchor"]), "text-max-angle": new gi(X2.layout_symbol["text-max-angle"]), "text-writing-mode": new gi(X2.layout_symbol["text-writing-mode"]), "text-rotate": new xi(X2.layout_symbol["text-rotate"]), "text-padding": new gi(X2.layout_symbol["text-padding"]), "text-keep-upright": new gi(X2.layout_symbol["text-keep-upright"]), "text-transform": new xi(X2.layout_symbol["text-transform"]), "text-offset": new xi(X2.layout_symbol["text-offset"]), "text-allow-overlap": new gi(X2.layout_symbol["text-allow-overlap"]), "text-overlap": new gi(X2.layout_symbol["text-overlap"]), "text-ignore-placement": new gi(X2.layout_symbol["text-ignore-placement"]), "text-optional": new gi(X2.layout_symbol["text-optional"]) });
      } };
      class Nu {
        constructor(t3) {
          if (void 0 === t3.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = t3.property.overrides ? t3.property.overrides.runtimeType : ht, this.defaultValue = t3;
        }
        evaluate(t3) {
          if (t3.formattedSection) {
            const e2 = this.defaultValue.property.overrides;
            if (e2 && e2.hasOverride(t3.formattedSection)) return e2.getOverride(t3.formattedSection);
          }
          return t3.feature && t3.featureState ? this.defaultValue.evaluate(t3.feature, t3.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t3) {
          this.defaultValue.isConstant() || t3(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return null;
        }
      }
      $n("FormatSectionOverride", Nu, { omit: ["defaultValue"] });
      class Zu extends Si {
        constructor(t3) {
          super(t3, ju);
        }
        recalculate(t3, e2) {
          if (super.recalculate(t3, e2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
            const t4 = this.layout.get("text-writing-mode");
            if (t4) {
              const e3 = [];
              for (const r3 of t4) e3.indexOf(r3) < 0 && e3.push(r3);
              this.layout._values["text-writing-mode"] = e3;
            } else this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t3, e2, r3, n3) {
          const i3 = this.layout.get(t3).evaluate(e2, {}, r3, n3), a3 = this._unevaluatedLayout._values[t3];
          return a3.isDataDriven() || Tr(a3.value) || !i3 ? i3 : function(t4, e3) {
            return e3.replace(/{([^{}]+)}/g, (e4, r4) => t4 && r4 in t4 ? String(t4[r4]) : "");
          }(e2.properties, i3);
        }
        createBucket(t3) {
          return new Uu(t3);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const t3 of ju.paint.overridableProperties) {
            if (!Zu.hasPaintOverride(this.layout, t3)) continue;
            const e2 = this.paint.get(t3), r3 = new Nu(e2), n3 = new Fr(r3, e2.property.specification);
            let i3 = null;
            i3 = "constant" === e2.value.kind || "source" === e2.value.kind ? new Lr("source", n3) : new Dr("composite", n3, e2.value.zoomStops), this.paint._values[t3] = new yi(e2.property, i3, e2.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(t3, e2, r3) {
          return !(!this.layout || e2.isDataDriven() || r3.isDataDriven()) && Zu.hasPaintOverride(this.layout, t3);
        }
        static hasPaintOverride(t3, e2) {
          const r3 = t3.get("text-field"), n3 = ju.paint.properties[e2];
          let i3 = false;
          const a3 = (t4) => {
            for (const e3 of t4) if (n3.overrides && n3.overrides.hasOverride(e3)) return void (i3 = true);
          };
          if ("constant" === r3.value.kind && r3.value.value instanceof Qt) a3(r3.value.value.sections);
          else if ("source" === r3.value.kind) {
            const t4 = (e4) => {
              i3 || (e4 instanceof le2 && se2(e4.value) === vt ? a3(e4.value.sections) : e4 instanceof pr ? a3(e4.sections) : e4.eachChild(t4));
            }, e3 = r3.value;
            e3._styleExpression && t4(e3._styleExpression.expression);
          }
          return i3;
        }
      }
      let Ku;
      var Gu = { get paint() {
        return Ku = Ku || new _i({ "background-color": new gi(X2.paint_background["background-color"]), "background-pattern": new bi(X2.paint_background["background-pattern"]), "background-opacity": new gi(X2.paint_background["background-opacity"]) });
      } };
      class Ju extends Si {
        constructor(t3) {
          super(t3, Gu);
        }
      }
      let Xu;
      var Yu = { get paint() {
        return Xu = Xu || new _i({ "raster-opacity": new gi(X2.paint_raster["raster-opacity"]), "raster-hue-rotate": new gi(X2.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new gi(X2.paint_raster["raster-brightness-min"]), "raster-brightness-max": new gi(X2.paint_raster["raster-brightness-max"]), "raster-saturation": new gi(X2.paint_raster["raster-saturation"]), "raster-contrast": new gi(X2.paint_raster["raster-contrast"]), "raster-resampling": new gi(X2.paint_raster["raster-resampling"]), "raster-fade-duration": new gi(X2.paint_raster["raster-fade-duration"]) });
      } };
      class Hu extends Si {
        constructor(t3) {
          super(t3, Yu);
        }
      }
      class Wu extends Si {
        constructor(t3) {
          super(t3, {}), this.onAdd = (t4) => {
            this.implementation.onAdd && this.implementation.onAdd(t4, t4.painter.context.gl);
          }, this.onRemove = (t4) => {
            this.implementation.onRemove && this.implementation.onRemove(t4, t4.painter.context.gl);
          }, this.implementation = t3;
        }
        is3D() {
          return "3d" === this.implementation.renderingMode;
        }
        hasOffscreenPass() {
          return void 0 !== this.implementation.prerender;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return false;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }
      class Qu {
        constructor(t3) {
          this._callback = t3, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = false, this._callback();
          });
        }
        trigger() {
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
            this._triggered = false, this._callback();
          }, 0));
        }
        remove() {
          delete this._channel, this._callback = () => {
          };
        }
      }
      const tc = 63710088e-1;
      class ec {
        constructor(t3, e2) {
          if (isNaN(t3) || isNaN(e2)) throw new Error(`Invalid LngLat object: (${t3}, ${e2})`);
          if (this.lng = +t3, this.lat = +e2, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new ec(m2(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t3) {
          const e2 = Math.PI / 180, r3 = this.lat * e2, n3 = t3.lat * e2, i3 = Math.sin(r3) * Math.sin(n3) + Math.cos(r3) * Math.cos(n3) * Math.cos((t3.lng - this.lng) * e2);
          return tc * Math.acos(Math.min(i3, 1));
        }
        static convert(t3) {
          if (t3 instanceof ec) return t3;
          if (Array.isArray(t3) && (2 === t3.length || 3 === t3.length)) return new ec(Number(t3[0]), Number(t3[1]));
          if (!Array.isArray(t3) && "object" == typeof t3 && null !== t3) return new ec(Number("lng" in t3 ? t3.lng : t3.lon), Number(t3.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const rc = 2 * Math.PI * tc;
      function nc(t3) {
        return rc * Math.cos(t3 * Math.PI / 180);
      }
      function ic(t3) {
        return (180 + t3) / 360;
      }
      function ac(t3) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3 * Math.PI / 360))) / 360;
      }
      function sc(t3, e2) {
        return t3 / nc(e2);
      }
      function oc(t3) {
        return 360 * t3 - 180;
      }
      function lc(t3) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t3) * Math.PI / 180)) - 90;
      }
      class uc {
        constructor(t3, e2, r3 = 0) {
          this.x = +t3, this.y = +e2, this.z = +r3;
        }
        static fromLngLat(t3, e2 = 0) {
          const r3 = ec.convert(t3);
          return new uc(ic(r3.lng), ac(r3.lat), sc(e2, r3.lat));
        }
        toLngLat() {
          return new ec(oc(this.x), lc(this.y));
        }
        toAltitude() {
          return this.z * nc(lc(this.y));
        }
        meterInMercatorCoordinateUnits() {
          return 1 / rc * (t3 = lc(this.y), 1 / Math.cos(t3 * Math.PI / 180));
          var t3;
        }
      }
      function cc(t3, e2, r3) {
        var n3 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r3);
        return [t3 * n3 - 2 * Math.PI * 6378137 / 2, e2 * n3 - 2 * Math.PI * 6378137 / 2];
      }
      class hc {
        constructor(t3, e2, r3) {
          if (t3 < 0 || t3 > 25 || r3 < 0 || r3 >= Math.pow(2, t3) || e2 < 0 || e2 >= Math.pow(2, t3)) throw new Error(`x=${e2}, y=${r3}, z=${t3} outside of bounds. 0<=x<${Math.pow(2, t3)}, 0<=y<${Math.pow(2, t3)} 0<=z<=25 `);
          this.z = t3, this.x = e2, this.y = r3, this.key = dc(0, t3, t3, e2, r3);
        }
        equals(t3) {
          return this.z === t3.z && this.x === t3.x && this.y === t3.y;
        }
        url(t3, e2, r3) {
          const n3 = (a3 = this.y, s3 = this.z, o3 = cc(256 * (i3 = this.x), 256 * (a3 = Math.pow(2, s3) - a3 - 1), s3), l3 = cc(256 * (i3 + 1), 256 * (a3 + 1), s3), o3[0] + "," + o3[1] + "," + l3[0] + "," + l3[1]);
          var i3, a3, s3, o3, l3;
          const u3 = function(t4, e3, r4) {
            let n4, i4 = "";
            for (let a4 = t4; a4 > 0; a4--) n4 = 1 << a4 - 1, i4 += (e3 & n4 ? 1 : 0) + (r4 & n4 ? 2 : 0);
            return i4;
          }(this.z, this.x, this.y);
          return t3[(this.x + this.y) % t3.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r3 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e2 > 1 ? "@2x" : "").replace(/{quadkey}/g, u3).replace(/{bbox-epsg-3857}/g, n3);
        }
        isChildOf(t3) {
          const e2 = this.z - t3.z;
          return e2 > 0 && t3.x === this.x >> e2 && t3.y === this.y >> e2;
        }
        getTilePoint(t3) {
          const e2 = Math.pow(2, this.z);
          return new a2((t3.x * e2 - this.x) * rs, (t3.y * e2 - this.y) * rs);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class pc {
        constructor(t3, e2) {
          this.wrap = t3, this.canonical = e2, this.key = dc(t3, e2.z, e2.z, e2.x, e2.y);
        }
      }
      class fc {
        constructor(t3, e2, r3, n3, i3) {
          if (t3 < r3) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t3}; z = ${r3}`);
          this.overscaledZ = t3, this.wrap = e2, this.canonical = new hc(r3, +n3, +i3), this.key = dc(e2, t3, r3, n3, i3);
        }
        clone() {
          return new fc(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(t3) {
          return this.overscaledZ === t3.overscaledZ && this.wrap === t3.wrap && this.canonical.equals(t3.canonical);
        }
        scaledTo(t3) {
          if (t3 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t3}; overscaledZ = ${this.overscaledZ}`);
          const e2 = this.canonical.z - t3;
          return t3 > this.canonical.z ? new fc(t3, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new fc(t3, this.wrap, t3, this.canonical.x >> e2, this.canonical.y >> e2);
        }
        calculateScaledKey(t3, e2) {
          if (t3 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t3}; overscaledZ = ${this.overscaledZ}`);
          const r3 = this.canonical.z - t3;
          return t3 > this.canonical.z ? dc(this.wrap * +e2, t3, this.canonical.z, this.canonical.x, this.canonical.y) : dc(this.wrap * +e2, t3, t3, this.canonical.x >> r3, this.canonical.y >> r3);
        }
        isChildOf(t3) {
          if (t3.wrap !== this.wrap) return false;
          const e2 = this.canonical.z - t3.canonical.z;
          return 0 === t3.overscaledZ || t3.overscaledZ < this.overscaledZ && t3.canonical.x === this.canonical.x >> e2 && t3.canonical.y === this.canonical.y >> e2;
        }
        children(t3) {
          if (this.overscaledZ >= t3) return [new fc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const e2 = this.canonical.z + 1, r3 = 2 * this.canonical.x, n3 = 2 * this.canonical.y;
          return [new fc(e2, this.wrap, e2, r3, n3), new fc(e2, this.wrap, e2, r3 + 1, n3), new fc(e2, this.wrap, e2, r3, n3 + 1), new fc(e2, this.wrap, e2, r3 + 1, n3 + 1)];
        }
        isLessThan(t3) {
          return this.wrap < t3.wrap || !(this.wrap > t3.wrap) && (this.overscaledZ < t3.overscaledZ || !(this.overscaledZ > t3.overscaledZ) && (this.canonical.x < t3.canonical.x || !(this.canonical.x > t3.canonical.x) && this.canonical.y < t3.canonical.y));
        }
        wrapped() {
          return new fc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t3) {
          return new fc(this.overscaledZ, t3, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new pc(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(t3) {
          return this.canonical.getTilePoint(new uc(t3.x - this.wrap, t3.y));
        }
      }
      function dc(t3, e2, r3, n3, i3) {
        (t3 *= 2) < 0 && (t3 = -1 * t3 - 1);
        const a3 = 1 << r3;
        return (a3 * a3 * t3 + a3 * i3 + n3).toString(36) + r3.toString(36) + e2.toString(36);
      }
      $n("CanonicalTileID", hc), $n("OverscaledTileID", fc, { omit: ["posMatrix"] });
      class yc {
        constructor(t3, e2, r3, n3 = 1, i3 = 1, a3 = 1, s3 = 0) {
          if (this.uid = t3, e2.height !== e2.width) throw new RangeError("DEM tiles must be square");
          if (r3 && !["mapbox", "terrarium", "custom"].includes(r3)) return void A2(`"${r3}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = e2.height;
          const o3 = this.dim = e2.height - 2;
          switch (this.data = new Uint32Array(e2.data.buffer), r3) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = n3, this.greenFactor = i3, this.blueFactor = a3, this.baseShift = s3;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let t4 = 0; t4 < o3; t4++) this.data[this._idx(-1, t4)] = this.data[this._idx(0, t4)], this.data[this._idx(o3, t4)] = this.data[this._idx(o3 - 1, t4)], this.data[this._idx(t4, -1)] = this.data[this._idx(t4, 0)], this.data[this._idx(t4, o3)] = this.data[this._idx(t4, o3 - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o3, -1)] = this.data[this._idx(o3 - 1, 0)], this.data[this._idx(-1, o3)] = this.data[this._idx(0, o3 - 1)], this.data[this._idx(o3, o3)] = this.data[this._idx(o3 - 1, o3 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let t4 = 0; t4 < o3; t4++) for (let e3 = 0; e3 < o3; e3++) {
            const r4 = this.get(t4, e3);
            r4 > this.max && (this.max = r4), r4 < this.min && (this.min = r4);
          }
        }
        get(t3, e2) {
          const r3 = new Uint8Array(this.data.buffer), n3 = 4 * this._idx(t3, e2);
          return this.unpack(r3[n3], r3[n3 + 1], r3[n3 + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(t3, e2) {
          if (t3 < -1 || t3 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
          return (e2 + 1) * this.stride + (t3 + 1);
        }
        unpack(t3, e2, r3) {
          return t3 * this.redFactor + e2 * this.greenFactor + r3 * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new qs({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(t3, e2, r3) {
          if (this.dim !== t3.dim) throw new Error("dem dimension mismatch");
          let n3 = e2 * this.dim, i3 = e2 * this.dim + this.dim, a3 = r3 * this.dim, s3 = r3 * this.dim + this.dim;
          switch (e2) {
            case -1:
              n3 = i3 - 1;
              break;
            case 1:
              i3 = n3 + 1;
          }
          switch (r3) {
            case -1:
              a3 = s3 - 1;
              break;
            case 1:
              s3 = a3 + 1;
          }
          const o3 = -e2 * this.dim, l3 = -r3 * this.dim;
          for (let e3 = a3; e3 < s3; e3++) for (let r4 = n3; r4 < i3; r4++) this.data[this._idx(r4, e3)] = t3.data[this._idx(r4 + o3, e3 + l3)];
        }
      }
      $n("DEMData", yc);
      class mc {
        constructor(t3) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let e2 = 0; e2 < t3.length; e2++) {
            const r3 = t3[e2];
            this._stringToNumber[r3] = e2, this._numberToString[e2] = r3;
          }
        }
        encode(t3) {
          return this._stringToNumber[t3];
        }
        decode(t3) {
          if (t3 >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t3} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[t3];
        }
      }
      class gc {
        constructor(t3, e2, r3, n3, i3) {
          this.type = "Feature", this._vectorTileFeature = t3, t3._z = e2, t3._x = r3, t3._y = n3, this.properties = t3.properties, this.id = i3;
        }
        get geometry() {
          return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(t3) {
          this._geometry = t3;
        }
        toJSON() {
          const t3 = { geometry: this.geometry };
          for (const e2 in this) "_geometry" !== e2 && "_vectorTileFeature" !== e2 && (t3[e2] = this[e2]);
          return t3;
        }
      }
      class xc {
        constructor(t3, e2) {
          this.tileID = t3, this.x = t3.canonical.x, this.y = t3.canonical.y, this.z = t3.canonical.z, this.grid = new Fn(rs, 16, 0), this.grid3D = new Fn(rs, 16, 0), this.featureIndexArray = new ca(), this.promoteId = e2;
        }
        insert(t3, e2, r3, n3, i3, a3) {
          const s3 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(r3, n3, i3);
          const o3 = a3 ? this.grid3D : this.grid;
          for (let t4 = 0; t4 < e2.length; t4++) {
            const r4 = e2[t4], n4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let t5 = 0; t5 < r4.length; t5++) {
              const e3 = r4[t5];
              n4[0] = Math.min(n4[0], e3.x), n4[1] = Math.min(n4[1], e3.y), n4[2] = Math.max(n4[2], e3.x), n4[3] = Math.max(n4[3], e3.y);
            }
            n4[0] < rs && n4[1] < rs && n4[2] >= 0 && n4[3] >= 0 && o3.insert(s3, n4[0], n4[1], n4[2], n4[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new Ro.VectorTile(new eu(this.rawTileData)).layers, this.sourceLayerCoder = new mc(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(t3, e2, r3, n3) {
          this.loadVTLayers();
          const i3 = t3.params || {}, s3 = rs / t3.tileSize / t3.scale, o3 = Nr(i3.filter), l3 = t3.queryGeometry, u3 = t3.queryPadding * s3, c3 = bc(l3), h3 = this.grid.query(c3.minX - u3, c3.minY - u3, c3.maxX + u3, c3.maxY + u3), p3 = bc(t3.cameraQueryGeometry), f3 = this.grid3D.query(p3.minX - u3, p3.minY - u3, p3.maxX + u3, p3.maxY + u3, (e3, r4, n4, i4) => function(t4, e4, r5, n5, i5) {
            for (const a3 of t4) if (e4 <= a3.x && r5 <= a3.y && n5 >= a3.x && i5 >= a3.y) return true;
            const s4 = [new a2(e4, r5), new a2(e4, i5), new a2(n5, i5), new a2(n5, r5)];
            if (t4.length > 2) {
              for (const e5 of s4) if (xs(t4, e5)) return true;
            }
            for (let e5 = 0; e5 < t4.length - 1; e5++) if (vs(t4[e5], t4[e5 + 1], s4)) return true;
            return false;
          }(t3.cameraQueryGeometry, e3 - u3, r4 - u3, n4 + u3, i4 + u3));
          for (const t4 of f3) h3.push(t4);
          h3.sort(wc);
          const d3 = {};
          let y3;
          for (let a3 = 0; a3 < h3.length; a3++) {
            const u4 = h3[a3];
            if (u4 === y3) continue;
            y3 = u4;
            const c4 = this.featureIndexArray.get(u4);
            let p4 = null;
            this.loadMatchingFeature(d3, c4.bucketIndex, c4.sourceLayerIndex, c4.featureIndex, o3, i3.layers, i3.availableImages, e2, r3, n3, (e3, r4, n4) => (p4 || (p4 = as(e3)), r4.queryIntersectsFeature(l3, e3, n4, p4, this.z, t3.transform, s3, t3.pixelPosMatrix)));
          }
          return d3;
        }
        loadMatchingFeature(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3) {
          const h3 = this.bucketLayerIDs[e2];
          if (a3 && !function(t4, e3) {
            for (let r4 = 0; r4 < t4.length; r4++) if (e3.indexOf(t4[r4]) >= 0) return true;
            return false;
          }(a3, h3)) return;
          const p3 = this.sourceLayerCoder.decode(r3), f3 = this.vtLayers[p3].feature(n3);
          if (i3.needGeometry) {
            const t4 = ss2(f3, true);
            if (!i3.filter(new li(this.tileID.overscaledZ), t4, this.tileID.canonical)) return;
          } else if (!i3.filter(new li(this.tileID.overscaledZ), f3)) return;
          const d3 = this.getId(f3, p3);
          for (let e3 = 0; e3 < h3.length; e3++) {
            const r4 = h3[e3];
            if (a3 && a3.indexOf(r4) < 0) continue;
            const i4 = o3[r4];
            if (!i4) continue;
            let p4 = {};
            d3 && u3 && (p4 = u3.getState(i4.sourceLayer || "_geojsonTileLayer", d3));
            const y3 = g2({}, l3[r4]);
            y3.paint = vc(y3.paint, i4.paint, f3, p4, s3), y3.layout = vc(y3.layout, i4.layout, f3, p4, s3);
            const m3 = !c3 || c3(f3, i4, p4);
            if (!m3) continue;
            const x3 = new gc(f3, this.z, this.x, this.y, d3);
            x3.layer = y3;
            let v3 = t3[r4];
            void 0 === v3 && (v3 = t3[r4] = []), v3.push({ featureIndex: n3, feature: x3, intersectionZ: m3 });
          }
        }
        lookupSymbolFeatures(t3, e2, r3, n3, i3, a3, s3, o3) {
          const l3 = {};
          this.loadVTLayers();
          const u3 = Nr(i3);
          for (const i4 of t3) this.loadMatchingFeature(l3, r3, n3, i4, u3, a3, s3, o3, e2);
          return l3;
        }
        hasLayer(t3) {
          for (const e2 of this.bucketLayerIDs) for (const r3 of e2) if (t3 === r3) return true;
          return false;
        }
        getId(t3, e2) {
          let r3 = t3.id;
          return this.promoteId && (r3 = t3.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2]], "boolean" == typeof r3 && (r3 = Number(r3))), r3;
        }
      }
      function vc(t3, e2, r3, n3, i3) {
        return v2(t3, (t4, a3) => {
          const s3 = e2 instanceof mi ? e2.get(a3) : null;
          return s3 && s3.evaluate ? s3.evaluate(r3, n3, i3) : s3;
        });
      }
      function bc(t3) {
        let e2 = 1 / 0, r3 = 1 / 0, n3 = -1 / 0, i3 = -1 / 0;
        for (const a3 of t3) e2 = Math.min(e2, a3.x), r3 = Math.min(r3, a3.y), n3 = Math.max(n3, a3.x), i3 = Math.max(i3, a3.y);
        return { minX: e2, minY: r3, maxX: n3, maxY: i3 };
      }
      function wc(t3, e2) {
        return e2 - t3;
      }
      function _c(t3, e2, r3, n3, i3) {
        const s3 = [];
        for (let o3 = 0; o3 < t3.length; o3++) {
          const l3 = t3[o3];
          let u3;
          for (let t4 = 0; t4 < l3.length - 1; t4++) {
            let o4 = l3[t4], c3 = l3[t4 + 1];
            o4.x < e2 && c3.x < e2 || (o4.x < e2 ? o4 = new a2(e2, o4.y + (e2 - o4.x) / (c3.x - o4.x) * (c3.y - o4.y))._round() : c3.x < e2 && (c3 = new a2(e2, o4.y + (e2 - o4.x) / (c3.x - o4.x) * (c3.y - o4.y))._round()), o4.y < r3 && c3.y < r3 || (o4.y < r3 ? o4 = new a2(o4.x + (r3 - o4.y) / (c3.y - o4.y) * (c3.x - o4.x), r3)._round() : c3.y < r3 && (c3 = new a2(o4.x + (r3 - o4.y) / (c3.y - o4.y) * (c3.x - o4.x), r3)._round()), o4.x >= n3 && c3.x >= n3 || (o4.x >= n3 ? o4 = new a2(n3, o4.y + (n3 - o4.x) / (c3.x - o4.x) * (c3.y - o4.y))._round() : c3.x >= n3 && (c3 = new a2(n3, o4.y + (n3 - o4.x) / (c3.x - o4.x) * (c3.y - o4.y))._round()), o4.y >= i3 && c3.y >= i3 || (o4.y >= i3 ? o4 = new a2(o4.x + (i3 - o4.y) / (c3.y - o4.y) * (c3.x - o4.x), i3)._round() : c3.y >= i3 && (c3 = new a2(o4.x + (i3 - o4.y) / (c3.y - o4.y) * (c3.x - o4.x), i3)._round()), u3 && o4.equals(u3[u3.length - 1]) || (u3 = [o4], s3.push(u3)), u3.push(c3)))));
          }
        }
        return s3;
      }
      $n("FeatureIndex", xc, { omit: ["rawTileData", "sourceLayerCoder"] });
      class Ac extends a2 {
        constructor(t3, e2, r3, n3) {
          super(t3, e2), this.angle = r3, void 0 !== n3 && (this.segment = n3);
        }
        clone() {
          return new Ac(this.x, this.y, this.angle, this.segment);
        }
      }
      function Sc(t3, e2, r3, n3, i3) {
        if (void 0 === e2.segment || 0 === r3) return true;
        let a3 = e2, s3 = e2.segment + 1, o3 = 0;
        for (; o3 > -r3 / 2; ) {
          if (s3--, s3 < 0) return false;
          o3 -= t3[s3].dist(a3), a3 = t3[s3];
        }
        o3 += t3[s3].dist(t3[s3 + 1]), s3++;
        const l3 = [];
        let u3 = 0;
        for (; o3 < r3 / 2; ) {
          const e3 = t3[s3], r4 = t3[s3 + 1];
          if (!r4) return false;
          let a4 = t3[s3 - 1].angleTo(e3) - e3.angleTo(r4);
          for (a4 = Math.abs((a4 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l3.push({ distance: o3, angleDelta: a4 }), u3 += a4; o3 - l3[0].distance > n3; ) u3 -= l3.shift().angleDelta;
          if (u3 > i3) return false;
          s3++, o3 += e3.dist(r4);
        }
        return true;
      }
      function kc(t3) {
        let e2 = 0;
        for (let r3 = 0; r3 < t3.length - 1; r3++) e2 += t3[r3].dist(t3[r3 + 1]);
        return e2;
      }
      function Ic(t3, e2, r3) {
        return t3 ? 0.6 * e2 * r3 : 0;
      }
      function zc(t3, e2) {
        return Math.max(t3 ? t3.right - t3.left : 0, e2 ? e2.right - e2.left : 0);
      }
      function Mc(t3, e2, r3, n3, i3, a3) {
        const s3 = Ic(r3, i3, a3), o3 = zc(r3, n3) * a3;
        let l3 = 0;
        const u3 = kc(t3) / 2;
        for (let r4 = 0; r4 < t3.length - 1; r4++) {
          const n4 = t3[r4], i4 = t3[r4 + 1], a4 = n4.dist(i4);
          if (l3 + a4 > u3) {
            const c3 = (u3 - l3) / a4, h3 = Ze2.number(n4.x, i4.x, c3), p3 = Ze2.number(n4.y, i4.y, c3), f3 = new Ac(h3, p3, i4.angleTo(n4), r4);
            return f3._round(), !s3 || Sc(t3, f3, o3, s3, e2) ? f3 : void 0;
          }
          l3 += a4;
        }
      }
      function Cc(t3, e2, r3, n3, i3, a3, s3, o3, l3) {
        const u3 = Ic(n3, a3, s3), c3 = zc(n3, i3), h3 = c3 * s3, p3 = 0 === t3[0].x || t3[0].x === l3 || 0 === t3[0].y || t3[0].y === l3;
        return e2 - h3 < e2 / 4 && (e2 = h3 + e2 / 4), Bc(t3, p3 ? e2 / 2 * o3 % e2 : (c3 / 2 + 2 * a3) * s3 * o3 % e2, e2, u3, r3, h3, p3, false, l3);
      }
      function Bc(t3, e2, r3, n3, i3, a3, s3, o3, l3) {
        const u3 = a3 / 2, c3 = kc(t3);
        let h3 = 0, p3 = e2 - r3, f3 = [];
        for (let e3 = 0; e3 < t3.length - 1; e3++) {
          const s4 = t3[e3], o4 = t3[e3 + 1], d3 = s4.dist(o4), y3 = o4.angleTo(s4);
          for (; p3 + r3 < h3 + d3; ) {
            p3 += r3;
            const m3 = (p3 - h3) / d3, g3 = Ze2.number(s4.x, o4.x, m3), x3 = Ze2.number(s4.y, o4.y, m3);
            if (g3 >= 0 && g3 < l3 && x3 >= 0 && x3 < l3 && p3 - u3 >= 0 && p3 + u3 <= c3) {
              const r4 = new Ac(g3, x3, y3, e3);
              r4._round(), n3 && !Sc(t3, r4, a3, n3, i3) || f3.push(r4);
            }
          }
          h3 += d3;
        }
        return o3 || f3.length || s3 || (f3 = Bc(t3, h3 / 2, r3, n3, i3, a3, s3, true, l3)), f3;
      }
      $n("Anchor", Ac);
      const Pc = lu;
      function Vc(t3, e2, r3, n3) {
        const i3 = [], s3 = t3.image, o3 = s3.pixelRatio, l3 = s3.paddedRect.w - 2 * Pc, u3 = s3.paddedRect.h - 2 * Pc, c3 = t3.right - t3.left, h3 = t3.bottom - t3.top, p3 = s3.stretchX || [[0, l3]], f3 = s3.stretchY || [[0, u3]], d3 = (t4, e3) => t4 + e3[1] - e3[0], y3 = p3.reduce(d3, 0), m3 = f3.reduce(d3, 0), g3 = l3 - y3, x3 = u3 - m3;
        let v3 = 0, b3 = y3, w3 = 0, _3 = m3, A3 = 0, S3 = g3, k3 = 0, I3 = x3;
        if (s3.content && n3) {
          const t4 = s3.content;
          v3 = Ec(p3, 0, t4[0]), w3 = Ec(f3, 0, t4[1]), b3 = Ec(p3, t4[0], t4[2]), _3 = Ec(f3, t4[1], t4[3]), A3 = t4[0] - v3, k3 = t4[1] - w3, S3 = t4[2] - t4[0] - b3, I3 = t4[3] - t4[1] - _3;
        }
        const z3 = (n4, i4, l4, u4) => {
          const p4 = Tc(n4.stretch - v3, b3, c3, t3.left), f4 = $c(n4.fixed - A3, S3, n4.stretch, y3), d4 = Tc(i4.stretch - w3, _3, h3, t3.top), g4 = $c(i4.fixed - k3, I3, i4.stretch, m3), x4 = Tc(l4.stretch - v3, b3, c3, t3.left), z4 = $c(l4.fixed - A3, S3, l4.stretch, y3), M3 = Tc(u4.stretch - w3, _3, h3, t3.top), C3 = $c(u4.fixed - k3, I3, u4.stretch, m3), B3 = new a2(p4, d4), P3 = new a2(x4, d4), V3 = new a2(x4, M3), E3 = new a2(p4, M3), F3 = new a2(f4 / o3, g4 / o3), T3 = new a2(z4 / o3, C3 / o3), $3 = e2 * Math.PI / 180;
          if ($3) {
            const t4 = Math.sin($3), e3 = Math.cos($3), r4 = [e3, -t4, t4, e3];
            B3._matMult(r4), P3._matMult(r4), E3._matMult(r4), V3._matMult(r4);
          }
          const L3 = n4.stretch + n4.fixed, D3 = i4.stretch + i4.fixed;
          return { tl: B3, tr: P3, bl: E3, br: V3, tex: { x: s3.paddedRect.x + Pc + L3, y: s3.paddedRect.y + Pc + D3, w: l4.stretch + l4.fixed - L3, h: u4.stretch + u4.fixed - D3 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F3, pixelOffsetBR: T3, minFontScaleX: S3 / o3 / c3, minFontScaleY: I3 / o3 / h3, isSDF: r3 };
        };
        if (n3 && (s3.stretchX || s3.stretchY)) {
          const t4 = Fc(p3, g3, y3), e3 = Fc(f3, x3, m3);
          for (let r4 = 0; r4 < t4.length - 1; r4++) {
            const n4 = t4[r4], a3 = t4[r4 + 1];
            for (let t5 = 0; t5 < e3.length - 1; t5++) i3.push(z3(n4, e3[t5], a3, e3[t5 + 1]));
          }
        } else i3.push(z3({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l3 + 1 }, { fixed: 0, stretch: u3 + 1 }));
        return i3;
      }
      function Ec(t3, e2, r3) {
        let n3 = 0;
        for (const i3 of t3) n3 += Math.max(e2, Math.min(r3, i3[1])) - Math.max(e2, Math.min(r3, i3[0]));
        return n3;
      }
      function Fc(t3, e2, r3) {
        const n3 = [{ fixed: -Pc, stretch: 0 }];
        for (const [e3, r4] of t3) {
          const t4 = n3[n3.length - 1];
          n3.push({ fixed: e3 - t4.stretch, stretch: t4.stretch }), n3.push({ fixed: e3 - t4.stretch, stretch: t4.stretch + (r4 - e3) });
        }
        return n3.push({ fixed: e2 + Pc, stretch: r3 }), n3;
      }
      function Tc(t3, e2, r3, n3) {
        return t3 / e2 * r3 + n3;
      }
      function $c(t3, e2, r3, n3) {
        return t3 - e2 * r3 / n3;
      }
      class Lc {
        constructor(t3, e2, r3, n3, i3, s3, o3, l3, u3, c3) {
          if (this.boxStartIndex = t3.length, u3) {
            let t4 = s3.top, e3 = s3.bottom;
            const r4 = s3.collisionPadding;
            r4 && (t4 -= r4[1], e3 += r4[3]);
            let n4 = e3 - t4;
            n4 > 0 && (n4 = Math.max(10, n4), this.circleDiameter = n4);
          } else {
            let u4 = s3.top * o3 - l3[0], h3 = s3.bottom * o3 + l3[2], p3 = s3.left * o3 - l3[3], f3 = s3.right * o3 + l3[1];
            const d3 = s3.collisionPadding;
            if (d3 && (p3 -= d3[0] * o3, u4 -= d3[1] * o3, f3 += d3[2] * o3, h3 += d3[3] * o3), c3) {
              const t4 = new a2(p3, u4), e3 = new a2(f3, u4), r4 = new a2(p3, h3), n4 = new a2(f3, h3), i4 = c3 * Math.PI / 180;
              t4._rotate(i4), e3._rotate(i4), r4._rotate(i4), n4._rotate(i4), p3 = Math.min(t4.x, e3.x, r4.x, n4.x), f3 = Math.max(t4.x, e3.x, r4.x, n4.x), u4 = Math.min(t4.y, e3.y, r4.y, n4.y), h3 = Math.max(t4.y, e3.y, r4.y, n4.y);
            }
            t3.emplaceBack(e2.x, e2.y, p3, u4, f3, h3, r3, n3, i3);
          }
          this.boxEndIndex = t3.length;
        }
      }
      class Dc {
        constructor(t3 = [], e2 = Oc) {
          if (this.data = t3, this.length = this.data.length, this.compare = e2, this.length > 0) for (let t4 = (this.length >> 1) - 1; t4 >= 0; t4--) this._down(t4);
        }
        push(t3) {
          this.data.push(t3), this.length++, this._up(this.length - 1);
        }
        pop() {
          if (0 === this.length) return;
          const t3 = this.data[0], e2 = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t3;
        }
        peek() {
          return this.data[0];
        }
        _up(t3) {
          const { data: e2, compare: r3 } = this, n3 = e2[t3];
          for (; t3 > 0; ) {
            const i3 = t3 - 1 >> 1, a3 = e2[i3];
            if (r3(n3, a3) >= 0) break;
            e2[t3] = a3, t3 = i3;
          }
          e2[t3] = n3;
        }
        _down(t3) {
          const { data: e2, compare: r3 } = this, n3 = this.length >> 1, i3 = e2[t3];
          for (; t3 < n3; ) {
            let n4 = 1 + (t3 << 1), a3 = e2[n4];
            const s3 = n4 + 1;
            if (s3 < this.length && r3(e2[s3], a3) < 0 && (n4 = s3, a3 = e2[s3]), r3(a3, i3) >= 0) break;
            e2[t3] = a3, t3 = n4;
          }
          e2[t3] = i3;
        }
      }
      function Oc(t3, e2) {
        return t3 < e2 ? -1 : t3 > e2 ? 1 : 0;
      }
      function Uc(t3, e2 = 1, r3 = false) {
        let n3 = 1 / 0, i3 = 1 / 0, s3 = -1 / 0, o3 = -1 / 0;
        const l3 = t3[0];
        for (let t4 = 0; t4 < l3.length; t4++) {
          const e3 = l3[t4];
          (!t4 || e3.x < n3) && (n3 = e3.x), (!t4 || e3.y < i3) && (i3 = e3.y), (!t4 || e3.x > s3) && (s3 = e3.x), (!t4 || e3.y > o3) && (o3 = e3.y);
        }
        const u3 = Math.min(s3 - n3, o3 - i3);
        let c3 = u3 / 2;
        const h3 = new Dc([], Rc);
        if (0 === u3) return new a2(n3, i3);
        for (let e3 = n3; e3 < s3; e3 += u3) for (let r4 = i3; r4 < o3; r4 += u3) h3.push(new qc(e3 + c3, r4 + c3, c3, t3));
        let p3 = function(t4) {
          let e3 = 0, r4 = 0, n4 = 0;
          const i4 = t4[0];
          for (let t5 = 0, a3 = i4.length, s4 = a3 - 1; t5 < a3; s4 = t5++) {
            const a4 = i4[t5], o4 = i4[s4], l4 = a4.x * o4.y - o4.x * a4.y;
            r4 += (a4.x + o4.x) * l4, n4 += (a4.y + o4.y) * l4, e3 += 3 * l4;
          }
          return new qc(r4 / e3, n4 / e3, 0, t4);
        }(t3), f3 = h3.length;
        for (; h3.length; ) {
          const n4 = h3.pop();
          (n4.d > p3.d || !p3.d) && (p3 = n4, r3 && console.log("found best %d after %d probes", Math.round(1e4 * n4.d) / 1e4, f3)), n4.max - p3.d <= e2 || (c3 = n4.h / 2, h3.push(new qc(n4.p.x - c3, n4.p.y - c3, c3, t3)), h3.push(new qc(n4.p.x + c3, n4.p.y - c3, c3, t3)), h3.push(new qc(n4.p.x - c3, n4.p.y + c3, c3, t3)), h3.push(new qc(n4.p.x + c3, n4.p.y + c3, c3, t3)), f3 += 4);
        }
        return r3 && (console.log(`num probes: ${f3}`), console.log(`best distance: ${p3.d}`)), p3.p;
      }
      function Rc(t3, e2) {
        return e2.max - t3.max;
      }
      function qc(t3, e2, r3, n3) {
        this.p = new a2(t3, e2), this.h = r3, this.d = function(t4, e3) {
          let r4 = false, n4 = 1 / 0;
          for (let i3 = 0; i3 < e3.length; i3++) {
            const a3 = e3[i3];
            for (let e4 = 0, i4 = a3.length, s3 = i4 - 1; e4 < i4; s3 = e4++) {
              const i5 = a3[e4], o3 = a3[s3];
              i5.y > t4.y != o3.y > t4.y && t4.x < (o3.x - i5.x) * (t4.y - i5.y) / (o3.y - i5.y) + i5.x && (r4 = !r4), n4 = Math.min(n4, ms(t4, i5, o3));
            }
          }
          return (r4 ? 1 : -1) * Math.sqrt(n4);
        }(this.p, n3), this.max = this.d + this.h * Math.SQRT2;
      }
      var jc;
      t2.aq = void 0, (jc = t2.aq || (t2.aq = {}))[jc.center = 1] = "center", jc[jc.left = 2] = "left", jc[jc.right = 3] = "right", jc[jc.top = 4] = "top", jc[jc.bottom = 5] = "bottom", jc[jc["top-left"] = 6] = "top-left", jc[jc["top-right"] = 7] = "top-right", jc[jc["bottom-left"] = 8] = "bottom-left", jc[jc["bottom-right"] = 9] = "bottom-right";
      const Nc = 7, Zc = Number.POSITIVE_INFINITY;
      function Kc(t3, e2) {
        return e2[1] !== Zc ? function(t4, e3, r3) {
          let n3 = 0, i3 = 0;
          switch (e3 = Math.abs(e3), r3 = Math.abs(r3), t4) {
            case "top-right":
            case "top-left":
            case "top":
              i3 = r3 - Nc;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              i3 = -r3 + Nc;
          }
          switch (t4) {
            case "top-right":
            case "bottom-right":
            case "right":
              n3 = -e3;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              n3 = e3;
          }
          return [n3, i3];
        }(t3, e2[0], e2[1]) : function(t4, e3) {
          let r3 = 0, n3 = 0;
          e3 < 0 && (e3 = 0);
          const i3 = e3 / Math.SQRT2;
          switch (t4) {
            case "top-right":
            case "top-left":
              n3 = i3 - Nc;
              break;
            case "bottom-right":
            case "bottom-left":
              n3 = -i3 + Nc;
              break;
            case "bottom":
              n3 = -e3 + Nc;
              break;
            case "top":
              n3 = e3 - Nc;
          }
          switch (t4) {
            case "top-right":
            case "bottom-right":
              r3 = -i3;
              break;
            case "top-left":
            case "bottom-left":
              r3 = i3;
              break;
            case "left":
              r3 = e3;
              break;
            case "right":
              r3 = -e3;
          }
          return [r3, n3];
        }(t3, e2[0]);
      }
      function Gc(t3, e2, r3) {
        var n3;
        const i3 = t3.layout, a3 = null === (n3 = i3.get("text-variable-anchor-offset")) || void 0 === n3 ? void 0 : n3.evaluate(e2, {}, r3);
        if (a3) {
          const t4 = a3.values, e3 = [];
          for (let r4 = 0; r4 < t4.length; r4 += 2) {
            const n4 = e3[r4] = t4[r4], i4 = t4[r4 + 1].map((t5) => t5 * Vl);
            n4.startsWith("top") ? i4[1] -= Nc : n4.startsWith("bottom") && (i4[1] += Nc), e3[r4 + 1] = i4;
          }
          return new re2(e3);
        }
        const s3 = i3.get("text-variable-anchor");
        if (s3) {
          let n4;
          n4 = void 0 !== t3._unevaluatedLayout.getValue("text-radial-offset") ? [i3.get("text-radial-offset").evaluate(e2, {}, r3) * Vl, Zc] : i3.get("text-offset").evaluate(e2, {}, r3).map((t4) => t4 * Vl);
          const a4 = [];
          for (const t4 of s3) a4.push(t4, Kc(t4, n4));
          return new re2(a4);
        }
        return null;
      }
      function Jc(t3) {
        switch (t3) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function Xc(e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3) {
        let p3 = s3.textMaxSize.evaluate(r3, {});
        void 0 === p3 && (p3 = o3);
        const f3 = e2.layers[0].layout, d3 = f3.get("icon-offset").evaluate(r3, {}, h3), y3 = Hc(n3.horizontal), m3 = o3 / 24, g3 = e2.tilePixelRatio * m3, x3 = e2.tilePixelRatio * p3 / 24, v3 = e2.tilePixelRatio * l3, b3 = e2.tilePixelRatio * f3.get("symbol-spacing"), w3 = f3.get("text-padding") * e2.tilePixelRatio, _3 = function(t3, e3, r4, n4 = 1) {
          const i4 = t3.get("icon-padding").evaluate(e3, {}, r4), a4 = i4 && i4.values;
          return [a4[0] * n4, a4[1] * n4, a4[2] * n4, a4[3] * n4];
        }(f3, r3, h3, e2.tilePixelRatio), S3 = f3.get("text-max-angle") / 180 * Math.PI, k3 = "viewport" !== f3.get("text-rotation-alignment") && "point" !== f3.get("symbol-placement"), I3 = "map" === f3.get("icon-rotation-alignment") && "point" !== f3.get("symbol-placement"), z3 = f3.get("symbol-placement"), M3 = b3 / 2, C3 = f3.get("icon-text-fit");
        let B3;
        i3 && "none" !== C3 && (e2.allowVerticalPlacement && n3.vertical && (B3 = zu(i3, n3.vertical, C3, f3.get("icon-text-fit-padding"), d3, m3)), y3 && (i3 = zu(i3, y3, C3, f3.get("icon-text-fit-padding"), d3, m3)));
        const P3 = (l4, p4) => {
          p4.x < 0 || p4.x >= rs || p4.y < 0 || p4.y >= rs || function(e3, r4, n4, i4, a4, s4, o4, l5, u4, c4, h4, p5, f4, d4, y4, m4, g4, x4, v4, b4, w4, _4, S4, k4, I4) {
            const z4 = e3.addToLineVertexArray(r4, n4);
            let M4, C4, B4, P4, V3 = 0, E3 = 0, F3 = 0, T3 = 0, $3 = -1, L3 = -1;
            const D3 = {};
            let O3 = $a("");
            if (e3.allowVerticalPlacement && i4.vertical) {
              const t3 = l5.layout.get("text-rotate").evaluate(w4, {}, k4) + 90;
              B4 = new Lc(u4, r4, c4, h4, p5, i4.vertical, f4, d4, y4, t3), o4 && (P4 = new Lc(u4, r4, c4, h4, p5, o4, g4, x4, y4, t3));
            }
            if (a4) {
              const n5 = l5.layout.get("icon-rotate").evaluate(w4, {}), i5 = "none" !== l5.layout.get("icon-text-fit"), s5 = Vc(a4, n5, S4, i5), f5 = o4 ? Vc(o4, n5, S4, i5) : void 0;
              C4 = new Lc(u4, r4, c4, h4, p5, a4, g4, x4, false, n5), V3 = 4 * s5.length;
              const d5 = e3.iconSizeData;
              let y5 = null;
              "source" === d5.kind ? (y5 = [Cu * l5.layout.get("icon-size").evaluate(w4, {})], y5[0] > Bu && A2(`${e3.layerIds[0]}: Value for "icon-size" is >= ${Mu}. Reduce your "icon-size".`)) : "composite" === d5.kind && (y5 = [Cu * _4.compositeIconSizes[0].evaluate(w4, {}, k4), Cu * _4.compositeIconSizes[1].evaluate(w4, {}, k4)], (y5[0] > Bu || y5[1] > Bu) && A2(`${e3.layerIds[0]}: Value for "icon-size" is >= ${Mu}. Reduce your "icon-size".`)), e3.addSymbols(e3.icon, s5, y5, b4, v4, w4, t2.ai.none, r4, z4.lineStartIndex, z4.lineLength, -1, k4), $3 = e3.icon.placedSymbolArray.length - 1, f5 && (E3 = 4 * f5.length, e3.addSymbols(e3.icon, f5, y5, b4, v4, w4, t2.ai.vertical, r4, z4.lineStartIndex, z4.lineLength, -1, k4), L3 = e3.icon.placedSymbolArray.length - 1);
            }
            const U3 = Object.keys(i4.horizontal);
            for (const n5 of U3) {
              const a5 = i4.horizontal[n5];
              if (!M4) {
                O3 = $a(a5.text);
                const t3 = l5.layout.get("text-rotate").evaluate(w4, {}, k4);
                M4 = new Lc(u4, r4, c4, h4, p5, a5, f4, d4, y4, t3);
              }
              const o5 = 1 === a5.positionedLines.length;
              if (F3 += Yc(e3, r4, a5, s4, l5, y4, w4, m4, z4, i4.vertical ? t2.ai.horizontal : t2.ai.horizontalOnly, o5 ? U3 : [n5], D3, $3, _4, k4), o5) break;
            }
            i4.vertical && (T3 += Yc(e3, r4, i4.vertical, s4, l5, y4, w4, m4, z4, t2.ai.vertical, ["vertical"], D3, L3, _4, k4));
            const R3 = M4 ? M4.boxStartIndex : e3.collisionBoxArray.length, q3 = M4 ? M4.boxEndIndex : e3.collisionBoxArray.length, j3 = B4 ? B4.boxStartIndex : e3.collisionBoxArray.length, N3 = B4 ? B4.boxEndIndex : e3.collisionBoxArray.length, Z3 = C4 ? C4.boxStartIndex : e3.collisionBoxArray.length, K3 = C4 ? C4.boxEndIndex : e3.collisionBoxArray.length, G3 = P4 ? P4.boxStartIndex : e3.collisionBoxArray.length, J3 = P4 ? P4.boxEndIndex : e3.collisionBoxArray.length;
            let X3 = -1;
            const Y3 = (t3, e4) => t3 && t3.circleDiameter ? Math.max(t3.circleDiameter, e4) : e4;
            X3 = Y3(M4, X3), X3 = Y3(B4, X3), X3 = Y3(C4, X3), X3 = Y3(P4, X3);
            const H3 = X3 > -1 ? 1 : 0;
            H3 && (X3 *= I4 / Vl), e3.glyphOffsetArray.length >= Uu.MAX_GLYPHS && A2("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w4.sortKey && e3.addToSortKeyRanges(e3.symbolInstances.length, w4.sortKey);
            const W3 = Gc(l5, w4, k4), [Q3, tt2] = function(e4, r5) {
              const n5 = e4.length, i5 = null == r5 ? void 0 : r5.values;
              if ((null == i5 ? void 0 : i5.length) > 0) for (let r6 = 0; r6 < i5.length; r6 += 2) {
                const n6 = i5[r6 + 1];
                e4.emplaceBack(t2.aq[i5[r6]], n6[0], n6[1]);
              }
              return [n5, e4.length];
            }(e3.textAnchorOffsets, W3);
            e3.symbolInstances.emplaceBack(r4.x, r4.y, D3.right >= 0 ? D3.right : -1, D3.center >= 0 ? D3.center : -1, D3.left >= 0 ? D3.left : -1, D3.vertical || -1, $3, L3, O3, R3, q3, j3, N3, Z3, K3, G3, J3, c4, F3, T3, V3, E3, H3, 0, f4, X3, Q3, tt2);
          }(e2, p4, l4, n3, i3, a3, B3, e2.layers[0], e2.collisionBoxArray, r3.index, r3.sourceLayerIndex, e2.index, g3, [w3, w3, w3, w3], k3, u3, v3, _3, I3, d3, r3, s3, c3, h3, o3);
        };
        if ("line" === z3) for (const t3 of _c(r3.geometry, 0, 0, rs, rs)) {
          const r4 = Cc(t3, b3, S3, n3.vertical || y3, i3, 24, x3, e2.overscaling, rs);
          for (const n4 of r4) y3 && Wc(e2, y3.text, M3, n4) || P3(t3, n4);
        }
        else if ("line-center" === z3) {
          for (const t3 of r3.geometry) if (t3.length > 1) {
            const e3 = Mc(t3, S3, n3.vertical || y3, i3, 24, x3);
            e3 && P3(t3, e3);
          }
        } else if ("Polygon" === r3.type) for (const t3 of Co(r3.geometry, 0)) {
          const e3 = Uc(t3, 16);
          P3(t3[0], new Ac(e3.x, e3.y, 0));
        }
        else if ("LineString" === r3.type) for (const t3 of r3.geometry) P3(t3, new Ac(t3[0].x, t3[0].y, 0));
        else if ("Point" === r3.type) for (const t3 of r3.geometry) for (const e3 of t3) P3([e3], new Ac(e3.x, e3.y, 0));
      }
      function Yc(t3, e2, r3, n3, i3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3) {
        const m3 = function(t4, e3, r4, n4, i4, s4, o4, l4) {
          const u4 = n4.layout.get("text-rotate").evaluate(s4, {}) * Math.PI / 180, c4 = [];
          for (const t5 of e3.positionedLines) for (const n5 of t5.positionedGlyphs) {
            if (!n5.rect) continue;
            const s5 = n5.rect || {};
            let h4 = su + 1, p4 = true, f4 = 1, d4 = 0;
            const y4 = (i4 || l4) && n5.vertical, m4 = n5.metrics.advance * n5.scale / 2;
            if (l4 && e3.verticalizable && (d4 = t5.lineOffset / 2 - (n5.imageName ? -(Vl - n5.metrics.width * n5.scale) / 2 : (n5.scale - 1) * Vl)), n5.imageName) {
              const t6 = o4[n5.imageName];
              p4 = t6.sdf, f4 = t6.pixelRatio, h4 = lu / f4;
            }
            const g4 = i4 ? [n5.x + m4, n5.y] : [0, 0];
            let x4 = i4 ? [0, 0] : [n5.x + m4 + r4[0], n5.y + r4[1] - d4], v3 = [0, 0];
            y4 && (v3 = x4, x4 = [0, 0]);
            const b3 = n5.metrics.isDoubleResolution ? 2 : 1, w3 = (n5.metrics.left - h4) * n5.scale - m4 + x4[0], _3 = (-n5.metrics.top - h4) * n5.scale + x4[1], A3 = w3 + s5.w / b3 * n5.scale / f4, S3 = _3 + s5.h / b3 * n5.scale / f4, k3 = new a2(w3, _3), I3 = new a2(A3, _3), z3 = new a2(w3, S3), M3 = new a2(A3, S3);
            if (y4) {
              const t6 = new a2(-m4, m4 - pu), e4 = -Math.PI / 2, r5 = Vl / 2 - m4, i5 = new a2(5 - pu - r5, -(n5.imageName ? r5 : 0)), s6 = new a2(...v3);
              k3._rotateAround(e4, t6)._add(i5)._add(s6), I3._rotateAround(e4, t6)._add(i5)._add(s6), z3._rotateAround(e4, t6)._add(i5)._add(s6), M3._rotateAround(e4, t6)._add(i5)._add(s6);
            }
            if (u4) {
              const t6 = Math.sin(u4), e4 = Math.cos(u4), r5 = [e4, -t6, t6, e4];
              k3._matMult(r5), I3._matMult(r5), z3._matMult(r5), M3._matMult(r5);
            }
            const C3 = new a2(0, 0), B3 = new a2(0, 0);
            c4.push({ tl: k3, tr: I3, bl: z3, br: M3, tex: s5, writingMode: e3.writingMode, glyphOffset: g4, sectionIndex: n5.sectionIndex, isSDF: p4, pixelOffsetTL: C3, pixelOffsetBR: B3, minFontScaleX: 0, minFontScaleY: 0 });
          }
          return c4;
        }(0, r3, l3, i3, s3, o3, n3, t3.allowVerticalPlacement), g3 = t3.textSizeData;
        let x3 = null;
        "source" === g3.kind ? (x3 = [Cu * i3.layout.get("text-size").evaluate(o3, {})], x3[0] > Bu && A2(`${t3.layerIds[0]}: Value for "text-size" is >= ${Mu}. Reduce your "text-size".`)) : "composite" === g3.kind && (x3 = [Cu * d3.compositeTextSizes[0].evaluate(o3, {}, y3), Cu * d3.compositeTextSizes[1].evaluate(o3, {}, y3)], (x3[0] > Bu || x3[1] > Bu) && A2(`${t3.layerIds[0]}: Value for "text-size" is >= ${Mu}. Reduce your "text-size".`)), t3.addSymbols(t3.text, m3, x3, l3, s3, o3, c3, e2, u3.lineStartIndex, u3.lineLength, f3, y3);
        for (const e3 of h3) p3[e3] = t3.text.placedSymbolArray.length - 1;
        return 4 * m3.length;
      }
      function Hc(t3) {
        for (const e2 in t3) return t3[e2];
        return null;
      }
      function Wc(t3, e2, r3, n3) {
        const i3 = t3.compareText;
        if (e2 in i3) {
          const t4 = i3[e2];
          for (let e3 = t4.length - 1; e3 >= 0; e3--) if (n3.dist(t4[e3]) < r3) return true;
        } else i3[e2] = [];
        return i3[e2].push(n3), false;
      }
      const Qc = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class th {
        static from(t3) {
          if (!(t3 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [e2, r3] = new Uint8Array(t3, 0, 2);
          if (219 !== e2) throw new Error("Data does not appear to be in a KDBush format.");
          const n3 = r3 >> 4;
          if (1 !== n3) throw new Error(`Got v${n3} data when expected v1.`);
          const i3 = Qc[15 & r3];
          if (!i3) throw new Error("Unrecognized array type.");
          const [a3] = new Uint16Array(t3, 2, 1), [s3] = new Uint32Array(t3, 4, 1);
          return new th(s3, a3, i3, t3);
        }
        constructor(t3, e2 = 64, r3 = Float64Array, n3) {
          if (isNaN(t3) || t3 < 0) throw new Error(`Unpexpected numItems value: ${t3}.`);
          this.numItems = +t3, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r3, this.IndexArrayType = t3 < 65536 ? Uint16Array : Uint32Array;
          const i3 = Qc.indexOf(this.ArrayType), a3 = 2 * t3 * this.ArrayType.BYTES_PER_ELEMENT, s3 = t3 * this.IndexArrayType.BYTES_PER_ELEMENT, o3 = (8 - s3 % 8) % 8;
          if (i3 < 0) throw new Error(`Unexpected typed array class: ${r3}.`);
          n3 && n3 instanceof ArrayBuffer ? (this.data = n3, this.ids = new this.IndexArrayType(this.data, 8, t3), this.coords = new this.ArrayType(this.data, 8 + s3 + o3, 2 * t3), this._pos = 2 * t3, this._finished = true) : (this.data = new ArrayBuffer(8 + a3 + s3 + o3), this.ids = new this.IndexArrayType(this.data, 8, t3), this.coords = new this.ArrayType(this.data, 8 + s3 + o3, 2 * t3), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i3]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t3);
        }
        add(t3, e2) {
          const r3 = this._pos >> 1;
          return this.ids[r3] = r3, this.coords[this._pos++] = t3, this.coords[this._pos++] = e2, r3;
        }
        finish() {
          const t3 = this._pos >> 1;
          if (t3 !== this.numItems) throw new Error(`Added ${t3} items when expected ${this.numItems}.`);
          return eh(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
        }
        range(t3, e2, r3, n3) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: i3, coords: a3, nodeSize: s3 } = this, o3 = [0, i3.length - 1, 0], l3 = [];
          for (; o3.length; ) {
            const u3 = o3.pop() || 0, c3 = o3.pop() || 0, h3 = o3.pop() || 0;
            if (c3 - h3 <= s3) {
              for (let s4 = h3; s4 <= c3; s4++) {
                const o4 = a3[2 * s4], u4 = a3[2 * s4 + 1];
                o4 >= t3 && o4 <= r3 && u4 >= e2 && u4 <= n3 && l3.push(i3[s4]);
              }
              continue;
            }
            const p3 = h3 + c3 >> 1, f3 = a3[2 * p3], d3 = a3[2 * p3 + 1];
            f3 >= t3 && f3 <= r3 && d3 >= e2 && d3 <= n3 && l3.push(i3[p3]), (0 === u3 ? t3 <= f3 : e2 <= d3) && (o3.push(h3), o3.push(p3 - 1), o3.push(1 - u3)), (0 === u3 ? r3 >= f3 : n3 >= d3) && (o3.push(p3 + 1), o3.push(c3), o3.push(1 - u3));
          }
          return l3;
        }
        within(t3, e2, r3) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: n3, coords: i3, nodeSize: a3 } = this, s3 = [0, n3.length - 1, 0], o3 = [], l3 = r3 * r3;
          for (; s3.length; ) {
            const u3 = s3.pop() || 0, c3 = s3.pop() || 0, h3 = s3.pop() || 0;
            if (c3 - h3 <= a3) {
              for (let r4 = h3; r4 <= c3; r4++) ah(i3[2 * r4], i3[2 * r4 + 1], t3, e2) <= l3 && o3.push(n3[r4]);
              continue;
            }
            const p3 = h3 + c3 >> 1, f3 = i3[2 * p3], d3 = i3[2 * p3 + 1];
            ah(f3, d3, t3, e2) <= l3 && o3.push(n3[p3]), (0 === u3 ? t3 - r3 <= f3 : e2 - r3 <= d3) && (s3.push(h3), s3.push(p3 - 1), s3.push(1 - u3)), (0 === u3 ? t3 + r3 >= f3 : e2 + r3 >= d3) && (s3.push(p3 + 1), s3.push(c3), s3.push(1 - u3));
          }
          return o3;
        }
      }
      function eh(t3, e2, r3, n3, i3, a3) {
        if (i3 - n3 <= r3) return;
        const s3 = n3 + i3 >> 1;
        rh(t3, e2, s3, n3, i3, a3), eh(t3, e2, r3, n3, s3 - 1, 1 - a3), eh(t3, e2, r3, s3 + 1, i3, 1 - a3);
      }
      function rh(t3, e2, r3, n3, i3, a3) {
        for (; i3 > n3; ) {
          if (i3 - n3 > 600) {
            const s4 = i3 - n3 + 1, o4 = r3 - n3 + 1, l4 = Math.log(s4), u3 = 0.5 * Math.exp(2 * l4 / 3), c3 = 0.5 * Math.sqrt(l4 * u3 * (s4 - u3) / s4) * (o4 - s4 / 2 < 0 ? -1 : 1);
            rh(t3, e2, r3, Math.max(n3, Math.floor(r3 - o4 * u3 / s4 + c3)), Math.min(i3, Math.floor(r3 + (s4 - o4) * u3 / s4 + c3)), a3);
          }
          const s3 = e2[2 * r3 + a3];
          let o3 = n3, l3 = i3;
          for (nh(t3, e2, n3, r3), e2[2 * i3 + a3] > s3 && nh(t3, e2, n3, i3); o3 < l3; ) {
            for (nh(t3, e2, o3, l3), o3++, l3--; e2[2 * o3 + a3] < s3; ) o3++;
            for (; e2[2 * l3 + a3] > s3; ) l3--;
          }
          e2[2 * n3 + a3] === s3 ? nh(t3, e2, n3, l3) : (l3++, nh(t3, e2, l3, i3)), l3 <= r3 && (n3 = l3 + 1), r3 <= l3 && (i3 = l3 - 1);
        }
      }
      function nh(t3, e2, r3, n3) {
        ih(t3, r3, n3), ih(e2, 2 * r3, 2 * n3), ih(e2, 2 * r3 + 1, 2 * n3 + 1);
      }
      function ih(t3, e2, r3) {
        const n3 = t3[e2];
        t3[e2] = t3[r3], t3[r3] = n3;
      }
      function ah(t3, e2, r3, n3) {
        const i3 = t3 - r3, a3 = e2 - n3;
        return i3 * i3 + a3 * a3;
      }
      var sh;
      t2.bh = void 0, (sh = t2.bh || (t2.bh = {})).create = "create", sh.load = "load", sh.fullLoad = "fullLoad";
      let oh = null, lh = [];
      const uh = 1e3 / 60, ch = "loadTime", hh = "fullLoadTime", ph = { mark(t3) {
        performance.mark(t3);
      }, frame(t3) {
        const e2 = t3;
        null != oh && lh.push(e2 - oh), oh = e2;
      }, clearMetrics() {
        oh = null, lh = [], performance.clearMeasures(ch), performance.clearMeasures(hh);
        for (const e2 in t2.bh) performance.clearMarks(t2.bh[e2]);
      }, getPerformanceMetrics() {
        performance.measure(ch, t2.bh.create, t2.bh.load), performance.measure(hh, t2.bh.create, t2.bh.fullLoad);
        const e2 = performance.getEntriesByName(ch)[0].duration, r3 = performance.getEntriesByName(hh)[0].duration, n3 = lh.length, i3 = 1 / (lh.reduce((t3, e3) => t3 + e3, 0) / n3 / 1e3), a3 = lh.filter((t3) => t3 > uh).reduce((t3, e3) => t3 + (e3 - uh) / uh, 0);
        return { loadTime: e2, fullLoadTime: r3, fps: i3, percentDroppedFrames: a3 / (n3 + a3) * 100, totalFrames: n3 };
      } };
      t2.$ = function(t3, e2, r3) {
        var n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3 = r3[0], m3 = r3[1], g3 = r3[2];
        return e2 === t3 ? (t3[12] = e2[0] * y3 + e2[4] * m3 + e2[8] * g3 + e2[12], t3[13] = e2[1] * y3 + e2[5] * m3 + e2[9] * g3 + e2[13], t3[14] = e2[2] * y3 + e2[6] * m3 + e2[10] * g3 + e2[14], t3[15] = e2[3] * y3 + e2[7] * m3 + e2[11] * g3 + e2[15]) : (i3 = e2[1], a3 = e2[2], s3 = e2[3], o3 = e2[4], l3 = e2[5], u3 = e2[6], c3 = e2[7], h3 = e2[8], p3 = e2[9], f3 = e2[10], d3 = e2[11], t3[0] = n3 = e2[0], t3[1] = i3, t3[2] = a3, t3[3] = s3, t3[4] = o3, t3[5] = l3, t3[6] = u3, t3[7] = c3, t3[8] = h3, t3[9] = p3, t3[10] = f3, t3[11] = d3, t3[12] = n3 * y3 + o3 * m3 + h3 * g3 + e2[12], t3[13] = i3 * y3 + l3 * m3 + p3 * g3 + e2[13], t3[14] = a3 * y3 + u3 * m3 + f3 * g3 + e2[14], t3[15] = s3 * y3 + c3 * m3 + d3 * g3 + e2[15]), t3;
      }, t2.A = zs, t2.B = Ze2, t2.C = class {
        constructor(t3, e2, r3) {
          this.receive = (t4) => {
            const e3 = t4.data, r4 = e3.id;
            if (r4 && (!e3.targetMapId || this.mapId === e3.targetMapId)) if ("<cancel>" === e3.type) {
              delete this.tasks[r4];
              const t5 = this.cancelCallbacks[r4];
              delete this.cancelCallbacks[r4], t5 && t5();
            } else I2() || e3.mustQueue ? (this.tasks[r4] = e3, this.taskQueue.push(r4), this.invoker.trigger()) : this.processTask(r4, e3);
          }, this.process = () => {
            if (!this.taskQueue.length) return;
            const t4 = this.taskQueue.shift(), e3 = this.tasks[t4];
            delete this.tasks[t4], this.taskQueue.length && this.invoker.trigger(), e3 && this.processTask(t4, e3);
          }, this.target = t3, this.parent = e2, this.mapId = r3, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, this.invoker = new Qu(this.process), this.target.addEventListener("message", this.receive, false), this.globalScope = I2() ? t3 : window;
        }
        send(t3, e2, r3, n3, i3 = false) {
          const a3 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          r3 && (this.callbacks[a3] = r3);
          const s3 = [], o3 = { id: a3, type: t3, hasCallback: !!r3, targetMapId: n3, mustQueue: i3, sourceMapId: this.mapId, data: Dn(e2, s3) };
          return this.target.postMessage(o3, { transfer: s3 }), { cancel: () => {
            r3 && delete this.callbacks[a3], this.target.postMessage({ id: a3, type: "<cancel>", targetMapId: n3, sourceMapId: this.mapId });
          } };
        }
        processTask(t3, e2) {
          if ("<response>" === e2.type) {
            const r3 = this.callbacks[t3];
            delete this.callbacks[t3], r3 && (e2.error ? r3(On(e2.error)) : r3(null, On(e2.data)));
          } else {
            let r3 = false;
            const n3 = [], i3 = e2.hasCallback ? (e3, i4) => {
              r3 = true, delete this.cancelCallbacks[t3];
              const a4 = { id: t3, type: "<response>", sourceMapId: this.mapId, error: e3 ? Dn(e3) : null, data: Dn(i4, n3) };
              this.target.postMessage(a4, { transfer: n3 });
            } : (t4) => {
              r3 = true;
            };
            let a3 = null;
            const s3 = On(e2.data);
            if (this.parent[e2.type]) a3 = this.parent[e2.type](e2.sourceMapId, s3, i3);
            else if ("getWorkerSource" in this.parent) {
              const t4 = e2.type.split(".");
              a3 = this.parent.getWorkerSource(e2.sourceMapId, t4[0], s3.source)[t4[1]](s3, i3);
            } else i3(new Error(`Could not find function ${e2.type}`));
            !r3 && a3 && a3.cancel && (this.cancelCallbacks[t3] = a3.cancel);
          }
        }
        remove() {
          this.invoker.remove(), this.target.removeEventListener("message", this.receive, false);
        }
      }, t2.D = gi, t2.E = J2, t2.F = function(t3, e2) {
        const r3 = {};
        for (let n3 = 0; n3 < e2.length; n3++) {
          const i3 = e2[n3];
          i3 in t3 && (r3[i3] = t3[i3]);
        }
        return r3;
      }, t2.G = ic, t2.H = ac, t2.I = uu, t2.J = h2, t2.K = p2, t2.L = ec, t2.M = B2, t2.N = rs, t2.O = fc, t2.P = a2, t2.Q = Mi, t2.R = qs, t2.S = za, t2.T = hi, t2.U = uc, t2.V = class extends Vi {
      }, t2.W = hc, t2.X = function(t3, e2) {
        const r3 = window.document.createElement("video");
        r3.muted = true, r3.onloadstart = function() {
          e2(null, r3);
        };
        for (let e3 = 0; e3 < t3.length; e3++) {
          const n3 = window.document.createElement("source");
          j2(t3[e3]) || (r3.crossOrigin = "Anonymous"), n3.src = t3[e3], r3.appendChild(n3);
        }
        return { cancel: () => {
        } };
      }, t2.Y = ot, t2.Z = function() {
        var t3 = new zs(16);
        return zs != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0), t3[0] = 1, t3[5] = 1, t3[10] = 1, t3[15] = 1, t3;
      }, t2._ = e, t2.a = M2, t2.a$ = class extends Hi {
      }, t2.a0 = function(t3, e2, r3) {
        var n3 = r3[0], i3 = r3[1], a3 = r3[2];
        return t3[0] = e2[0] * n3, t3[1] = e2[1] * n3, t3[2] = e2[2] * n3, t3[3] = e2[3] * n3, t3[4] = e2[4] * i3, t3[5] = e2[5] * i3, t3[6] = e2[6] * i3, t3[7] = e2[7] * i3, t3[8] = e2[8] * a3, t3[9] = e2[9] * a3, t3[10] = e2[10] * a3, t3[11] = e2[11] * a3, t3[12] = e2[12], t3[13] = e2[13], t3[14] = e2[14], t3[15] = e2[15], t3;
      }, t2.a1 = Cs, t2.a2 = function() {
        return x2++;
      }, t2.a3 = ta, t2.a4 = Uu, t2.a5 = function() {
        oi.isLoading() || oi.isLoaded() || "deferred" !== ai() || si();
      }, t2.a6 = Nr, t2.a7 = ss2, t2.a8 = li, t2.a9 = gc, t2.aA = ri, t2.aB = function(t3) {
        t3 = t3.slice();
        const e2 = /* @__PURE__ */ Object.create(null);
        for (let r3 = 0; r3 < t3.length; r3++) e2[t3[r3].id] = t3[r3];
        for (let r3 = 0; r3 < t3.length; r3++) "ref" in t3[r3] && (t3[r3] = H2(t3[r3], e2[t3[r3].ref]));
        return t3;
      }, t2.aC = function(t3) {
        if ("custom" === t3.type) return new Wu(t3);
        switch (t3.type) {
          case "background":
            return new Ju(t3);
          case "circle":
            return new Es(t3);
          case "fill":
            return new Lo(t3);
          case "fill-extrusion":
            return new ol(t3);
          case "heatmap":
            return new Ns(t3);
          case "hillshade":
            return new Gs(t3);
          case "line":
            return new Al(t3);
          case "raster":
            return new Hu(t3);
          case "symbol":
            return new Zu(t3);
        }
      }, t2.aD = w2, t2.aE = function(t3, e2) {
        if (!t3) return [{ command: Q2.setStyle, args: [e2] }];
        let r3 = [];
        try {
          if (!W2(t3.version, e2.version)) return [{ command: Q2.setStyle, args: [e2] }];
          W2(t3.center, e2.center) || r3.push({ command: Q2.setCenter, args: [e2.center] }), W2(t3.zoom, e2.zoom) || r3.push({ command: Q2.setZoom, args: [e2.zoom] }), W2(t3.bearing, e2.bearing) || r3.push({ command: Q2.setBearing, args: [e2.bearing] }), W2(t3.pitch, e2.pitch) || r3.push({ command: Q2.setPitch, args: [e2.pitch] }), W2(t3.sprite, e2.sprite) || r3.push({ command: Q2.setSprite, args: [e2.sprite] }), W2(t3.glyphs, e2.glyphs) || r3.push({ command: Q2.setGlyphs, args: [e2.glyphs] }), W2(t3.transition, e2.transition) || r3.push({ command: Q2.setTransition, args: [e2.transition] }), W2(t3.light, e2.light) || r3.push({ command: Q2.setLight, args: [e2.light] });
          const n3 = {}, i3 = [];
          !function(t4, e3, r4, n4) {
            let i4;
            for (i4 in e3 = e3 || {}, t4 = t4 || {}) Object.prototype.hasOwnProperty.call(t4, i4) && (Object.prototype.hasOwnProperty.call(e3, i4) || et(i4, r4, n4));
            for (i4 in e3) Object.prototype.hasOwnProperty.call(e3, i4) && (Object.prototype.hasOwnProperty.call(t4, i4) ? W2(t4[i4], e3[i4]) || ("geojson" === t4[i4].type && "geojson" === e3[i4].type && nt(t4, e3, i4) ? r4.push({ command: Q2.setGeoJSONSourceData, args: [i4, e3[i4].data] }) : rt(i4, e3, r4, n4)) : tt(i4, e3, r4));
          }(t3.sources, e2.sources, i3, n3);
          const a3 = [];
          t3.layers && t3.layers.forEach((t4) => {
            n3[t4.source] ? r3.push({ command: Q2.removeLayer, args: [t4.id] }) : a3.push(t4);
          }), r3 = r3.concat(i3), function(t4, e3, r4) {
            e3 = e3 || [];
            const n4 = (t4 = t4 || []).map(at), i4 = e3.map(at), a4 = t4.reduce(st, {}), s3 = e3.reduce(st, {}), o3 = n4.slice(), l3 = /* @__PURE__ */ Object.create(null);
            let u3, c3, h3, p3, f3, d3, y3;
            for (u3 = 0, c3 = 0; u3 < n4.length; u3++) h3 = n4[u3], Object.prototype.hasOwnProperty.call(s3, h3) ? c3++ : (r4.push({ command: Q2.removeLayer, args: [h3] }), o3.splice(o3.indexOf(h3, c3), 1));
            for (u3 = 0, c3 = 0; u3 < i4.length; u3++) h3 = i4[i4.length - 1 - u3], o3[o3.length - 1 - u3] !== h3 && (Object.prototype.hasOwnProperty.call(a4, h3) ? (r4.push({ command: Q2.removeLayer, args: [h3] }), o3.splice(o3.lastIndexOf(h3, o3.length - c3), 1)) : c3++, d3 = o3[o3.length - u3], r4.push({ command: Q2.addLayer, args: [s3[h3], d3] }), o3.splice(o3.length - u3, 0, h3), l3[h3] = true);
            for (u3 = 0; u3 < i4.length; u3++) if (h3 = i4[u3], p3 = a4[h3], f3 = s3[h3], !l3[h3] && !W2(p3, f3)) if (W2(p3.source, f3.source) && W2(p3["source-layer"], f3["source-layer"]) && W2(p3.type, f3.type)) {
              for (y3 in it(p3.layout, f3.layout, r4, h3, null, Q2.setLayoutProperty), it(p3.paint, f3.paint, r4, h3, null, Q2.setPaintProperty), W2(p3.filter, f3.filter) || r4.push({ command: Q2.setFilter, args: [h3, f3.filter] }), W2(p3.minzoom, f3.minzoom) && W2(p3.maxzoom, f3.maxzoom) || r4.push({ command: Q2.setLayerZoomRange, args: [h3, f3.minzoom, f3.maxzoom] }), p3) Object.prototype.hasOwnProperty.call(p3, y3) && "layout" !== y3 && "paint" !== y3 && "filter" !== y3 && "metadata" !== y3 && "minzoom" !== y3 && "maxzoom" !== y3 && (0 === y3.indexOf("paint.") ? it(p3[y3], f3[y3], r4, h3, y3.slice(6), Q2.setPaintProperty) : W2(p3[y3], f3[y3]) || r4.push({ command: Q2.setLayerProperty, args: [h3, y3, f3[y3]] }));
              for (y3 in f3) Object.prototype.hasOwnProperty.call(f3, y3) && !Object.prototype.hasOwnProperty.call(p3, y3) && "layout" !== y3 && "paint" !== y3 && "filter" !== y3 && "metadata" !== y3 && "minzoom" !== y3 && "maxzoom" !== y3 && (0 === y3.indexOf("paint.") ? it(p3[y3], f3[y3], r4, h3, y3.slice(6), Q2.setPaintProperty) : W2(p3[y3], f3[y3]) || r4.push({ command: Q2.setLayerProperty, args: [h3, y3, f3[y3]] }));
            } else r4.push({ command: Q2.removeLayer, args: [h3] }), d3 = o3[o3.lastIndexOf(h3) + 1], r4.push({ command: Q2.addLayer, args: [f3, d3] });
          }(a3, e2.layers, r3);
        } catch (t4) {
          console.warn("Unable to compute style diff:", t4), r3 = [{ command: Q2.setStyle, args: [e2] }];
        }
        return r3;
      }, t2.aF = function(t3) {
        const e2 = [], r3 = t3.id;
        return void 0 === r3 && e2.push({ message: `layers.${r3}: missing required property "id"` }), void 0 === t3.render && e2.push({ message: `layers.${r3}: missing required method "render"` }), t3.renderingMode && "2d" !== t3.renderingMode && "3d" !== t3.renderingMode && e2.push({ message: `layers.${r3}: property "renderingMode" must be either "2d" or "3d"` }), e2;
      }, t2.aG = function t3(e2, r3) {
        if (Array.isArray(e2)) {
          if (!Array.isArray(r3) || e2.length !== r3.length) return false;
          for (let n3 = 0; n3 < e2.length; n3++) if (!t3(e2[n3], r3[n3])) return false;
          return true;
        }
        if ("object" == typeof e2 && null !== e2 && null !== r3) {
          if ("object" != typeof r3) return false;
          if (Object.keys(e2).length !== Object.keys(r3).length) return false;
          for (const n3 in e2) if (!t3(e2[n3], r3[n3])) return false;
          return true;
        }
        return e2 === r3;
      }, t2.aH = v2, t2.aI = b2, t2.aJ = ii, t2.aK = function(t3) {
        return t3({ pluginStatus: ti, pluginURL: ei }), ii.on("pluginStateChange", t3), t3;
      }, t2.aL = class extends Ra {
        constructor(t3, e2) {
          super(t3, e2), this.current = 0;
        }
        set(t3) {
          this.current !== t3 && (this.current = t3, this.gl.uniform1i(this.location, t3));
        }
      }, t2.aM = qa, t2.aN = class extends Ra {
        constructor(t3, e2) {
          super(t3, e2), this.current = Za;
        }
        set(t3) {
          if (t3[12] !== this.current[12] || t3[0] !== this.current[0]) return this.current = t3, void this.gl.uniformMatrix4fv(this.location, false, t3);
          for (let e2 = 1; e2 < 16; e2++) if (t3[e2] !== this.current[e2]) {
            this.current = t3, this.gl.uniformMatrix4fv(this.location, false, t3);
            break;
          }
        }
      }, t2.aO = ja, t2.aP = class extends Ra {
        constructor(t3, e2) {
          super(t3, e2), this.current = [0, 0, 0];
        }
        set(t3) {
          t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] || (this.current = t3, this.gl.uniform3f(this.location, t3[0], t3[1], t3[2]));
        }
      }, t2.aQ = class extends Ra {
        constructor(t3, e2) {
          super(t3, e2), this.current = [0, 0];
        }
        set(t3) {
          t3[0] === this.current[0] && t3[1] === this.current[1] || (this.current = t3, this.gl.uniform2f(this.location, t3[0], t3[1]));
        }
      }, t2.aR = Na, t2.aS = function(t3, e2, r3, n3, i3, a3, s3) {
        var o3 = 1 / (e2 - r3), l3 = 1 / (n3 - i3), u3 = 1 / (a3 - s3);
        return t3[0] = -2 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * l3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 2 * u3, t3[11] = 0, t3[12] = (e2 + r3) * o3, t3[13] = (i3 + n3) * l3, t3[14] = (s3 + a3) * u3, t3[15] = 1, t3;
      }, t2.aT = Yt, t2.aU = Ps, t2.aV = class extends qi {
      }, t2.aW = Cl, t2.aX = class extends Ni {
      }, t2.aY = function(t3) {
        return t3 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t3) / Math.LN2));
      }, t2.aZ = js, t2.a_ = ha, t2.aa = function(t3) {
        const e2 = {};
        if (t3.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t4, r3, n3, i3) => {
          const a3 = n3 || i3;
          return e2[r3] = !a3 || a3.toLowerCase(), "";
        }), e2["max-age"]) {
          const t4 = parseInt(e2["max-age"], 10);
          isNaN(t4) ? delete e2["max-age"] : e2["max-age"] = t4;
        }
        return e2;
      }, t2.ab = function(t3, e2) {
        const r3 = [];
        for (const n3 in t3) n3 in e2 || r3.push(n3);
        return r3;
      }, t2.ac = function(t3) {
        if (null == z2) {
          const e2 = t3.navigator ? t3.navigator.userAgent : null;
          z2 = !!t3.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
        }
        return z2;
      }, t2.ad = y2, t2.ae = function(t3, e2, r3) {
        var n3 = Math.sin(r3), i3 = Math.cos(r3), a3 = e2[0], s3 = e2[1], o3 = e2[2], l3 = e2[3], u3 = e2[4], c3 = e2[5], h3 = e2[6], p3 = e2[7];
        return e2 !== t3 && (t3[8] = e2[8], t3[9] = e2[9], t3[10] = e2[10], t3[11] = e2[11], t3[12] = e2[12], t3[13] = e2[13], t3[14] = e2[14], t3[15] = e2[15]), t3[0] = a3 * i3 + u3 * n3, t3[1] = s3 * i3 + c3 * n3, t3[2] = o3 * i3 + h3 * n3, t3[3] = l3 * i3 + p3 * n3, t3[4] = u3 * i3 - a3 * n3, t3[5] = c3 * i3 - s3 * n3, t3[6] = h3 * i3 - o3 * n3, t3[7] = p3 * i3 - l3 * n3, t3;
      }, t2.af = function(t3) {
        var e2 = new zs(16);
        return e2[0] = t3[0], e2[1] = t3[1], e2[2] = t3[2], e2[3] = t3[3], e2[4] = t3[4], e2[5] = t3[5], e2[6] = t3[6], e2[7] = t3[7], e2[8] = t3[8], e2[9] = t3[9], e2[10] = t3[10], e2[11] = t3[11], e2[12] = t3[12], e2[13] = t3[13], e2[14] = t3[14], e2[15] = t3[15], e2;
      }, t2.ag = Vs, t2.ah = function(t3, e2) {
        let r3 = 0, n3 = 0;
        if ("constant" === t3.kind) n3 = t3.layoutSize;
        else if ("source" !== t3.kind) {
          const { interpolationType: i3, minZoom: a3, maxZoom: s3 } = t3, o3 = i3 ? y2(Ke.interpolationFactor(i3, e2, a3, s3), 0, 1) : 0;
          "camera" === t3.kind ? n3 = Ze2.number(t3.minSize, t3.maxSize, o3) : r3 = o3;
        }
        return { uSizeT: r3, uSize: n3 };
      }, t2.aj = function(t3, { uSize: e2, uSizeT: r3 }, { lowerSize: n3, upperSize: i3 }) {
        return "source" === t3.kind ? n3 / Cu : "composite" === t3.kind ? Ze2.number(n3 / Cu, i3 / Cu, r3) : e2;
      }, t2.ak = $u, t2.al = function(t3, e2, r3, n3) {
        const i3 = e2.y - t3.y, s3 = e2.x - t3.x, o3 = n3.y - r3.y, l3 = n3.x - r3.x, u3 = o3 * s3 - l3 * i3;
        if (0 === u3) return null;
        const c3 = (l3 * (t3.y - r3.y) - o3 * (t3.x - r3.x)) / u3;
        return new a2(t3.x + c3 * s3, t3.y + c3 * i3);
      }, t2.am = _c, t2.an = us, t2.ao = Ms, t2.ap = Vl, t2.ar = Vu, t2.as = function(t3, e2) {
        var r3 = e2[0], n3 = e2[1], i3 = e2[2], a3 = e2[3], s3 = e2[4], o3 = e2[5], l3 = e2[6], u3 = e2[7], c3 = e2[8], h3 = e2[9], p3 = e2[10], f3 = e2[11], d3 = e2[12], y3 = e2[13], m3 = e2[14], g3 = e2[15], x3 = r3 * o3 - n3 * s3, v3 = r3 * l3 - i3 * s3, b3 = r3 * u3 - a3 * s3, w3 = n3 * l3 - i3 * o3, _3 = n3 * u3 - a3 * o3, A3 = i3 * u3 - a3 * l3, S3 = c3 * y3 - h3 * d3, k3 = c3 * m3 - p3 * d3, I3 = c3 * g3 - f3 * d3, z3 = h3 * m3 - p3 * y3, M3 = h3 * g3 - f3 * y3, C3 = p3 * g3 - f3 * m3, B3 = x3 * C3 - v3 * M3 + b3 * z3 + w3 * I3 - _3 * k3 + A3 * S3;
        return B3 ? (t3[0] = (o3 * C3 - l3 * M3 + u3 * z3) * (B3 = 1 / B3), t3[1] = (i3 * M3 - n3 * C3 - a3 * z3) * B3, t3[2] = (y3 * A3 - m3 * _3 + g3 * w3) * B3, t3[3] = (p3 * _3 - h3 * A3 - f3 * w3) * B3, t3[4] = (l3 * I3 - s3 * C3 - u3 * k3) * B3, t3[5] = (r3 * C3 - i3 * I3 + a3 * k3) * B3, t3[6] = (m3 * b3 - d3 * A3 - g3 * v3) * B3, t3[7] = (c3 * A3 - p3 * b3 + f3 * v3) * B3, t3[8] = (s3 * M3 - o3 * I3 + u3 * S3) * B3, t3[9] = (n3 * I3 - r3 * M3 - a3 * S3) * B3, t3[10] = (d3 * _3 - y3 * b3 + g3 * x3) * B3, t3[11] = (h3 * b3 - c3 * _3 - f3 * x3) * B3, t3[12] = (o3 * k3 - s3 * z3 - l3 * S3) * B3, t3[13] = (r3 * z3 - n3 * k3 + i3 * S3) * B3, t3[14] = (y3 * v3 - d3 * w3 - m3 * x3) * B3, t3[15] = (c3 * w3 - h3 * v3 + p3 * x3) * B3, t3) : null;
      }, t2.at = Jc, t2.au = Su, t2.av = th, t2.aw = function() {
        const t3 = {}, e2 = X2.$version;
        for (const r3 in X2.$root) {
          const n3 = X2.$root[r3];
          if (n3.required) {
            let i3 = null;
            i3 = "version" === r3 ? e2 : "array" === n3.type ? [] : {}, null != i3 && (t3[r3] = i3);
          }
        }
        return t3;
      }, t2.ax = Q2, t2.ay = Un, t2.az = D2, t2.b = function(t3, e2) {
        const r3 = new Blob([new Uint8Array(t3)], { type: "image/png" });
        createImageBitmap(r3).then((t4) => {
          e2(null, t4);
        }).catch((t4) => {
          e2(new Error(`Could not load image because of ${t4.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
        });
      }, t2.b0 = Aa, t2.b1 = function(t3, e2) {
        var r3 = t3[0], n3 = t3[1], i3 = t3[2], a3 = t3[3], s3 = t3[4], o3 = t3[5], l3 = t3[6], u3 = t3[7], c3 = t3[8], h3 = t3[9], p3 = t3[10], f3 = t3[11], d3 = t3[12], y3 = t3[13], m3 = t3[14], g3 = t3[15], x3 = e2[0], v3 = e2[1], b3 = e2[2], w3 = e2[3], _3 = e2[4], A3 = e2[5], S3 = e2[6], k3 = e2[7], I3 = e2[8], z3 = e2[9], M3 = e2[10], C3 = e2[11], B3 = e2[12], P3 = e2[13], V3 = e2[14], E3 = e2[15];
        return Math.abs(r3 - x3) <= Is * Math.max(1, Math.abs(r3), Math.abs(x3)) && Math.abs(n3 - v3) <= Is * Math.max(1, Math.abs(n3), Math.abs(v3)) && Math.abs(i3 - b3) <= Is * Math.max(1, Math.abs(i3), Math.abs(b3)) && Math.abs(a3 - w3) <= Is * Math.max(1, Math.abs(a3), Math.abs(w3)) && Math.abs(s3 - _3) <= Is * Math.max(1, Math.abs(s3), Math.abs(_3)) && Math.abs(o3 - A3) <= Is * Math.max(1, Math.abs(o3), Math.abs(A3)) && Math.abs(l3 - S3) <= Is * Math.max(1, Math.abs(l3), Math.abs(S3)) && Math.abs(u3 - k3) <= Is * Math.max(1, Math.abs(u3), Math.abs(k3)) && Math.abs(c3 - I3) <= Is * Math.max(1, Math.abs(c3), Math.abs(I3)) && Math.abs(h3 - z3) <= Is * Math.max(1, Math.abs(h3), Math.abs(z3)) && Math.abs(p3 - M3) <= Is * Math.max(1, Math.abs(p3), Math.abs(M3)) && Math.abs(f3 - C3) <= Is * Math.max(1, Math.abs(f3), Math.abs(C3)) && Math.abs(d3 - B3) <= Is * Math.max(1, Math.abs(d3), Math.abs(B3)) && Math.abs(y3 - P3) <= Is * Math.max(1, Math.abs(y3), Math.abs(P3)) && Math.abs(m3 - V3) <= Is * Math.max(1, Math.abs(m3), Math.abs(V3)) && Math.abs(g3 - E3) <= Is * Math.max(1, Math.abs(g3), Math.abs(E3));
      }, t2.b2 = function(t3, e2) {
        return t3[0] = e2[0], t3[1] = e2[1], t3[2] = e2[2], t3[3] = e2[3], t3[4] = e2[4], t3[5] = e2[5], t3[6] = e2[6], t3[7] = e2[7], t3[8] = e2[8], t3[9] = e2[9], t3[10] = e2[10], t3[11] = e2[11], t3[12] = e2[12], t3[13] = e2[13], t3[14] = e2[14], t3[15] = e2[15], t3;
      }, t2.b3 = function(t3, e2, r3) {
        return t3[0] = e2[0] * r3[0], t3[1] = e2[1] * r3[1], t3[2] = e2[2] * r3[2], t3[3] = e2[3] * r3[3], t3;
      }, t2.b4 = function(t3, e2) {
        return t3[0] * e2[0] + t3[1] * e2[1] + t3[2] * e2[2] + t3[3] * e2[3];
      }, t2.b5 = m2, t2.b6 = pc, t2.b7 = sc, t2.b8 = function(t3, e2, r3, n3, i3) {
        var a3, s3 = 1 / Math.tan(e2 / 2);
        return t3[0] = s3 / r3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = s3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[15] = 0, null != i3 && i3 !== 1 / 0 ? (t3[10] = (i3 + n3) * (a3 = 1 / (n3 - i3)), t3[14] = 2 * i3 * n3 * a3) : (t3[10] = -1, t3[14] = -2 * n3), t3;
      }, t2.b9 = function(t3, e2, r3) {
        var n3 = Math.sin(r3), i3 = Math.cos(r3), a3 = e2[4], s3 = e2[5], o3 = e2[6], l3 = e2[7], u3 = e2[8], c3 = e2[9], h3 = e2[10], p3 = e2[11];
        return e2 !== t3 && (t3[0] = e2[0], t3[1] = e2[1], t3[2] = e2[2], t3[3] = e2[3], t3[12] = e2[12], t3[13] = e2[13], t3[14] = e2[14], t3[15] = e2[15]), t3[4] = a3 * i3 + u3 * n3, t3[5] = s3 * i3 + c3 * n3, t3[6] = o3 * i3 + h3 * n3, t3[7] = l3 * i3 + p3 * n3, t3[8] = u3 * i3 - a3 * n3, t3[9] = c3 * i3 - s3 * n3, t3[10] = h3 * i3 - o3 * n3, t3[11] = p3 * i3 - l3 * n3, t3;
      }, t2.bA = n2, t2.bB = El, t2.bC = $r, t2.bD = oi, t2.ba = f2, t2.bb = d2, t2.bc = function(t3, e2) {
        return t3[0] = e2[0], t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = e2[1], t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = e2[2], t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
      }, t2.bd = class extends Pi {
      }, t2.be = tc, t2.bf = oc, t2.bg = ph, t2.bi = L2, t2.bj = function(t3, e2, r3 = false) {
        if (ti === Yn || ti === Hn || ti === Wn) throw new Error("setRTLTextPlugin cannot be called multiple times.");
        ei = T2.resolveURL(t3), ti = Yn, Qn = e2, ni(), r3 || si();
      }, t2.bk = ai, t2.bl = function(t3, e2) {
        const r3 = {};
        for (let n4 = 0; n4 < t3.length; n4++) {
          const i3 = e2 && e2[t3[n4].id] || Qr(t3[n4]);
          e2 && (e2[t3[n4].id] = i3);
          let a3 = r3[i3];
          a3 || (a3 = r3[i3] = []), a3.push(t3[n4]);
        }
        const n3 = [];
        for (const t4 in r3) n3.push(r3[t4]);
        return n3;
      }, t2.bm = $n, t2.bn = mc, t2.bo = xc, t2.bp = cu, t2.bq = function(e2) {
        e2.bucket.createArrays(), e2.bucket.tilePixelRatio = rs / (512 * e2.bucket.overscaling), e2.bucket.compareText = {}, e2.bucket.iconsNeedLinear = false;
        const r3 = e2.bucket.layers[0], n3 = r3.layout, i3 = r3._unevaluatedLayout._values, a3 = { layoutIconSize: i3["icon-size"].possiblyEvaluate(new li(e2.bucket.zoom + 1), e2.canonical), layoutTextSize: i3["text-size"].possiblyEvaluate(new li(e2.bucket.zoom + 1), e2.canonical), textMaxSize: i3["text-size"].possiblyEvaluate(new li(18)) };
        if ("composite" === e2.bucket.textSizeData.kind) {
          const { minZoom: t3, maxZoom: r4 } = e2.bucket.textSizeData;
          a3.compositeTextSizes = [i3["text-size"].possiblyEvaluate(new li(t3), e2.canonical), i3["text-size"].possiblyEvaluate(new li(r4), e2.canonical)];
        }
        if ("composite" === e2.bucket.iconSizeData.kind) {
          const { minZoom: t3, maxZoom: r4 } = e2.bucket.iconSizeData;
          a3.compositeIconSizes = [i3["icon-size"].possiblyEvaluate(new li(t3), e2.canonical), i3["icon-size"].possiblyEvaluate(new li(r4), e2.canonical)];
        }
        const s3 = n3.get("text-line-height") * Vl, o3 = "viewport" !== n3.get("text-rotation-alignment") && "point" !== n3.get("symbol-placement"), l3 = n3.get("text-keep-upright"), u3 = n3.get("text-size");
        for (const i4 of e2.bucket.features) {
          const c3 = n3.get("text-font").evaluate(i4, {}, e2.canonical).join(","), h3 = u3.evaluate(i4, {}, e2.canonical), p3 = a3.layoutTextSize.evaluate(i4, {}, e2.canonical), f3 = a3.layoutIconSize.evaluate(i4, {}, e2.canonical), d3 = { horizontal: {}, vertical: void 0 }, y3 = i4.text;
          let m3, g3 = [0, 0];
          if (y3) {
            const a4 = y3.toString(), u4 = n3.get("text-letter-spacing").evaluate(i4, {}, e2.canonical) * Vl, f4 = jn(a4) ? u4 : 0, m4 = n3.get("text-anchor").evaluate(i4, {}, e2.canonical), x4 = Gc(r3, i4, e2.canonical);
            if (!x4) {
              const t3 = n3.get("text-radial-offset").evaluate(i4, {}, e2.canonical);
              g3 = t3 ? Kc(m4, [t3 * Vl, Zc]) : n3.get("text-offset").evaluate(i4, {}, e2.canonical).map((t4) => t4 * Vl);
            }
            let v4 = o3 ? "center" : n3.get("text-justify").evaluate(i4, {}, e2.canonical);
            const b3 = n3.get("symbol-placement"), w3 = "point" === b3 ? n3.get("text-max-width").evaluate(i4, {}, e2.canonical) * Vl : 0, _3 = () => {
              e2.bucket.allowVerticalPlacement && qn(a4) && (d3.vertical = yu(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c3, w3, s3, m4, "left", f4, g3, t2.ai.vertical, true, b3, p3, h3));
            };
            if (!o3 && x4) {
              const r4 = /* @__PURE__ */ new Set();
              if ("auto" === v4) for (let t3 = 0; t3 < x4.values.length; t3 += 2) r4.add(Jc(x4.values[t3]));
              else r4.add(v4);
              let n4 = false;
              for (const i5 of r4) if (!d3.horizontal[i5]) if (n4) d3.horizontal[i5] = d3.horizontal[0];
              else {
                const r5 = yu(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c3, w3, s3, "center", i5, f4, g3, t2.ai.horizontal, false, b3, p3, h3);
                r5 && (d3.horizontal[i5] = r5, n4 = 1 === r5.positionedLines.length);
              }
              _3();
            } else {
              "auto" === v4 && (v4 = Jc(m4));
              const r4 = yu(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c3, w3, s3, m4, v4, f4, g3, t2.ai.horizontal, false, b3, p3, h3);
              r4 && (d3.horizontal[v4] = r4), _3(), qn(a4) && o3 && l3 && (d3.vertical = yu(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c3, w3, s3, m4, v4, f4, g3, t2.ai.vertical, false, b3, p3, h3));
            }
          }
          let x3 = false;
          if (i4.icon && i4.icon.name) {
            const t3 = e2.imageMap[i4.icon.name];
            t3 && (m3 = Iu(e2.imagePositions[i4.icon.name], n3.get("icon-offset").evaluate(i4, {}, e2.canonical), n3.get("icon-anchor").evaluate(i4, {}, e2.canonical)), x3 = !!t3.sdf, void 0 === e2.bucket.sdfIcons ? e2.bucket.sdfIcons = x3 : e2.bucket.sdfIcons !== x3 && A2("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t3.pixelRatio !== e2.bucket.pixelRatio || 0 !== n3.get("icon-rotate").constantOr(1)) && (e2.bucket.iconsNeedLinear = true));
          }
          const v3 = Hc(d3.horizontal) || d3.vertical;
          e2.bucket.iconsInText = !!v3 && v3.iconsInText, (v3 || m3) && Xc(e2.bucket, i4, d3, m3, e2.imageMap, a3, p3, f3, g3, x3, e2.canonical);
        }
        e2.showCollisionBoxes && e2.bucket.generateCollisionDebugBuffers();
      }, t2.br = gl, t2.bs = Eo, t2.bt = rl, t2.bu = class {
        constructor(t3) {
          this._marks = { start: [t3.url, "start"].join("#"), end: [t3.url, "end"].join("#"), measure: t3.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let t3 = performance.getEntriesByName(this._marks.measure);
          return 0 === t3.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t3 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t3;
        }
      }, t2.bv = eu, t2.bw = Ro, t2.bx = function(t3, r3, n3, i3, a3) {
        return e(this, void 0, void 0, function* () {
          if (p2()) try {
            return yield B2(t3, r3, n3, i3, a3);
          } catch (t4) {
          }
          return function(t4, e2, r4, n4, i4) {
            const a4 = t4.width, s3 = t4.height;
            P2 && V2 || (P2 = new OffscreenCanvas(a4, s3), V2 = P2.getContext("2d", { willReadFrequently: true })), P2.width = a4, P2.height = s3, V2.drawImage(t4, 0, 0, a4, s3);
            const o3 = V2.getImageData(e2, r4, n4, i4);
            return V2.clearRect(0, 0, a4, s3), o3.data;
          }(t3, r3, n3, i3, a3);
        });
      }, t2.by = yc, t2.bz = r2, t2.c = $2, t2.d = function(t3, e2) {
        const r3 = new Image();
        r3.onload = () => {
          e2(null, r3), URL.revokeObjectURL(r3.src), r3.onload = null, window.requestAnimationFrame(() => {
            r3.src = C2;
          });
        }, r3.onerror = () => e2(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const n3 = new Blob([new Uint8Array(t3)], { type: "image/png" });
        r3.src = t3.byteLength ? URL.createObjectURL(n3) : C2;
      }, t2.e = g2, t2.f = function(t3, e2) {
        return R2(g2(t3, { type: "json" }), e2);
      }, t2.g = O2, t2.h = T2, t2.i = I2, t2.j = G2, t2.k = K2, t2.l = q2, t2.m = R2, t2.n = function(t3) {
        return new eu(t3).readFields(nu, []);
      }, t2.o = function(t3, e2, r3) {
        if (!t3.length) return r3(null, []);
        let n3 = t3.length;
        const i3 = new Array(t3.length);
        let a3 = null;
        t3.forEach((t4, s3) => {
          e2(t4, (t5, e3) => {
            t5 && (a3 = t5), i3[s3] = e3, 0 == --n3 && r3(a3, i3);
          });
        });
      }, t2.p = ou, t2.q = Rs, t2.r = _i, t2.s = j2, t2.t = Bn, t2.u = Rn, t2.v = X2, t2.w = A2, t2.x = En, t2.y = Cn, t2.z = function([t3, e2, r3]) {
        return e2 += 90, e2 *= Math.PI / 180, r3 *= Math.PI / 180, { x: t3 * Math.cos(e2) * Math.sin(r3), y: t3 * Math.sin(e2) * Math.sin(r3), z: t3 * Math.cos(r3) };
      };
    });
    define(["./shared"], function(e) {
      class t2 {
        constructor(e2) {
          this.keyCache = {}, e2 && this.replace(e2);
        }
        replace(e2) {
          this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
        }
        update(t3, i3) {
          for (const i4 of t3) {
            this._layerConfigs[i4.id] = i4;
            const t4 = this._layers[i4.id] = e.aC(i4);
            t4._featureFilter = e.a6(t4.filter), this.keyCache[i4.id] && delete this.keyCache[i4.id];
          }
          for (const e2 of i3) delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
          this.familiesBySource = {};
          const o3 = e.bl(Object.values(this._layerConfigs), this.keyCache);
          for (const e2 of o3) {
            const t4 = e2.map((e3) => this._layers[e3.id]), i4 = t4[0];
            if ("none" === i4.visibility) continue;
            const o4 = i4.source || "";
            let r3 = this.familiesBySource[o4];
            r3 || (r3 = this.familiesBySource[o4] = {});
            const s3 = i4.sourceLayer || "_geojsonTileLayer";
            let n3 = r3[s3];
            n3 || (n3 = r3[s3] = []), n3.push(t4);
          }
        }
      }
      class i2 {
        constructor(t3) {
          const i3 = {}, o3 = [];
          for (const e2 in t3) {
            const r4 = t3[e2], s4 = i3[e2] = {};
            for (const e3 in r4) {
              const t4 = r4[+e3];
              if (!t4 || 0 === t4.bitmap.width || 0 === t4.bitmap.height) continue;
              const i4 = { x: 0, y: 0, w: t4.bitmap.width + 2, h: t4.bitmap.height + 2 };
              o3.push(i4), s4[e3] = { rect: i4, metrics: t4.metrics };
            }
          }
          const { w: r3, h: s3 } = e.p(o3), n3 = new e.q({ width: r3 || 1, height: s3 || 1 });
          for (const o4 in t3) {
            const r4 = t3[o4];
            for (const t4 in r4) {
              const s4 = r4[+t4];
              if (!s4 || 0 === s4.bitmap.width || 0 === s4.bitmap.height) continue;
              const a3 = i3[o4][t4].rect;
              e.q.copy(s4.bitmap, n3, { x: 0, y: 0 }, { x: a3.x + 1, y: a3.y + 1 }, s4.bitmap);
            }
          }
          this.image = n3, this.positions = i3;
        }
      }
      e.bm("GlyphAtlas", i2);
      class o2 {
        constructor(t3) {
          this.tileID = new e.O(t3.tileID.overscaledZ, t3.tileID.wrap, t3.tileID.canonical.z, t3.tileID.canonical.x, t3.tileID.canonical.y), this.uid = t3.uid, this.zoom = t3.zoom, this.pixelRatio = t3.pixelRatio, this.tileSize = t3.tileSize, this.source = t3.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t3.showCollisionBoxes, this.collectResourceTiming = !!t3.collectResourceTiming, this.returnDependencies = !!t3.returnDependencies, this.promoteId = t3.promoteId, this.inFlightDependencies = [], this.dependencySentinel = -1;
        }
        parse(t3, o3, s3, n3, a3) {
          this.status = "parsing", this.data = t3, this.collisionBoxArray = new e.a3();
          const l3 = new e.bn(Object.keys(t3.layers).sort()), c3 = new e.bo(this.tileID, this.promoteId);
          c3.bucketLayerIDs = [];
          const h3 = {}, u3 = { featureIndex: c3, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: s3 }, d3 = o3.familiesBySource[this.source];
          for (const i3 in d3) {
            const o4 = t3.layers[i3];
            if (!o4) continue;
            1 === o4.version && e.w(`Vector tile source "${this.source}" layer "${i3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
            const n4 = l3.encode(i3), a4 = [];
            for (let e2 = 0; e2 < o4.length; e2++) {
              const t4 = o4.feature(e2), r3 = c3.getId(t4, i3);
              a4.push({ feature: t4, id: r3, index: e2, sourceLayerIndex: n4 });
            }
            for (const t4 of d3[i3]) {
              const i4 = t4[0];
              i4.source !== this.source && e.w(`layer.source = ${i4.source} does not equal this.source = ${this.source}`), i4.minzoom && this.zoom < Math.floor(i4.minzoom) || i4.maxzoom && this.zoom >= i4.maxzoom || "none" !== i4.visibility && (r2(t4, this.zoom, s3), (h3[i4.id] = i4.createBucket({ index: c3.bucketLayerIDs.length, layers: t4, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n4, sourceID: this.source })).populate(a4, u3, this.tileID.canonical), c3.bucketLayerIDs.push(t4.map((e2) => e2.id)));
            }
          }
          let p3, f3, g3, m3;
          const y3 = e.aH(u3.glyphDependencies, (e2) => Object.keys(e2).map(Number));
          this.inFlightDependencies.forEach((e2) => null == e2 ? void 0 : e2.cancel()), this.inFlightDependencies = [];
          const v3 = ++this.dependencySentinel;
          Object.keys(y3).length ? this.inFlightDependencies.push(n3.send("getGlyphs", { uid: this.uid, stacks: y3, source: this.source, tileID: this.tileID, type: "glyphs" }, (e2, t4) => {
            v3 === this.dependencySentinel && (p3 || (p3 = e2, f3 = t4, b3.call(this)));
          })) : f3 = {};
          const w3 = Object.keys(u3.iconDependencies);
          w3.length ? this.inFlightDependencies.push(n3.send("getImages", { icons: w3, source: this.source, tileID: this.tileID, type: "icons" }, (e2, t4) => {
            v3 === this.dependencySentinel && (p3 || (p3 = e2, g3 = t4, b3.call(this)));
          })) : g3 = {};
          const x3 = Object.keys(u3.patternDependencies);
          function b3() {
            if (p3) return a3(p3);
            if (f3 && g3 && m3) {
              const t4 = new i2(f3), o4 = new e.bp(g3, m3);
              for (const i3 in h3) {
                const n4 = h3[i3];
                n4 instanceof e.a4 ? (r2(n4.layers, this.zoom, s3), e.bq({ bucket: n4, glyphMap: f3, glyphPositions: t4.positions, imageMap: g3, imagePositions: o4.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : n4.hasPattern && (n4 instanceof e.br || n4 instanceof e.bs || n4 instanceof e.bt) && (r2(n4.layers, this.zoom, s3), n4.addFeatures(u3, this.tileID.canonical, o4.patternPositions));
              }
              this.status = "done", a3(null, { buckets: Object.values(h3).filter((e2) => !e2.isEmpty()), featureIndex: c3, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t4.image, imageAtlas: o4, glyphMap: this.returnDependencies ? f3 : null, iconMap: this.returnDependencies ? g3 : null, glyphPositions: this.returnDependencies ? t4.positions : null });
            }
          }
          x3.length ? this.inFlightDependencies.push(n3.send("getImages", { icons: x3, source: this.source, tileID: this.tileID, type: "patterns" }, (e2, t4) => {
            v3 === this.dependencySentinel && (p3 || (p3 = e2, m3 = t4, b3.call(this)));
          })) : m3 = {}, b3.call(this);
        }
      }
      function r2(t3, i3, o3) {
        const r3 = new e.a8(i3);
        for (const e2 of t3) e2.recalculate(r3, o3);
      }
      function s2(t3, i3) {
        const o3 = e.l(t3.request, (o4, r3, s3, n3) => {
          if (o4) i3(o4);
          else if (r3) try {
            const t4 = new e.bw.VectorTile(new e.bv(r3));
            i3(null, { vectorTile: t4, rawData: r3, cacheControl: s3, expires: n3 });
          } catch (e2) {
            const o5 = new Uint8Array(r3);
            let s4 = `Unable to parse the tile at ${t3.request.url}, `;
            s4 += 31 === o5[0] && 139 === o5[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e2.messge}`, i3(new Error(s4));
          }
        });
        return () => {
          o3.cancel(), i3();
        };
      }
      class n2 {
        constructor(e2, t3, i3, o3) {
          this.actor = e2, this.layerIndex = t3, this.availableImages = i3, this.loadVectorData = o3 || s2, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadTile(t3, i3) {
          const r3 = t3.uid;
          this.loading || (this.loading = {});
          const s3 = !!(t3 && t3.request && t3.request.collectResourceTiming) && new e.bu(t3.request), n3 = this.loading[r3] = new o2(t3);
          n3.abort = this.loadVectorData(t3, (t4, o3) => {
            if (delete this.loading[r3], t4 || !o3) return n3.status = "done", this.loaded[r3] = n3, i3(t4);
            const a3 = o3.rawData, l3 = {};
            o3.expires && (l3.expires = o3.expires), o3.cacheControl && (l3.cacheControl = o3.cacheControl);
            const c3 = {};
            if (s3) {
              const e2 = s3.finish();
              e2 && (c3.resourceTiming = JSON.parse(JSON.stringify(e2)));
            }
            n3.vectorTile = o3.vectorTile, n3.parse(o3.vectorTile, this.layerIndex, this.availableImages, this.actor, (t5, o4) => {
              if (delete this.fetching[r3], t5 || !o4) return i3(t5);
              i3(null, e.e({ rawTileData: a3.slice(0) }, o4, l3, c3));
            }), this.loaded = this.loaded || {}, this.loaded[r3] = n3, this.fetching[r3] = { rawTileData: a3, cacheControl: l3, resourceTiming: c3 };
          });
        }
        reloadTile(t3, i3) {
          const o3 = this.loaded, r3 = t3.uid;
          if (o3 && o3[r3]) {
            const s3 = o3[r3];
            s3.showCollisionBoxes = t3.showCollisionBoxes, "parsing" === s3.status ? s3.parse(s3.vectorTile, this.layerIndex, this.availableImages, this.actor, (t4, o4) => {
              if (t4 || !o4) return i3(t4, o4);
              let s4;
              if (this.fetching[r3]) {
                const { rawTileData: t5, cacheControl: i4, resourceTiming: n3 } = this.fetching[r3];
                delete this.fetching[r3], s4 = e.e({ rawTileData: t5.slice(0) }, o4, i4, n3);
              } else s4 = o4;
              i3(null, s4);
            }) : "done" === s3.status && (s3.vectorTile ? s3.parse(s3.vectorTile, this.layerIndex, this.availableImages, this.actor, i3) : i3());
          }
        }
        abortTile(e2, t3) {
          const i3 = this.loading, o3 = e2.uid;
          i3 && i3[o3] && i3[o3].abort && (i3[o3].abort(), delete i3[o3]), t3();
        }
        removeTile(e2, t3) {
          const i3 = this.loaded, o3 = e2.uid;
          i3 && i3[o3] && delete i3[o3], t3();
        }
      }
      class a2 {
        constructor() {
          this.loaded = {};
        }
        loadTile(t3, i3) {
          return e._(this, void 0, void 0, function* () {
            const { uid: o3, encoding: r3, rawImageData: s3, redFactor: n3, greenFactor: a3, blueFactor: l3, baseShift: c3 } = t3, h3 = s3.width + 2, u3 = s3.height + 2, d3 = e.a(s3) ? new e.R({ width: h3, height: u3 }, yield e.bx(s3, -1, -1, h3, u3)) : s3, p3 = new e.by(o3, d3, r3, n3, a3, l3, c3);
            this.loaded = this.loaded || {}, this.loaded[o3] = p3, i3(null, p3);
          });
        }
        removeTile(e2) {
          const t3 = this.loaded, i3 = e2.uid;
          t3 && t3[i3] && delete t3[i3];
        }
      }
      function l2(e2, t3) {
        if (0 !== e2.length) {
          c2(e2[0], t3);
          for (var i3 = 1; i3 < e2.length; i3++) c2(e2[i3], !t3);
        }
      }
      function c2(e2, t3) {
        for (var i3 = 0, o3 = 0, r3 = 0, s3 = e2.length, n3 = s3 - 1; r3 < s3; n3 = r3++) {
          var a3 = (e2[r3][0] - e2[n3][0]) * (e2[n3][1] + e2[r3][1]), l3 = i3 + a3;
          o3 += Math.abs(i3) >= Math.abs(a3) ? i3 - l3 + a3 : a3 - l3 + i3, i3 = l3;
        }
        i3 + o3 >= 0 != !!t3 && e2.reverse();
      }
      var h2 = e.bz(function e2(t3, i3) {
        var o3, r3 = t3 && t3.type;
        if ("FeatureCollection" === r3) for (o3 = 0; o3 < t3.features.length; o3++) e2(t3.features[o3], i3);
        else if ("GeometryCollection" === r3) for (o3 = 0; o3 < t3.geometries.length; o3++) e2(t3.geometries[o3], i3);
        else if ("Feature" === r3) e2(t3.geometry, i3);
        else if ("Polygon" === r3) l2(t3.coordinates, i3);
        else if ("MultiPolygon" === r3) for (o3 = 0; o3 < t3.coordinates.length; o3++) l2(t3.coordinates[o3], i3);
        return t3;
      });
      const u2 = e.bw.VectorTileFeature.prototype.toGeoJSON;
      var d2 = { exports: {} }, p2 = e.bA, f2 = e.bw.VectorTileFeature, g2 = m2;
      function m2(e2, t3) {
        this.options = t3 || {}, this.features = e2, this.length = e2.length;
      }
      function y2(e2, t3) {
        this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t3 || 4096;
      }
      m2.prototype.feature = function(e2) {
        return new y2(this.features[e2], this.options.extent);
      }, y2.prototype.loadGeometry = function() {
        var e2 = this.rawGeometry;
        this.geometry = [];
        for (var t3 = 0; t3 < e2.length; t3++) {
          for (var i3 = e2[t3], o3 = [], r3 = 0; r3 < i3.length; r3++) o3.push(new p2(i3[r3][0], i3[r3][1]));
          this.geometry.push(o3);
        }
        return this.geometry;
      }, y2.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var e2 = this.geometry, t3 = 1 / 0, i3 = -1 / 0, o3 = 1 / 0, r3 = -1 / 0, s3 = 0; s3 < e2.length; s3++) for (var n3 = e2[s3], a3 = 0; a3 < n3.length; a3++) {
          var l3 = n3[a3];
          t3 = Math.min(t3, l3.x), i3 = Math.max(i3, l3.x), o3 = Math.min(o3, l3.y), r3 = Math.max(r3, l3.y);
        }
        return [t3, o3, i3, r3];
      }, y2.prototype.toGeoJSON = f2.prototype.toGeoJSON;
      var v2 = e.bB, w2 = g2;
      function x2(e2) {
        var t3 = new v2();
        return function(e3, t4) {
          for (var i3 in e3.layers) t4.writeMessage(3, b2, e3.layers[i3]);
        }(e2, t3), t3.finish();
      }
      function b2(e2, t3) {
        var i3;
        t3.writeVarintField(15, e2.version || 1), t3.writeStringField(1, e2.name || ""), t3.writeVarintField(5, e2.extent || 4096);
        var o3 = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (i3 = 0; i3 < e2.length; i3++) o3.feature = e2.feature(i3), t3.writeMessage(2, S2, o3);
        var r3 = o3.keys;
        for (i3 = 0; i3 < r3.length; i3++) t3.writeStringField(3, r3[i3]);
        var s3 = o3.values;
        for (i3 = 0; i3 < s3.length; i3++) t3.writeMessage(4, _2, s3[i3]);
      }
      function S2(e2, t3) {
        var i3 = e2.feature;
        void 0 !== i3.id && t3.writeVarintField(1, i3.id), t3.writeMessage(2, M2, e2), t3.writeVarintField(3, i3.type), t3.writeMessage(4, T2, i3);
      }
      function M2(e2, t3) {
        var i3 = e2.feature, o3 = e2.keys, r3 = e2.values, s3 = e2.keycache, n3 = e2.valuecache;
        for (var a3 in i3.properties) {
          var l3 = i3.properties[a3], c3 = s3[a3];
          if (null !== l3) {
            void 0 === c3 && (o3.push(a3), s3[a3] = c3 = o3.length - 1), t3.writeVarint(c3);
            var h3 = typeof l3;
            "string" !== h3 && "boolean" !== h3 && "number" !== h3 && (l3 = JSON.stringify(l3));
            var u3 = h3 + ":" + l3, d3 = n3[u3];
            void 0 === d3 && (r3.push(l3), n3[u3] = d3 = r3.length - 1), t3.writeVarint(d3);
          }
        }
      }
      function I2(e2, t3) {
        return (t3 << 3) + (7 & e2);
      }
      function P2(e2) {
        return e2 << 1 ^ e2 >> 31;
      }
      function T2(e2, t3) {
        for (var i3 = e2.loadGeometry(), o3 = e2.type, r3 = 0, s3 = 0, n3 = i3.length, a3 = 0; a3 < n3; a3++) {
          var l3 = i3[a3], c3 = 1;
          1 === o3 && (c3 = l3.length), t3.writeVarint(I2(1, c3));
          for (var h3 = 3 === o3 ? l3.length - 1 : l3.length, u3 = 0; u3 < h3; u3++) {
            1 === u3 && 1 !== o3 && t3.writeVarint(I2(2, h3 - 1));
            var d3 = l3[u3].x - r3, p3 = l3[u3].y - s3;
            t3.writeVarint(P2(d3)), t3.writeVarint(P2(p3)), r3 += d3, s3 += p3;
          }
          3 === o3 && t3.writeVarint(I2(7, 1));
        }
      }
      function _2(e2, t3) {
        var i3 = typeof e2;
        "string" === i3 ? t3.writeStringField(1, e2) : "boolean" === i3 ? t3.writeBooleanField(7, e2) : "number" === i3 && (e2 % 1 != 0 ? t3.writeDoubleField(3, e2) : e2 < 0 ? t3.writeSVarintField(6, e2) : t3.writeVarintField(5, e2));
      }
      d2.exports = x2, d2.exports.fromVectorTileJs = x2, d2.exports.fromGeojsonVt = function(e2, t3) {
        t3 = t3 || {};
        var i3 = {};
        for (var o3 in e2) i3[o3] = new w2(e2[o3].features, t3), i3[o3].name = o3, i3[o3].version = t3.version, i3[o3].extent = t3.extent;
        return x2({ layers: i3 });
      }, d2.exports.GeoJSONWrapper = w2;
      var k2 = e.bz(d2.exports);
      const D2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, O2 = Math.fround || (C2 = new Float32Array(1), (e2) => (C2[0] = +e2, C2[0]));
      var C2;
      const L2 = 3, F2 = 5, z2 = 6;
      class N2 {
        constructor(e2) {
          this.options = Object.assign(Object.create(D2), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(e2) {
          const { log: t3, minZoom: i3, maxZoom: o3 } = this.options;
          t3 && console.time("total time");
          const r3 = `prepare ${e2.length} points`;
          t3 && console.time(r3), this.points = e2;
          const s3 = [];
          for (let t4 = 0; t4 < e2.length; t4++) {
            const i4 = e2[t4];
            if (!i4.geometry) continue;
            const [o4, r4] = i4.geometry.coordinates, n4 = O2(Z2(o4)), a3 = O2(G2(r4));
            s3.push(n4, a3, 1 / 0, t4, -1, 1), this.options.reduce && s3.push(0);
          }
          let n3 = this.trees[o3 + 1] = this._createTree(s3);
          t3 && console.timeEnd(r3);
          for (let e3 = o3; e3 >= i3; e3--) {
            const i4 = +Date.now();
            n3 = this.trees[e3] = this._createTree(this._cluster(n3, e3)), t3 && console.log("z%d: %d clusters in %dms", e3, n3.numItems, +Date.now() - i4);
          }
          return t3 && console.timeEnd("total time"), this;
        }
        getClusters(e2, t3) {
          let i3 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
          const o3 = Math.max(-90, Math.min(90, e2[1]));
          let r3 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
          const s3 = Math.max(-90, Math.min(90, e2[3]));
          if (e2[2] - e2[0] >= 360) i3 = -180, r3 = 180;
          else if (i3 > r3) {
            const e3 = this.getClusters([i3, o3, 180, s3], t3), n4 = this.getClusters([-180, o3, r3, s3], t3);
            return e3.concat(n4);
          }
          const n3 = this.trees[this._limitZoom(t3)], a3 = n3.range(Z2(i3), G2(s3), Z2(r3), G2(o3)), l3 = n3.data, c3 = [];
          for (const e3 of a3) {
            const t4 = this.stride * e3;
            c3.push(l3[t4 + F2] > 1 ? E2(l3, t4, this.clusterProps) : this.points[l3[t4 + L2]]);
          }
          return c3;
        }
        getChildren(e2) {
          const t3 = this._getOriginId(e2), i3 = this._getOriginZoom(e2), o3 = "No cluster with the specified id.", r3 = this.trees[i3];
          if (!r3) throw new Error(o3);
          const s3 = r3.data;
          if (t3 * this.stride >= s3.length) throw new Error(o3);
          const n3 = this.options.radius / (this.options.extent * Math.pow(2, i3 - 1)), a3 = r3.within(s3[t3 * this.stride], s3[t3 * this.stride + 1], n3), l3 = [];
          for (const t4 of a3) {
            const i4 = t4 * this.stride;
            s3[i4 + 4] === e2 && l3.push(s3[i4 + F2] > 1 ? E2(s3, i4, this.clusterProps) : this.points[s3[i4 + L2]]);
          }
          if (0 === l3.length) throw new Error(o3);
          return l3;
        }
        getLeaves(e2, t3, i3) {
          const o3 = [];
          return this._appendLeaves(o3, e2, t3 = t3 || 10, i3 = i3 || 0, 0), o3;
        }
        getTile(e2, t3, i3) {
          const o3 = this.trees[this._limitZoom(e2)], r3 = Math.pow(2, e2), { extent: s3, radius: n3 } = this.options, a3 = n3 / s3, l3 = (i3 - a3) / r3, c3 = (i3 + 1 + a3) / r3, h3 = { features: [] };
          return this._addTileFeatures(o3.range((t3 - a3) / r3, l3, (t3 + 1 + a3) / r3, c3), o3.data, t3, i3, r3, h3), 0 === t3 && this._addTileFeatures(o3.range(1 - a3 / r3, l3, 1, c3), o3.data, r3, i3, r3, h3), t3 === r3 - 1 && this._addTileFeatures(o3.range(0, l3, a3 / r3, c3), o3.data, -1, i3, r3, h3), h3.features.length ? h3 : null;
        }
        getClusterExpansionZoom(e2) {
          let t3 = this._getOriginZoom(e2) - 1;
          for (; t3 <= this.options.maxZoom; ) {
            const i3 = this.getChildren(e2);
            if (t3++, 1 !== i3.length) break;
            e2 = i3[0].properties.cluster_id;
          }
          return t3;
        }
        _appendLeaves(e2, t3, i3, o3, r3) {
          const s3 = this.getChildren(t3);
          for (const t4 of s3) {
            const s4 = t4.properties;
            if (s4 && s4.cluster ? r3 + s4.point_count <= o3 ? r3 += s4.point_count : r3 = this._appendLeaves(e2, s4.cluster_id, i3, o3, r3) : r3 < o3 ? r3++ : e2.push(t4), e2.length === i3) break;
          }
          return r3;
        }
        _createTree(t3) {
          const i3 = new e.av(t3.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let e2 = 0; e2 < t3.length; e2 += this.stride) i3.add(t3[e2], t3[e2 + 1]);
          return i3.finish(), i3.data = t3, i3;
        }
        _addTileFeatures(e2, t3, i3, o3, r3, s3) {
          for (const n3 of e2) {
            const e3 = n3 * this.stride, a3 = t3[e3 + F2] > 1;
            let l3, c3, h3;
            if (a3) l3 = j2(t3, e3, this.clusterProps), c3 = t3[e3], h3 = t3[e3 + 1];
            else {
              const i4 = this.points[t3[e3 + L2]];
              l3 = i4.properties;
              const [o4, r4] = i4.geometry.coordinates;
              c3 = Z2(o4), h3 = G2(r4);
            }
            const u3 = { type: 1, geometry: [[Math.round(this.options.extent * (c3 * r3 - i3)), Math.round(this.options.extent * (h3 * r3 - o3))]], tags: l3 };
            let d3;
            d3 = a3 || this.options.generateId ? t3[e3 + L2] : this.points[t3[e3 + L2]].id, void 0 !== d3 && (u3.id = d3), s3.features.push(u3);
          }
        }
        _limitZoom(e2) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
        }
        _cluster(e2, t3) {
          const { radius: i3, extent: o3, reduce: r3, minPoints: s3 } = this.options, n3 = i3 / (o3 * Math.pow(2, t3)), a3 = e2.data, l3 = [], c3 = this.stride;
          for (let i4 = 0; i4 < a3.length; i4 += c3) {
            if (a3[i4 + 2] <= t3) continue;
            a3[i4 + 2] = t3;
            const o4 = a3[i4], h3 = a3[i4 + 1], u3 = e2.within(a3[i4], a3[i4 + 1], n3), d3 = a3[i4 + F2];
            let p3 = d3;
            for (const e3 of u3) {
              const i5 = e3 * c3;
              a3[i5 + 2] > t3 && (p3 += a3[i5 + F2]);
            }
            if (p3 > d3 && p3 >= s3) {
              let e3, s4 = o4 * d3, n4 = h3 * d3, f3 = -1;
              const g3 = ((i4 / c3 | 0) << 5) + (t3 + 1) + this.points.length;
              for (const o5 of u3) {
                const l4 = o5 * c3;
                if (a3[l4 + 2] <= t3) continue;
                a3[l4 + 2] = t3;
                const h4 = a3[l4 + F2];
                s4 += a3[l4] * h4, n4 += a3[l4 + 1] * h4, a3[l4 + 4] = g3, r3 && (e3 || (e3 = this._map(a3, i4, true), f3 = this.clusterProps.length, this.clusterProps.push(e3)), r3(e3, this._map(a3, l4)));
              }
              a3[i4 + 4] = g3, l3.push(s4 / p3, n4 / p3, 1 / 0, g3, -1, p3), r3 && l3.push(f3);
            } else {
              for (let e3 = 0; e3 < c3; e3++) l3.push(a3[i4 + e3]);
              if (p3 > 1) for (const e3 of u3) {
                const i5 = e3 * c3;
                if (!(a3[i5 + 2] <= t3)) {
                  a3[i5 + 2] = t3;
                  for (let e4 = 0; e4 < c3; e4++) l3.push(a3[i5 + e4]);
                }
              }
            }
          }
          return l3;
        }
        _getOriginId(e2) {
          return e2 - this.points.length >> 5;
        }
        _getOriginZoom(e2) {
          return (e2 - this.points.length) % 32;
        }
        _map(e2, t3, i3) {
          if (e2[t3 + F2] > 1) {
            const o4 = this.clusterProps[e2[t3 + z2]];
            return i3 ? Object.assign({}, o4) : o4;
          }
          const o3 = this.points[e2[t3 + L2]].properties, r3 = this.options.map(o3);
          return i3 && r3 === o3 ? Object.assign({}, r3) : r3;
        }
      }
      function E2(e2, t3, i3) {
        return { type: "Feature", id: e2[t3 + L2], properties: j2(e2, t3, i3), geometry: { type: "Point", coordinates: [(o3 = e2[t3], 360 * (o3 - 0.5)), J2(e2[t3 + 1])] } };
        var o3;
      }
      function j2(e2, t3, i3) {
        const o3 = e2[t3 + F2], r3 = o3 >= 1e4 ? `${Math.round(o3 / 1e3)}k` : o3 >= 1e3 ? Math.round(o3 / 100) / 10 + "k" : o3, s3 = e2[t3 + z2], n3 = -1 === s3 ? {} : Object.assign({}, i3[s3]);
        return Object.assign(n3, { cluster: true, cluster_id: e2[t3 + L2], point_count: o3, point_count_abbreviated: r3 });
      }
      function Z2(e2) {
        return e2 / 360 + 0.5;
      }
      function G2(e2) {
        const t3 = Math.sin(e2 * Math.PI / 180), i3 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
        return i3 < 0 ? 0 : i3 > 1 ? 1 : i3;
      }
      function J2(e2) {
        const t3 = (180 - 360 * e2) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t3)) / Math.PI - 90;
      }
      function Y2(e2, t3, i3, o3) {
        for (var r3, s3 = o3, n3 = i3 - t3 >> 1, a3 = i3 - t3, l3 = e2[t3], c3 = e2[t3 + 1], h3 = e2[i3], u3 = e2[i3 + 1], d3 = t3 + 3; d3 < i3; d3 += 3) {
          var p3 = A2(e2[d3], e2[d3 + 1], l3, c3, h3, u3);
          if (p3 > s3) r3 = d3, s3 = p3;
          else if (p3 === s3) {
            var f3 = Math.abs(d3 - n3);
            f3 < a3 && (r3 = d3, a3 = f3);
          }
        }
        s3 > o3 && (r3 - t3 > 3 && Y2(e2, t3, r3, o3), e2[r3 + 2] = s3, i3 - r3 > 3 && Y2(e2, r3, i3, o3));
      }
      function A2(e2, t3, i3, o3, r3, s3) {
        var n3 = r3 - i3, a3 = s3 - o3;
        if (0 !== n3 || 0 !== a3) {
          var l3 = ((e2 - i3) * n3 + (t3 - o3) * a3) / (n3 * n3 + a3 * a3);
          l3 > 1 ? (i3 = r3, o3 = s3) : l3 > 0 && (i3 += n3 * l3, o3 += a3 * l3);
        }
        return (n3 = e2 - i3) * n3 + (a3 = t3 - o3) * a3;
      }
      function V2(e2, t3, i3, o3) {
        var r3 = { id: void 0 === e2 ? null : e2, type: t3, geometry: i3, tags: o3, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        return function(e3) {
          var t4 = e3.geometry, i4 = e3.type;
          if ("Point" === i4 || "MultiPoint" === i4 || "LineString" === i4) B2(e3, t4);
          else if ("Polygon" === i4 || "MultiLineString" === i4) for (var o4 = 0; o4 < t4.length; o4++) B2(e3, t4[o4]);
          else if ("MultiPolygon" === i4) for (o4 = 0; o4 < t4.length; o4++) for (var r4 = 0; r4 < t4[o4].length; r4++) B2(e3, t4[o4][r4]);
        }(r3), r3;
      }
      function B2(e2, t3) {
        for (var i3 = 0; i3 < t3.length; i3 += 3) e2.minX = Math.min(e2.minX, t3[i3]), e2.minY = Math.min(e2.minY, t3[i3 + 1]), e2.maxX = Math.max(e2.maxX, t3[i3]), e2.maxY = Math.max(e2.maxY, t3[i3 + 1]);
      }
      function X2(e2, t3, i3, o3) {
        if (t3.geometry) {
          var r3 = t3.geometry.coordinates, s3 = t3.geometry.type, n3 = Math.pow(i3.tolerance / ((1 << i3.maxZoom) * i3.extent), 2), a3 = [], l3 = t3.id;
          if (i3.promoteId ? l3 = t3.properties[i3.promoteId] : i3.generateId && (l3 = o3 || 0), "Point" === s3) q2(r3, a3);
          else if ("MultiPoint" === s3) for (var c3 = 0; c3 < r3.length; c3++) q2(r3[c3], a3);
          else if ("LineString" === s3) R2(r3, a3, n3, false);
          else if ("MultiLineString" === s3) {
            if (i3.lineMetrics) {
              for (c3 = 0; c3 < r3.length; c3++) R2(r3[c3], a3 = [], n3, false), e2.push(V2(l3, "LineString", a3, t3.properties));
              return;
            }
            W2(r3, a3, n3, false);
          } else if ("Polygon" === s3) W2(r3, a3, n3, true);
          else {
            if ("MultiPolygon" !== s3) {
              if ("GeometryCollection" === s3) {
                for (c3 = 0; c3 < t3.geometry.geometries.length; c3++) X2(e2, { id: l3, geometry: t3.geometry.geometries[c3], properties: t3.properties }, i3, o3);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (c3 = 0; c3 < r3.length; c3++) {
              var h3 = [];
              W2(r3[c3], h3, n3, true), a3.push(h3);
            }
          }
          e2.push(V2(l3, s3, a3, t3.properties));
        }
      }
      function q2(e2, t3) {
        t3.push($2(e2[0])), t3.push(U2(e2[1])), t3.push(0);
      }
      function R2(e2, t3, i3, o3) {
        for (var r3, s3, n3 = 0, a3 = 0; a3 < e2.length; a3++) {
          var l3 = $2(e2[a3][0]), c3 = U2(e2[a3][1]);
          t3.push(l3), t3.push(c3), t3.push(0), a3 > 0 && (n3 += o3 ? (r3 * c3 - l3 * s3) / 2 : Math.sqrt(Math.pow(l3 - r3, 2) + Math.pow(c3 - s3, 2))), r3 = l3, s3 = c3;
        }
        var h3 = t3.length - 3;
        t3[2] = 1, Y2(t3, 0, h3, i3), t3[h3 + 2] = 1, t3.size = Math.abs(n3), t3.start = 0, t3.end = t3.size;
      }
      function W2(e2, t3, i3, o3) {
        for (var r3 = 0; r3 < e2.length; r3++) {
          var s3 = [];
          R2(e2[r3], s3, i3, o3), t3.push(s3);
        }
      }
      function $2(e2) {
        return e2 / 360 + 0.5;
      }
      function U2(e2) {
        var t3 = Math.sin(e2 * Math.PI / 180), i3 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
        return i3 < 0 ? 0 : i3 > 1 ? 1 : i3;
      }
      function H2(e2, t3, i3, o3, r3, s3, n3, a3) {
        if (o3 /= t3, s3 >= (i3 /= t3) && n3 < o3) return e2;
        if (n3 < i3 || s3 >= o3) return null;
        for (var l3 = [], c3 = 0; c3 < e2.length; c3++) {
          var h3 = e2[c3], u3 = h3.geometry, d3 = h3.type, p3 = 0 === r3 ? h3.minX : h3.minY, f3 = 0 === r3 ? h3.maxX : h3.maxY;
          if (p3 >= i3 && f3 < o3) l3.push(h3);
          else if (!(f3 < i3 || p3 >= o3)) {
            var g3 = [];
            if ("Point" === d3 || "MultiPoint" === d3) K2(u3, g3, i3, o3, r3);
            else if ("LineString" === d3) Q2(u3, g3, i3, o3, r3, false, a3.lineMetrics);
            else if ("MultiLineString" === d3) te2(u3, g3, i3, o3, r3, false);
            else if ("Polygon" === d3) te2(u3, g3, i3, o3, r3, true);
            else if ("MultiPolygon" === d3) for (var m3 = 0; m3 < u3.length; m3++) {
              var y3 = [];
              te2(u3[m3], y3, i3, o3, r3, true), y3.length && g3.push(y3);
            }
            if (g3.length) {
              if (a3.lineMetrics && "LineString" === d3) {
                for (m3 = 0; m3 < g3.length; m3++) l3.push(V2(h3.id, d3, g3[m3], h3.tags));
                continue;
              }
              "LineString" !== d3 && "MultiLineString" !== d3 || (1 === g3.length ? (d3 = "LineString", g3 = g3[0]) : d3 = "MultiLineString"), "Point" !== d3 && "MultiPoint" !== d3 || (d3 = 3 === g3.length ? "Point" : "MultiPoint"), l3.push(V2(h3.id, d3, g3, h3.tags));
            }
          }
        }
        return l3.length ? l3 : null;
      }
      function K2(e2, t3, i3, o3, r3) {
        for (var s3 = 0; s3 < e2.length; s3 += 3) {
          var n3 = e2[s3 + r3];
          n3 >= i3 && n3 <= o3 && (t3.push(e2[s3]), t3.push(e2[s3 + 1]), t3.push(e2[s3 + 2]));
        }
      }
      function Q2(e2, t3, i3, o3, r3, s3, n3) {
        for (var a3, l3, c3 = ee2(e2), h3 = 0 === r3 ? oe2 : re2, u3 = e2.start, d3 = 0; d3 < e2.length - 3; d3 += 3) {
          var p3 = e2[d3], f3 = e2[d3 + 1], g3 = e2[d3 + 2], m3 = e2[d3 + 3], y3 = e2[d3 + 4], v3 = 0 === r3 ? p3 : f3, w3 = 0 === r3 ? m3 : y3, x3 = false;
          n3 && (a3 = Math.sqrt(Math.pow(p3 - m3, 2) + Math.pow(f3 - y3, 2))), v3 < i3 ? w3 > i3 && (l3 = h3(c3, p3, f3, m3, y3, i3), n3 && (c3.start = u3 + a3 * l3)) : v3 > o3 ? w3 < o3 && (l3 = h3(c3, p3, f3, m3, y3, o3), n3 && (c3.start = u3 + a3 * l3)) : ie2(c3, p3, f3, g3), w3 < i3 && v3 >= i3 && (l3 = h3(c3, p3, f3, m3, y3, i3), x3 = true), w3 > o3 && v3 <= o3 && (l3 = h3(c3, p3, f3, m3, y3, o3), x3 = true), !s3 && x3 && (n3 && (c3.end = u3 + a3 * l3), t3.push(c3), c3 = ee2(e2)), n3 && (u3 += a3);
        }
        var b3 = e2.length - 3;
        p3 = e2[b3], f3 = e2[b3 + 1], g3 = e2[b3 + 2], (v3 = 0 === r3 ? p3 : f3) >= i3 && v3 <= o3 && ie2(c3, p3, f3, g3), b3 = c3.length - 3, s3 && b3 >= 3 && (c3[b3] !== c3[0] || c3[b3 + 1] !== c3[1]) && ie2(c3, c3[0], c3[1], c3[2]), c3.length && t3.push(c3);
      }
      function ee2(e2) {
        var t3 = [];
        return t3.size = e2.size, t3.start = e2.start, t3.end = e2.end, t3;
      }
      function te2(e2, t3, i3, o3, r3, s3) {
        for (var n3 = 0; n3 < e2.length; n3++) Q2(e2[n3], t3, i3, o3, r3, s3, false);
      }
      function ie2(e2, t3, i3, o3) {
        e2.push(t3), e2.push(i3), e2.push(o3);
      }
      function oe2(e2, t3, i3, o3, r3, s3) {
        var n3 = (s3 - t3) / (o3 - t3);
        return e2.push(s3), e2.push(i3 + (r3 - i3) * n3), e2.push(1), n3;
      }
      function re2(e2, t3, i3, o3, r3, s3) {
        var n3 = (s3 - i3) / (r3 - i3);
        return e2.push(t3 + (o3 - t3) * n3), e2.push(s3), e2.push(1), n3;
      }
      function se2(e2, t3) {
        for (var i3 = [], o3 = 0; o3 < e2.length; o3++) {
          var r3, s3 = e2[o3], n3 = s3.type;
          if ("Point" === n3 || "MultiPoint" === n3 || "LineString" === n3) r3 = ne2(s3.geometry, t3);
          else if ("MultiLineString" === n3 || "Polygon" === n3) {
            r3 = [];
            for (var a3 = 0; a3 < s3.geometry.length; a3++) r3.push(ne2(s3.geometry[a3], t3));
          } else if ("MultiPolygon" === n3) for (r3 = [], a3 = 0; a3 < s3.geometry.length; a3++) {
            for (var l3 = [], c3 = 0; c3 < s3.geometry[a3].length; c3++) l3.push(ne2(s3.geometry[a3][c3], t3));
            r3.push(l3);
          }
          i3.push(V2(s3.id, n3, r3, s3.tags));
        }
        return i3;
      }
      function ne2(e2, t3) {
        var i3 = [];
        i3.size = e2.size, void 0 !== e2.start && (i3.start = e2.start, i3.end = e2.end);
        for (var o3 = 0; o3 < e2.length; o3 += 3) i3.push(e2[o3] + t3, e2[o3 + 1], e2[o3 + 2]);
        return i3;
      }
      function ae2(e2, t3) {
        if (e2.transformed) return e2;
        var i3, o3, r3, s3 = 1 << e2.z, n3 = e2.x, a3 = e2.y;
        for (i3 = 0; i3 < e2.features.length; i3++) {
          var l3 = e2.features[i3], c3 = l3.geometry, h3 = l3.type;
          if (l3.geometry = [], 1 === h3) for (o3 = 0; o3 < c3.length; o3 += 2) l3.geometry.push(le2(c3[o3], c3[o3 + 1], t3, s3, n3, a3));
          else for (o3 = 0; o3 < c3.length; o3++) {
            var u3 = [];
            for (r3 = 0; r3 < c3[o3].length; r3 += 2) u3.push(le2(c3[o3][r3], c3[o3][r3 + 1], t3, s3, n3, a3));
            l3.geometry.push(u3);
          }
        }
        return e2.transformed = true, e2;
      }
      function le2(e2, t3, i3, o3, r3, s3) {
        return [Math.round(i3 * (e2 * o3 - r3)), Math.round(i3 * (t3 * o3 - s3))];
      }
      function ce2(e2, t3, i3, o3, r3) {
        for (var s3 = t3 === r3.maxZoom ? 0 : r3.tolerance / ((1 << t3) * r3.extent), n3 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: i3, y: o3, z: t3, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a3 = 0; a3 < e2.length; a3++) {
          n3.numFeatures++, he2(n3, e2[a3], s3, r3);
          var l3 = e2[a3].minX, c3 = e2[a3].minY, h3 = e2[a3].maxX, u3 = e2[a3].maxY;
          l3 < n3.minX && (n3.minX = l3), c3 < n3.minY && (n3.minY = c3), h3 > n3.maxX && (n3.maxX = h3), u3 > n3.maxY && (n3.maxY = u3);
        }
        return n3;
      }
      function he2(e2, t3, i3, o3) {
        var r3 = t3.geometry, s3 = t3.type, n3 = [];
        if ("Point" === s3 || "MultiPoint" === s3) for (var a3 = 0; a3 < r3.length; a3 += 3) n3.push(r3[a3]), n3.push(r3[a3 + 1]), e2.numPoints++, e2.numSimplified++;
        else if ("LineString" === s3) ue2(n3, r3, e2, i3, false, false);
        else if ("MultiLineString" === s3 || "Polygon" === s3) for (a3 = 0; a3 < r3.length; a3++) ue2(n3, r3[a3], e2, i3, "Polygon" === s3, 0 === a3);
        else if ("MultiPolygon" === s3) for (var l3 = 0; l3 < r3.length; l3++) {
          var c3 = r3[l3];
          for (a3 = 0; a3 < c3.length; a3++) ue2(n3, c3[a3], e2, i3, true, 0 === a3);
        }
        if (n3.length) {
          var h3 = t3.tags || null;
          if ("LineString" === s3 && o3.lineMetrics) {
            for (var u3 in h3 = {}, t3.tags) h3[u3] = t3.tags[u3];
            h3.mapbox_clip_start = r3.start / r3.size, h3.mapbox_clip_end = r3.end / r3.size;
          }
          var d3 = { geometry: n3, type: "Polygon" === s3 || "MultiPolygon" === s3 ? 3 : "LineString" === s3 || "MultiLineString" === s3 ? 2 : 1, tags: h3 };
          null !== t3.id && (d3.id = t3.id), e2.features.push(d3);
        }
      }
      function ue2(e2, t3, i3, o3, r3, s3) {
        var n3 = o3 * o3;
        if (o3 > 0 && t3.size < (r3 ? n3 : o3)) i3.numPoints += t3.length / 3;
        else {
          for (var a3 = [], l3 = 0; l3 < t3.length; l3 += 3) (0 === o3 || t3[l3 + 2] > n3) && (i3.numSimplified++, a3.push(t3[l3]), a3.push(t3[l3 + 1])), i3.numPoints++;
          r3 && function(e3, t4) {
            for (var i4 = 0, o4 = 0, r4 = e3.length, s4 = r4 - 2; o4 < r4; s4 = o4, o4 += 2) i4 += (e3[o4] - e3[s4]) * (e3[o4 + 1] + e3[s4 + 1]);
            if (i4 > 0 === t4) for (o4 = 0, r4 = e3.length; o4 < r4 / 2; o4 += 2) {
              var n4 = e3[o4], a4 = e3[o4 + 1];
              e3[o4] = e3[r4 - 2 - o4], e3[o4 + 1] = e3[r4 - 1 - o4], e3[r4 - 2 - o4] = n4, e3[r4 - 1 - o4] = a4;
            }
          }(a3, s3), e2.push(a3);
        }
      }
      function de2(e2, t3) {
        var i3 = (t3 = this.options = function(e3, t4) {
          for (var i4 in t4) e3[i4] = t4[i4];
          return e3;
        }(Object.create(this.options), t3)).debug;
        if (i3 && console.time("preprocess data"), t3.maxZoom < 0 || t3.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
        if (t3.promoteId && t3.generateId) throw new Error("promoteId and generateId cannot be used together.");
        var o3 = function(e3, t4) {
          var i4 = [];
          if ("FeatureCollection" === e3.type) for (var o4 = 0; o4 < e3.features.length; o4++) X2(i4, e3.features[o4], t4, o4);
          else X2(i4, "Feature" === e3.type ? e3 : { geometry: e3 }, t4);
          return i4;
        }(e2, t3);
        this.tiles = {}, this.tileCoords = [], i3 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t3.indexMaxZoom, t3.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o3 = function(e3, t4) {
          var i4 = t4.buffer / t4.extent, o4 = e3, r3 = H2(e3, 1, -1 - i4, i4, 0, -1, 2, t4), s3 = H2(e3, 1, 1 - i4, 2 + i4, 0, -1, 2, t4);
          return (r3 || s3) && (o4 = H2(e3, 1, -i4, 1 + i4, 0, -1, 2, t4) || [], r3 && (o4 = se2(r3, 1).concat(o4)), s3 && (o4 = o4.concat(se2(s3, -1)))), o4;
        }(o3, t3), o3.length && this.splitTile(o3, 0, 0, 0), i3 && (o3.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
      }
      function pe2(e2, t3, i3) {
        return 32 * ((1 << e2) * i3 + t3) + e2;
      }
      function fe2(e2, t3) {
        return t3 ? e2.properties[t3] : e2.id;
      }
      function ge2(e2, t3) {
        if (null == e2) return true;
        if ("Feature" === e2.type) return null != fe2(e2, t3);
        if ("FeatureCollection" === e2.type) {
          const i3 = /* @__PURE__ */ new Set();
          for (const o3 of e2.features) {
            const e3 = fe2(o3, t3);
            if (null == e3) return false;
            if (i3.has(e3)) return false;
            i3.add(e3);
          }
          return true;
        }
        return false;
      }
      function me2(e2, t3) {
        const i3 = /* @__PURE__ */ new Map();
        if (null == e2) ;
        else if ("Feature" === e2.type) i3.set(fe2(e2, t3), e2);
        else for (const o3 of e2.features) i3.set(fe2(o3, t3), o3);
        return i3;
      }
      de2.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, de2.prototype.splitTile = function(e2, t3, i3, o3, r3, s3, n3) {
        for (var a3 = [e2, t3, i3, o3], l3 = this.options, c3 = l3.debug; a3.length; ) {
          o3 = a3.pop(), i3 = a3.pop(), t3 = a3.pop(), e2 = a3.pop();
          var h3 = 1 << t3, u3 = pe2(t3, i3, o3), d3 = this.tiles[u3];
          if (!d3 && (c3 > 1 && console.time("creation"), d3 = this.tiles[u3] = ce2(e2, t3, i3, o3, l3), this.tileCoords.push({ z: t3, x: i3, y: o3 }), c3)) {
            c3 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t3, i3, o3, d3.numFeatures, d3.numPoints, d3.numSimplified), console.timeEnd("creation"));
            var p3 = "z" + t3;
            this.stats[p3] = (this.stats[p3] || 0) + 1, this.total++;
          }
          if (d3.source = e2, r3) {
            if (t3 === l3.maxZoom || t3 === r3) continue;
            var f3 = 1 << r3 - t3;
            if (i3 !== Math.floor(s3 / f3) || o3 !== Math.floor(n3 / f3)) continue;
          } else if (t3 === l3.indexMaxZoom || d3.numPoints <= l3.indexMaxPoints) continue;
          if (d3.source = null, 0 !== e2.length) {
            c3 > 1 && console.time("clipping");
            var g3, m3, y3, v3, w3, x3, b3 = 0.5 * l3.buffer / l3.extent, S3 = 0.5 - b3, M3 = 0.5 + b3, I3 = 1 + b3;
            g3 = m3 = y3 = v3 = null, w3 = H2(e2, h3, i3 - b3, i3 + M3, 0, d3.minX, d3.maxX, l3), x3 = H2(e2, h3, i3 + S3, i3 + I3, 0, d3.minX, d3.maxX, l3), e2 = null, w3 && (g3 = H2(w3, h3, o3 - b3, o3 + M3, 1, d3.minY, d3.maxY, l3), m3 = H2(w3, h3, o3 + S3, o3 + I3, 1, d3.minY, d3.maxY, l3), w3 = null), x3 && (y3 = H2(x3, h3, o3 - b3, o3 + M3, 1, d3.minY, d3.maxY, l3), v3 = H2(x3, h3, o3 + S3, o3 + I3, 1, d3.minY, d3.maxY, l3), x3 = null), c3 > 1 && console.timeEnd("clipping"), a3.push(g3 || [], t3 + 1, 2 * i3, 2 * o3), a3.push(m3 || [], t3 + 1, 2 * i3, 2 * o3 + 1), a3.push(y3 || [], t3 + 1, 2 * i3 + 1, 2 * o3), a3.push(v3 || [], t3 + 1, 2 * i3 + 1, 2 * o3 + 1);
          }
        }
      }, de2.prototype.getTile = function(e2, t3, i3) {
        var o3 = this.options, r3 = o3.extent, s3 = o3.debug;
        if (e2 < 0 || e2 > 24) return null;
        var n3 = 1 << e2, a3 = pe2(e2, t3 = (t3 % n3 + n3) % n3, i3);
        if (this.tiles[a3]) return ae2(this.tiles[a3], r3);
        s3 > 1 && console.log("drilling down to z%d-%d-%d", e2, t3, i3);
        for (var l3, c3 = e2, h3 = t3, u3 = i3; !l3 && c3 > 0; ) c3--, h3 = Math.floor(h3 / 2), u3 = Math.floor(u3 / 2), l3 = this.tiles[pe2(c3, h3, u3)];
        return l3 && l3.source ? (s3 > 1 && console.log("found parent tile z%d-%d-%d", c3, h3, u3), s3 > 1 && console.time("drilling down"), this.splitTile(l3.source, c3, h3, u3, e2, t3, i3), s3 > 1 && console.timeEnd("drilling down"), this.tiles[a3] ? ae2(this.tiles[a3], r3) : null) : null;
      };
      class ye2 extends n2 {
        constructor(t3, i3, o3, r3) {
          super(t3, i3, o3), this._dataUpdateable = /* @__PURE__ */ new Map(), this.loadGeoJSON = (t4, i4) => {
            const { promoteId: o4 } = t4;
            if (t4.request) return e.f(t4.request, (e2, t5, r4, s3) => {
              this._dataUpdateable = ge2(t5, o4) ? me2(t5, o4) : void 0, i4(e2, t5, r4, s3);
            });
            if ("string" == typeof t4.data) try {
              const e2 = JSON.parse(t4.data);
              this._dataUpdateable = ge2(e2, o4) ? me2(e2, o4) : void 0, i4(null, e2);
            } catch (e2) {
              i4(new Error(`Input data given to '${t4.source}' is not a valid GeoJSON object.`));
            }
            else t4.dataDiff ? this._dataUpdateable ? (function(e2, t5, i5) {
              var o5, r4, s3, n3;
              if (t5.removeAll && e2.clear(), t5.remove) for (const i6 of t5.remove) e2.delete(i6);
              if (t5.add) for (const o6 of t5.add) {
                const t6 = fe2(o6, i5);
                null != t6 && e2.set(t6, o6);
              }
              if (t5.update) for (const i6 of t5.update) {
                let t6 = e2.get(i6.id);
                if (null == t6) continue;
                const a3 = !i6.removeAllProperties && ((null === (o5 = i6.removeProperties) || void 0 === o5 ? void 0 : o5.length) > 0 || (null === (r4 = i6.addOrUpdateProperties) || void 0 === r4 ? void 0 : r4.length) > 0);
                if ((i6.newGeometry || i6.removeAllProperties || a3) && (t6 = Object.assign({}, t6), e2.set(i6.id, t6), a3 && (t6.properties = Object.assign({}, t6.properties))), i6.newGeometry && (t6.geometry = i6.newGeometry), i6.removeAllProperties) t6.properties = {};
                else if ((null === (s3 = i6.removeProperties) || void 0 === s3 ? void 0 : s3.length) > 0) for (const e3 of i6.removeProperties) Object.prototype.hasOwnProperty.call(t6.properties, e3) && delete t6.properties[e3];
                if ((null === (n3 = i6.addOrUpdateProperties) || void 0 === n3 ? void 0 : n3.length) > 0) for (const { key: e3, value: o6 } of i6.addOrUpdateProperties) t6.properties[e3] = o6;
              }
            }(this._dataUpdateable, t4.dataDiff, o4), i4(null, { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) })) : i4(new Error(`Cannot update existing geojson data in ${t4.source}`)) : i4(new Error(`Input data given to '${t4.source}' is not a valid GeoJSON object.`));
            return { cancel: () => {
            } };
          }, this.loadVectorData = this.loadGeoJSONTile, r3 && (this.loadGeoJSON = r3);
        }
        loadGeoJSONTile(t3, i3) {
          const o3 = t3.tileID.canonical;
          if (!this._geoJSONIndex) return i3(null, null);
          const r3 = this._geoJSONIndex.getTile(o3.z, o3.x, o3.y);
          if (!r3) return i3(null, null);
          const s3 = new class {
            constructor(t4) {
              this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.N, this.length = t4.length, this._features = t4;
            }
            feature(t4) {
              return new class {
                constructor(t5) {
                  this._feature = t5, this.extent = e.N, this.type = t5.type, this.properties = t5.tags, "id" in t5 && !isNaN(t5.id) && (this.id = parseInt(t5.id, 10));
                }
                loadGeometry() {
                  if (1 === this._feature.type) {
                    const t5 = [];
                    for (const i4 of this._feature.geometry) t5.push([new e.P(i4[0], i4[1])]);
                    return t5;
                  }
                  {
                    const t5 = [];
                    for (const i4 of this._feature.geometry) {
                      const o4 = [];
                      for (const t6 of i4) o4.push(new e.P(t6[0], t6[1]));
                      t5.push(o4);
                    }
                    return t5;
                  }
                }
                toGeoJSON(e2, t5, i4) {
                  return u2.call(this, e2, t5, i4);
                }
              }(this._features[t4]);
            }
          }(r3.features);
          let n3 = k2(s3);
          0 === n3.byteOffset && n3.byteLength === n3.buffer.byteLength || (n3 = new Uint8Array(n3)), i3(null, { vectorTile: s3, rawData: n3.buffer });
        }
        loadData(t3, i3) {
          var o3;
          null === (o3 = this._pendingRequest) || void 0 === o3 || o3.cancel(), this._pendingCallback && this._pendingCallback(null, { abandoned: true });
          const r3 = !!(t3 && t3.request && t3.request.collectResourceTiming) && new e.bu(t3.request);
          this._pendingCallback = i3, this._pendingRequest = this.loadGeoJSON(t3, (o4, s3) => {
            if (delete this._pendingCallback, delete this._pendingRequest, o4 || !s3) return i3(o4);
            if ("object" != typeof s3) return i3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
            {
              h2(s3, true);
              try {
                if (t3.filter) {
                  const i4 = e.bC(t3.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                  if ("error" === i4.result) throw new Error(i4.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                  const o5 = s3.features.filter((e2) => i4.value.evaluate({ zoom: 0 }, e2));
                  s3 = { type: "FeatureCollection", features: o5 };
                }
                this._geoJSONIndex = t3.cluster ? new N2(function({ superclusterOptions: t4, clusterProperties: i4 }) {
                  if (!i4 || !t4) return t4;
                  const o5 = {}, r4 = {}, s4 = { accumulated: null, zoom: 0 }, n4 = { properties: null }, a3 = Object.keys(i4);
                  for (const t5 of a3) {
                    const [s5, n5] = i4[t5], a4 = e.bC(n5), l3 = e.bC("string" == typeof s5 ? [s5, ["accumulated"], ["get", t5]] : s5);
                    o5[t5] = a4.value, r4[t5] = l3.value;
                  }
                  return t4.map = (e2) => {
                    n4.properties = e2;
                    const t5 = {};
                    for (const e3 of a3) t5[e3] = o5[e3].evaluate(s4, n4);
                    return t5;
                  }, t4.reduce = (e2, t5) => {
                    n4.properties = t5;
                    for (const t6 of a3) s4.accumulated = e2[t6], e2[t6] = r4[t6].evaluate(s4, n4);
                  }, t4;
                }(t3)).load(s3.features) : function(e2, t4) {
                  return new de2(e2, t4);
                }(s3, t3.geojsonVtOptions);
              } catch (o5) {
                return i3(o5);
              }
              this.loaded = {};
              const n3 = {};
              if (r3) {
                const e2 = r3.finish();
                e2 && (n3.resourceTiming = {}, n3.resourceTiming[t3.source] = JSON.parse(JSON.stringify(e2)));
              }
              i3(null, n3);
            }
          });
        }
        reloadTile(e2, t3) {
          const i3 = this.loaded;
          return i3 && i3[e2.uid] ? super.reloadTile(e2, t3) : this.loadTile(e2, t3);
        }
        removeSource(e2, t3) {
          this._pendingCallback && this._pendingCallback(null, { abandoned: true }), t3();
        }
        getClusterExpansionZoom(e2, t3) {
          try {
            t3(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
          } catch (e3) {
            t3(e3);
          }
        }
        getClusterChildren(e2, t3) {
          try {
            t3(null, this._geoJSONIndex.getChildren(e2.clusterId));
          } catch (e3) {
            t3(e3);
          }
        }
        getClusterLeaves(e2, t3) {
          try {
            t3(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
          } catch (e3) {
            t3(e3);
          }
        }
      }
      class ve2 {
        constructor(t3) {
          this.self = t3, this.actor = new e.C(t3, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: n2, geojson: ye2 }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e2, t4) => {
            if (this.workerSourceTypes[e2]) throw new Error(`Worker source with name "${e2}" already registered.`);
            this.workerSourceTypes[e2] = t4;
          }, this.self.registerRTLTextPlugin = (t4) => {
            if (e.bD.isParsed()) throw new Error("RTL text plugin already registered.");
            e.bD.applyArabicShaping = t4.applyArabicShaping, e.bD.processBidirectionalText = t4.processBidirectionalText, e.bD.processStyledBidirectionalText = t4.processStyledBidirectionalText;
          };
        }
        setReferrer(e2, t3) {
          this.referrer = t3;
        }
        setImages(e2, t3, i3) {
          this.availableImages[e2] = t3;
          for (const i4 in this.workerSources[e2]) {
            const o3 = this.workerSources[e2][i4];
            for (const e3 in o3) o3[e3].availableImages = t3;
          }
          i3();
        }
        setLayers(e2, t3, i3) {
          this.getLayerIndex(e2).replace(t3), i3();
        }
        updateLayers(e2, t3, i3) {
          this.getLayerIndex(e2).update(t3.layers, t3.removedIds), i3();
        }
        loadTile(e2, t3, i3) {
          this.getWorkerSource(e2, t3.type, t3.source).loadTile(t3, i3);
        }
        loadDEMTile(e2, t3, i3) {
          this.getDEMWorkerSource(e2, t3.source).loadTile(t3, i3);
        }
        reloadTile(e2, t3, i3) {
          this.getWorkerSource(e2, t3.type, t3.source).reloadTile(t3, i3);
        }
        abortTile(e2, t3, i3) {
          this.getWorkerSource(e2, t3.type, t3.source).abortTile(t3, i3);
        }
        removeTile(e2, t3, i3) {
          this.getWorkerSource(e2, t3.type, t3.source).removeTile(t3, i3);
        }
        removeDEMTile(e2, t3) {
          this.getDEMWorkerSource(e2, t3.source).removeTile(t3);
        }
        removeSource(e2, t3, i3) {
          if (!this.workerSources[e2] || !this.workerSources[e2][t3.type] || !this.workerSources[e2][t3.type][t3.source]) return;
          const o3 = this.workerSources[e2][t3.type][t3.source];
          delete this.workerSources[e2][t3.type][t3.source], void 0 !== o3.removeSource ? o3.removeSource(t3, i3) : i3();
        }
        loadWorkerSource(e2, t3, i3) {
          try {
            this.self.importScripts(t3.url), i3();
          } catch (e3) {
            i3(e3.toString());
          }
        }
        syncRTLPluginState(t3, i3, o3) {
          try {
            e.bD.setState(i3);
            const t4 = e.bD.getPluginURL();
            if (e.bD.isLoaded() && !e.bD.isParsed() && null != t4) {
              this.self.importScripts(t4);
              const i4 = e.bD.isParsed();
              o3(i4 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t4}`), i4);
            }
          } catch (e2) {
            o3(e2.toString());
          }
        }
        getAvailableImages(e2) {
          let t3 = this.availableImages[e2];
          return t3 || (t3 = []), t3;
        }
        getLayerIndex(e2) {
          let i3 = this.layerIndexes[e2];
          return i3 || (i3 = this.layerIndexes[e2] = new t2()), i3;
        }
        getWorkerSource(e2, t3, i3) {
          return this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t3] || (this.workerSources[e2][t3] = {}), this.workerSources[e2][t3][i3] || (this.workerSources[e2][t3][i3] = new this.workerSourceTypes[t3]({ send: (t4, i4, o3) => {
            this.actor.send(t4, i4, o3, e2);
          } }, this.getLayerIndex(e2), this.getAvailableImages(e2))), this.workerSources[e2][t3][i3];
        }
        getDEMWorkerSource(e2, t3) {
          return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t3] || (this.demWorkerSources[e2][t3] = new a2()), this.demWorkerSources[e2][t3];
        }
      }
      return e.i() && (self.worker = new ve2(self)), ve2;
    });
    define(["./shared"], function(t2) {
      var e = "3.6.2";
      class i2 {
        static testProp(t3) {
          if (!i2.docStyle) return t3[0];
          for (let e2 = 0; e2 < t3.length; e2++) if (t3[e2] in i2.docStyle) return t3[e2];
          return t3[0];
        }
        static create(t3, e2, i3) {
          const s3 = window.document.createElement(t3);
          return void 0 !== e2 && (s3.className = e2), i3 && i3.appendChild(s3), s3;
        }
        static createNS(t3, e2) {
          return window.document.createElementNS(t3, e2);
        }
        static disableDrag() {
          i2.docStyle && i2.selectProp && (i2.userSelect = i2.docStyle[i2.selectProp], i2.docStyle[i2.selectProp] = "none");
        }
        static enableDrag() {
          i2.docStyle && i2.selectProp && (i2.docStyle[i2.selectProp] = i2.userSelect);
        }
        static setTransform(t3, e2) {
          t3.style[i2.transformProp] = e2;
        }
        static addEventListener(t3, e2, i3, s3 = {}) {
          t3.addEventListener(e2, i3, "passive" in s3 ? s3 : s3.capture);
        }
        static removeEventListener(t3, e2, i3, s3 = {}) {
          t3.removeEventListener(e2, i3, "passive" in s3 ? s3 : s3.capture);
        }
        static suppressClickInternal(t3) {
          t3.preventDefault(), t3.stopPropagation(), window.removeEventListener("click", i2.suppressClickInternal, true);
        }
        static suppressClick() {
          window.addEventListener("click", i2.suppressClickInternal, true), window.setTimeout(() => {
            window.removeEventListener("click", i2.suppressClickInternal, true);
          }, 0);
        }
        static mousePos(e2, i3) {
          const s3 = e2.getBoundingClientRect();
          return new t2.P(i3.clientX - s3.left - e2.clientLeft, i3.clientY - s3.top - e2.clientTop);
        }
        static touchPos(e2, i3) {
          const s3 = e2.getBoundingClientRect(), a3 = [];
          for (let o3 = 0; o3 < i3.length; o3++) a3.push(new t2.P(i3[o3].clientX - s3.left - e2.clientLeft, i3[o3].clientY - s3.top - e2.clientTop));
          return a3;
        }
        static mouseButton(t3) {
          return t3.button;
        }
        static remove(t3) {
          t3.parentNode && t3.parentNode.removeChild(t3);
        }
      }
      i2.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, i2.selectProp = i2.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), i2.transformProp = i2.testProp(["transform", "WebkitTransform"]);
      const s2 = { supported: false, testSupport: function(t3) {
        !r2 && o2 && (n2 ? l2(t3) : a2 = t3);
      } };
      let a2, o2, r2 = false, n2 = false;
      function l2(t3) {
        const e2 = t3.createTexture();
        t3.bindTexture(t3.TEXTURE_2D, e2);
        try {
          if (t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE, o2), t3.isContextLost()) return;
          s2.supported = true;
        } catch (t4) {
        }
        t3.deleteTexture(e2), r2 = true;
      }
      var h2, c2;
      "undefined" != typeof document && (o2 = document.createElement("img"), o2.onload = function() {
        a2 && l2(a2), a2 = null, n2 = true;
      }, o2.onerror = function() {
        r2 = true, a2 = null;
      }, o2.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e2) {
        let i3, a3, o3, r3;
        e2.resetRequestQueue = () => {
          i3 = [], a3 = 0, o3 = 0, r3 = {};
        }, e2.addThrottleControl = (t3) => {
          const e3 = o3++;
          return r3[e3] = t3, e3;
        }, e2.removeThrottleControl = (t3) => {
          delete r3[t3], h3();
        }, e2.getImage = (t3, e3, o4 = true) => {
          s2.supported && (t3.headers || (t3.headers = {}), t3.headers.accept = "image/webp,*/*");
          const r4 = { requestParameters: t3, supportImageRefresh: o4, callback: e3, cancelled: false, completed: false, cancel: () => {
            r4.completed || r4.cancelled || (r4.cancelled = true, r4.innerRequest && (r4.innerRequest.cancel(), a3--), h3());
          } };
          return i3.push(r4), h3(), r4;
        };
        const n3 = (e3) => {
          const { requestParameters: i4, supportImageRefresh: s3, callback: a4 } = e3;
          return t2.e(i4, { type: "image" }), (false !== s3 || t2.i() || t2.g(i4.url) || i4.headers && !Object.keys(i4.headers).reduce((t3, e4) => t3 && "accept" === e4, true) ? t2.m : c3)(i4, (t3, i5, s4, o4) => {
            l3(e3, a4, t3, i5, s4, o4);
          });
        }, l3 = (e3, i4, s3, o4, r4, n4) => {
          s3 ? i4(s3) : o4 instanceof HTMLImageElement || t2.a(o4) ? i4(null, o4) : o4 && ((e4, i5) => {
            "function" == typeof createImageBitmap ? t2.b(e4, i5) : t2.d(e4, i5);
          })(o4, (t3, e4) => {
            null != t3 ? i4(t3) : null != e4 && i4(null, e4, { cacheControl: r4, expires: n4 });
          }), e3.cancelled || (e3.completed = true, a3--, h3());
        }, h3 = () => {
          const e3 = (() => {
            const t3 = Object.keys(r3);
            let e4 = false;
            if (t3.length > 0) {
              for (const i4 of t3) if (e4 = r3[i4](), e4) break;
            }
            return e4;
          })() ? t2.c.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t2.c.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let t3 = a3; t3 < e3 && i3.length > 0; t3++) {
            const e4 = i3.shift();
            if (e4.cancelled) {
              t3--;
              continue;
            }
            const s3 = n3(e4);
            a3++, e4.innerRequest = s3;
          }
        }, c3 = (e3, i4) => {
          const s3 = new Image(), a4 = e3.url;
          let o4 = false;
          const r4 = e3.credentials;
          return r4 && "include" === r4 ? s3.crossOrigin = "use-credentials" : (r4 && "same-origin" === r4 || !t2.s(a4)) && (s3.crossOrigin = "anonymous"), s3.fetchPriority = "high", s3.onload = () => {
            i4(null, s3), s3.onerror = s3.onload = null;
          }, s3.onerror = () => {
            o4 || i4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")), s3.onerror = s3.onload = null;
          }, s3.src = a4, { cancel: () => {
            o4 = true, s3.src = "";
          } };
        };
      }(h2 || (h2 = {})), h2.resetRequestQueue(), function(t3) {
        t3.Glyphs = "Glyphs", t3.Image = "Image", t3.Source = "Source", t3.SpriteImage = "SpriteImage", t3.SpriteJSON = "SpriteJSON", t3.Style = "Style", t3.Tile = "Tile", t3.Unknown = "Unknown";
      }(c2 || (c2 = {}));
      class u2 {
        constructor(t3) {
          this._transformRequestFn = t3;
        }
        transformRequest(t3, e2) {
          return this._transformRequestFn && this._transformRequestFn(t3, e2) || { url: t3 };
        }
        normalizeSpriteURL(t3, e2, i3) {
          const s3 = function(t4) {
            const e3 = t4.match(d2);
            if (!e3) throw new Error(`Unable to parse URL "${t4}"`);
            return { protocol: e3[1], authority: e3[2], path: e3[3] || "/", params: e3[4] ? e3[4].split("&") : [] };
          }(t3);
          return s3.path += `${e2}${i3}`, function(t4) {
            const e3 = t4.params.length ? `?${t4.params.join("&")}` : "";
            return `${t4.protocol}://${t4.authority}${t4.path}${e3}`;
          }(s3);
        }
        setTransformRequest(t3) {
          this._transformRequestFn = t3;
        }
      }
      const d2 = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function _2(e2) {
        var i3 = new t2.A(3);
        return i3[0] = e2[0], i3[1] = e2[1], i3[2] = e2[2], i3;
      }
      var p2, m2 = function(t3, e2, i3) {
        return t3[0] = e2[0] - i3[0], t3[1] = e2[1] - i3[1], t3[2] = e2[2] - i3[2], t3;
      };
      p2 = new t2.A(3), t2.A != Float32Array && (p2[0] = 0, p2[1] = 0, p2[2] = 0);
      var f2 = function(t3) {
        var e2 = t3[0], i3 = t3[1];
        return e2 * e2 + i3 * i3;
      };
      function g2(t3) {
        const e2 = [];
        if ("string" == typeof t3) e2.push({ id: "default", url: t3 });
        else if (t3 && t3.length > 0) {
          const i3 = [];
          for (const { id: s3, url: a3 } of t3) {
            const t4 = `${s3}${a3}`;
            -1 === i3.indexOf(t4) && (i3.push(t4), e2.push({ id: s3, url: a3 }));
          }
        }
        return e2;
      }
      function v2(e2, i3, s3, a3, o3) {
        if (a3) return void e2(a3);
        if (o3 !== Object.values(i3).length || o3 !== Object.values(s3).length) return;
        const r3 = {};
        for (const e3 in i3) {
          r3[e3] = {};
          const a4 = t2.h.getImageCanvasContext(s3[e3]), o4 = i3[e3];
          for (const t3 in o4) {
            const { width: i4, height: s4, x: n3, y: l3, sdf: h3, pixelRatio: c3, stretchX: u3, stretchY: d3, content: _3 } = o4[t3];
            r3[e3][t3] = { data: null, pixelRatio: c3, sdf: h3, stretchX: u3, stretchY: d3, content: _3, spriteData: { width: i4, height: s4, x: n3, y: l3, context: a4 } };
          }
        }
        e2(null, r3);
      }
      !function() {
        var e2 = new t2.A(2);
        t2.A != Float32Array && (e2[0] = 0, e2[1] = 0);
      }();
      class x2 {
        constructor(t3, e2, i3, s3) {
          this.context = t3, this.format = i3, this.texture = t3.gl.createTexture(), this.update(e2, s3);
        }
        update(e2, i3, s3) {
          const { width: a3, height: o3 } = e2, r3 = !(this.size && this.size[0] === a3 && this.size[1] === o3 || s3), { context: n3 } = this, { gl: l3 } = n3;
          if (this.useMipmap = Boolean(i3 && i3.useMipmap), l3.bindTexture(l3.TEXTURE_2D, this.texture), n3.pixelStoreUnpackFlipY.set(false), n3.pixelStoreUnpack.set(1), n3.pixelStoreUnpackPremultiplyAlpha.set(this.format === l3.RGBA && (!i3 || false !== i3.premultiply)), r3) this.size = [a3, o3], e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t2.a(e2) ? l3.texImage2D(l3.TEXTURE_2D, 0, this.format, this.format, l3.UNSIGNED_BYTE, e2) : l3.texImage2D(l3.TEXTURE_2D, 0, this.format, a3, o3, 0, this.format, l3.UNSIGNED_BYTE, e2.data);
          else {
            const { x: i4, y: r4 } = s3 || { x: 0, y: 0 };
            e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t2.a(e2) ? l3.texSubImage2D(l3.TEXTURE_2D, 0, i4, r4, l3.RGBA, l3.UNSIGNED_BYTE, e2) : l3.texSubImage2D(l3.TEXTURE_2D, 0, i4, r4, a3, o3, l3.RGBA, l3.UNSIGNED_BYTE, e2.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && l3.generateMipmap(l3.TEXTURE_2D);
        }
        bind(t3, e2, i3) {
          const { context: s3 } = this, { gl: a3 } = s3;
          a3.bindTexture(a3.TEXTURE_2D, this.texture), i3 !== a3.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i3 = a3.LINEAR), t3 !== this.filter && (a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_MAG_FILTER, t3), a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_MIN_FILTER, i3 || t3), this.filter = t3), e2 !== this.wrap && (a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_WRAP_S, e2), a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_WRAP_T, e2), this.wrap = e2);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: t3 } = this.context;
          t3.deleteTexture(this.texture), this.texture = null;
        }
      }
      function y2(t3) {
        const { userImage: e2 } = t3;
        return !!(e2 && e2.render && e2.render()) && (t3.data.replace(new Uint8Array(e2.data.buffer)), true);
      }
      class b2 extends t2.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t2.R({ width: 1, height: 1 }), this.dirty = true;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(t3) {
          if (this.loaded !== t3 && (this.loaded = t3, t3)) {
            for (const { ids: t4, callback: e2 } of this.requestors) this._notify(t4, e2);
            this.requestors = [];
          }
        }
        getImage(e2) {
          const i3 = this.images[e2];
          if (i3 && !i3.data && i3.spriteData) {
            const e3 = i3.spriteData;
            i3.data = new t2.R({ width: e3.width, height: e3.height }, e3.context.getImageData(e3.x, e3.y, e3.width, e3.height).data), i3.spriteData = null;
          }
          return i3;
        }
        addImage(t3, e2) {
          if (this.images[t3]) throw new Error(`Image id ${t3} already exist, use updateImage instead`);
          this._validate(t3, e2) && (this.images[t3] = e2);
        }
        _validate(e2, i3) {
          let s3 = true;
          const a3 = i3.data || i3.spriteData;
          return this._validateStretch(i3.stretchX, a3 && a3.width) || (this.fire(new t2.j(new Error(`Image "${e2}" has invalid "stretchX" value`))), s3 = false), this._validateStretch(i3.stretchY, a3 && a3.height) || (this.fire(new t2.j(new Error(`Image "${e2}" has invalid "stretchY" value`))), s3 = false), this._validateContent(i3.content, i3) || (this.fire(new t2.j(new Error(`Image "${e2}" has invalid "content" value`))), s3 = false), s3;
        }
        _validateStretch(t3, e2) {
          if (!t3) return true;
          let i3 = 0;
          for (const s3 of t3) {
            if (s3[0] < i3 || s3[1] < s3[0] || e2 < s3[1]) return false;
            i3 = s3[1];
          }
          return true;
        }
        _validateContent(t3, e2) {
          if (!t3) return true;
          if (4 !== t3.length) return false;
          const i3 = e2.spriteData, s3 = i3 && i3.width || e2.data.width, a3 = i3 && i3.height || e2.data.height;
          return !(t3[0] < 0 || s3 < t3[0] || t3[1] < 0 || a3 < t3[1] || t3[2] < 0 || s3 < t3[2] || t3[3] < 0 || a3 < t3[3] || t3[2] < t3[0] || t3[3] < t3[1]);
        }
        updateImage(t3, e2, i3 = true) {
          const s3 = this.getImage(t3);
          if (i3 && (s3.data.width !== e2.data.width || s3.data.height !== e2.data.height)) throw new Error(`size mismatch between old image (${s3.data.width}x${s3.data.height}) and new image (${e2.data.width}x${e2.data.height}).`);
          e2.version = s3.version + 1, this.images[t3] = e2, this.updatedImages[t3] = true;
        }
        removeImage(t3) {
          const e2 = this.images[t3];
          delete this.images[t3], delete this.patterns[t3], e2.userImage && e2.userImage.onRemove && e2.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(t3, e2) {
          let i3 = true;
          if (!this.isLoaded()) for (const e3 of t3) this.images[e3] || (i3 = false);
          this.isLoaded() || i3 ? this._notify(t3, e2) : this.requestors.push({ ids: t3, callback: e2 });
        }
        _notify(e2, i3) {
          const s3 = {};
          for (const i4 of e2) {
            let e3 = this.getImage(i4);
            e3 || (this.fire(new t2.k("styleimagemissing", { id: i4 })), e3 = this.getImage(i4)), e3 ? s3[i4] = { data: e3.data.clone(), pixelRatio: e3.pixelRatio, sdf: e3.sdf, version: e3.version, stretchX: e3.stretchX, stretchY: e3.stretchY, content: e3.content, hasRenderCallback: Boolean(e3.userImage && e3.userImage.render) } : t2.w(`Image "${i4}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          i3(null, s3);
        }
        getPixelSize() {
          const { width: t3, height: e2 } = this.atlasImage;
          return { width: t3, height: e2 };
        }
        getPattern(e2) {
          const i3 = this.patterns[e2], s3 = this.getImage(e2);
          if (!s3) return null;
          if (i3 && i3.position.version === s3.version) return i3.position;
          if (i3) i3.position.version = s3.version;
          else {
            const i4 = { w: s3.data.width + 2, h: s3.data.height + 2, x: 0, y: 0 }, a3 = new t2.I(i4, s3);
            this.patterns[e2] = { bin: i4, position: a3 };
          }
          return this._updatePatternAtlas(), this.patterns[e2].position;
        }
        bind(t3) {
          const e2 = t3.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new x2(t3, this.atlasImage, e2.RGBA), this.atlasTexture.bind(e2.LINEAR, e2.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const e2 = [];
          for (const t3 in this.patterns) e2.push(this.patterns[t3].bin);
          const { w: i3, h: s3 } = t2.p(e2), a3 = this.atlasImage;
          a3.resize({ width: i3 || 1, height: s3 || 1 });
          for (const e3 in this.patterns) {
            const { bin: i4 } = this.patterns[e3], s4 = i4.x + 1, o3 = i4.y + 1, r3 = this.getImage(e3).data, n3 = r3.width, l3 = r3.height;
            t2.R.copy(r3, a3, { x: 0, y: 0 }, { x: s4, y: o3 }, { width: n3, height: l3 }), t2.R.copy(r3, a3, { x: 0, y: l3 - 1 }, { x: s4, y: o3 - 1 }, { width: n3, height: 1 }), t2.R.copy(r3, a3, { x: 0, y: 0 }, { x: s4, y: o3 + l3 }, { width: n3, height: 1 }), t2.R.copy(r3, a3, { x: n3 - 1, y: 0 }, { x: s4 - 1, y: o3 }, { width: 1, height: l3 }), t2.R.copy(r3, a3, { x: 0, y: 0 }, { x: s4 + n3, y: o3 }, { width: 1, height: l3 });
          }
          this.dirty = true;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(e2) {
          for (const i3 of e2) {
            if (this.callbackDispatchedThisFrame[i3]) continue;
            this.callbackDispatchedThisFrame[i3] = true;
            const e3 = this.getImage(i3);
            e3 || t2.w(`Image with ID: "${i3}" was not found`), y2(e3) && this.updateImage(i3, e3);
          }
        }
      }
      const w2 = 1e20;
      function T2(t3, e2, i3, s3, a3, o3, r3, n3, l3) {
        for (let h3 = e2; h3 < e2 + s3; h3++) I2(t3, i3 * o3 + h3, o3, a3, r3, n3, l3);
        for (let h3 = i3; h3 < i3 + a3; h3++) I2(t3, h3 * o3 + e2, 1, s3, r3, n3, l3);
      }
      function I2(t3, e2, i3, s3, a3, o3, r3) {
        o3[0] = 0, r3[0] = -w2, r3[1] = w2, a3[0] = t3[e2];
        for (let n3 = 1, l3 = 0, h3 = 0; n3 < s3; n3++) {
          a3[n3] = t3[e2 + n3 * i3];
          const s4 = n3 * n3;
          do {
            const t4 = o3[l3];
            h3 = (a3[n3] - a3[t4] + s4 - t4 * t4) / (n3 - t4) / 2;
          } while (h3 <= r3[l3] && --l3 > -1);
          l3++, o3[l3] = n3, r3[l3] = h3, r3[l3 + 1] = w2;
        }
        for (let n3 = 0, l3 = 0; n3 < s3; n3++) {
          for (; r3[l3 + 1] < n3; ) l3++;
          const s4 = o3[l3], h3 = n3 - s4;
          t3[e2 + n3 * i3] = a3[s4] + h3 * h3;
        }
      }
      class E2 {
        constructor(t3, e2) {
          this.requestManager = t3, this.localIdeographFontFamily = e2, this.entries = {};
        }
        setURL(t3) {
          this.url = t3;
        }
        getGlyphs(e2, i3) {
          const s3 = [];
          for (const t3 in e2) for (const i4 of e2[t3]) s3.push({ stack: t3, id: i4 });
          t2.o(s3, ({ stack: t3, id: e3 }, i4) => {
            let s4 = this.entries[t3];
            s4 || (s4 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {} });
            let a3 = s4.glyphs[e3];
            if (void 0 !== a3) return void i4(null, { stack: t3, id: e3, glyph: a3 });
            if (a3 = this._tinySDF(s4, t3, e3), a3) return s4.glyphs[e3] = a3, void i4(null, { stack: t3, id: e3, glyph: a3 });
            const o3 = Math.floor(e3 / 256);
            if (256 * o3 > 65535) return void i4(new Error("glyphs > 65535 not supported"));
            if (s4.ranges[o3]) return void i4(null, { stack: t3, id: e3, glyph: a3 });
            if (!this.url) return void i4(new Error("glyphsUrl is not set"));
            let r3 = s4.requests[o3];
            r3 || (r3 = s4.requests[o3] = [], E2.loadGlyphRange(t3, o3, this.url, this.requestManager, (t4, e4) => {
              if (e4) {
                for (const t5 in e4) this._doesCharSupportLocalGlyph(+t5) || (s4.glyphs[+t5] = e4[+t5]);
                s4.ranges[o3] = true;
              }
              for (const i5 of r3) i5(t4, e4);
              delete s4.requests[o3];
            })), r3.push((s5, a4) => {
              s5 ? i4(s5) : a4 && i4(null, { stack: t3, id: e3, glyph: a4[e3] || null });
            });
          }, (t3, e3) => {
            if (t3) i3(t3);
            else if (e3) {
              const t4 = {};
              for (const { stack: i4, id: s4, glyph: a3 } of e3) (t4[i4] || (t4[i4] = {}))[s4] = a3 && { id: a3.id, bitmap: a3.bitmap.clone(), metrics: a3.metrics };
              i3(null, t4);
            }
          });
        }
        _doesCharSupportLocalGlyph(e2) {
          return !!this.localIdeographFontFamily && (t2.u["CJK Unified Ideographs"](e2) || t2.u["Hangul Syllables"](e2) || t2.u.Hiragana(e2) || t2.u.Katakana(e2));
        }
        _tinySDF(e2, i3, s3) {
          const a3 = this.localIdeographFontFamily;
          if (!a3) return;
          if (!this._doesCharSupportLocalGlyph(s3)) return;
          let o3 = e2.tinySDF;
          if (!o3) {
            let t3 = "400";
            /bold/i.test(i3) ? t3 = "900" : /medium/i.test(i3) ? t3 = "500" : /light/i.test(i3) && (t3 = "200"), o3 = e2.tinySDF = new E2.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: a3, fontWeight: t3 });
          }
          const r3 = o3.draw(String.fromCharCode(s3));
          return { id: s3, bitmap: new t2.q({ width: r3.width || 60, height: r3.height || 60 }, r3.data), metrics: { width: r3.glyphWidth / 2 || 24, height: r3.glyphHeight / 2 || 24, left: r3.glyphLeft / 2 + 0.5 || 0, top: r3.glyphTop / 2 - 27.5 || -8, advance: r3.glyphAdvance / 2 || 24, isDoubleResolution: true } };
        }
      }
      E2.loadGlyphRange = function(e2, i3, s3, a3, o3) {
        const r3 = 256 * i3, n3 = r3 + 255, l3 = a3.transformRequest(s3.replace("{fontstack}", e2).replace("{range}", `${r3}-${n3}`), c2.Glyphs);
        t2.l(l3, (e3, i4) => {
          if (e3) o3(e3);
          else if (i4) {
            const e4 = {};
            for (const s4 of t2.n(i4)) e4[s4.id] = s4;
            o3(null, e4);
          }
        });
      }, E2.TinySDF = class {
        constructor({ fontSize: t3 = 24, buffer: e2 = 3, radius: i3 = 8, cutoff: s3 = 0.25, fontFamily: a3 = "sans-serif", fontWeight: o3 = "normal", fontStyle: r3 = "normal" } = {}) {
          this.buffer = e2, this.cutoff = s3, this.radius = i3;
          const n3 = this.size = t3 + 4 * e2, l3 = this._createCanvas(n3), h3 = this.ctx = l3.getContext("2d", { willReadFrequently: true });
          h3.font = `${r3} ${o3} ${t3}px ${a3}`, h3.textBaseline = "alphabetic", h3.textAlign = "left", h3.fillStyle = "black", this.gridOuter = new Float64Array(n3 * n3), this.gridInner = new Float64Array(n3 * n3), this.f = new Float64Array(n3), this.z = new Float64Array(n3 + 1), this.v = new Uint16Array(n3);
        }
        _createCanvas(t3) {
          const e2 = document.createElement("canvas");
          return e2.width = e2.height = t3, e2;
        }
        draw(t3) {
          const { width: e2, actualBoundingBoxAscent: i3, actualBoundingBoxDescent: s3, actualBoundingBoxLeft: a3, actualBoundingBoxRight: o3 } = this.ctx.measureText(t3), r3 = Math.ceil(i3), n3 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o3 - a3))), l3 = Math.min(this.size - this.buffer, r3 + Math.ceil(s3)), h3 = n3 + 2 * this.buffer, c3 = l3 + 2 * this.buffer, u3 = Math.max(h3 * c3, 0), d3 = new Uint8ClampedArray(u3), _3 = { data: d3, width: h3, height: c3, glyphWidth: n3, glyphHeight: l3, glyphTop: r3, glyphLeft: 0, glyphAdvance: e2 };
          if (0 === n3 || 0 === l3) return _3;
          const { ctx: p3, buffer: m3, gridInner: f3, gridOuter: g3 } = this;
          p3.clearRect(m3, m3, n3, l3), p3.fillText(t3, m3, m3 + r3);
          const v3 = p3.getImageData(m3, m3, n3, l3);
          g3.fill(w2, 0, u3), f3.fill(0, 0, u3);
          for (let t4 = 0; t4 < l3; t4++) for (let e3 = 0; e3 < n3; e3++) {
            const i4 = v3.data[4 * (t4 * n3 + e3) + 3] / 255;
            if (0 === i4) continue;
            const s4 = (t4 + m3) * h3 + e3 + m3;
            if (1 === i4) g3[s4] = 0, f3[s4] = w2;
            else {
              const t5 = 0.5 - i4;
              g3[s4] = t5 > 0 ? t5 * t5 : 0, f3[s4] = t5 < 0 ? t5 * t5 : 0;
            }
          }
          T2(g3, 0, 0, h3, c3, h3, this.f, this.v, this.z), T2(f3, m3, m3, n3, l3, h3, this.f, this.v, this.z);
          for (let t4 = 0; t4 < u3; t4++) {
            const e3 = Math.sqrt(g3[t4]) - Math.sqrt(f3[t4]);
            d3[t4] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
          }
          return _3;
        }
      };
      class S2 {
        constructor() {
          this.specification = t2.v.light.position;
        }
        possiblyEvaluate(e2, i3) {
          return t2.z(e2.expression.evaluate(i3));
        }
        interpolate(e2, i3, s3) {
          return { x: t2.B.number(e2.x, i3.x, s3), y: t2.B.number(e2.y, i3.y, s3), z: t2.B.number(e2.z, i3.z, s3) };
        }
      }
      let C2;
      class P2 extends t2.E {
        constructor(e2) {
          super(), C2 = C2 || new t2.r({ anchor: new t2.D(t2.v.light.anchor), position: new S2(), color: new t2.D(t2.v.light.color), intensity: new t2.D(t2.v.light.intensity) }), this._transitionable = new t2.T(C2), this.setLight(e2), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(e2, i3 = {}) {
          if (!this._validate(t2.t, e2, i3)) for (const t3 in e2) {
            const i4 = e2[t3];
            t3.endsWith("-transition") ? this._transitionable.setTransition(t3.slice(0, -11), i4) : this._transitionable.setValue(t3, i4);
          }
        }
        updateTransitions(t3) {
          this._transitioning = this._transitionable.transitioned(t3, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t3) {
          this.properties = this._transitioning.possiblyEvaluate(t3);
        }
        _validate(e2, i3, s3) {
          return (!s3 || false !== s3.validate) && t2.x(this, e2.call(t2.y, t2.e({ value: i3, style: { glyphs: true, sprite: true }, styleSpec: t2.v })));
        }
      }
      class D2 {
        constructor(t3, e2) {
          this.width = t3, this.height = e2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(t3, e2) {
          const i3 = t3.join(",") + String(e2);
          return this.dashEntry[i3] || (this.dashEntry[i3] = this.addDash(t3, e2)), this.dashEntry[i3];
        }
        getDashRanges(t3, e2, i3) {
          const s3 = [];
          let a3 = t3.length % 2 == 1 ? -t3[t3.length - 1] * i3 : 0, o3 = t3[0] * i3, r3 = true;
          s3.push({ left: a3, right: o3, isDash: r3, zeroLength: 0 === t3[0] });
          let n3 = t3[0];
          for (let e3 = 1; e3 < t3.length; e3++) {
            r3 = !r3;
            const l3 = t3[e3];
            a3 = n3 * i3, n3 += l3, o3 = n3 * i3, s3.push({ left: a3, right: o3, isDash: r3, zeroLength: 0 === l3 });
          }
          return s3;
        }
        addRoundDash(t3, e2, i3) {
          const s3 = e2 / 2;
          for (let e3 = -i3; e3 <= i3; e3++) {
            const a3 = this.width * (this.nextRow + i3 + e3);
            let o3 = 0, r3 = t3[o3];
            for (let n3 = 0; n3 < this.width; n3++) {
              n3 / r3.right > 1 && (r3 = t3[++o3]);
              const l3 = Math.abs(n3 - r3.left), h3 = Math.abs(n3 - r3.right), c3 = Math.min(l3, h3);
              let u3;
              const d3 = e3 / i3 * (s3 + 1);
              if (r3.isDash) {
                const t4 = s3 - Math.abs(d3);
                u3 = Math.sqrt(c3 * c3 + t4 * t4);
              } else u3 = s3 - Math.sqrt(c3 * c3 + d3 * d3);
              this.data[a3 + n3] = Math.max(0, Math.min(255, u3 + 128));
            }
          }
        }
        addRegularDash(t3) {
          for (let e3 = t3.length - 1; e3 >= 0; --e3) {
            const i4 = t3[e3], s4 = t3[e3 + 1];
            i4.zeroLength ? t3.splice(e3, 1) : s4 && s4.isDash === i4.isDash && (s4.left = i4.left, t3.splice(e3, 1));
          }
          const e2 = t3[0], i3 = t3[t3.length - 1];
          e2.isDash === i3.isDash && (e2.left = i3.left - this.width, i3.right = e2.right + this.width);
          const s3 = this.width * this.nextRow;
          let a3 = 0, o3 = t3[a3];
          for (let e3 = 0; e3 < this.width; e3++) {
            e3 / o3.right > 1 && (o3 = t3[++a3]);
            const i4 = Math.abs(e3 - o3.left), r3 = Math.abs(e3 - o3.right), n3 = Math.min(i4, r3);
            this.data[s3 + e3] = Math.max(0, Math.min(255, (o3.isDash ? n3 : -n3) + 128));
          }
        }
        addDash(e2, i3) {
          const s3 = i3 ? 7 : 0, a3 = 2 * s3 + 1;
          if (this.nextRow + a3 > this.height) return t2.w("LineAtlas out of space"), null;
          let o3 = 0;
          for (let t3 = 0; t3 < e2.length; t3++) o3 += e2[t3];
          if (0 !== o3) {
            const t3 = this.width / o3, a4 = this.getDashRanges(e2, this.width, t3);
            i3 ? this.addRoundDash(a4, t3, s3) : this.addRegularDash(a4);
          }
          const r3 = { y: (this.nextRow + s3 + 0.5) / this.height, height: 2 * s3 / this.height, width: o3 };
          return this.nextRow += a3, this.dirty = true, r3;
        }
        bind(t3) {
          const e2 = t3.gl;
          this.texture ? (e2.bindTexture(e2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, this.width, this.height, e2.ALPHA, e2.UNSIGNED_BYTE, this.data))) : (this.texture = e2.createTexture(), e2.bindTexture(e2.TEXTURE_2D, this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR), e2.texImage2D(e2.TEXTURE_2D, 0, e2.ALPHA, this.width, this.height, 0, e2.ALPHA, e2.UNSIGNED_BYTE, this.data));
        }
      }
      class M2 {
        constructor(e2, i3, s3) {
          this.workerPool = e2, this.actors = [], this.currentActor = 0, this.id = s3;
          const a3 = this.workerPool.acquire(s3);
          for (let e3 = 0; e3 < a3.length; e3++) {
            const o3 = new t2.C(a3[e3], i3, s3);
            o3.name = `Worker ${e3}`, this.actors.push(o3);
          }
          if (!this.actors.length) throw new Error("No actors found");
        }
        broadcast(e2, i3, s3) {
          t2.o(this.actors, (t3, s4) => {
            t3.send(e2, i3, s4);
          }, s3 = s3 || function() {
          });
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove(t3 = true) {
          this.actors.forEach((t4) => {
            t4.remove();
          }), this.actors = [], t3 && this.workerPool.release(this.id);
        }
      }
      function z2(e2, i3, s3) {
        const a3 = function(i4, a4) {
          if (i4) return s3(i4);
          if (a4) {
            const i5 = t2.F(t2.e(a4, e2), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            a4.vector_layers && (i5.vectorLayers = a4.vector_layers, i5.vectorLayerIds = i5.vectorLayers.map((t3) => t3.id)), s3(null, i5);
          }
        };
        return e2.url ? t2.f(i3.transformRequest(e2.url, c2.Source), a3) : t2.h.frame(() => a3(null, e2));
      }
      class L2 {
        constructor(t3, e2) {
          t3 && (e2 ? this.setSouthWest(t3).setNorthEast(e2) : Array.isArray(t3) && (4 === t3.length ? this.setSouthWest([t3[0], t3[1]]).setNorthEast([t3[2], t3[3]]) : this.setSouthWest(t3[0]).setNorthEast(t3[1])));
        }
        setNorthEast(e2) {
          return this._ne = e2 instanceof t2.L ? new t2.L(e2.lng, e2.lat) : t2.L.convert(e2), this;
        }
        setSouthWest(e2) {
          return this._sw = e2 instanceof t2.L ? new t2.L(e2.lng, e2.lat) : t2.L.convert(e2), this;
        }
        extend(e2) {
          const i3 = this._sw, s3 = this._ne;
          let a3, o3;
          if (e2 instanceof t2.L) a3 = e2, o3 = e2;
          else {
            if (!(e2 instanceof L2)) return Array.isArray(e2) ? 4 === e2.length || e2.every(Array.isArray) ? this.extend(L2.convert(e2)) : this.extend(t2.L.convert(e2)) : e2 && ("lng" in e2 || "lon" in e2) && "lat" in e2 ? this.extend(t2.L.convert(e2)) : this;
            if (a3 = e2._sw, o3 = e2._ne, !a3 || !o3) return this;
          }
          return i3 || s3 ? (i3.lng = Math.min(a3.lng, i3.lng), i3.lat = Math.min(a3.lat, i3.lat), s3.lng = Math.max(o3.lng, s3.lng), s3.lat = Math.max(o3.lat, s3.lat)) : (this._sw = new t2.L(a3.lng, a3.lat), this._ne = new t2.L(o3.lng, o3.lat)), this;
        }
        getCenter() {
          return new t2.L((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new t2.L(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new t2.L(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(e2) {
          const { lng: i3, lat: s3 } = t2.L.convert(e2);
          let a3 = this._sw.lng <= i3 && i3 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (a3 = this._sw.lng >= i3 && i3 >= this._ne.lng), this._sw.lat <= s3 && s3 <= this._ne.lat && a3;
        }
        static convert(t3) {
          return t3 instanceof L2 ? t3 : t3 ? new L2(t3) : t3;
        }
        static fromLngLat(e2, i3 = 0) {
          const s3 = 360 * i3 / 40075017, a3 = s3 / Math.cos(Math.PI / 180 * e2.lat);
          return new L2(new t2.L(e2.lng - a3, e2.lat - s3), new t2.L(e2.lng + a3, e2.lat + s3));
        }
      }
      class A2 {
        constructor(t3, e2, i3) {
          this.bounds = L2.convert(this.validateBounds(t3)), this.minzoom = e2 || 0, this.maxzoom = i3 || 24;
        }
        validateBounds(t3) {
          return Array.isArray(t3) && 4 === t3.length ? [Math.max(-180, t3[0]), Math.max(-90, t3[1]), Math.min(180, t3[2]), Math.min(90, t3[3])] : [-180, -90, 180, 90];
        }
        contains(e2) {
          const i3 = Math.pow(2, e2.z), s3 = Math.floor(t2.G(this.bounds.getWest()) * i3), a3 = Math.floor(t2.H(this.bounds.getNorth()) * i3), o3 = Math.ceil(t2.G(this.bounds.getEast()) * i3), r3 = Math.ceil(t2.H(this.bounds.getSouth()) * i3);
          return e2.x >= s3 && e2.x < o3 && e2.y >= a3 && e2.y < r3;
        }
      }
      class R2 extends t2.E {
        constructor(e2, i3, s3, a3) {
          if (super(), this.load = () => {
            this._loaded = false, this.fire(new t2.k("dataloading", { dataType: "source" })), this._tileJSONRequest = z2(this._options, this.map._requestManager, (e3, i4) => {
              this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e3 ? this.fire(new t2.j(e3)) : i4 && (t2.e(this, i4), i4.bounds && (this.tileBounds = new A2(i4.bounds, this.minzoom, this.maxzoom)), this.fire(new t2.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t2.k("data", { dataType: "source", sourceDataType: "content" })));
            });
          }, this.serialize = () => t2.e({}, this._options), this.id = e2, this.dispatcher = s3, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t2.e(this, t2.F(i3, ["url", "scheme", "tileSize", "promoteId"])), this._options = t2.e({ type: "vector" }, i3), this._collectResourceTiming = i3.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(a3);
        }
        loaded() {
          return this._loaded;
        }
        hasTile(t3) {
          return !this.tileBounds || this.tileBounds.contains(t3.canonical);
        }
        onAdd(t3) {
          this.map = t3, this.load();
        }
        setSourceProperty(t3) {
          this._tileJSONRequest && this._tileJSONRequest.cancel(), t3(), this.load();
        }
        setTiles(t3) {
          return this.setSourceProperty(() => {
            this._options.tiles = t3;
          }), this;
        }
        setUrl(t3) {
          return this.setSourceProperty(() => {
            this.url = t3, this._options.url = t3;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
        loadTile(t3, e2) {
          const i3 = t3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), s3 = { request: this.map._requestManager.transformRequest(i3, c2.Tile), uid: t3.uid, tileID: t3.tileID, zoom: t3.tileID.overscaledZ, tileSize: this.tileSize * t3.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
          function a3(i4, s4) {
            return delete t3.request, t3.aborted ? e2(null) : i4 && 404 !== i4.status ? e2(i4) : (s4 && s4.resourceTiming && (t3.resourceTiming = s4.resourceTiming), this.map._refreshExpiredTiles && s4 && t3.setExpiryData(s4), t3.loadVectorData(s4, this.map.painter), e2(null), void (t3.reloadCallback && (this.loadTile(t3, t3.reloadCallback), t3.reloadCallback = null)));
          }
          s3.request.collectResourceTiming = this._collectResourceTiming, t3.actor && "expired" !== t3.state ? "loading" === t3.state ? t3.reloadCallback = e2 : t3.request = t3.actor.send("reloadTile", s3, a3.bind(this)) : (t3.actor = this.dispatcher.getActor(), t3.request = t3.actor.send("loadTile", s3, a3.bind(this)));
        }
        abortTile(t3) {
          t3.request && (t3.request.cancel(), delete t3.request), t3.actor && t3.actor.send("abortTile", { uid: t3.uid, type: this.type, source: this.id }, void 0);
        }
        unloadTile(t3) {
          t3.unloadVectorData(), t3.actor && t3.actor.send("removeTile", { uid: t3.uid, type: this.type, source: this.id }, void 0);
        }
        hasTransition() {
          return false;
        }
      }
      class k2 extends t2.E {
        constructor(e2, i3, s3, a3) {
          super(), this.id = e2, this.dispatcher = s3, this.setEventedParent(a3), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t2.e({ type: "raster" }, i3), t2.e(this, t2.F(i3, ["url", "scheme", "tileSize"]));
        }
        load() {
          this._loaded = false, this.fire(new t2.k("dataloading", { dataType: "source" })), this._tileJSONRequest = z2(this._options, this.map._requestManager, (e2, i3) => {
            this._tileJSONRequest = null, this._loaded = true, e2 ? this.fire(new t2.j(e2)) : i3 && (t2.e(this, i3), i3.bounds && (this.tileBounds = new A2(i3.bounds, this.minzoom, this.maxzoom)), this.fire(new t2.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t2.k("data", { dataType: "source", sourceDataType: "content" })));
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t3) {
          this.map = t3, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
        setSourceProperty(t3) {
          this._tileJSONRequest && this._tileJSONRequest.cancel(), t3(), this.load();
        }
        setTiles(t3) {
          return this.setSourceProperty(() => {
            this._options.tiles = t3;
          }), this;
        }
        serialize() {
          return t2.e({}, this._options);
        }
        hasTile(t3) {
          return !this.tileBounds || this.tileBounds.contains(t3.canonical);
        }
        loadTile(t3, e2) {
          const i3 = t3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
          t3.request = h2.getImage(this.map._requestManager.transformRequest(i3, c2.Tile), (i4, s3, a3) => {
            if (delete t3.request, t3.aborted) t3.state = "unloaded", e2(null);
            else if (i4) t3.state = "errored", e2(i4);
            else if (s3) {
              this.map._refreshExpiredTiles && a3 && t3.setExpiryData(a3);
              const i5 = this.map.painter.context, o3 = i5.gl;
              t3.texture = this.map.painter.getTileTexture(s3.width), t3.texture ? t3.texture.update(s3, { useMipmap: true }) : (t3.texture = new x2(i5, s3, o3.RGBA, { useMipmap: true }), t3.texture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE, o3.LINEAR_MIPMAP_NEAREST), i5.extTextureFilterAnisotropic && o3.texParameterf(o3.TEXTURE_2D, i5.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, i5.extTextureFilterAnisotropicMax)), t3.state = "loaded", e2(null);
            }
          }, this.map._refreshExpiredTiles);
        }
        abortTile(t3, e2) {
          t3.request && (t3.request.cancel(), delete t3.request), e2();
        }
        unloadTile(t3, e2) {
          t3.texture && this.map.painter.saveTileTexture(t3.texture), e2();
        }
        hasTransition() {
          return false;
        }
      }
      class F2 extends k2 {
        constructor(e2, i3, s3, a3) {
          super(e2, i3, s3, a3), this.type = "raster-dem", this.maxzoom = 22, this._options = t2.e({ type: "raster-dem" }, i3), this.encoding = i3.encoding || "mapbox", this.redFactor = i3.redFactor, this.greenFactor = i3.greenFactor, this.blueFactor = i3.blueFactor, this.baseShift = i3.baseShift;
        }
        loadTile(e2, i3) {
          const s3 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a3 = this.map._requestManager.transformRequest(s3, c2.Tile);
          function o3(t3, s4) {
            t3 && (e2.state = "errored", i3(t3)), s4 && (e2.dem = s4, e2.needsHillshadePrepare = true, e2.needsTerrainPrepare = true, e2.state = "loaded", i3(null));
          }
          e2.neighboringTiles = this._getNeighboringTiles(e2.tileID), e2.request = h2.getImage(a3, (s4, a4, r3) => t2._(this, void 0, void 0, function* () {
            if (delete e2.request, e2.aborted) e2.state = "unloaded", i3(null);
            else if (s4) e2.state = "errored", i3(s4);
            else if (a4) {
              this.map._refreshExpiredTiles && e2.setExpiryData(r3);
              const i4 = t2.a(a4) && t2.J() ? a4 : yield function(e3) {
                return t2._(this, void 0, void 0, function* () {
                  if ("undefined" != typeof VideoFrame && t2.K()) {
                    const i5 = e3.width + 2, s6 = e3.height + 2;
                    try {
                      return new t2.R({ width: i5, height: s6 }, yield t2.M(e3, -1, -1, i5, s6));
                    } catch (t3) {
                    }
                  }
                  return t2.h.getImageData(e3, 1);
                });
              }(a4), s5 = { uid: e2.uid, coord: e2.tileID, source: this.id, rawImageData: i4, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
              e2.actor && "expired" !== e2.state || (e2.actor = this.dispatcher.getActor(), e2.actor.send("loadDEMTile", s5, o3));
            }
          }), this.map._refreshExpiredTiles);
        }
        _getNeighboringTiles(e2) {
          const i3 = e2.canonical, s3 = Math.pow(2, i3.z), a3 = (i3.x - 1 + s3) % s3, o3 = 0 === i3.x ? e2.wrap - 1 : e2.wrap, r3 = (i3.x + 1 + s3) % s3, n3 = i3.x + 1 === s3 ? e2.wrap + 1 : e2.wrap, l3 = {};
          return l3[new t2.O(e2.overscaledZ, o3, i3.z, a3, i3.y).key] = { backfilled: false }, l3[new t2.O(e2.overscaledZ, n3, i3.z, r3, i3.y).key] = { backfilled: false }, i3.y > 0 && (l3[new t2.O(e2.overscaledZ, o3, i3.z, a3, i3.y - 1).key] = { backfilled: false }, l3[new t2.O(e2.overscaledZ, e2.wrap, i3.z, i3.x, i3.y - 1).key] = { backfilled: false }, l3[new t2.O(e2.overscaledZ, n3, i3.z, r3, i3.y - 1).key] = { backfilled: false }), i3.y + 1 < s3 && (l3[new t2.O(e2.overscaledZ, o3, i3.z, a3, i3.y + 1).key] = { backfilled: false }, l3[new t2.O(e2.overscaledZ, e2.wrap, i3.z, i3.x, i3.y + 1).key] = { backfilled: false }, l3[new t2.O(e2.overscaledZ, n3, i3.z, r3, i3.y + 1).key] = { backfilled: false }), l3;
        }
        unloadTile(t3) {
          t3.demTexture && this.map.painter.saveTileTexture(t3.demTexture), t3.fbo && (t3.fbo.destroy(), delete t3.fbo), t3.dem && delete t3.dem, delete t3.neighboringTiles, t3.state = "unloaded", t3.actor && t3.actor.send("removeDEMTile", { uid: t3.uid, source: this.id });
        }
      }
      class B2 extends t2.E {
        constructor(e2, i3, s3, a3) {
          super(), this.load = () => {
            this._updateWorkerData();
          }, this.serialize = () => t2.e({}, this._options, { type: this.type, data: this._data }), this.id = e2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = s3.getActor(), this.setEventedParent(a3), this._data = i3.data, this._options = t2.e({}, i3), this._collectResourceTiming = i3.collectResourceTiming, void 0 !== i3.maxzoom && (this.maxzoom = i3.maxzoom), i3.type && (this.type = i3.type), i3.attribution && (this.attribution = i3.attribution), this.promoteId = i3.promoteId;
          const o3 = t2.N / this.tileSize;
          this.workerOptions = t2.e({ source: this.id, cluster: i3.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i3.buffer ? i3.buffer : 128) * o3, tolerance: (void 0 !== i3.tolerance ? i3.tolerance : 0.375) * o3, extent: t2.N, maxZoom: this.maxzoom, lineMetrics: i3.lineMetrics || false, generateId: i3.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i3.clusterMaxZoom ? i3.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i3.clusterMinPoints || 2), extent: t2.N, radius: (i3.clusterRadius || 50) * o3, log: false, generateId: i3.generateId || false }, clusterProperties: i3.clusterProperties, filter: i3.filter }, i3.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
        }
        onAdd(t3) {
          this.map = t3, this.load();
        }
        setData(t3) {
          return this._data = t3, this._updateWorkerData(), this;
        }
        updateData(t3) {
          return this._updateWorkerData(t3), this;
        }
        setClusterOptions(t3) {
          return this.workerOptions.cluster = t3.cluster, t3 && (void 0 !== t3.clusterRadius && (this.workerOptions.superclusterOptions.radius = t3.clusterRadius), void 0 !== t3.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = t3.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(t3, e2) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t3, source: this.id }, e2), this;
        }
        getClusterChildren(t3, e2) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: t3, source: this.id }, e2), this;
        }
        getClusterLeaves(t3, e2, i3, s3) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t3, limit: e2, offset: i3 }, s3), this;
        }
        _updateWorkerData(e2) {
          const i3 = t2.e({}, this.workerOptions);
          e2 ? i3.dataDiff = e2 : "string" == typeof this._data ? (i3.request = this.map._requestManager.transformRequest(t2.h.resolveURL(this._data), c2.Source), i3.request.collectResourceTiming = this._collectResourceTiming) : i3.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new t2.k("dataloading", { dataType: "source" })), this.actor.send(`${this.type}.loadData`, i3, (e3, i4) => {
            if (this._pendingLoads--, this._removed || i4 && i4.abandoned) return void this.fire(new t2.k("dataabort", { dataType: "source" }));
            let s3 = null;
            if (i4 && i4.resourceTiming && i4.resourceTiming[this.id] && (s3 = i4.resourceTiming[this.id].slice(0)), e3) return void this.fire(new t2.j(e3));
            const a3 = { dataType: "source" };
            this._collectResourceTiming && s3 && s3.length > 0 && t2.e(a3, { resourceTiming: s3 }), this.fire(new t2.k("data", Object.assign(Object.assign({}, a3), { sourceDataType: "metadata" }))), this.fire(new t2.k("data", Object.assign(Object.assign({}, a3), { sourceDataType: "content" })));
          });
        }
        loaded() {
          return 0 === this._pendingLoads;
        }
        loadTile(t3, e2) {
          const i3 = t3.actor ? "reloadTile" : "loadTile";
          t3.actor = this.actor;
          const s3 = { type: this.type, uid: t3.uid, tileID: t3.tileID, zoom: t3.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
          t3.request = this.actor.send(i3, s3, (s4, a3) => (delete t3.request, t3.unloadVectorData(), t3.aborted ? e2(null) : s4 ? e2(s4) : (t3.loadVectorData(a3, this.map.painter, "reloadTile" === i3), e2(null))));
        }
        abortTile(t3) {
          t3.request && (t3.request.cancel(), delete t3.request), t3.aborted = true;
        }
        unloadTile(t3) {
          t3.unloadVectorData(), this.actor.send("removeTile", { uid: t3.uid, type: this.type, source: this.id });
        }
        onRemove() {
          this._removed = true, this.actor.send("removeSource", { type: this.type, source: this.id });
        }
        hasTransition() {
          return false;
        }
      }
      var O2 = t2.Q([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      class N2 extends t2.E {
        constructor(e2, i3, s3, a3) {
          super(), this.load = (e3, i4) => {
            this._loaded = false, this.fire(new t2.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = h2.getImage(this.map._requestManager.transformRequest(this.url, c2.Image), (s4, a4) => {
              this._request = null, this._loaded = true, s4 ? this.fire(new t2.j(s4)) : a4 && (this.image = a4, e3 && (this.coordinates = e3), i4 && i4(), this._finishLoading());
            });
          }, this.prepare = () => {
            if (0 === Object.keys(this.tiles).length || !this.image) return;
            const e3 = this.map.painter.context, i4 = e3.gl;
            this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, O2.members)), this.boundsSegments || (this.boundsSegments = t2.S.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new x2(e3, this.image, i4.RGBA), this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE));
            let s4 = false;
            for (const t3 in this.tiles) {
              const e4 = this.tiles[t3];
              "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture, s4 = true);
            }
            s4 && this.fire(new t2.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }, this.serialize = () => ({ type: "image", url: this.options.url, coordinates: this.coordinates }), this.id = e2, this.dispatcher = s3, this.coordinates = i3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(a3), this.options = i3;
        }
        loaded() {
          return this._loaded;
        }
        updateImage(t3) {
          return t3.url ? (this._request && (this._request.cancel(), this._request = null), this.options.url = t3.url, this.load(t3.coordinates, () => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new t2.k("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(t3) {
          this.map = t3, this.load();
        }
        onRemove() {
          this._request && (this._request.cancel(), this._request = null);
        }
        setCoordinates(e2) {
          this.coordinates = e2;
          const i3 = e2.map(t2.U.fromLngLat);
          this.tileID = function(e3) {
            let i4 = 1 / 0, s4 = 1 / 0, a3 = -1 / 0, o3 = -1 / 0;
            for (const t3 of e3) i4 = Math.min(i4, t3.x), s4 = Math.min(s4, t3.y), a3 = Math.max(a3, t3.x), o3 = Math.max(o3, t3.y);
            const r3 = Math.max(a3 - i4, o3 - s4), n3 = Math.max(0, Math.floor(-Math.log(r3) / Math.LN2)), l3 = Math.pow(2, n3);
            return new t2.W(n3, Math.floor((i4 + a3) / 2 * l3), Math.floor((s4 + o3) / 2 * l3));
          }(i3), this.minzoom = this.maxzoom = this.tileID.z;
          const s3 = i3.map((t3) => this.tileID.getTilePoint(t3)._round());
          return this._boundsArray = new t2.V(), this._boundsArray.emplaceBack(s3[0].x, s3[0].y, 0, 0), this._boundsArray.emplaceBack(s3[1].x, s3[1].y, t2.N, 0), this._boundsArray.emplaceBack(s3[3].x, s3[3].y, 0, t2.N), this._boundsArray.emplaceBack(s3[2].x, s3[2].y, t2.N, t2.N), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t2.k("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        loadTile(t3, e2) {
          this.tileID && this.tileID.equals(t3.tileID.canonical) ? (this.tiles[String(t3.tileID.wrap)] = t3, t3.buckets = {}, e2(null)) : (t3.state = "errored", e2(null));
        }
        hasTransition() {
          return false;
        }
      }
      class U2 extends N2 {
        constructor(e2, i3, s3, a3) {
          super(e2, i3, s3, a3), this.load = () => {
            this._loaded = false;
            const e3 = this.options;
            this.urls = [];
            for (const t3 of e3.urls) this.urls.push(this.map._requestManager.transformRequest(t3, c2.Source).url);
            t2.X(this.urls, (e4, i4) => {
              this._loaded = true, e4 ? this.fire(new t2.j(e4)) : i4 && (this.video = i4, this.video.loop = true, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading());
            });
          }, this.prepare = () => {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
            const e3 = this.map.painter.context, i4 = e3.gl;
            this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, O2.members)), this.boundsSegments || (this.boundsSegments = t2.S.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE), i4.texSubImage2D(i4.TEXTURE_2D, 0, 0, 0, i4.RGBA, i4.UNSIGNED_BYTE, this.video)) : (this.texture = new x2(e3, this.video, i4.RGBA), this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE));
            let s4 = false;
            for (const t3 in this.tiles) {
              const e4 = this.tiles[t3];
              "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture, s4 = true);
            }
            s4 && this.fire(new t2.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }, this.serialize = () => ({ type: "video", urls: this.urls, coordinates: this.coordinates }), this.roundZoom = true, this.type = "video", this.options = i3;
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(e2) {
          if (this.video) {
            const i3 = this.video.seekable;
            e2 < i3.start(0) || e2 > i3.end(0) ? this.fire(new t2.j(new t2.Y(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i3.start(0)} and ${i3.end(0)}-second mark.`))) : this.video.currentTime = e2;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(t3) {
          this.map || (this.map = t3, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class Z2 extends N2 {
        constructor(e2, i3, s3, a3) {
          super(e2, i3, s3, a3), this.load = () => {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t2.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          }, this.prepare = () => {
            let e3 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e3 = true), this._hasInvalidDimensions()) return;
            if (0 === Object.keys(this.tiles).length) return;
            const i4 = this.map.painter.context, s4 = i4.gl;
            this.boundsBuffer || (this.boundsBuffer = i4.createVertexBuffer(this._boundsArray, O2.members)), this.boundsSegments || (this.boundsSegments = t2.S.simpleSegment(0, 0, 4, 2)), this.texture ? (e3 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new x2(i4, this.canvas, s4.RGBA, { premultiply: true });
            let a4 = false;
            for (const t3 in this.tiles) {
              const e4 = this.tiles[t3];
              "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture, a4 = true);
            }
            a4 && this.fire(new t2.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }, this.serialize = () => ({ type: "canvas", coordinates: this.coordinates }), i3.coordinates ? Array.isArray(i3.coordinates) && 4 === i3.coordinates.length && !i3.coordinates.some((t3) => !Array.isArray(t3) || 2 !== t3.length || t3.some((t4) => "number" != typeof t4)) || this.fire(new t2.j(new t2.Y(`sources.${e2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t2.j(new t2.Y(`sources.${e2}`, null, 'missing required property "coordinates"'))), i3.animate && "boolean" != typeof i3.animate && this.fire(new t2.j(new t2.Y(`sources.${e2}`, null, 'optional "animate" property must be a boolean value'))), i3.canvas ? "string" == typeof i3.canvas || i3.canvas instanceof HTMLCanvasElement || this.fire(new t2.j(new t2.Y(`sources.${e2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t2.j(new t2.Y(`sources.${e2}`, null, 'missing required property "canvas"'))), this.options = i3, this.animate = void 0 === i3.animate || i3.animate;
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(t3) {
          this.map = t3, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const t3 of [this.canvas.width, this.canvas.height]) if (isNaN(t3) || t3 <= 0) return true;
          return false;
        }
      }
      const G2 = {}, j2 = (t3) => {
        switch (t3) {
          case "geojson":
            return B2;
          case "image":
            return N2;
          case "raster":
            return k2;
          case "raster-dem":
            return F2;
          case "vector":
            return R2;
          case "video":
            return U2;
          case "canvas":
            return Z2;
        }
        return G2[t3];
      };
      function V2(e2, i3) {
        const s3 = t2.Z();
        return t2.$(s3, s3, [1, 1, 0]), t2.a0(s3, s3, [0.5 * e2.width, 0.5 * e2.height, 1]), t2.a1(s3, s3, e2.calculatePosMatrix(i3.toUnwrapped()));
      }
      function q2(t3, e2, i3, s3, a3, o3) {
        const r3 = function(t4, e3, i4) {
          if (t4) for (const s4 of t4) {
            const t5 = e3[s4];
            if (t5 && t5.source === i4 && "fill-extrusion" === t5.type) return true;
          }
          else for (const t5 in e3) {
            const s4 = e3[t5];
            if (s4.source === i4 && "fill-extrusion" === s4.type) return true;
          }
          return false;
        }(a3 && a3.layers, e2, t3.id), n3 = o3.maxPitchScaleFactor(), l3 = t3.tilesIn(s3, n3, r3);
        l3.sort($2);
        const h3 = [];
        for (const s4 of l3) h3.push({ wrappedTileID: s4.tileID.wrapped().key, queryResults: s4.tile.queryRenderedFeatures(e2, i3, t3._state, s4.queryGeometry, s4.cameraQueryGeometry, s4.scale, a3, o3, n3, V2(t3.transform, s4.tileID)) });
        const c3 = function(t4) {
          const e3 = {}, i4 = {};
          for (const s4 of t4) {
            const t5 = s4.queryResults, a4 = s4.wrappedTileID, o4 = i4[a4] = i4[a4] || {};
            for (const i5 in t5) {
              const s5 = t5[i5], a5 = o4[i5] = o4[i5] || {}, r4 = e3[i5] = e3[i5] || [];
              for (const t6 of s5) a5[t6.featureIndex] || (a5[t6.featureIndex] = true, r4.push(t6));
            }
          }
          return e3;
        }(h3);
        for (const e3 in c3) c3[e3].forEach((e4) => {
          const i4 = e4.feature, s4 = t3.getFeatureState(i4.layer["source-layer"], i4.id);
          i4.source = i4.layer.source, i4.layer["source-layer"] && (i4.sourceLayer = i4.layer["source-layer"]), i4.state = s4;
        });
        return c3;
      }
      function $2(t3, e2) {
        const i3 = t3.tileID, s3 = e2.tileID;
        return i3.overscaledZ - s3.overscaledZ || i3.canonical.y - s3.canonical.y || i3.wrap - s3.wrap || i3.canonical.x - s3.canonical.x;
      }
      class W2 {
        constructor(e2, i3) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e2, this.uid = t2.a2(), this.uses = 0, this.tileSize = i3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(t3) {
          const e2 = t3 + this.timeAdded;
          e2 < this.fadeEndTime || (this.fadeEndTime = e2);
        }
        wasRequested() {
          return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
        }
        clearTextures(t3) {
          this.demTexture && t3.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(e2, i3, s3) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e2) {
            e2.featureIndex && (this.latestFeatureIndex = e2.featureIndex, e2.rawTileData ? (this.latestRawTileData = e2.rawTileData, this.latestFeatureIndex.rawTileData = e2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e2.collisionBoxArray, this.buckets = function(t3, e3) {
              const i4 = {};
              if (!e3) return i4;
              for (const s4 of t3) {
                const t4 = s4.layerIds.map((t5) => e3.getLayer(t5)).filter(Boolean);
                if (0 !== t4.length) {
                  s4.layers = t4, s4.stateDependentLayerIds && (s4.stateDependentLayers = s4.stateDependentLayerIds.map((e4) => t4.filter((t5) => t5.id === e4)[0]));
                  for (const e4 of t4) i4[e4.id] = s4;
                }
              }
              return i4;
            }(e2.buckets, i3.style), this.hasSymbolBuckets = false;
            for (const e3 in this.buckets) {
              const i4 = this.buckets[e3];
              if (i4 instanceof t2.a4) {
                if (this.hasSymbolBuckets = true, !s3) break;
                i4.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets) for (const e3 in this.buckets) {
              const i4 = this.buckets[e3];
              if (i4 instanceof t2.a4 && i4.hasRTLText) {
                this.hasRTLText = true, t2.a5();
                break;
              }
            }
            this.queryPadding = 0;
            for (const t3 in this.buckets) {
              const e3 = this.buckets[t3];
              this.queryPadding = Math.max(this.queryPadding, i3.style.getLayer(t3).queryRadius(e3));
            }
            e2.imageAtlas && (this.imageAtlas = e2.imageAtlas), e2.glyphAtlasImage && (this.glyphAtlasImage = e2.glyphAtlasImage);
          } else this.collisionBoxArray = new t2.a3();
        }
        unloadVectorData() {
          for (const t3 in this.buckets) this.buckets[t3].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(t3) {
          return this.buckets[t3.id];
        }
        upload(t3) {
          for (const e3 in this.buckets) {
            const i3 = this.buckets[e3];
            i3.uploadPending() && i3.upload(t3);
          }
          const e2 = t3.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new x2(t3, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new x2(t3, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(t3) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(t3, this.imageAtlasTexture);
        }
        queryRenderedFeatures(t3, e2, i3, s3, a3, o3, r3, n3, l3, h3) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: s3, cameraQueryGeometry: a3, scale: o3, tileSize: this.tileSize, pixelPosMatrix: h3, transform: n3, params: r3, queryPadding: this.queryPadding * l3 }, t3, e2, i3) : {};
        }
        querySourceFeatures(e2, i3) {
          const s3 = this.latestFeatureIndex;
          if (!s3 || !s3.rawTileData) return;
          const a3 = s3.loadVTLayers(), o3 = i3 && i3.sourceLayer ? i3.sourceLayer : "", r3 = a3._geojsonTileLayer || a3[o3];
          if (!r3) return;
          const n3 = t2.a6(i3 && i3.filter), { z: l3, x: h3, y: c3 } = this.tileID.canonical, u3 = { z: l3, x: h3, y: c3 };
          for (let i4 = 0; i4 < r3.length; i4++) {
            const a4 = r3.feature(i4);
            if (n3.needGeometry) {
              const e3 = t2.a7(a4, true);
              if (!n3.filter(new t2.a8(this.tileID.overscaledZ), e3, this.tileID.canonical)) continue;
            } else if (!n3.filter(new t2.a8(this.tileID.overscaledZ), a4)) continue;
            const d3 = s3.getId(a4, o3), _3 = new t2.a9(a4, l3, h3, c3, d3);
            _3.tile = u3, e2.push(_3);
          }
        }
        hasData() {
          return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(e2) {
          const i3 = this.expirationTime;
          if (e2.cacheControl) {
            const i4 = t2.aa(e2.cacheControl);
            i4["max-age"] && (this.expirationTime = Date.now() + 1e3 * i4["max-age"]);
          } else e2.expires && (this.expirationTime = new Date(e2.expires).getTime());
          if (this.expirationTime) {
            const t3 = Date.now();
            let e3 = false;
            if (this.expirationTime > t3) e3 = false;
            else if (i3) if (this.expirationTime < i3) e3 = true;
            else {
              const s3 = this.expirationTime - i3;
              s3 ? this.expirationTime = t3 + Math.max(s3, 3e4) : e3 = true;
            }
            else e3 = true;
            e3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(t3, e2) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t3).length) return;
          const i3 = this.latestFeatureIndex.loadVTLayers();
          for (const s3 in this.buckets) {
            if (!e2.style.hasLayer(s3)) continue;
            const a3 = this.buckets[s3], o3 = a3.layers[0].sourceLayer || "_geojsonTileLayer", r3 = i3[o3], n3 = t3[o3];
            if (!r3 || !n3 || 0 === Object.keys(n3).length) continue;
            a3.update(n3, r3, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const l3 = e2 && e2.style && e2.style.getLayer(s3);
            l3 && (this.queryPadding = Math.max(this.queryPadding, l3.queryRadius(a3)));
          }
        }
        holdingForFade() {
          return void 0 !== this.symbolFadeHoldUntil;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < t2.h.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(e2) {
          this.symbolFadeHoldUntil = t2.h.now() + e2;
        }
        setDependencies(t3, e2) {
          const i3 = {};
          for (const t4 of e2) i3[t4] = true;
          this.dependencies[t3] = i3;
        }
        hasDependency(t3, e2) {
          for (const i3 of t3) {
            const t4 = this.dependencies[i3];
            if (t4) {
              for (const i4 of e2) if (t4[i4]) return true;
            }
          }
          return false;
        }
      }
      class H2 {
        constructor(t3, e2) {
          this.max = t3, this.onRemove = e2, this.reset();
        }
        reset() {
          for (const t3 in this.data) for (const e2 of this.data[t3]) e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
          return this.data = {}, this.order = [], this;
        }
        add(t3, e2, i3) {
          const s3 = t3.wrapped().key;
          void 0 === this.data[s3] && (this.data[s3] = []);
          const a3 = { value: e2, timeout: void 0 };
          if (void 0 !== i3 && (a3.timeout = setTimeout(() => {
            this.remove(t3, a3);
          }, i3)), this.data[s3].push(a3), this.order.push(s3), this.order.length > this.max) {
            const t4 = this._getAndRemoveByKey(this.order[0]);
            t4 && this.onRemove(t4);
          }
          return this;
        }
        has(t3) {
          return t3.wrapped().key in this.data;
        }
        getAndRemove(t3) {
          return this.has(t3) ? this._getAndRemoveByKey(t3.wrapped().key) : null;
        }
        _getAndRemoveByKey(t3) {
          const e2 = this.data[t3].shift();
          return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t3].length && delete this.data[t3], this.order.splice(this.order.indexOf(t3), 1), e2.value;
        }
        getByKey(t3) {
          const e2 = this.data[t3];
          return e2 ? e2[0].value : null;
        }
        get(t3) {
          return this.has(t3) ? this.data[t3.wrapped().key][0].value : null;
        }
        remove(t3, e2) {
          if (!this.has(t3)) return this;
          const i3 = t3.wrapped().key, s3 = void 0 === e2 ? 0 : this.data[i3].indexOf(e2), a3 = this.data[i3][s3];
          return this.data[i3].splice(s3, 1), a3.timeout && clearTimeout(a3.timeout), 0 === this.data[i3].length && delete this.data[i3], this.onRemove(a3.value), this.order.splice(this.order.indexOf(i3), 1), this;
        }
        setMaxSize(t3) {
          for (this.max = t3; this.order.length > this.max; ) {
            const t4 = this._getAndRemoveByKey(this.order[0]);
            t4 && this.onRemove(t4);
          }
          return this;
        }
        filter(t3) {
          const e2 = [];
          for (const i3 in this.data) for (const s3 of this.data[i3]) t3(s3.value) || e2.push(s3);
          for (const t4 of e2) this.remove(t4.value.tileID, t4);
        }
      }
      class X2 {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(e2, i3, s3) {
          const a3 = String(i3);
          if (this.stateChanges[e2] = this.stateChanges[e2] || {}, this.stateChanges[e2][a3] = this.stateChanges[e2][a3] || {}, t2.e(this.stateChanges[e2][a3], s3), null === this.deletedStates[e2]) {
            this.deletedStates[e2] = {};
            for (const t3 in this.state[e2]) t3 !== a3 && (this.deletedStates[e2][t3] = null);
          } else if (this.deletedStates[e2] && null === this.deletedStates[e2][a3]) {
            this.deletedStates[e2][a3] = {};
            for (const t3 in this.state[e2][a3]) s3[t3] || (this.deletedStates[e2][a3][t3] = null);
          } else for (const t3 in s3) this.deletedStates[e2] && this.deletedStates[e2][a3] && null === this.deletedStates[e2][a3][t3] && delete this.deletedStates[e2][a3][t3];
        }
        removeFeatureState(t3, e2, i3) {
          if (null === this.deletedStates[t3]) return;
          const s3 = String(e2);
          if (this.deletedStates[t3] = this.deletedStates[t3] || {}, i3 && void 0 !== e2) null !== this.deletedStates[t3][s3] && (this.deletedStates[t3][s3] = this.deletedStates[t3][s3] || {}, this.deletedStates[t3][s3][i3] = null);
          else if (void 0 !== e2) if (this.stateChanges[t3] && this.stateChanges[t3][s3]) for (i3 in this.deletedStates[t3][s3] = {}, this.stateChanges[t3][s3]) this.deletedStates[t3][s3][i3] = null;
          else this.deletedStates[t3][s3] = null;
          else this.deletedStates[t3] = null;
        }
        getState(e2, i3) {
          const s3 = String(i3), a3 = t2.e({}, (this.state[e2] || {})[s3], (this.stateChanges[e2] || {})[s3]);
          if (null === this.deletedStates[e2]) return {};
          if (this.deletedStates[e2]) {
            const t3 = this.deletedStates[e2][i3];
            if (null === t3) return {};
            for (const e3 in t3) delete a3[e3];
          }
          return a3;
        }
        initializeTileState(t3, e2) {
          t3.setFeatureState(this.state, e2);
        }
        coalesceChanges(e2, i3) {
          const s3 = {};
          for (const e3 in this.stateChanges) {
            this.state[e3] = this.state[e3] || {};
            const i4 = {};
            for (const s4 in this.stateChanges[e3]) this.state[e3][s4] || (this.state[e3][s4] = {}), t2.e(this.state[e3][s4], this.stateChanges[e3][s4]), i4[s4] = this.state[e3][s4];
            s3[e3] = i4;
          }
          for (const e3 in this.deletedStates) {
            this.state[e3] = this.state[e3] || {};
            const i4 = {};
            if (null === this.deletedStates[e3]) for (const t3 in this.state[e3]) i4[t3] = {}, this.state[e3][t3] = {};
            else for (const t3 in this.deletedStates[e3]) {
              if (null === this.deletedStates[e3][t3]) this.state[e3][t3] = {};
              else for (const i5 of Object.keys(this.deletedStates[e3][t3])) delete this.state[e3][t3][i5];
              i4[t3] = this.state[e3][t3];
            }
            s3[e3] = s3[e3] || {}, t2.e(s3[e3], i4);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(s3).length) for (const t3 in e2) e2[t3].setFeatureState(s3, i3);
        }
      }
      class K2 extends t2.E {
        constructor(t3, e2, i3) {
          super(), this.id = t3, this.dispatcher = i3, this.on("data", (t4) => {
            "source" === t4.dataType && "metadata" === t4.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t4.dataType && "content" === t4.sourceDataType && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
          }), this.on("dataloading", () => {
            this._sourceErrored = false;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((t4, e3, i4, s3) => {
            const a3 = new (j2(e3.type))(t4, e3, i4, s3);
            if (a3.id !== t4) throw new Error(`Expected Source id to be ${t4} instead of ${a3.id}`);
            return a3;
          })(t3, e2, i3, this), this._tiles = {}, this._cache = new H2(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new X2(), this._didEmitContent = false, this._updated = false;
        }
        onAdd(t3) {
          this.map = t3, this._maxTileCacheSize = t3 ? t3._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t3 ? t3._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t3);
        }
        onRemove(t3) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t3);
        }
        loaded() {
          if (this._sourceErrored) return true;
          if (!this._sourceLoaded) return false;
          if (!this._source.loaded()) return false;
          if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain)) return true;
          if (!this._updated) return false;
          for (const t3 in this._tiles) {
            const e2 = this._tiles[t3];
            if ("loaded" !== e2.state && "errored" !== e2.state) return false;
          }
          return true;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused) return;
          const t3 = this._shouldReloadOnResume;
          this._paused = false, this._shouldReloadOnResume = false, t3 && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(t3, e2) {
          return this._source.loadTile(t3, e2);
        }
        _unloadTile(t3) {
          if (this._source.unloadTile) return this._source.unloadTile(t3, () => {
          });
        }
        _abortTile(e2) {
          this._source.abortTile && this._source.abortTile(e2, () => {
          }), this._source.fire(new t2.k("dataabort", { tile: e2, coord: e2.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t3) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const e2 in this._tiles) {
            const i3 = this._tiles[e2];
            i3.upload(t3), i3.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((t3) => t3.tileID).sort(Q2).map((t3) => t3.key);
        }
        getRenderableIds(e2) {
          const i3 = [];
          for (const t3 in this._tiles) this._isIdRenderable(t3, e2) && i3.push(this._tiles[t3]);
          return e2 ? i3.sort((e3, i4) => {
            const s3 = e3.tileID, a3 = i4.tileID, o3 = new t2.P(s3.canonical.x, s3.canonical.y)._rotate(this.transform.angle), r3 = new t2.P(a3.canonical.x, a3.canonical.y)._rotate(this.transform.angle);
            return s3.overscaledZ - a3.overscaledZ || r3.y - o3.y || r3.x - o3.x;
          }).map((t3) => t3.tileID.key) : i3.map((t3) => t3.tileID).sort(Q2).map((t3) => t3.key);
        }
        hasRenderableParent(t3) {
          const e2 = this.findLoadedParent(t3, 0);
          return !!e2 && this._isIdRenderable(e2.tileID.key);
        }
        _isIdRenderable(t3, e2) {
          return this._tiles[t3] && this._tiles[t3].hasData() && !this._coveredTiles[t3] && (e2 || !this._tiles[t3].holdingForFade());
        }
        reload() {
          if (this._paused) this._shouldReloadOnResume = true;
          else {
            this._cache.reset();
            for (const t3 in this._tiles) "errored" !== this._tiles[t3].state && this._reloadTile(t3, "reloading");
          }
        }
        _reloadTile(t3, e2) {
          const i3 = this._tiles[t3];
          i3 && ("loading" !== i3.state && (i3.state = e2), this._loadTile(i3, this._tileLoaded.bind(this, i3, t3, e2)));
        }
        _tileLoaded(e2, i3, s3, a3) {
          if (a3) return e2.state = "errored", void (404 !== a3.status ? this._source.fire(new t2.j(a3, { tile: e2 })) : this.update(this.transform, this.terrain));
          e2.timeAdded = t2.h.now(), "expired" === s3 && (e2.refreshedUponExpiration = true), this._setTileReloadTimer(i3, e2), "raster-dem" === this.getSource().type && e2.dem && this._backfillDEM(e2), this._state.initializeTileState(e2, this.map ? this.map.painter : null), e2.aborted || this._source.fire(new t2.k("data", { dataType: "source", tile: e2, coord: e2.tileID }));
        }
        _backfillDEM(t3) {
          const e2 = this.getRenderableIds();
          for (let s3 = 0; s3 < e2.length; s3++) {
            const a3 = e2[s3];
            if (t3.neighboringTiles && t3.neighboringTiles[a3]) {
              const e3 = this.getTileByID(a3);
              i3(t3, e3), i3(e3, t3);
            }
          }
          function i3(t4, e3) {
            t4.needsHillshadePrepare = true, t4.needsTerrainPrepare = true;
            let i4 = e3.tileID.canonical.x - t4.tileID.canonical.x;
            const s3 = e3.tileID.canonical.y - t4.tileID.canonical.y, a3 = Math.pow(2, t4.tileID.canonical.z), o3 = e3.tileID.key;
            0 === i4 && 0 === s3 || Math.abs(s3) > 1 || (Math.abs(i4) > 1 && (1 === Math.abs(i4 + a3) ? i4 += a3 : 1 === Math.abs(i4 - a3) && (i4 -= a3)), e3.dem && t4.dem && (t4.dem.backfillBorder(e3.dem, i4, s3), t4.neighboringTiles && t4.neighboringTiles[o3] && (t4.neighboringTiles[o3].backfilled = true)));
          }
        }
        getTile(t3) {
          return this.getTileByID(t3.key);
        }
        getTileByID(t3) {
          return this._tiles[t3];
        }
        _retainLoadedChildren(t3, e2, i3, s3) {
          for (const a3 in this._tiles) {
            let o3 = this._tiles[a3];
            if (s3[a3] || !o3.hasData() || o3.tileID.overscaledZ <= e2 || o3.tileID.overscaledZ > i3) continue;
            let r3 = o3.tileID;
            for (; o3 && o3.tileID.overscaledZ > e2 + 1; ) {
              const t4 = o3.tileID.scaledTo(o3.tileID.overscaledZ - 1);
              o3 = this._tiles[t4.key], o3 && o3.hasData() && (r3 = t4);
            }
            let n3 = r3;
            for (; n3.overscaledZ > e2; ) if (n3 = n3.scaledTo(n3.overscaledZ - 1), t3[n3.key]) {
              s3[r3.key] = r3;
              break;
            }
          }
        }
        findLoadedParent(t3, e2) {
          if (t3.key in this._loadedParentTiles) {
            const i3 = this._loadedParentTiles[t3.key];
            return i3 && i3.tileID.overscaledZ >= e2 ? i3 : null;
          }
          for (let i3 = t3.overscaledZ - 1; i3 >= e2; i3--) {
            const e3 = t3.scaledTo(i3), s3 = this._getLoadedTile(e3);
            if (s3) return s3;
          }
        }
        _getLoadedTile(t3) {
          const e2 = this._tiles[t3.key];
          return e2 && e2.hasData() ? e2 : this._cache.getByKey(t3.wrapped().key);
        }
        updateCacheSize(e2) {
          const i3 = Math.ceil(e2.width / this._source.tileSize) + 1, s3 = Math.ceil(e2.height / this._source.tileSize) + 1, a3 = Math.floor(i3 * s3 * (null === this._maxTileCacheZoomLevels ? t2.c.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o3 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, a3) : a3;
          this._cache.setMaxSize(o3);
        }
        handleWrapJump(t3) {
          const e2 = Math.round((t3 - (void 0 === this._prevLng ? t3 : this._prevLng)) / 360);
          if (this._prevLng = t3, e2) {
            const t4 = {};
            for (const i3 in this._tiles) {
              const s3 = this._tiles[i3];
              s3.tileID = s3.tileID.unwrapTo(s3.tileID.wrap + e2), t4[s3.tileID.key] = s3;
            }
            this._tiles = t4;
            for (const t5 in this._timers) clearTimeout(this._timers[t5]), delete this._timers[t5];
            for (const t5 in this._tiles) this._setTileReloadTimer(t5, this._tiles[t5]);
          }
        }
        update(e2, i3) {
          if (this.transform = e2, this.terrain = i3, !this._sourceLoaded || this._paused) return;
          let s3;
          this.updateCacheSize(e2), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? s3 = e2.getVisibleUnwrappedCoordinates(this._source.tileID).map((e3) => new t2.O(e3.canonical.z, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y)) : (s3 = e2.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i3 }), this._source.hasTile && (s3 = s3.filter((t3) => this._source.hasTile(t3)))) : s3 = [];
          const a3 = e2.coveringZoomLevel(this._source), o3 = Math.max(a3 - K2.maxOverzooming, this._source.minzoom), r3 = Math.max(a3 + K2.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const t3 = {};
            for (const e3 of s3) if (e3.canonical.z > this._source.minzoom) {
              const i4 = e3.scaledTo(e3.canonical.z - 1);
              t3[i4.key] = i4;
              const s4 = e3.scaledTo(Math.max(this._source.minzoom, Math.min(e3.canonical.z, 5)));
              t3[s4.key] = s4;
            }
            s3 = s3.concat(Object.values(t3));
          }
          const n3 = 0 === s3.length && !this._updated && this._didEmitContent;
          this._updated = true, n3 && this.fire(new t2.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
          const l3 = this._updateRetainedTiles(s3, a3);
          if (Y2(this._source.type)) {
            const e3 = {}, n4 = {}, h4 = Object.keys(l3), c3 = t2.h.now();
            for (const t3 of h4) {
              const i4 = l3[t3], s4 = this._tiles[t3];
              if (!s4 || 0 !== s4.fadeEndTime && s4.fadeEndTime <= c3) continue;
              const a4 = this.findLoadedParent(i4, o3);
              a4 && (this._addTile(a4.tileID), e3[a4.tileID.key] = a4.tileID), n4[t3] = i4;
            }
            this._retainLoadedChildren(n4, a3, r3, l3);
            for (const t3 in e3) l3[t3] || (this._coveredTiles[t3] = true, l3[t3] = e3[t3]);
            if (i3) {
              const t3 = {}, e4 = {};
              for (const i4 of s3) this._tiles[i4.key].hasData() ? t3[i4.key] = i4 : e4[i4.key] = i4;
              for (const i4 in e4) {
                const s4 = e4[i4].children(this._source.maxzoom);
                this._tiles[s4[0].key] && this._tiles[s4[1].key] && this._tiles[s4[2].key] && this._tiles[s4[3].key] && (t3[s4[0].key] = l3[s4[0].key] = s4[0], t3[s4[1].key] = l3[s4[1].key] = s4[1], t3[s4[2].key] = l3[s4[2].key] = s4[2], t3[s4[3].key] = l3[s4[3].key] = s4[3], delete e4[i4]);
              }
              for (const i4 in e4) {
                const s4 = this.findLoadedParent(e4[i4], this._source.minzoom);
                if (s4) {
                  t3[s4.tileID.key] = l3[s4.tileID.key] = s4.tileID;
                  for (const e5 in t3) t3[e5].isChildOf(s4.tileID) && delete t3[e5];
                }
              }
              for (const e5 in this._tiles) t3[e5] || (this._coveredTiles[e5] = true);
            }
          }
          for (const t3 in l3) this._tiles[t3].clearFadeHold();
          const h3 = t2.ab(this._tiles, l3);
          for (const t3 of h3) {
            const e3 = this._tiles[t3];
            e3.hasSymbolBuckets && !e3.holdingForFade() ? e3.setHoldDuration(this.map._fadeDuration) : e3.hasSymbolBuckets && !e3.symbolFadeFinished() || this._removeTile(t3);
          }
          this._updateLoadedParentTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const t3 in this._tiles) this._tiles[t3].holdingForFade() && this._removeTile(t3);
        }
        _updateRetainedTiles(t3, e2) {
          const i3 = {}, s3 = {}, a3 = Math.max(e2 - K2.maxOverzooming, this._source.minzoom), o3 = Math.max(e2 + K2.maxUnderzooming, this._source.minzoom), r3 = {};
          for (const s4 of t3) {
            const t4 = this._addTile(s4);
            i3[s4.key] = s4, t4.hasData() || e2 < this._source.maxzoom && (r3[s4.key] = s4);
          }
          this._retainLoadedChildren(r3, e2, o3, i3);
          for (const o4 of t3) {
            let t4 = this._tiles[o4.key];
            if (t4.hasData()) continue;
            if (e2 + 1 > this._source.maxzoom) {
              const t5 = o4.children(this._source.maxzoom)[0], e3 = this.getTile(t5);
              if (e3 && e3.hasData()) {
                i3[t5.key] = t5;
                continue;
              }
            } else {
              const t5 = o4.children(this._source.maxzoom);
              if (i3[t5[0].key] && i3[t5[1].key] && i3[t5[2].key] && i3[t5[3].key]) continue;
            }
            let r4 = t4.wasRequested();
            for (let e3 = o4.overscaledZ - 1; e3 >= a3; --e3) {
              const a4 = o4.scaledTo(e3);
              if (s3[a4.key]) break;
              if (s3[a4.key] = true, t4 = this.getTile(a4), !t4 && r4 && (t4 = this._addTile(a4)), t4) {
                const e4 = t4.hasData();
                if ((r4 || e4) && (i3[a4.key] = a4), r4 = t4.wasRequested(), e4) break;
              }
            }
          }
          return i3;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const t3 in this._tiles) {
            const e2 = [];
            let i3, s3 = this._tiles[t3].tileID;
            for (; s3.overscaledZ > 0; ) {
              if (s3.key in this._loadedParentTiles) {
                i3 = this._loadedParentTiles[s3.key];
                break;
              }
              e2.push(s3.key);
              const t4 = s3.scaledTo(s3.overscaledZ - 1);
              if (i3 = this._getLoadedTile(t4), i3) break;
              s3 = t4;
            }
            for (const t4 of e2) this._loadedParentTiles[t4] = i3;
          }
        }
        _addTile(e2) {
          let i3 = this._tiles[e2.key];
          if (i3) return i3;
          i3 = this._cache.getAndRemove(e2), i3 && (this._setTileReloadTimer(e2.key, i3), i3.tileID = e2, this._state.initializeTileState(i3, this.map ? this.map.painter : null), this._cacheTimers[e2.key] && (clearTimeout(this._cacheTimers[e2.key]), delete this._cacheTimers[e2.key], this._setTileReloadTimer(e2.key, i3)));
          const s3 = i3;
          return i3 || (i3 = new W2(e2, this._source.tileSize * e2.overscaleFactor()), this._loadTile(i3, this._tileLoaded.bind(this, i3, e2.key, i3.state))), i3.uses++, this._tiles[e2.key] = i3, s3 || this._source.fire(new t2.k("dataloading", { tile: i3, coord: i3.tileID, dataType: "source" })), i3;
        }
        _setTileReloadTimer(t3, e2) {
          t3 in this._timers && (clearTimeout(this._timers[t3]), delete this._timers[t3]);
          const i3 = e2.getExpiryTimeout();
          i3 && (this._timers[t3] = setTimeout(() => {
            this._reloadTile(t3, "expired"), delete this._timers[t3];
          }, i3));
        }
        _removeTile(t3) {
          const e2 = this._tiles[t3];
          e2 && (e2.uses--, delete this._tiles[t3], this._timers[t3] && (clearTimeout(this._timers[t3]), delete this._timers[t3]), e2.uses > 0 || (e2.hasData() && "reloading" !== e2.state ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
        }
        clearTiles() {
          this._shouldReloadOnResume = false, this._paused = false;
          for (const t3 in this._tiles) this._removeTile(t3);
          this._cache.reset();
        }
        tilesIn(e2, i3, s3) {
          const a3 = [], o3 = this.transform;
          if (!o3) return a3;
          const r3 = s3 ? o3.getCameraQueryGeometry(e2) : e2, n3 = e2.map((t3) => o3.pointCoordinate(t3, this.terrain)), l3 = r3.map((t3) => o3.pointCoordinate(t3, this.terrain)), h3 = this.getIds();
          let c3 = 1 / 0, u3 = 1 / 0, d3 = -1 / 0, _3 = -1 / 0;
          for (const t3 of l3) c3 = Math.min(c3, t3.x), u3 = Math.min(u3, t3.y), d3 = Math.max(d3, t3.x), _3 = Math.max(_3, t3.y);
          for (let e3 = 0; e3 < h3.length; e3++) {
            const s4 = this._tiles[h3[e3]];
            if (s4.holdingForFade()) continue;
            const r4 = s4.tileID, p3 = Math.pow(2, o3.zoom - s4.tileID.overscaledZ), m3 = i3 * s4.queryPadding * t2.N / s4.tileSize / p3, f3 = [r4.getTilePoint(new t2.U(c3, u3)), r4.getTilePoint(new t2.U(d3, _3))];
            if (f3[0].x - m3 < t2.N && f3[0].y - m3 < t2.N && f3[1].x + m3 >= 0 && f3[1].y + m3 >= 0) {
              const t3 = n3.map((t4) => r4.getTilePoint(t4)), e4 = l3.map((t4) => r4.getTilePoint(t4));
              a3.push({ tile: s4, tileID: r4, queryGeometry: t3, cameraQueryGeometry: e4, scale: p3 });
            }
          }
          return a3;
        }
        getVisibleCoordinates(t3) {
          const e2 = this.getRenderableIds(t3).map((t4) => this._tiles[t4].tileID);
          for (const t4 of e2) t4.posMatrix = this.transform.calculatePosMatrix(t4.toUnwrapped());
          return e2;
        }
        hasTransition() {
          if (this._source.hasTransition()) return true;
          if (Y2(this._source.type)) {
            const e2 = t2.h.now();
            for (const t3 in this._tiles) if (this._tiles[t3].fadeEndTime >= e2) return true;
          }
          return false;
        }
        setFeatureState(t3, e2, i3) {
          this._state.updateState(t3 = t3 || "_geojsonTileLayer", e2, i3);
        }
        removeFeatureState(t3, e2, i3) {
          this._state.removeFeatureState(t3 = t3 || "_geojsonTileLayer", e2, i3);
        }
        getFeatureState(t3, e2) {
          return this._state.getState(t3 = t3 || "_geojsonTileLayer", e2);
        }
        setDependencies(t3, e2, i3) {
          const s3 = this._tiles[t3];
          s3 && s3.setDependencies(e2, i3);
        }
        reloadTilesForDependencies(t3, e2) {
          for (const i3 in this._tiles) this._tiles[i3].hasDependency(t3, e2) && this._reloadTile(i3, "reloading");
          this._cache.filter((i3) => !i3.hasDependency(t3, e2));
        }
      }
      function Q2(t3, e2) {
        const i3 = Math.abs(2 * t3.wrap) - +(t3.wrap < 0), s3 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
        return t3.overscaledZ - e2.overscaledZ || s3 - i3 || e2.canonical.y - t3.canonical.y || e2.canonical.x - t3.canonical.x;
      }
      function Y2(t3) {
        return "raster" === t3 || "image" === t3 || "video" === t3;
      }
      K2.maxOverzooming = 10, K2.maxUnderzooming = 3;
      const J2 = "mapboxgl_preloaded_worker_pool";
      class tt {
        constructor() {
          this.active = {};
        }
        acquire(e2) {
          if (!this.workers) for (this.workers = []; this.workers.length < tt.workerCount; ) this.workers.push(new Worker(t2.c.WORKER_URL));
          return this.active[e2] = true, this.workers.slice();
        }
        release(t3) {
          delete this.active[t3], 0 === this.numActive() && (this.workers.forEach((t4) => {
            t4.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[J2];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const et = Math.floor(t2.h.hardwareConcurrency / 2);
      let it;
      function st() {
        return it || (it = new tt()), it;
      }
      tt.workerCount = t2.ac(globalThis) ? Math.max(Math.min(et, 3), 1) : 1;
      class at {
        constructor(t3, e2) {
          this.reset(t3, e2);
        }
        reset(t3, e2) {
          this.points = t3 || [], this._distances = [0];
          for (let t4 = 1; t4 < this.points.length; t4++) this._distances[t4] = this._distances[t4 - 1] + this.points[t4].dist(this.points[t4 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(e2) {
          if (1 === this.points.length) return this.points[0];
          e2 = t2.ad(e2, 0, 1);
          let i3 = 1, s3 = this._distances[i3];
          const a3 = e2 * this.paddedLength + this.padding;
          for (; s3 < a3 && i3 < this._distances.length; ) s3 = this._distances[++i3];
          const o3 = i3 - 1, r3 = this._distances[o3], n3 = s3 - r3, l3 = n3 > 0 ? (a3 - r3) / n3 : 0;
          return this.points[o3].mult(1 - l3).add(this.points[i3].mult(l3));
        }
      }
      function ot(t3, e2) {
        let i3 = true;
        return "always" === t3 || "never" !== t3 && "never" !== e2 || (i3 = false), i3;
      }
      class rt {
        constructor(t3, e2, i3) {
          const s3 = this.boxCells = [], a3 = this.circleCells = [];
          this.xCellCount = Math.ceil(t3 / i3), this.yCellCount = Math.ceil(e2 / i3);
          for (let t4 = 0; t4 < this.xCellCount * this.yCellCount; t4++) s3.push([]), a3.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t3, this.height = e2, this.xScale = this.xCellCount / t3, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(t3, e2, i3, s3, a3) {
          this._forEachCell(e2, i3, s3, a3, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t3), this.bboxes.push(e2), this.bboxes.push(i3), this.bboxes.push(s3), this.bboxes.push(a3);
        }
        insertCircle(t3, e2, i3, s3) {
          this._forEachCell(e2 - s3, i3 - s3, e2 + s3, i3 + s3, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t3), this.circles.push(e2), this.circles.push(i3), this.circles.push(s3);
        }
        _insertBoxCell(t3, e2, i3, s3, a3, o3) {
          this.boxCells[a3].push(o3);
        }
        _insertCircleCell(t3, e2, i3, s3, a3, o3) {
          this.circleCells[a3].push(o3);
        }
        _query(t3, e2, i3, s3, a3, o3, r3) {
          if (i3 < 0 || t3 > this.width || s3 < 0 || e2 > this.height) return [];
          const n3 = [];
          if (t3 <= 0 && e2 <= 0 && this.width <= i3 && this.height <= s3) {
            if (a3) return [{ key: null, x1: t3, y1: e2, x2: i3, y2: s3 }];
            for (let t4 = 0; t4 < this.boxKeys.length; t4++) n3.push({ key: this.boxKeys[t4], x1: this.bboxes[4 * t4], y1: this.bboxes[4 * t4 + 1], x2: this.bboxes[4 * t4 + 2], y2: this.bboxes[4 * t4 + 3] });
            for (let t4 = 0; t4 < this.circleKeys.length; t4++) {
              const e3 = this.circles[3 * t4], i4 = this.circles[3 * t4 + 1], s4 = this.circles[3 * t4 + 2];
              n3.push({ key: this.circleKeys[t4], x1: e3 - s4, y1: i4 - s4, x2: e3 + s4, y2: i4 + s4 });
            }
          } else this._forEachCell(t3, e2, i3, s3, this._queryCell, n3, { hitTest: a3, overlapMode: o3, seenUids: { box: {}, circle: {} } }, r3);
          return n3;
        }
        query(t3, e2, i3, s3) {
          return this._query(t3, e2, i3, s3, false, null);
        }
        hitTest(t3, e2, i3, s3, a3, o3) {
          return this._query(t3, e2, i3, s3, true, a3, o3).length > 0;
        }
        hitTestCircle(t3, e2, i3, s3, a3) {
          const o3 = t3 - i3, r3 = t3 + i3, n3 = e2 - i3, l3 = e2 + i3;
          if (r3 < 0 || o3 > this.width || l3 < 0 || n3 > this.height) return false;
          const h3 = [];
          return this._forEachCell(o3, n3, r3, l3, this._queryCellCircle, h3, { hitTest: true, overlapMode: s3, circle: { x: t3, y: e2, radius: i3 }, seenUids: { box: {}, circle: {} } }, a3), h3.length > 0;
        }
        _queryCell(t3, e2, i3, s3, a3, o3, r3, n3) {
          const { seenUids: l3, hitTest: h3, overlapMode: c3 } = r3, u3 = this.boxCells[a3];
          if (null !== u3) {
            const a4 = this.bboxes;
            for (const r4 of u3) if (!l3.box[r4]) {
              l3.box[r4] = true;
              const u4 = 4 * r4, d4 = this.boxKeys[r4];
              if (t3 <= a4[u4 + 2] && e2 <= a4[u4 + 3] && i3 >= a4[u4 + 0] && s3 >= a4[u4 + 1] && (!n3 || n3(d4)) && (!h3 || !ot(c3, d4.overlapMode)) && (o3.push({ key: d4, x1: a4[u4], y1: a4[u4 + 1], x2: a4[u4 + 2], y2: a4[u4 + 3] }), h3)) return true;
            }
          }
          const d3 = this.circleCells[a3];
          if (null !== d3) {
            const a4 = this.circles;
            for (const r4 of d3) if (!l3.circle[r4]) {
              l3.circle[r4] = true;
              const u4 = 3 * r4, d4 = this.circleKeys[r4];
              if (this._circleAndRectCollide(a4[u4], a4[u4 + 1], a4[u4 + 2], t3, e2, i3, s3) && (!n3 || n3(d4)) && (!h3 || !ot(c3, d4.overlapMode))) {
                const t4 = a4[u4], e3 = a4[u4 + 1], i4 = a4[u4 + 2];
                if (o3.push({ key: d4, x1: t4 - i4, y1: e3 - i4, x2: t4 + i4, y2: e3 + i4 }), h3) return true;
              }
            }
          }
          return false;
        }
        _queryCellCircle(t3, e2, i3, s3, a3, o3, r3, n3) {
          const { circle: l3, seenUids: h3, overlapMode: c3 } = r3, u3 = this.boxCells[a3];
          if (null !== u3) {
            const t4 = this.bboxes;
            for (const e3 of u3) if (!h3.box[e3]) {
              h3.box[e3] = true;
              const i4 = 4 * e3, s4 = this.boxKeys[e3];
              if (this._circleAndRectCollide(l3.x, l3.y, l3.radius, t4[i4 + 0], t4[i4 + 1], t4[i4 + 2], t4[i4 + 3]) && (!n3 || n3(s4)) && !ot(c3, s4.overlapMode)) return o3.push(true), true;
            }
          }
          const d3 = this.circleCells[a3];
          if (null !== d3) {
            const t4 = this.circles;
            for (const e3 of d3) if (!h3.circle[e3]) {
              h3.circle[e3] = true;
              const i4 = 3 * e3, s4 = this.circleKeys[e3];
              if (this._circlesCollide(t4[i4], t4[i4 + 1], t4[i4 + 2], l3.x, l3.y, l3.radius) && (!n3 || n3(s4)) && !ot(c3, s4.overlapMode)) return o3.push(true), true;
            }
          }
        }
        _forEachCell(t3, e2, i3, s3, a3, o3, r3, n3) {
          const l3 = this._convertToXCellCoord(t3), h3 = this._convertToYCellCoord(e2), c3 = this._convertToXCellCoord(i3), u3 = this._convertToYCellCoord(s3);
          for (let d3 = l3; d3 <= c3; d3++) for (let l4 = h3; l4 <= u3; l4++) if (a3.call(this, t3, e2, i3, s3, this.xCellCount * l4 + d3, o3, r3, n3)) return;
        }
        _convertToXCellCoord(t3) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t3 * this.xScale)));
        }
        _convertToYCellCoord(t3) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t3 * this.yScale)));
        }
        _circlesCollide(t3, e2, i3, s3, a3, o3) {
          const r3 = s3 - t3, n3 = a3 - e2, l3 = i3 + o3;
          return l3 * l3 > r3 * r3 + n3 * n3;
        }
        _circleAndRectCollide(t3, e2, i3, s3, a3, o3, r3) {
          const n3 = (o3 - s3) / 2, l3 = Math.abs(t3 - (s3 + n3));
          if (l3 > n3 + i3) return false;
          const h3 = (r3 - a3) / 2, c3 = Math.abs(e2 - (a3 + h3));
          if (c3 > h3 + i3) return false;
          if (l3 <= n3 || c3 <= h3) return true;
          const u3 = l3 - n3, d3 = c3 - h3;
          return u3 * u3 + d3 * d3 <= i3 * i3;
        }
      }
      function nt(e2, i3, s3, a3, o3) {
        const r3 = t2.Z();
        return i3 ? (t2.a0(r3, r3, [1 / o3, 1 / o3, 1]), s3 || t2.ae(r3, r3, a3.angle)) : t2.a1(r3, a3.labelPlaneMatrix, e2), r3;
      }
      function lt(e2, i3, s3, a3, o3) {
        if (i3) {
          const i4 = t2.af(e2);
          return t2.a0(i4, i4, [o3, o3, 1]), s3 || t2.ae(i4, i4, -a3.angle), i4;
        }
        return a3.glCoordMatrix;
      }
      function ht(e2, i3, s3) {
        let a3;
        s3 ? (a3 = [e2.x, e2.y, s3(e2.x, e2.y), 1], t2.ag(a3, a3, i3)) : (a3 = [e2.x, e2.y, 0, 1], Tt(a3, a3, i3));
        const o3 = a3[3];
        return { point: new t2.P(a3[0] / o3, a3[1] / o3), signedDistanceFromCamera: o3 };
      }
      function ct(t3, e2) {
        return 0.5 + t3 / e2 * 0.5;
      }
      function ut(t3, e2) {
        const i3 = t3[0] / t3[3], s3 = t3[1] / t3[3];
        return i3 >= -e2[0] && i3 <= e2[0] && s3 >= -e2[1] && s3 <= e2[1];
      }
      function dt(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3) {
        const u3 = a3 ? e2.textSizeData : e2.iconSizeData, d3 = t2.ah(u3, s3.transform.zoom), _3 = [256 / s3.width * 2 + 1, 256 / s3.height * 2 + 1], p3 = a3 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
        p3.clear();
        const m3 = e2.lineVertexArray, f3 = a3 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, g3 = s3.transform.width / s3.transform.height;
        let v3 = false;
        for (let a4 = 0; a4 < f3.length; a4++) {
          const x3 = f3.get(a4);
          if (x3.hidden || x3.writingMode === t2.ai.vertical && !v3) {
            wt(x3.numGlyphs, p3);
            continue;
          }
          let y3;
          if (v3 = false, c3 ? (y3 = [x3.anchorX, x3.anchorY, c3(x3.anchorX, x3.anchorY), 1], t2.ag(y3, y3, i3)) : (y3 = [x3.anchorX, x3.anchorY, 0, 1], Tt(y3, y3, i3)), !ut(y3, _3)) {
            wt(x3.numGlyphs, p3);
            continue;
          }
          const b3 = ct(s3.transform.cameraToCenterDistance, y3[3]), w3 = t2.aj(u3, d3, x3), T3 = n3 ? w3 / b3 : w3 * b3, I3 = new t2.P(x3.anchorX, x3.anchorY), E3 = ht(I3, o3, c3).point, S3 = { projections: {}, offsets: {} }, C3 = mt(x3, T3, false, l3, i3, o3, r3, e2.glyphOffsetArray, m3, p3, E3, I3, S3, g3, h3, c3);
          v3 = C3.useVertical, (C3.notEnoughRoom || v3 || C3.needsFlipping && mt(x3, T3, true, l3, i3, o3, r3, e2.glyphOffsetArray, m3, p3, E3, I3, S3, g3, h3, c3).notEnoughRoom) && wt(x3.numGlyphs, p3);
        }
        a3 ? e2.text.dynamicLayoutVertexBuffer.updateData(p3) : e2.icon.dynamicLayoutVertexBuffer.updateData(p3);
      }
      function _t(t3, e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3) {
        const _3 = n3.glyphStartIndex + n3.numGlyphs, p3 = n3.lineStartIndex, m3 = n3.lineStartIndex + n3.lineLength, f3 = e2.getoffsetX(n3.glyphStartIndex), g3 = e2.getoffsetX(_3 - 1), v3 = yt(t3 * f3, i3, s3, a3, o3, r3, n3.segment, p3, m3, l3, h3, c3, u3, d3);
        if (!v3) return null;
        const x3 = yt(t3 * g3, i3, s3, a3, o3, r3, n3.segment, p3, m3, l3, h3, c3, u3, d3);
        return x3 ? { first: v3, last: x3 } : null;
      }
      function pt(e2, i3, s3, a3) {
        return e2 === t2.ai.horizontal && Math.abs(s3.y - i3.y) > Math.abs(s3.x - i3.x) * a3 ? { useVertical: true } : (e2 === t2.ai.vertical ? i3.y < s3.y : i3.x > s3.x) ? { needsFlipping: true } : null;
      }
      function mt(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3, _3, p3, m3, f3) {
        const g3 = i3 / 24, v3 = e2.lineOffsetX * g3, x3 = e2.lineOffsetY * g3;
        let y3;
        if (e2.numGlyphs > 1) {
          const t3 = e2.glyphStartIndex + e2.numGlyphs, i4 = e2.lineStartIndex, o4 = e2.lineStartIndex + e2.lineLength, c4 = _t(g3, l3, v3, x3, s3, u3, d3, e2, h3, r3, _3, m3, f3);
          if (!c4) return { notEnoughRoom: true };
          const b3 = ht(c4.first.point, n3, f3).point, w3 = ht(c4.last.point, n3, f3).point;
          if (a3 && !s3) {
            const t4 = pt(e2.writingMode, b3, w3, p3);
            if (t4) return t4;
          }
          y3 = [c4.first];
          for (let a4 = e2.glyphStartIndex + 1; a4 < t3 - 1; a4++) y3.push(yt(g3 * l3.getoffsetX(a4), v3, x3, s3, u3, d3, e2.segment, i4, o4, h3, r3, _3, m3, f3));
          y3.push(c4.last);
        } else {
          if (a3 && !s3) {
            const i5 = ht(d3, o3, f3).point, s4 = e2.lineStartIndex + e2.segment + 1, a4 = new t2.P(h3.getx(s4), h3.gety(s4)), r4 = ht(a4, o3, f3), n4 = r4.signedDistanceFromCamera > 0 ? r4.point : ft(d3, a4, i5, 1, o3, f3), l4 = pt(e2.writingMode, i5, n4, p3);
            if (l4) return l4;
          }
          const i4 = yt(g3 * l3.getoffsetX(e2.glyphStartIndex), v3, x3, s3, u3, d3, e2.segment, e2.lineStartIndex, e2.lineStartIndex + e2.lineLength, h3, r3, _3, m3, f3);
          if (!i4) return { notEnoughRoom: true };
          y3 = [i4];
        }
        for (const e3 of y3) t2.ak(c3, e3.point, e3.angle);
        return {};
      }
      function ft(t3, e2, i3, s3, a3, o3) {
        const r3 = ht(t3.add(t3.sub(e2)._unit()), a3, o3).point, n3 = i3.sub(r3);
        return i3.add(n3._mult(s3 / n3.mag()));
      }
      function gt(e2, i3) {
        const { projectionCache: s3, lineVertexArray: a3, labelPlaneMatrix: o3, tileAnchorPoint: r3, distanceFromAnchor: n3, getElevation: l3, previousVertex: h3, direction: c3, absOffsetX: u3 } = i3;
        if (s3.projections[e2]) return s3.projections[e2];
        const d3 = new t2.P(a3.getx(e2), a3.gety(e2)), _3 = ht(d3, o3, l3);
        if (_3.signedDistanceFromCamera > 0) return s3.projections[e2] = _3.point, _3.point;
        const p3 = e2 - c3;
        return ft(0 === n3 ? r3 : new t2.P(a3.getx(p3), a3.gety(p3)), d3, h3, u3 - n3 + 1, o3, l3);
      }
      function vt(t3, e2, i3) {
        return t3._unit()._perp()._mult(e2 * i3);
      }
      function xt(e2, i3, s3, a3, o3, r3, n3, l3) {
        const { projectionCache: h3, direction: c3 } = l3;
        if (h3.offsets[e2]) return h3.offsets[e2];
        const u3 = s3.add(i3);
        if (e2 + c3 < a3 || e2 + c3 >= o3) return h3.offsets[e2] = u3, u3;
        const d3 = gt(e2 + c3, l3), _3 = vt(d3.sub(s3), n3, c3), p3 = s3.add(_3), m3 = d3.add(_3);
        return h3.offsets[e2] = t2.al(r3, u3, p3, m3) || u3, h3.offsets[e2];
      }
      function yt(t3, e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3, _3) {
        const p3 = s3 ? t3 - e2 : t3 + e2;
        let m3 = p3 > 0 ? 1 : -1, f3 = 0;
        s3 && (m3 *= -1, f3 = Math.PI), m3 < 0 && (f3 += Math.PI);
        let g3, v3, x3 = m3 > 0 ? n3 + r3 : n3 + r3 + 1, y3 = a3, b3 = a3, w3 = 0, T3 = 0;
        const I3 = Math.abs(p3), E3 = [];
        let S3;
        for (; w3 + T3 <= I3; ) {
          if (x3 += m3, x3 < n3 || x3 >= l3) return null;
          w3 += T3, b3 = y3, v3 = g3;
          const t4 = { projectionCache: u3, lineVertexArray: h3, labelPlaneMatrix: c3, tileAnchorPoint: o3, distanceFromAnchor: w3, getElevation: _3, previousVertex: b3, direction: m3, absOffsetX: I3 };
          if (y3 = gt(x3, t4), 0 === i3) E3.push(b3), S3 = y3.sub(b3);
          else {
            let e3;
            const s4 = y3.sub(b3);
            e3 = 0 === s4.mag() ? vt(gt(x3 + m3, t4).sub(y3), i3, m3) : vt(s4, i3, m3), v3 || (v3 = b3.add(e3)), g3 = xt(x3, e3, y3, n3, l3, v3, i3, t4), E3.push(v3), S3 = g3.sub(v3);
          }
          T3 = S3.mag();
        }
        const C3 = S3._mult((I3 - w3) / T3)._add(v3 || b3), P3 = f3 + Math.atan2(y3.y - b3.y, y3.x - b3.x);
        return E3.push(C3), { point: C3, angle: d3 ? P3 : 0, path: E3 };
      }
      const bt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function wt(t3, e2) {
        for (let i3 = 0; i3 < t3; i3++) {
          const t4 = e2.length;
          e2.resize(t4 + 4), e2.float32.set(bt, 3 * t4);
        }
      }
      function Tt(t3, e2, i3) {
        const s3 = e2[0], a3 = e2[1];
        return t3[0] = i3[0] * s3 + i3[4] * a3 + i3[12], t3[1] = i3[1] * s3 + i3[5] * a3 + i3[13], t3[3] = i3[3] * s3 + i3[7] * a3 + i3[15], t3;
      }
      const It = 100;
      class Et {
        constructor(t3, e2 = new rt(t3.width + 200, t3.height + 200, 25), i3 = new rt(t3.width + 200, t3.height + 200, 25)) {
          this.transform = t3, this.grid = e2, this.ignoredGrid = i3, this.pitchfactor = Math.cos(t3._pitch) * t3.cameraToCenterDistance, this.screenRightBoundary = t3.width + It, this.screenBottomBoundary = t3.height + It, this.gridRightBoundary = t3.width + 200, this.gridBottomBoundary = t3.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(t3, e2, i3, s3, a3, o3) {
          const r3 = this.projectAndGetPerspectiveRatio(s3, t3.anchorPointX, t3.anchorPointY, o3), n3 = i3 * r3.perspectiveRatio, l3 = t3.x1 * n3 + r3.point.x, h3 = t3.y1 * n3 + r3.point.y, c3 = t3.x2 * n3 + r3.point.x, u3 = t3.y2 * n3 + r3.point.y;
          return !this.isInsideGrid(l3, h3, c3, u3) || "always" !== e2 && this.grid.hitTest(l3, h3, c3, u3, e2, a3) || r3.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: false } : { box: [l3, h3, c3, u3], offscreen: this.isOffscreen(l3, h3, c3, u3) };
        }
        placeCollisionCircles(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3, _3, p3) {
          const m3 = [], f3 = new t2.P(i3.anchorX, i3.anchorY), g3 = ht(f3, r3, p3), v3 = ct(this.transform.cameraToCenterDistance, g3.signedDistanceFromCamera), x3 = (c3 ? o3 / v3 : o3 * v3) / t2.ap, y3 = ht(f3, n3, p3).point, b3 = _t(x3, a3, i3.lineOffsetX * x3, i3.lineOffsetY * x3, false, y3, f3, i3, s3, n3, { projections: {}, offsets: {} }, false, p3);
          let w3 = false, T3 = false, I3 = true;
          if (b3) {
            const i4 = 0.5 * d3 * v3 + _3, s4 = new t2.P(-100, -100), a4 = new t2.P(this.screenRightBoundary, this.screenBottomBoundary), o4 = new at(), r4 = b3.first, n4 = b3.last;
            let c4 = [];
            for (let t3 = r4.path.length - 1; t3 >= 1; t3--) c4.push(r4.path[t3]);
            for (let t3 = 1; t3 < n4.path.length; t3++) c4.push(n4.path[t3]);
            const f4 = 2.5 * i4;
            if (l3) {
              const t3 = c4.map((t4) => ht(t4, l3, p3));
              c4 = t3.some((t4) => t4.signedDistanceFromCamera <= 0) ? [] : t3.map((t4) => t4.point);
            }
            let g4 = [];
            if (c4.length > 0) {
              const e3 = c4[0].clone(), i5 = c4[0].clone();
              for (let t3 = 1; t3 < c4.length; t3++) e3.x = Math.min(e3.x, c4[t3].x), e3.y = Math.min(e3.y, c4[t3].y), i5.x = Math.max(i5.x, c4[t3].x), i5.y = Math.max(i5.y, c4[t3].y);
              g4 = e3.x >= s4.x && i5.x <= a4.x && e3.y >= s4.y && i5.y <= a4.y ? [c4] : i5.x < s4.x || e3.x > a4.x || i5.y < s4.y || e3.y > a4.y ? [] : t2.am([c4], s4.x, s4.y, a4.x, a4.y);
            }
            for (const t3 of g4) {
              o4.reset(t3, 0.25 * i4);
              let s5 = 0;
              s5 = o4.length <= 0.5 * i4 ? 1 : Math.ceil(o4.paddedLength / f4) + 1;
              for (let t4 = 0; t4 < s5; t4++) {
                const a5 = t4 / Math.max(s5 - 1, 1), r5 = o4.lerp(a5), n5 = r5.x + It, l4 = r5.y + It;
                m3.push(n5, l4, i4, 0);
                const c5 = n5 - i4, d4 = l4 - i4, _4 = n5 + i4, p4 = l4 + i4;
                if (I3 = I3 && this.isOffscreen(c5, d4, _4, p4), T3 = T3 || this.isInsideGrid(c5, d4, _4, p4), "always" !== e2 && this.grid.hitTestCircle(n5, l4, i4, e2, u3) && (w3 = true, !h3)) return { circles: [], offscreen: false, collisionDetected: w3 };
              }
            }
          }
          return { circles: !h3 && w3 || !T3 || v3 < this.perspectiveRatioCutoff ? [] : m3, offscreen: I3, collisionDetected: w3 };
        }
        queryRenderedSymbols(e2) {
          if (0 === e2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
          const i3 = [];
          let s3 = 1 / 0, a3 = 1 / 0, o3 = -1 / 0, r3 = -1 / 0;
          for (const n4 of e2) {
            const e3 = new t2.P(n4.x + It, n4.y + It);
            s3 = Math.min(s3, e3.x), a3 = Math.min(a3, e3.y), o3 = Math.max(o3, e3.x), r3 = Math.max(r3, e3.y), i3.push(e3);
          }
          const n3 = this.grid.query(s3, a3, o3, r3).concat(this.ignoredGrid.query(s3, a3, o3, r3)), l3 = {}, h3 = {};
          for (const e3 of n3) {
            const s4 = e3.key;
            if (void 0 === l3[s4.bucketInstanceId] && (l3[s4.bucketInstanceId] = {}), l3[s4.bucketInstanceId][s4.featureIndex]) continue;
            const a4 = [new t2.P(e3.x1, e3.y1), new t2.P(e3.x2, e3.y1), new t2.P(e3.x2, e3.y2), new t2.P(e3.x1, e3.y2)];
            t2.an(i3, a4) && (l3[s4.bucketInstanceId][s4.featureIndex] = true, void 0 === h3[s4.bucketInstanceId] && (h3[s4.bucketInstanceId] = []), h3[s4.bucketInstanceId].push(s4.featureIndex));
          }
          return h3;
        }
        insertCollisionBox(t3, e2, i3, s3, a3, o3) {
          (i3 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: s3, featureIndex: a3, collisionGroupID: o3, overlapMode: e2 }, t3[0], t3[1], t3[2], t3[3]);
        }
        insertCollisionCircles(t3, e2, i3, s3, a3, o3) {
          const r3 = i3 ? this.ignoredGrid : this.grid, n3 = { bucketInstanceId: s3, featureIndex: a3, collisionGroupID: o3, overlapMode: e2 };
          for (let e3 = 0; e3 < t3.length; e3 += 4) r3.insertCircle(n3, t3[e3], t3[e3 + 1], t3[e3 + 2]);
        }
        projectAndGetPerspectiveRatio(e2, i3, s3, a3) {
          let o3;
          return a3 ? (o3 = [i3, s3, a3(i3, s3), 1], t2.ag(o3, o3, e2)) : (o3 = [i3, s3, 0, 1], Tt(o3, o3, e2)), { point: new t2.P((o3[0] / o3[3] + 1) / 2 * this.transform.width + It, (-o3[1] / o3[3] + 1) / 2 * this.transform.height + It), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / o3[3] * 0.5 };
        }
        isOffscreen(t3, e2, i3, s3) {
          return i3 < It || t3 >= this.screenRightBoundary || s3 < It || e2 > this.screenBottomBoundary;
        }
        isInsideGrid(t3, e2, i3, s3) {
          return i3 >= 0 && t3 < this.gridRightBoundary && s3 >= 0 && e2 < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const e2 = t2.ao([]);
          return t2.$(e2, e2, [-100, -100, 0]), e2;
        }
      }
      function St(e2, i3, s3) {
        return i3 * (t2.N / (e2.tileSize * Math.pow(2, s3 - e2.tileID.overscaledZ)));
      }
      class Ct {
        constructor(t3, e2, i3, s3) {
          this.opacity = t3 ? Math.max(0, Math.min(1, t3.opacity + (t3.placed ? e2 : -e2))) : s3 && i3 ? 1 : 0, this.placed = i3;
        }
        isHidden() {
          return 0 === this.opacity && !this.placed;
        }
      }
      class Pt {
        constructor(t3, e2, i3, s3, a3) {
          this.text = new Ct(t3 ? t3.text : null, e2, i3, a3), this.icon = new Ct(t3 ? t3.icon : null, e2, s3, a3);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class Dt {
        constructor(t3, e2, i3) {
          this.text = t3, this.icon = e2, this.skipFade = i3;
        }
      }
      class Mt {
        constructor() {
          this.invProjMatrix = t2.Z(), this.viewportMatrix = t2.Z(), this.circles = [];
        }
      }
      class zt {
        constructor(t3, e2, i3, s3, a3) {
          this.bucketInstanceId = t3, this.featureIndex = e2, this.sourceLayerIndex = i3, this.bucketIndex = s3, this.tileID = a3;
        }
      }
      class Lt {
        constructor(t3) {
          this.crossSourceCollisions = t3, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(t3) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[t3]) {
            const e2 = ++this.maxGroupID;
            this.collisionGroups[t3] = { ID: e2, predicate: (t4) => t4.collisionGroupID === e2 };
          }
          return this.collisionGroups[t3];
        }
      }
      function At(e2, i3, s3, a3, o3) {
        const { horizontalAlign: r3, verticalAlign: n3 } = t2.au(e2);
        return new t2.P(-(r3 - 0.5) * i3 + a3[0] * o3, -(n3 - 0.5) * s3 + a3[1] * o3);
      }
      function Rt(e2, i3, s3, a3, o3, r3) {
        const { x1: n3, x2: l3, y1: h3, y2: c3, anchorPointX: u3, anchorPointY: d3 } = e2, _3 = new t2.P(i3, s3);
        return a3 && _3._rotate(o3 ? r3 : -r3), { x1: n3 + _3.x, y1: h3 + _3.y, x2: l3 + _3.x, y2: c3 + _3.y, anchorPointX: u3, anchorPointY: d3 };
      }
      class kt {
        constructor(t3, e2, i3, s3, a3) {
          this.transform = t3.clone(), this.terrain = e2, this.collisionIndex = new Et(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i3, this.retainedQueryData = {}, this.collisionGroups = new Lt(s3), this.collisionCircleArrays = {}, this.prevPlacement = a3, a3 && (a3.prevPlacement = void 0), this.placedOrientations = {};
        }
        getBucketParts(e2, i3, s3, a3) {
          const o3 = s3.getBucket(i3), r3 = s3.latestFeatureIndex;
          if (!o3 || !r3 || i3.id !== o3.layerIds[0]) return;
          const n3 = s3.collisionBoxArray, l3 = o3.layers[0].layout, h3 = Math.pow(2, this.transform.zoom - s3.tileID.overscaledZ), c3 = s3.tileSize / t2.N, u3 = this.transform.calculatePosMatrix(s3.tileID.toUnwrapped()), d3 = "map" === l3.get("text-pitch-alignment"), _3 = "map" === l3.get("text-rotation-alignment"), p3 = St(s3, 1, this.transform.zoom), m3 = nt(u3, d3, _3, this.transform, p3);
          let f3 = null;
          if (d3) {
            const e3 = lt(u3, d3, _3, this.transform, p3);
            f3 = t2.a1([], this.transform.labelPlaneMatrix, e3);
          }
          this.retainedQueryData[o3.bucketInstanceId] = new zt(o3.bucketInstanceId, r3, o3.sourceLayerIndex, o3.index, s3.tileID);
          const g3 = { bucket: o3, layout: l3, posMatrix: u3, textLabelPlaneMatrix: m3, labelToScreenMatrix: f3, scale: h3, textPixelRatio: c3, holdingForFade: s3.holdingForFade(), collisionBoxArray: n3, partiallyEvaluatedTextSize: t2.ah(o3.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o3.sourceID) };
          if (a3) for (const t3 of o3.sortKeyRanges) {
            const { sortKey: i4, symbolInstanceStart: s4, symbolInstanceEnd: a4 } = t3;
            e2.push({ sortKey: i4, symbolInstanceStart: s4, symbolInstanceEnd: a4, parameters: g3 });
          }
          else e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: o3.symbolInstances.length, parameters: g3 });
        }
        attemptAnchorPlacement(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3, _3, p3, m3, f3) {
          const g3 = t2.aq[e2.textAnchor], v3 = [e2.textOffset0, e2.textOffset1], x3 = At(g3, s3, a3, v3, o3), y3 = this.collisionIndex.placeCollisionBox(Rt(i3, x3.x, x3.y, r3, n3, this.transform.angle), u3, l3, h3, c3.predicate, f3);
          if ((!m3 || 0 !== this.collisionIndex.placeCollisionBox(Rt(m3, x3.x, x3.y, r3, n3, this.transform.angle), u3, l3, h3, c3.predicate, f3).box.length) && y3.box.length > 0) {
            let t3;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[d3.crossTileID] && this.prevPlacement.placements[d3.crossTileID] && this.prevPlacement.placements[d3.crossTileID].text && (t3 = this.prevPlacement.variableOffsets[d3.crossTileID].anchor), 0 === d3.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[d3.crossTileID] = { textOffset: v3, width: s3, height: a3, anchor: g3, textBoxScale: o3, prevAnchor: t3 }, this.markUsedJustification(_3, g3, d3, p3), _3.allowVerticalPlacement && (this.markUsedOrientation(_3, p3, d3), this.placedOrientations[d3.crossTileID] = p3), { shift: x3, placedGlyphBoxes: y3 };
          }
        }
        placeLayerBucketPart(e2, i3, s3) {
          const { bucket: a3, layout: o3, posMatrix: r3, textLabelPlaneMatrix: n3, labelToScreenMatrix: l3, textPixelRatio: h3, holdingForFade: c3, collisionBoxArray: u3, partiallyEvaluatedTextSize: d3, collisionGroup: _3 } = e2.parameters, p3 = o3.get("text-optional"), m3 = o3.get("icon-optional"), f3 = t2.ar(o3, "text-overlap", "text-allow-overlap"), g3 = "always" === f3, v3 = t2.ar(o3, "icon-overlap", "icon-allow-overlap"), x3 = "always" === v3, y3 = "map" === o3.get("text-rotation-alignment"), b3 = "map" === o3.get("text-pitch-alignment"), w3 = "none" !== o3.get("icon-text-fit"), T3 = "viewport-y" === o3.get("symbol-z-order"), I3 = g3 && (x3 || !a3.hasIconData() || m3), E3 = x3 && (g3 || !a3.hasTextData() || p3);
          !a3.collisionArrays && u3 && a3.deserializeCollisionBoxes(u3);
          const S3 = this.retainedQueryData[a3.bucketInstanceId].tileID, C3 = this.terrain ? (t3, e3) => this.terrain.getElevation(S3, t3, e3) : null, P3 = (e3, u4) => {
            var x4, T4;
            if (i3[e3.crossTileID]) return;
            if (c3) return void (this.placements[e3.crossTileID] = new Dt(false, false, false));
            let S4 = false, P4 = false, D3 = true, M3 = null, z3 = { box: null, offscreen: null }, L3 = { box: null, offscreen: null }, A3 = null, R3 = null, k3 = null, F3 = 0, B3 = 0, O3 = 0;
            u4.textFeatureIndex ? F3 = u4.textFeatureIndex : e3.useRuntimeCollisionCircles && (F3 = e3.featureIndex), u4.verticalTextFeatureIndex && (B3 = u4.verticalTextFeatureIndex);
            const N3 = u4.textBox;
            if (N3) {
              const i4 = (i5) => {
                let s5 = t2.ai.horizontal;
                if (a3.allowVerticalPlacement && !i5 && this.prevPlacement) {
                  const t3 = this.prevPlacement.placedOrientations[e3.crossTileID];
                  t3 && (this.placedOrientations[e3.crossTileID] = t3, s5 = t3, this.markUsedOrientation(a3, s5, e3));
                }
                return s5;
              }, s4 = (i5, s5) => {
                if (a3.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && u4.verticalTextBox) {
                  for (const e4 of a3.writingModes) if (e4 === t2.ai.vertical ? (z3 = s5(), L3 = z3) : z3 = i5(), z3 && z3.box && z3.box.length) break;
                } else z3 = i5();
              }, o4 = e3.textAnchorOffsetStartIndex, n4 = e3.textAnchorOffsetEndIndex;
              if (n4 === o4) {
                const o5 = (t3, i5) => {
                  const s5 = this.collisionIndex.placeCollisionBox(t3, f3, h3, r3, _3.predicate, C3);
                  return s5 && s5.box && s5.box.length && (this.markUsedOrientation(a3, i5, e3), this.placedOrientations[e3.crossTileID] = i5), s5;
                };
                s4(() => o5(N3, t2.ai.horizontal), () => {
                  const i5 = u4.verticalTextBox;
                  return a3.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && i5 ? o5(i5, t2.ai.vertical) : { box: null, offscreen: null };
                }), i4(z3 && z3.box && z3.box.length);
              } else {
                let l4 = t2.aq[null === (T4 = null === (x4 = this.prevPlacement) || void 0 === x4 ? void 0 : x4.variableOffsets[e3.crossTileID]) || void 0 === T4 ? void 0 : T4.anchor];
                const c4 = (t3, i5, s5) => {
                  const c5 = t3.x2 - t3.x1, u5 = t3.y2 - t3.y1, d5 = e3.textBoxScale, p4 = w3 && "never" === v3 ? i5 : null;
                  let m4 = { box: [], offscreen: false }, g4 = "never" === f3 ? 1 : 2, x5 = "never";
                  l4 && g4++;
                  for (let i6 = 0; i6 < g4; i6++) {
                    for (let i7 = o4; i7 < n4; i7++) {
                      const o5 = a3.textAnchorOffsets.get(i7);
                      if (l4 && o5.textAnchor !== l4) continue;
                      const n5 = this.attemptAnchorPlacement(o5, t3, c5, u5, d5, y3, b3, h3, r3, _3, x5, e3, a3, s5, p4, C3);
                      if (n5 && (m4 = n5.placedGlyphBoxes, m4 && m4.box && m4.box.length)) return S4 = true, M3 = n5.shift, m4;
                    }
                    l4 ? l4 = null : x5 = f3;
                  }
                  return m4;
                };
                s4(() => c4(N3, u4.iconBox, t2.ai.horizontal), () => {
                  const i5 = u4.verticalTextBox;
                  return a3.allowVerticalPlacement && !(z3 && z3.box && z3.box.length) && e3.numVerticalGlyphVertices > 0 && i5 ? c4(i5, u4.verticalIconBox, t2.ai.vertical) : { box: null, offscreen: null };
                }), z3 && (S4 = z3.box, D3 = z3.offscreen);
                const d4 = i4(z3 && z3.box);
                if (!S4 && this.prevPlacement) {
                  const t3 = this.prevPlacement.variableOffsets[e3.crossTileID];
                  t3 && (this.variableOffsets[e3.crossTileID] = t3, this.markUsedJustification(a3, t3.anchor, e3, d4));
                }
              }
            }
            if (A3 = z3, S4 = A3 && A3.box && A3.box.length > 0, D3 = A3 && A3.offscreen, e3.useRuntimeCollisionCircles) {
              const i4 = a3.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex), h4 = t2.aj(a3.textSizeData, d3, i4), c4 = o3.get("text-padding");
              R3 = this.collisionIndex.placeCollisionCircles(f3, i4, a3.lineVertexArray, a3.glyphOffsetArray, h4, r3, n3, l3, s3, b3, _3.predicate, e3.collisionCircleDiameter, c4, C3), R3.circles.length && R3.collisionDetected && !s3 && t2.w("Collisions detected, but collision boxes are not shown"), S4 = g3 || R3.circles.length > 0 && !R3.collisionDetected, D3 = D3 && R3.offscreen;
            }
            if (u4.iconFeatureIndex && (O3 = u4.iconFeatureIndex), u4.iconBox) {
              const t3 = (t4) => {
                const e4 = w3 && M3 ? Rt(t4, M3.x, M3.y, y3, b3, this.transform.angle) : t4;
                return this.collisionIndex.placeCollisionBox(e4, v3, h3, r3, _3.predicate, C3);
              };
              L3 && L3.box && L3.box.length && u4.verticalIconBox ? (k3 = t3(u4.verticalIconBox), P4 = k3.box.length > 0) : (k3 = t3(u4.iconBox), P4 = k3.box.length > 0), D3 = D3 && k3.offscreen;
            }
            const U3 = p3 || 0 === e3.numHorizontalGlyphVertices && 0 === e3.numVerticalGlyphVertices, Z3 = m3 || 0 === e3.numIconVertices;
            if (U3 || Z3 ? Z3 ? U3 || (P4 = P4 && S4) : S4 = P4 && S4 : P4 = S4 = P4 && S4, S4 && A3 && A3.box && this.collisionIndex.insertCollisionBox(A3.box, f3, o3.get("text-ignore-placement"), a3.bucketInstanceId, L3 && L3.box && B3 ? B3 : F3, _3.ID), P4 && k3 && this.collisionIndex.insertCollisionBox(k3.box, v3, o3.get("icon-ignore-placement"), a3.bucketInstanceId, O3, _3.ID), R3 && (S4 && this.collisionIndex.insertCollisionCircles(R3.circles, f3, o3.get("text-ignore-placement"), a3.bucketInstanceId, F3, _3.ID), s3)) {
              const t3 = a3.bucketInstanceId;
              let e4 = this.collisionCircleArrays[t3];
              void 0 === e4 && (e4 = this.collisionCircleArrays[t3] = new Mt());
              for (let t4 = 0; t4 < R3.circles.length; t4 += 4) e4.circles.push(R3.circles[t4 + 0]), e4.circles.push(R3.circles[t4 + 1]), e4.circles.push(R3.circles[t4 + 2]), e4.circles.push(R3.collisionDetected ? 1 : 0);
            }
            if (0 === e3.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
            if (0 === a3.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[e3.crossTileID] = new Dt(S4 || I3, P4 || E3, D3 || a3.justReloaded), i3[e3.crossTileID] = true;
          };
          if (T3) {
            if (0 !== e2.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
            const t3 = a3.getSortedSymbolIndexes(this.transform.angle);
            for (let e3 = t3.length - 1; e3 >= 0; --e3) {
              const i4 = t3[e3];
              P3(a3.symbolInstances.get(i4), a3.collisionArrays[i4]);
            }
          } else for (let t3 = e2.symbolInstanceStart; t3 < e2.symbolInstanceEnd; t3++) P3(a3.symbolInstances.get(t3), a3.collisionArrays[t3]);
          if (s3 && a3.bucketInstanceId in this.collisionCircleArrays) {
            const e3 = this.collisionCircleArrays[a3.bucketInstanceId];
            t2.as(e3.invProjMatrix, r3), e3.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          a3.justReloaded = false;
        }
        markUsedJustification(e2, i3, s3, a3) {
          let o3;
          o3 = a3 === t2.ai.vertical ? s3.verticalPlacedTextSymbolIndex : { left: s3.leftJustifiedTextSymbolIndex, center: s3.centerJustifiedTextSymbolIndex, right: s3.rightJustifiedTextSymbolIndex }[t2.at(i3)];
          const r3 = [s3.leftJustifiedTextSymbolIndex, s3.centerJustifiedTextSymbolIndex, s3.rightJustifiedTextSymbolIndex, s3.verticalPlacedTextSymbolIndex];
          for (const t3 of r3) t3 >= 0 && (e2.text.placedSymbolArray.get(t3).crossTileID = o3 >= 0 && t3 !== o3 ? 0 : s3.crossTileID);
        }
        markUsedOrientation(e2, i3, s3) {
          const a3 = i3 === t2.ai.horizontal || i3 === t2.ai.horizontalOnly ? i3 : 0, o3 = i3 === t2.ai.vertical ? i3 : 0, r3 = [s3.leftJustifiedTextSymbolIndex, s3.centerJustifiedTextSymbolIndex, s3.rightJustifiedTextSymbolIndex];
          for (const t3 of r3) e2.text.placedSymbolArray.get(t3).placedOrientation = a3;
          s3.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(s3.verticalPlacedTextSymbolIndex).placedOrientation = o3);
        }
        commit(t3) {
          this.commitTime = t3, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const e2 = this.prevPlacement;
          let i3 = false;
          this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
          const s3 = e2 ? e2.symbolFadeChange(t3) : 1, a3 = e2 ? e2.opacities : {}, o3 = e2 ? e2.variableOffsets : {}, r3 = e2 ? e2.placedOrientations : {};
          for (const t4 in this.placements) {
            const e3 = this.placements[t4], o4 = a3[t4];
            o4 ? (this.opacities[t4] = new Pt(o4, s3, e3.text, e3.icon), i3 = i3 || e3.text !== o4.text.placed || e3.icon !== o4.icon.placed) : (this.opacities[t4] = new Pt(null, s3, e3.text, e3.icon, e3.skipFade), i3 = i3 || e3.text || e3.icon);
          }
          for (const t4 in a3) {
            const e3 = a3[t4];
            if (!this.opacities[t4]) {
              const a4 = new Pt(e3, s3, false, false);
              a4.isHidden() || (this.opacities[t4] = a4, i3 = i3 || e3.text.placed || e3.icon.placed);
            }
          }
          for (const t4 in o3) this.variableOffsets[t4] || !this.opacities[t4] || this.opacities[t4].isHidden() || (this.variableOffsets[t4] = o3[t4]);
          for (const t4 in r3) this.placedOrientations[t4] || !this.opacities[t4] || this.opacities[t4].isHidden() || (this.placedOrientations[t4] = r3[t4]);
          if (e2 && void 0 === e2.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
          i3 ? this.lastPlacementChangeTime = t3 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t3);
        }
        updateLayerOpacities(t3, e2) {
          const i3 = {};
          for (const s3 of e2) {
            const e3 = s3.getBucket(t3);
            e3 && s3.latestFeatureIndex && t3.id === e3.layerIds[0] && this.updateBucketOpacities(e3, i3, s3.collisionBoxArray);
          }
        }
        updateBucketOpacities(e2, i3, s3) {
          e2.hasTextData() && (e2.text.opacityVertexArray.clear(), e2.text.hasVisibleVertices = false), e2.hasIconData() && (e2.icon.opacityVertexArray.clear(), e2.icon.hasVisibleVertices = false), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
          const a3 = e2.layers[0], o3 = a3.layout, r3 = new Pt(null, 0, false, false, true), n3 = o3.get("text-allow-overlap"), l3 = o3.get("icon-allow-overlap"), h3 = a3._unevaluatedLayout.hasValue("text-variable-anchor") || a3._unevaluatedLayout.hasValue("text-variable-anchor-offset"), c3 = "map" === o3.get("text-rotation-alignment"), u3 = "map" === o3.get("text-pitch-alignment"), d3 = "none" !== o3.get("icon-text-fit"), _3 = new Pt(null, 0, n3 && (l3 || !e2.hasIconData() || o3.get("icon-optional")), l3 && (n3 || !e2.hasTextData() || o3.get("text-optional")), true);
          !e2.collisionArrays && s3 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(s3);
          const p3 = (t3, e3, i4) => {
            for (let s4 = 0; s4 < e3 / 4; s4++) t3.opacityVertexArray.emplaceBack(i4);
            t3.hasVisibleVertices = t3.hasVisibleVertices || i4 !== qt;
          };
          for (let s4 = 0; s4 < e2.symbolInstances.length; s4++) {
            const a4 = e2.symbolInstances.get(s4), { numHorizontalGlyphVertices: o4, numVerticalGlyphVertices: n4, crossTileID: l4 } = a4;
            let m3 = this.opacities[l4];
            i3[l4] ? m3 = r3 : m3 || (m3 = _3, this.opacities[l4] = m3), i3[l4] = true;
            const f3 = a4.numIconVertices > 0, g3 = this.placedOrientations[a4.crossTileID], v3 = g3 === t2.ai.vertical, x3 = g3 === t2.ai.horizontal || g3 === t2.ai.horizontalOnly;
            if (o4 > 0 || n4 > 0) {
              const t3 = Vt(m3.text);
              p3(e2.text, o4, v3 ? qt : t3), p3(e2.text, n4, x3 ? qt : t3);
              const i4 = m3.text.isHidden();
              [a4.rightJustifiedTextSymbolIndex, a4.centerJustifiedTextSymbolIndex, a4.leftJustifiedTextSymbolIndex].forEach((t4) => {
                t4 >= 0 && (e2.text.placedSymbolArray.get(t4).hidden = i4 || v3 ? 1 : 0);
              }), a4.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(a4.verticalPlacedTextSymbolIndex).hidden = i4 || x3 ? 1 : 0);
              const s5 = this.variableOffsets[a4.crossTileID];
              s5 && this.markUsedJustification(e2, s5.anchor, a4, g3);
              const r4 = this.placedOrientations[a4.crossTileID];
              r4 && (this.markUsedJustification(e2, "left", a4, r4), this.markUsedOrientation(e2, r4, a4));
            }
            if (f3) {
              const t3 = Vt(m3.icon), i4 = !(d3 && a4.verticalPlacedIconSymbolIndex && v3);
              a4.placedIconSymbolIndex >= 0 && (p3(e2.icon, a4.numIconVertices, i4 ? t3 : qt), e2.icon.placedSymbolArray.get(a4.placedIconSymbolIndex).hidden = m3.icon.isHidden()), a4.verticalPlacedIconSymbolIndex >= 0 && (p3(e2.icon, a4.numVerticalIconVertices, i4 ? qt : t3), e2.icon.placedSymbolArray.get(a4.verticalPlacedIconSymbolIndex).hidden = m3.icon.isHidden());
            }
            if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
              const i4 = e2.collisionArrays[s4];
              if (i4) {
                let s5 = new t2.P(0, 0);
                if (i4.textBox || i4.verticalTextBox) {
                  let t3 = true;
                  if (h3) {
                    const e3 = this.variableOffsets[l4];
                    e3 ? (s5 = At(e3.anchor, e3.width, e3.height, e3.textOffset, e3.textBoxScale), c3 && s5._rotate(u3 ? this.transform.angle : -this.transform.angle)) : t3 = false;
                  }
                  i4.textBox && Ft(e2.textCollisionBox.collisionVertexArray, m3.text.placed, !t3 || v3, s5.x, s5.y), i4.verticalTextBox && Ft(e2.textCollisionBox.collisionVertexArray, m3.text.placed, !t3 || x3, s5.x, s5.y);
                }
                const a5 = Boolean(!x3 && i4.verticalIconBox);
                i4.iconBox && Ft(e2.iconCollisionBox.collisionVertexArray, m3.icon.placed, a5, d3 ? s5.x : 0, d3 ? s5.y : 0), i4.verticalIconBox && Ft(e2.iconCollisionBox.collisionVertexArray, m3.icon.placed, !a5, d3 ? s5.x : 0, d3 ? s5.y : 0);
              }
            }
          }
          if (e2.sortFeatures(this.transform.angle), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.text.opacityVertexArray.length !== e2.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e2.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e2.text.layoutVertexArray.length}) / 4`);
          if (e2.icon.opacityVertexArray.length !== e2.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e2.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e2.icon.layoutVertexArray.length}) / 4`);
          if (e2.bucketInstanceId in this.collisionCircleArrays) {
            const t3 = this.collisionCircleArrays[e2.bucketInstanceId];
            e2.placementInvProjMatrix = t3.invProjMatrix, e2.placementViewportMatrix = t3.viewportMatrix, e2.collisionCircleArray = t3.circles, delete this.collisionCircleArrays[e2.bucketInstanceId];
          }
        }
        symbolFadeChange(t3) {
          return 0 === this.fadeDuration ? 1 : (t3 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(t3) {
          return Math.max(0, (this.transform.zoom - t3) / 1.5);
        }
        hasTransitions(t3) {
          return this.stale || t3 - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(t3, e2) {
          const i3 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
          return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i3 > t3;
        }
        setStale() {
          this.stale = true;
        }
      }
      function Ft(t3, e2, i3, s3, a3) {
        t3.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, s3 || 0, a3 || 0), t3.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, s3 || 0, a3 || 0), t3.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, s3 || 0, a3 || 0), t3.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, s3 || 0, a3 || 0);
      }
      const Bt = Math.pow(2, 25), Ot = Math.pow(2, 24), Nt = Math.pow(2, 17), Ut = Math.pow(2, 16), Zt = Math.pow(2, 9), Gt = Math.pow(2, 8), jt = Math.pow(2, 1);
      function Vt(t3) {
        if (0 === t3.opacity && !t3.placed) return 0;
        if (1 === t3.opacity && t3.placed) return 4294967295;
        const e2 = t3.placed ? 1 : 0, i3 = Math.floor(127 * t3.opacity);
        return i3 * Bt + e2 * Ot + i3 * Nt + e2 * Ut + i3 * Zt + e2 * Gt + i3 * jt + e2;
      }
      const qt = 0;
      class $t {
        constructor(t3) {
          this._sortAcrossTiles = "viewport-y" !== t3.layout.get("symbol-z-order") && !t3.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(t3, e2, i3, s3, a3) {
          const o3 = this._bucketParts;
          for (; this._currentTileIndex < t3.length; ) if (e2.getBucketParts(o3, s3, t3[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a3()) return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o3.sort((t4, e3) => t4.sortKey - e3.sortKey)); this._currentPartIndex < o3.length; ) if (e2.placeLayerBucketPart(o3[this._currentPartIndex], this._seenCrossTileIDs, i3), this._currentPartIndex++, a3()) return true;
          return false;
        }
      }
      class Wt {
        constructor(t3, e2, i3, s3, a3, o3, r3, n3) {
          this.placement = new kt(t3, e2, o3, r3, n3), this._currentPlacementIndex = i3.length - 1, this._forceFullPlacement = s3, this._showCollisionBoxes = a3, this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(e2, i3, s3) {
          const a3 = t2.h.now(), o3 = () => !this._forceFullPlacement && t2.h.now() - a3 > 2;
          for (; this._currentPlacementIndex >= 0; ) {
            const t3 = i3[e2[this._currentPlacementIndex]], a4 = this.placement.collisionIndex.transform.zoom;
            if ("symbol" === t3.type && (!t3.minzoom || t3.minzoom <= a4) && (!t3.maxzoom || t3.maxzoom > a4)) {
              if (this._inProgressLayer || (this._inProgressLayer = new $t(t3)), this._inProgressLayer.continuePlacement(s3[t3.source], this.placement, this._showCollisionBoxes, t3, o3)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(t3) {
          return this.placement.commit(t3), this.placement;
        }
      }
      const Ht = 512 / t2.N / 2;
      class Xt {
        constructor(e2, i3, s3) {
          this.tileID = e2, this.bucketInstanceId = s3, this._symbolsByKey = {};
          const a3 = /* @__PURE__ */ new Map();
          for (let t3 = 0; t3 < i3.length; t3++) {
            const e3 = i3.get(t3), s4 = e3.key, o3 = a3.get(s4);
            o3 ? o3.push(e3) : a3.set(s4, [e3]);
          }
          for (const [e3, i4] of a3) {
            const s4 = { positions: i4.map((t3) => ({ x: Math.floor(t3.anchorX * Ht), y: Math.floor(t3.anchorY * Ht) })), crossTileIDs: i4.map((t3) => t3.crossTileID) };
            if (s4.positions.length > 128) {
              const e4 = new t2.av(s4.positions.length, 16, Uint16Array);
              for (const { x: t3, y: i5 } of s4.positions) e4.add(t3, i5);
              e4.finish(), delete s4.positions, s4.index = e4;
            }
            this._symbolsByKey[e3] = s4;
          }
        }
        getScaledCoordinates(e2, i3) {
          const { x: s3, y: a3, z: o3 } = this.tileID.canonical, { x: r3, y: n3, z: l3 } = i3.canonical, h3 = Ht / Math.pow(2, l3 - o3), c3 = (n3 * t2.N + e2.anchorY) * h3, u3 = a3 * t2.N * Ht;
          return { x: Math.floor((r3 * t2.N + e2.anchorX) * h3 - s3 * t2.N * Ht), y: Math.floor(c3 - u3) };
        }
        findMatches(t3, e2, i3) {
          const s3 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z);
          for (let a3 = 0; a3 < t3.length; a3++) {
            const o3 = t3.get(a3);
            if (o3.crossTileID) continue;
            const r3 = this._symbolsByKey[o3.key];
            if (!r3) continue;
            const n3 = this.getScaledCoordinates(o3, e2);
            if (r3.index) {
              const t4 = r3.index.range(n3.x - s3, n3.y - s3, n3.x + s3, n3.y + s3).sort();
              for (const e3 of t4) {
                const t5 = r3.crossTileIDs[e3];
                if (!i3[t5]) {
                  i3[t5] = true, o3.crossTileID = t5;
                  break;
                }
              }
            } else if (r3.positions) for (let t4 = 0; t4 < r3.positions.length; t4++) {
              const e3 = r3.positions[t4], a4 = r3.crossTileIDs[t4];
              if (Math.abs(e3.x - n3.x) <= s3 && Math.abs(e3.y - n3.y) <= s3 && !i3[a4]) {
                i3[a4] = true, o3.crossTileID = a4;
                break;
              }
            }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map(({ crossTileIDs: t3 }) => t3);
        }
      }
      class Kt {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class Qt {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(t3) {
          const e2 = Math.round((t3 - this.lng) / 360);
          if (0 !== e2) for (const t4 in this.indexes) {
            const i3 = this.indexes[t4], s3 = {};
            for (const t5 in i3) {
              const a3 = i3[t5];
              a3.tileID = a3.tileID.unwrapTo(a3.tileID.wrap + e2), s3[a3.tileID.key] = a3;
            }
            this.indexes[t4] = s3;
          }
          this.lng = t3;
        }
        addBucket(t3, e2, i3) {
          if (this.indexes[t3.overscaledZ] && this.indexes[t3.overscaledZ][t3.key]) {
            if (this.indexes[t3.overscaledZ][t3.key].bucketInstanceId === e2.bucketInstanceId) return false;
            this.removeBucketCrossTileIDs(t3.overscaledZ, this.indexes[t3.overscaledZ][t3.key]);
          }
          for (let t4 = 0; t4 < e2.symbolInstances.length; t4++) e2.symbolInstances.get(t4).crossTileID = 0;
          this.usedCrossTileIDs[t3.overscaledZ] || (this.usedCrossTileIDs[t3.overscaledZ] = {});
          const s3 = this.usedCrossTileIDs[t3.overscaledZ];
          for (const i4 in this.indexes) {
            const a3 = this.indexes[i4];
            if (Number(i4) > t3.overscaledZ) for (const i5 in a3) {
              const o3 = a3[i5];
              o3.tileID.isChildOf(t3) && o3.findMatches(e2.symbolInstances, t3, s3);
            }
            else {
              const o3 = a3[t3.scaledTo(Number(i4)).key];
              o3 && o3.findMatches(e2.symbolInstances, t3, s3);
            }
          }
          for (let t4 = 0; t4 < e2.symbolInstances.length; t4++) {
            const a3 = e2.symbolInstances.get(t4);
            a3.crossTileID || (a3.crossTileID = i3.generate(), s3[a3.crossTileID] = true);
          }
          return void 0 === this.indexes[t3.overscaledZ] && (this.indexes[t3.overscaledZ] = {}), this.indexes[t3.overscaledZ][t3.key] = new Xt(t3, e2.symbolInstances, e2.bucketInstanceId), true;
        }
        removeBucketCrossTileIDs(t3, e2) {
          for (const i3 of e2.getCrossTileIDsLists()) for (const e3 of i3) delete this.usedCrossTileIDs[t3][e3];
        }
        removeStaleBuckets(t3) {
          let e2 = false;
          for (const i3 in this.indexes) {
            const s3 = this.indexes[i3];
            for (const a3 in s3) t3[s3[a3].bucketInstanceId] || (this.removeBucketCrossTileIDs(i3, s3[a3]), delete s3[a3], e2 = true);
          }
          return e2;
        }
      }
      class Yt {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new Kt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(t3, e2, i3) {
          let s3 = this.layerIndexes[t3.id];
          void 0 === s3 && (s3 = this.layerIndexes[t3.id] = new Qt());
          let a3 = false;
          const o3 = {};
          s3.handleWrapJump(i3);
          for (const i4 of e2) {
            const e3 = i4.getBucket(t3);
            e3 && t3.id === e3.layerIds[0] && (e3.bucketInstanceId || (e3.bucketInstanceId = ++this.maxBucketInstanceId), s3.addBucket(i4.tileID, e3, this.crossTileIDs) && (a3 = true), o3[e3.bucketInstanceId] = true);
          }
          return s3.removeStaleBuckets(o3) && (a3 = true), a3;
        }
        pruneUnusedLayers(t3) {
          const e2 = {};
          t3.forEach((t4) => {
            e2[t4] = true;
          });
          for (const t4 in this.layerIndexes) e2[t4] || delete this.layerIndexes[t4];
        }
      }
      const Jt = (e2, i3) => t2.x(e2, i3 && i3.filter((t3) => "source.canvas" !== t3.identifier)), te2 = t2.F(t2.ax, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setGlyphs", "setSprite"]), ee2 = t2.F(t2.ax, ["setCenter", "setZoom", "setBearing", "setPitch"]), ie2 = t2.aw();
      class se2 extends t2.E {
        constructor(e2, i3 = {}) {
          super(), this.map = e2, this.dispatcher = new M2(st(), this, e2._getMapId()), this.imageManager = new b2(), this.imageManager.setEventedParent(this), this.glyphManager = new E2(e2._requestManager, i3.localIdeographFontFamily), this.lineAtlas = new D2(256, 512), this.crossTileSymbolIndex = new Yt(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t2.ay(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t2.az());
          const s3 = this;
          this._rtlTextPluginCallback = se2.registerForPluginStateChange((e3) => {
            s3.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e3.pluginStatus, pluginURL: e3.pluginURL }, (e4, i4) => {
              if (t2.aA(e4), i4 && i4.every((t3) => t3)) for (const t3 in s3.sourceCaches) {
                const e5 = s3.sourceCaches[t3].getSource().type;
                "vector" !== e5 && "geojson" !== e5 || s3.sourceCaches[t3].reload();
              }
            });
          }), this.on("data", (t3) => {
            if ("source" !== t3.dataType || "metadata" !== t3.sourceDataType) return;
            const e3 = this.sourceCaches[t3.sourceId];
            if (!e3) return;
            const i4 = e3.getSource();
            if (i4 && i4.vectorLayerIds) for (const t4 in this._layers) {
              const e4 = this._layers[t4];
              e4.source === i4.id && this._validateLayer(e4);
            }
          });
        }
        loadURL(e2, i3 = {}, s3) {
          this.fire(new t2.k("dataloading", { dataType: "style" })), i3.validate = "boolean" != typeof i3.validate || i3.validate;
          const a3 = this.map._requestManager.transformRequest(e2, c2.Style);
          this._request = t2.f(a3, (e3, a4) => {
            this._request = null, e3 ? this.fire(new t2.j(e3)) : a4 && this._load(a4, i3, s3);
          });
        }
        loadJSON(e2, i3 = {}, s3) {
          this.fire(new t2.k("dataloading", { dataType: "style" })), this._request = t2.h.frame(() => {
            this._request = null, i3.validate = false !== i3.validate, this._load(e2, i3, s3);
          });
        }
        loadEmpty() {
          this.fire(new t2.k("dataloading", { dataType: "style" })), this._load(ie2, { validate: false });
        }
        _load(e2, i3, s3) {
          var a3;
          const o3 = i3.transformStyle ? i3.transformStyle(s3, e2) : e2;
          if (!i3.validate || !Jt(this, t2.y(o3))) {
            this._loaded = true, this.stylesheet = o3;
            for (const t3 in o3.sources) this.addSource(t3, o3.sources[t3], { validate: false });
            o3.sprite ? this._loadSprite(o3.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(o3.glyphs), this._createLayers(), this.light = new P2(this.stylesheet.light), this.map.setTerrain(null !== (a3 = this.stylesheet.terrain) && void 0 !== a3 ? a3 : null), this.fire(new t2.k("data", { dataType: "style" })), this.fire(new t2.k("style.load"));
          }
        }
        _createLayers() {
          const e2 = t2.aB(this.stylesheet.layers);
          this.dispatcher.broadcast("setLayers", e2), this._order = e2.map((t3) => t3.id), this._layers = {}, this._serializedLayers = null;
          for (const i3 of e2) {
            const e3 = t2.aC(i3);
            e3.setEventedParent(this, { layer: { id: i3.id } }), this._layers[i3.id] = e3;
          }
        }
        _loadSprite(e2, i3 = false, s3 = void 0) {
          this.imageManager.setLoaded(false), this._spriteRequest = function(e3, i4, s4, a3) {
            const o3 = g2(e3), r3 = o3.length, n3 = s4 > 1 ? "@2x" : "", l3 = {}, u3 = {}, d3 = {};
            for (const { id: e4, url: s5 } of o3) {
              const o4 = i4.transformRequest(i4.normalizeSpriteURL(s5, n3, ".json"), c2.SpriteJSON), _3 = `${e4}_${o4.url}`;
              l3[_3] = t2.f(o4, (t3, i5) => {
                delete l3[_3], u3[e4] = i5, v2(a3, u3, d3, t3, r3);
              });
              const p3 = i4.transformRequest(i4.normalizeSpriteURL(s5, n3, ".png"), c2.SpriteImage), m3 = `${e4}_${p3.url}`;
              l3[m3] = h2.getImage(p3, (t3, i5) => {
                delete l3[m3], d3[e4] = i5, v2(a3, u3, d3, t3, r3);
              });
            }
            return { cancel() {
              for (const t3 of Object.values(l3)) t3.cancel();
            } };
          }(e2, this.map._requestManager, this.map.getPixelRatio(), (e3, a3) => {
            if (this._spriteRequest = null, e3) this.fire(new t2.j(e3));
            else if (a3) for (const t3 in a3) {
              this._spritesImagesIds[t3] = [];
              const e4 = this._spritesImagesIds[t3] ? this._spritesImagesIds[t3].filter((t4) => !(t4 in a3)) : [];
              for (const t4 of e4) this.imageManager.removeImage(t4), this._changedImages[t4] = true;
              for (const e5 in a3[t3]) {
                const s4 = "default" === t3 ? e5 : `${t3}:${e5}`;
                this._spritesImagesIds[t3].push(s4), s4 in this.imageManager.images ? this.imageManager.updateImage(s4, a3[t3][e5], false) : this.imageManager.addImage(s4, a3[t3][e5]), i3 && (this._changedImages[s4] = true);
              }
            }
            this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i3 && (this._changed = true), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t2.k("data", { dataType: "style" })), s3 && s3(e3);
          });
        }
        _unloadSprite() {
          for (const t3 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(t3), this._changedImages[t3] = true;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t2.k("data", { dataType: "style" }));
        }
        _validateLayer(e2) {
          const i3 = this.sourceCaches[e2.source];
          if (!i3) return;
          const s3 = e2.sourceLayer;
          if (!s3) return;
          const a3 = i3.getSource();
          ("geojson" === a3.type || a3.vectorLayerIds && -1 === a3.vectorLayerIds.indexOf(s3)) && this.fire(new t2.j(new Error(`Source layer "${s3}" does not exist on source "${a3.id}" as specified by style layer "${e2.id}".`)));
        }
        loaded() {
          if (!this._loaded) return false;
          if (Object.keys(this._updatedSources).length) return false;
          for (const t3 in this.sourceCaches) if (!this.sourceCaches[t3].loaded()) return false;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(t3) {
          const e2 = this._serializedAllLayers();
          if (!t3 || 0 === t3.length) return Object.values(e2);
          const i3 = [];
          for (const s3 of t3) e2[s3] && i3.push(e2[s3]);
          return i3;
        }
        _serializedAllLayers() {
          let t3 = this._serializedLayers;
          if (t3) return t3;
          t3 = this._serializedLayers = {};
          const e2 = Object.keys(this._layers);
          for (const i3 of e2) {
            const e3 = this._layers[i3];
            "custom" !== e3.type && (t3[i3] = e3.serialize());
          }
          return t3;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition()) return true;
          for (const t3 in this.sourceCaches) if (this.sourceCaches[t3].hasTransition()) return true;
          for (const t3 in this._layers) if (this._layers[t3].hasTransition()) return true;
          return false;
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error("Style is not done loading.");
        }
        update(e2) {
          if (!this._loaded) return;
          const i3 = this._changed;
          if (this._changed) {
            const t3 = Object.keys(this._updatedLayers), i4 = Object.keys(this._removedLayers);
            (t3.length || i4.length) && this._updateWorkerLayers(t3, i4);
            for (const t4 in this._updatedSources) {
              const e3 = this._updatedSources[t4];
              if ("reload" === e3) this._reloadSource(t4);
              else {
                if ("clear" !== e3) throw new Error(`Invalid action ${e3}`);
                this._clearSource(t4);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const t4 in this._updatedPaintProps) this._layers[t4].updateTransitions(e2);
            this.light.updateTransitions(e2), this._resetUpdates();
          }
          const s3 = {};
          for (const t3 in this.sourceCaches) {
            const e3 = this.sourceCaches[t3];
            s3[t3] = e3.used, e3.used = false;
          }
          for (const t3 of this._order) {
            const i4 = this._layers[t3];
            i4.recalculate(e2, this._availableImages), !i4.isHidden(e2.zoom) && i4.source && (this.sourceCaches[i4.source].used = true);
          }
          for (const e3 in s3) {
            const i4 = this.sourceCaches[e3];
            s3[e3] !== i4.used && i4.fire(new t2.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: e3 }));
          }
          this.light.recalculate(e2), this.z = e2.zoom, i3 && this.fire(new t2.k("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const t3 = Object.keys(this._changedImages);
          if (t3.length) {
            for (const e2 in this.sourceCaches) this.sourceCaches[e2].reloadTilesForDependencies(["icons", "patterns"], t3);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const t3 in this.sourceCaches) this.sourceCaches[t3].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = false;
          }
        }
        _updateWorkerLayers(t3, e2) {
          this.dispatcher.broadcast("updateLayers", { layers: this._serializeByIds(t3), removedIds: e2 });
        }
        _resetUpdates() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
        }
        setState(e2, i3 = {}) {
          this._checkLoaded();
          const s3 = this.serialize();
          if (e2 = i3.transformStyle ? i3.transformStyle(s3, e2) : e2, Jt(this, t2.y(e2))) return false;
          (e2 = t2.aD(e2)).layers = t2.aB(e2.layers);
          const a3 = t2.aE(s3, e2).filter((t3) => !(t3.command in ee2));
          if (0 === a3.length) return false;
          const o3 = a3.filter((t3) => !(t3.command in te2));
          if (o3.length > 0) throw new Error(`Unimplemented: ${o3.map((t3) => t3.command).join(", ")}.`);
          for (const t3 of a3) "setTransition" !== t3.command && this[t3.command].apply(this, t3.args);
          return this.stylesheet = e2, this._serializedLayers = null, true;
        }
        addImage(e2, i3) {
          if (this.getImage(e2)) return this.fire(new t2.j(new Error(`An image named "${e2}" already exists.`)));
          this.imageManager.addImage(e2, i3), this._afterImageUpdated(e2);
        }
        updateImage(t3, e2) {
          this.imageManager.updateImage(t3, e2);
        }
        getImage(t3) {
          return this.imageManager.getImage(t3);
        }
        removeImage(e2) {
          if (!this.getImage(e2)) return this.fire(new t2.j(new Error(`An image named "${e2}" does not exist.`)));
          this.imageManager.removeImage(e2), this._afterImageUpdated(e2);
        }
        _afterImageUpdated(e2) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[e2] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t2.k("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(e2, i3, s3 = {}) {
          if (this._checkLoaded(), void 0 !== this.sourceCaches[e2]) throw new Error(`Source "${e2}" already exists.`);
          if (!i3.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i3).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(i3.type) >= 0 && this._validate(t2.y.source, `sources.${e2}`, i3, null, s3)) return;
          this.map && this.map._collectResourceTiming && (i3.collectResourceTiming = true);
          const a3 = this.sourceCaches[e2] = new K2(e2, i3, this.dispatcher);
          a3.style = this, a3.setEventedParent(this, () => ({ isSourceLoaded: a3.loaded(), source: a3.serialize(), sourceId: e2 })), a3.onAdd(this.map), this._changed = true;
        }
        removeSource(e2) {
          if (this._checkLoaded(), void 0 === this.sourceCaches[e2]) throw new Error("There is no source with this ID");
          for (const i4 in this._layers) if (this._layers[i4].source === e2) return this.fire(new t2.j(new Error(`Source "${e2}" cannot be removed while layer "${i4}" is using it.`)));
          const i3 = this.sourceCaches[e2];
          delete this.sourceCaches[e2], delete this._updatedSources[e2], i3.fire(new t2.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: e2 })), i3.setEventedParent(null), i3.onRemove(this.map), this._changed = true;
        }
        setGeoJSONSourceData(t3, e2) {
          if (this._checkLoaded(), void 0 === this.sourceCaches[t3]) throw new Error(`There is no source with this ID=${t3}`);
          const i3 = this.sourceCaches[t3].getSource();
          if ("geojson" !== i3.type) throw new Error(`geojsonSource.type is ${i3.type}, which is !== 'geojson`);
          i3.setData(e2), this._changed = true;
        }
        getSource(t3) {
          return this.sourceCaches[t3] && this.sourceCaches[t3].getSource();
        }
        addLayer(e2, i3, s3 = {}) {
          this._checkLoaded();
          const a3 = e2.id;
          if (this.getLayer(a3)) return void this.fire(new t2.j(new Error(`Layer "${a3}" already exists on this map.`)));
          let o3;
          if ("custom" === e2.type) {
            if (Jt(this, t2.aF(e2))) return;
            o3 = t2.aC(e2);
          } else {
            if ("source" in e2 && "object" == typeof e2.source && (this.addSource(a3, e2.source), e2 = t2.aD(e2), e2 = t2.e(e2, { source: a3 })), this._validate(t2.y.layer, `layers.${a3}`, e2, { arrayIndex: -1 }, s3)) return;
            o3 = t2.aC(e2), this._validateLayer(o3), o3.setEventedParent(this, { layer: { id: a3 } });
          }
          const r3 = i3 ? this._order.indexOf(i3) : this._order.length;
          if (i3 && -1 === r3) this.fire(new t2.j(new Error(`Cannot add layer "${a3}" before non-existing layer "${i3}".`)));
          else {
            if (this._order.splice(r3, 0, a3), this._layerOrderChanged = true, this._layers[a3] = o3, this._removedLayers[a3] && o3.source && "custom" !== o3.type) {
              const t3 = this._removedLayers[a3];
              delete this._removedLayers[a3], t3.type !== o3.type ? this._updatedSources[o3.source] = "clear" : (this._updatedSources[o3.source] = "reload", this.sourceCaches[o3.source].pause());
            }
            this._updateLayer(o3), o3.onAdd && o3.onAdd(this.map);
          }
        }
        moveLayer(e2, i3) {
          if (this._checkLoaded(), this._changed = true, !this._layers[e2]) return void this.fire(new t2.j(new Error(`The layer '${e2}' does not exist in the map's style and cannot be moved.`)));
          if (e2 === i3) return;
          const s3 = this._order.indexOf(e2);
          this._order.splice(s3, 1);
          const a3 = i3 ? this._order.indexOf(i3) : this._order.length;
          i3 && -1 === a3 ? this.fire(new t2.j(new Error(`Cannot move layer "${e2}" before non-existing layer "${i3}".`))) : (this._order.splice(a3, 0, e2), this._layerOrderChanged = true);
        }
        removeLayer(e2) {
          this._checkLoaded();
          const i3 = this._layers[e2];
          if (!i3) return void this.fire(new t2.j(new Error(`Cannot remove non-existing layer "${e2}".`)));
          i3.setEventedParent(null);
          const s3 = this._order.indexOf(e2);
          this._order.splice(s3, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e2] = i3, delete this._layers[e2], this._serializedLayers && delete this._serializedLayers[e2], delete this._updatedLayers[e2], delete this._updatedPaintProps[e2], i3.onRemove && i3.onRemove(this.map);
        }
        getLayer(t3) {
          return this._layers[t3];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(t3) {
          return t3 in this._layers;
        }
        setLayerZoomRange(e2, i3, s3) {
          this._checkLoaded();
          const a3 = this.getLayer(e2);
          a3 ? a3.minzoom === i3 && a3.maxzoom === s3 || (null != i3 && (a3.minzoom = i3), null != s3 && (a3.maxzoom = s3), this._updateLayer(a3)) : this.fire(new t2.j(new Error(`Cannot set the zoom range of non-existing layer "${e2}".`)));
        }
        setFilter(e2, i3, s3 = {}) {
          this._checkLoaded();
          const a3 = this.getLayer(e2);
          if (a3) {
            if (!t2.aG(a3.filter, i3)) return null == i3 ? (a3.filter = void 0, void this._updateLayer(a3)) : void (this._validate(t2.y.filter, `layers.${a3.id}.filter`, i3, null, s3) || (a3.filter = t2.aD(i3), this._updateLayer(a3)));
          } else this.fire(new t2.j(new Error(`Cannot filter non-existing layer "${e2}".`)));
        }
        getFilter(e2) {
          return t2.aD(this.getLayer(e2).filter);
        }
        setLayoutProperty(e2, i3, s3, a3 = {}) {
          this._checkLoaded();
          const o3 = this.getLayer(e2);
          o3 ? t2.aG(o3.getLayoutProperty(i3), s3) || (o3.setLayoutProperty(i3, s3, a3), this._updateLayer(o3)) : this.fire(new t2.j(new Error(`Cannot style non-existing layer "${e2}".`)));
        }
        getLayoutProperty(e2, i3) {
          const s3 = this.getLayer(e2);
          if (s3) return s3.getLayoutProperty(i3);
          this.fire(new t2.j(new Error(`Cannot get style of non-existing layer "${e2}".`)));
        }
        setPaintProperty(e2, i3, s3, a3 = {}) {
          this._checkLoaded();
          const o3 = this.getLayer(e2);
          o3 ? t2.aG(o3.getPaintProperty(i3), s3) || (o3.setPaintProperty(i3, s3, a3) && this._updateLayer(o3), this._changed = true, this._updatedPaintProps[e2] = true) : this.fire(new t2.j(new Error(`Cannot style non-existing layer "${e2}".`)));
        }
        getPaintProperty(t3, e2) {
          return this.getLayer(t3).getPaintProperty(e2);
        }
        setFeatureState(e2, i3) {
          this._checkLoaded();
          const s3 = e2.source, a3 = e2.sourceLayer, o3 = this.sourceCaches[s3];
          if (void 0 === o3) return void this.fire(new t2.j(new Error(`The source '${s3}' does not exist in the map's style.`)));
          const r3 = o3.getSource().type;
          "geojson" === r3 && a3 ? this.fire(new t2.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== r3 || a3 ? (void 0 === e2.id && this.fire(new t2.j(new Error("The feature id parameter must be provided."))), o3.setFeatureState(a3, e2.id, i3)) : this.fire(new t2.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(e2, i3) {
          this._checkLoaded();
          const s3 = e2.source, a3 = this.sourceCaches[s3];
          if (void 0 === a3) return void this.fire(new t2.j(new Error(`The source '${s3}' does not exist in the map's style.`)));
          const o3 = a3.getSource().type, r3 = "vector" === o3 ? e2.sourceLayer : void 0;
          "vector" !== o3 || r3 ? i3 && "string" != typeof e2.id && "number" != typeof e2.id ? this.fire(new t2.j(new Error("A feature id is required to remove its specific state property."))) : a3.removeFeatureState(r3, e2.id, i3) : this.fire(new t2.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(e2) {
          this._checkLoaded();
          const i3 = e2.source, s3 = e2.sourceLayer, a3 = this.sourceCaches[i3];
          if (void 0 !== a3) return "vector" !== a3.getSource().type || s3 ? (void 0 === e2.id && this.fire(new t2.j(new Error("The feature id parameter must be provided."))), a3.getFeatureState(s3, e2.id)) : void this.fire(new t2.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new t2.j(new Error(`The source '${i3}' does not exist in the map's style.`)));
        }
        getTransition() {
          return t2.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded) return;
          const e2 = t2.aH(this.sourceCaches, (t3) => t3.serialize()), i3 = this._serializeByIds(this._order), s3 = this.map.getTerrain() || void 0, a3 = this.stylesheet;
          return t2.aI({ version: a3.version, name: a3.name, metadata: a3.metadata, light: a3.light, center: a3.center, zoom: a3.zoom, bearing: a3.bearing, pitch: a3.pitch, sprite: a3.sprite, glyphs: a3.glyphs, transition: a3.transition, sources: e2, layers: i3, terrain: s3 }, (t3) => void 0 !== t3);
        }
        _updateLayer(t3) {
          this._updatedLayers[t3.id] = true, t3.source && !this._updatedSources[t3.source] && "raster" !== this.sourceCaches[t3.source].getSource().type && (this._updatedSources[t3.source] = "reload", this.sourceCaches[t3.source].pause()), this._serializedLayers = null, this._changed = true;
        }
        _flattenAndSortRenderedFeatures(t3) {
          const e2 = (t4) => "fill-extrusion" === this._layers[t4].type, i3 = {}, s3 = [];
          for (let a4 = this._order.length - 1; a4 >= 0; a4--) {
            const o3 = this._order[a4];
            if (e2(o3)) {
              i3[o3] = a4;
              for (const e3 of t3) {
                const t4 = e3[o3];
                if (t4) for (const e4 of t4) s3.push(e4);
              }
            }
          }
          s3.sort((t4, e3) => e3.intersectionZ - t4.intersectionZ);
          const a3 = [];
          for (let o3 = this._order.length - 1; o3 >= 0; o3--) {
            const r3 = this._order[o3];
            if (e2(r3)) for (let t4 = s3.length - 1; t4 >= 0; t4--) {
              const e3 = s3[t4].feature;
              if (i3[e3.layer.id] < o3) break;
              a3.push(e3), s3.pop();
            }
            else for (const e3 of t3) {
              const t4 = e3[r3];
              if (t4) for (const e4 of t4) a3.push(e4.feature);
            }
          }
          return a3;
        }
        queryRenderedFeatures(e2, i3, s3) {
          i3 && i3.filter && this._validate(t2.y.filter, "queryRenderedFeatures.filter", i3.filter, null, i3);
          const a3 = {};
          if (i3 && i3.layers) {
            if (!Array.isArray(i3.layers)) return this.fire(new t2.j(new Error("parameters.layers must be an Array."))), [];
            for (const e3 of i3.layers) {
              const i4 = this._layers[e3];
              if (!i4) return this.fire(new t2.j(new Error(`The layer '${e3}' does not exist in the map's style and cannot be queried for features.`))), [];
              a3[i4.source] = true;
            }
          }
          const o3 = [];
          i3.availableImages = this._availableImages;
          const r3 = this._serializedAllLayers();
          for (const t3 in this.sourceCaches) i3.layers && !a3[t3] || o3.push(q2(this.sourceCaches[t3], this._layers, r3, e2, i3, s3));
          return this.placement && o3.push(function(t3, e3, i4, s4, a4, o4, r4) {
            const n3 = {}, l3 = o4.queryRenderedSymbols(s4), h3 = [];
            for (const t4 of Object.keys(l3).map(Number)) h3.push(r4[t4]);
            h3.sort($2);
            for (const i5 of h3) {
              const s5 = i5.featureIndex.lookupSymbolFeatures(l3[i5.bucketInstanceId], e3, i5.bucketIndex, i5.sourceLayerIndex, a4.filter, a4.layers, a4.availableImages, t3);
              for (const t4 in s5) {
                const e4 = n3[t4] = n3[t4] || [], a5 = s5[t4];
                a5.sort((t5, e5) => {
                  const s6 = i5.featureSortOrder;
                  if (s6) {
                    const i6 = s6.indexOf(t5.featureIndex);
                    return s6.indexOf(e5.featureIndex) - i6;
                  }
                  return e5.featureIndex - t5.featureIndex;
                });
                for (const t5 of a5) e4.push(t5);
              }
            }
            for (const e4 in n3) n3[e4].forEach((s5) => {
              const a5 = s5.feature, o5 = i4[t3[e4].source].getFeatureState(a5.layer["source-layer"], a5.id);
              a5.source = a5.layer.source, a5.layer["source-layer"] && (a5.sourceLayer = a5.layer["source-layer"]), a5.state = o5;
            });
            return n3;
          }(this._layers, r3, this.sourceCaches, e2, i3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o3);
        }
        querySourceFeatures(e2, i3) {
          i3 && i3.filter && this._validate(t2.y.filter, "querySourceFeatures.filter", i3.filter, null, i3);
          const s3 = this.sourceCaches[e2];
          return s3 ? function(t3, e3) {
            const i4 = t3.getRenderableIds().map((e4) => t3.getTileByID(e4)), s4 = [], a3 = {};
            for (let t4 = 0; t4 < i4.length; t4++) {
              const o3 = i4[t4], r3 = o3.tileID.canonical.key;
              a3[r3] || (a3[r3] = true, o3.querySourceFeatures(s4, e3));
            }
            return s4;
          }(s3, i3) : [];
        }
        addSourceType(t3, e2, i3) {
          return j2(t3) ? i3(new Error(`A source type called "${t3}" already exists.`)) : (((t4, e3) => {
            G2[t4] = e3;
          })(t3, e2), e2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t3, url: e2.workerSourceURL }, i3) : i3(null, null));
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(e2, i3 = {}) {
          this._checkLoaded();
          const s3 = this.light.getLight();
          let a3 = false;
          for (const i4 in e2) if (!t2.aG(e2[i4], s3[i4])) {
            a3 = true;
            break;
          }
          if (!a3) return;
          const o3 = { now: t2.h.now(), transition: t2.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(e2, i3), this.light.updateTransitions(o3);
        }
        _validate(e2, i3, s3, a3, o3 = {}) {
          return (!o3 || false !== o3.validate) && Jt(this, e2.call(t2.y, t2.e({ key: i3, style: this.serialize(), value: s3, styleSpec: t2.v }, a3)));
        }
        _remove(e2 = true) {
          this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t2.aJ.off("pluginStateChange", this._rtlTextPluginCallback);
          for (const t3 in this._layers) this._layers[t3].setEventedParent(null);
          for (const t3 in this.sourceCaches) {
            const e3 = this.sourceCaches[t3];
            e3.setEventedParent(null), e3.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove(e2);
        }
        _clearSource(t3) {
          this.sourceCaches[t3].clearTiles();
        }
        _reloadSource(t3) {
          this.sourceCaches[t3].resume(), this.sourceCaches[t3].reload();
        }
        _updateSources(t3) {
          for (const e2 in this.sourceCaches) this.sourceCaches[e2].update(t3, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const t3 in this.sourceCaches) this._reloadSource(t3);
        }
        _updatePlacement(e2, i3, s3, a3, o3 = false) {
          let r3 = false, n3 = false;
          const l3 = {};
          for (const t3 of this._order) {
            const i4 = this._layers[t3];
            if ("symbol" !== i4.type) continue;
            if (!l3[i4.source]) {
              const t4 = this.sourceCaches[i4.source];
              l3[i4.source] = t4.getRenderableIds(true).map((e3) => t4.getTileByID(e3)).sort((t5, e3) => e3.tileID.overscaledZ - t5.tileID.overscaledZ || (t5.tileID.isLessThan(e3.tileID) ? -1 : 1));
            }
            const s4 = this.crossTileSymbolIndex.addLayer(i4, l3[i4.source], e2.center.lng);
            r3 = r3 || s4;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((o3 = o3 || this._layerOrderChanged || 0 === s3) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t2.h.now(), e2.zoom)) && (this.pauseablePlacement = new Wt(e2, this.map.terrain, this._order, o3, i3, s3, a3, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l3), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t2.h.now()), n3 = true), r3 && this.pauseablePlacement.placement.setStale()), n3 || r3) for (const t3 of this._order) {
            const e3 = this._layers[t3];
            "symbol" === e3.type && this.placement.updateLayerOpacities(e3, l3[e3.source]);
          }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t2.h.now());
        }
        _releaseSymbolFadeTiles() {
          for (const t3 in this.sourceCaches) this.sourceCaches[t3].releaseSymbolFadeTiles();
        }
        getImages(t3, e2, i3) {
          this.imageManager.getImages(e2.icons, i3), this._updateTilesForChangedImages();
          const s3 = this.sourceCaches[e2.source];
          s3 && s3.setDependencies(e2.tileID.key, e2.type, e2.icons);
        }
        getGlyphs(t3, e2, i3) {
          this.glyphManager.getGlyphs(e2.stacks, i3);
          const s3 = this.sourceCaches[e2.source];
          s3 && s3.setDependencies(e2.tileID.key, e2.type, [""]);
        }
        getResource(e2, i3, s3) {
          return t2.m(i3, s3);
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(e2, i3 = {}) {
          this._checkLoaded(), e2 && this._validate(t2.y.glyphs, "glyphs", e2, null, i3) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e2, this.glyphManager.entries = {}, this.glyphManager.setURL(e2));
        }
        addSprite(e2, i3, s3 = {}, a3) {
          this._checkLoaded();
          const o3 = [{ id: e2, url: i3 }], r3 = [...g2(this.stylesheet.sprite), ...o3];
          this._validate(t2.y.sprite, "sprite", r3, null, s3) || (this.stylesheet.sprite = r3, this._loadSprite(o3, true, a3));
        }
        removeSprite(e2) {
          this._checkLoaded();
          const i3 = g2(this.stylesheet.sprite);
          if (i3.find((t3) => t3.id === e2)) {
            if (this._spritesImagesIds[e2]) for (const t3 of this._spritesImagesIds[e2]) this.imageManager.removeImage(t3), this._changedImages[t3] = true;
            i3.splice(i3.findIndex((t3) => t3.id === e2), 1), this.stylesheet.sprite = i3.length > 0 ? i3 : void 0, delete this._spritesImagesIds[e2], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t2.k("data", { dataType: "style" }));
          } else this.fire(new t2.j(new Error(`Sprite "${e2}" doesn't exists on this map.`)));
        }
        getSprite() {
          return g2(this.stylesheet.sprite);
        }
        setSprite(e2, i3 = {}, s3) {
          this._checkLoaded(), e2 && this._validate(t2.y.sprite, "sprite", e2, null, i3) || (this.stylesheet.sprite = e2, e2 ? this._loadSprite(e2, true, s3) : (this._unloadSprite(), s3 && s3(null)));
        }
      }
      se2.registerForPluginStateChange = t2.aK;
      var ae2 = t2.Q([{ name: "a_pos", type: "Int16", components: 2 }]), oe2 = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
      const re2 = { prelude: ne2("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}"), background: ne2("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: ne2("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: ne2("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: ne2("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: ne2("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), heatmapTexture: ne2("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: ne2("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: ne2("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: ne2("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: ne2("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), fillOutline: ne2("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillOutlinePattern: ne2("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillPattern: ne2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: ne2("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: ne2("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: ne2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: ne2("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: ne2("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: ne2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: ne2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: ne2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: ne2("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: ne2("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: ne2("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: ne2("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: ne2("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", oe2), terrainDepth: ne2("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", oe2), terrainCoords: ne2("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", oe2) };
      function ne2(t3, e2) {
        const i3 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, s3 = e2.match(/attribute ([\w]+) ([\w]+)/g), a3 = t3.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o3 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r3 = o3 ? o3.concat(a3) : a3, n3 = {};
        return { fragmentSource: t3 = t3.replace(i3, (t4, e3, i4, s4, a4) => (n3[a4] = true, "define" === e3 ? `
#ifndef HAS_UNIFORM_u_${a4}
varying ${i4} ${s4} ${a4};
#else
uniform ${i4} ${s4} u_${a4};
#endif
` : `
#ifdef HAS_UNIFORM_u_${a4}
    ${i4} ${s4} ${a4} = u_${a4};
#endif
`)), vertexSource: e2 = e2.replace(i3, (t4, e3, i4, s4, a4) => {
          const o4 = "float" === s4 ? "vec2" : "vec4", r4 = a4.match(/color/) ? "color" : o4;
          return n3[a4] ? "define" === e3 ? `
#ifndef HAS_UNIFORM_u_${a4}
uniform lowp float u_${a4}_t;
attribute ${i4} ${o4} a_${a4};
varying ${i4} ${s4} ${a4};
#else
uniform ${i4} ${s4} u_${a4};
#endif
` : "vec4" === r4 ? `
#ifndef HAS_UNIFORM_u_${a4}
    ${a4} = a_${a4};
#else
    ${i4} ${s4} ${a4} = u_${a4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a4}
    ${a4} = unpack_mix_${r4}(a_${a4}, u_${a4}_t);
#else
    ${i4} ${s4} ${a4} = u_${a4};
#endif
` : "define" === e3 ? `
#ifndef HAS_UNIFORM_u_${a4}
uniform lowp float u_${a4}_t;
attribute ${i4} ${o4} a_${a4};
#else
uniform ${i4} ${s4} u_${a4};
#endif
` : "vec4" === r4 ? `
#ifndef HAS_UNIFORM_u_${a4}
    ${i4} ${s4} ${a4} = a_${a4};
#else
    ${i4} ${s4} ${a4} = u_${a4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a4}
    ${i4} ${s4} ${a4} = unpack_mix_${r4}(a_${a4}, u_${a4}_t);
#else
    ${i4} ${s4} ${a4} = u_${a4};
#endif
`;
        }), staticAttributes: s3, staticUniforms: r3 };
      }
      class le2 {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(t3, e2, i3, s3, a3, o3, r3, n3, l3) {
          this.context = t3;
          let h3 = this.boundPaintVertexBuffers.length !== s3.length;
          for (let t4 = 0; !h3 && t4 < s3.length; t4++) this.boundPaintVertexBuffers[t4] !== s3[t4] && (h3 = true);
          !this.vao || this.boundProgram !== e2 || this.boundLayoutVertexBuffer !== i3 || h3 || this.boundIndexBuffer !== a3 || this.boundVertexOffset !== o3 || this.boundDynamicVertexBuffer !== r3 || this.boundDynamicVertexBuffer2 !== n3 || this.boundDynamicVertexBuffer3 !== l3 ? this.freshBind(e2, i3, s3, a3, o3, r3, n3, l3) : (t3.bindVertexArray.set(this.vao), r3 && r3.bind(), a3 && a3.dynamicDraw && a3.bind(), n3 && n3.bind(), l3 && l3.bind());
        }
        freshBind(t3, e2, i3, s3, a3, o3, r3, n3) {
          const l3 = t3.numAttributes, h3 = this.context, c3 = h3.gl;
          this.vao && this.destroy(), this.vao = h3.createVertexArray(), h3.bindVertexArray.set(this.vao), this.boundProgram = t3, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i3, this.boundIndexBuffer = s3, this.boundVertexOffset = a3, this.boundDynamicVertexBuffer = o3, this.boundDynamicVertexBuffer2 = r3, this.boundDynamicVertexBuffer3 = n3, e2.enableAttributes(c3, t3);
          for (const e3 of i3) e3.enableAttributes(c3, t3);
          o3 && o3.enableAttributes(c3, t3), r3 && r3.enableAttributes(c3, t3), n3 && n3.enableAttributes(c3, t3), e2.bind(), e2.setVertexAttribPointers(c3, t3, a3);
          for (const e3 of i3) e3.bind(), e3.setVertexAttribPointers(c3, t3, a3);
          o3 && (o3.bind(), o3.setVertexAttribPointers(c3, t3, a3)), s3 && s3.bind(), r3 && (r3.bind(), r3.setVertexAttribPointers(c3, t3, a3)), n3 && (n3.bind(), n3.setVertexAttribPointers(c3, t3, a3)), h3.currentNumAttributes = l3;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      function he2(t3) {
        const e2 = [];
        for (let i3 = 0; i3 < t3.length; i3++) {
          if (null === t3[i3]) continue;
          const s3 = t3[i3].split(" ");
          e2.push(s3.pop());
        }
        return e2;
      }
      class ce2 {
        constructor(e2, i3, s3, a3, o3, r3) {
          const n3 = e2.gl;
          this.program = n3.createProgram();
          const l3 = he2(i3.staticAttributes), h3 = s3 ? s3.getBinderAttributes() : [], c3 = l3.concat(h3), u3 = re2.prelude.staticUniforms ? he2(re2.prelude.staticUniforms) : [], d3 = i3.staticUniforms ? he2(i3.staticUniforms) : [], _3 = s3 ? s3.getBinderUniforms() : [], p3 = u3.concat(d3).concat(_3), m3 = [];
          for (const t3 of p3) m3.indexOf(t3) < 0 && m3.push(t3);
          const f3 = s3 ? s3.defines() : [];
          o3 && f3.push("#define OVERDRAW_INSPECTOR;"), r3 && f3.push("#define TERRAIN3D;");
          const g3 = f3.concat(re2.prelude.fragmentSource, i3.fragmentSource).join("\n"), v3 = f3.concat(re2.prelude.vertexSource, i3.vertexSource).join("\n"), x3 = n3.createShader(n3.FRAGMENT_SHADER);
          if (n3.isContextLost()) return void (this.failedToCreate = true);
          if (n3.shaderSource(x3, g3), n3.compileShader(x3), !n3.getShaderParameter(x3, n3.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${n3.getShaderInfoLog(x3)}`);
          n3.attachShader(this.program, x3);
          const y3 = n3.createShader(n3.VERTEX_SHADER);
          if (n3.isContextLost()) return void (this.failedToCreate = true);
          if (n3.shaderSource(y3, v3), n3.compileShader(y3), !n3.getShaderParameter(y3, n3.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${n3.getShaderInfoLog(y3)}`);
          n3.attachShader(this.program, y3), this.attributes = {};
          const b3 = {};
          this.numAttributes = c3.length;
          for (let t3 = 0; t3 < this.numAttributes; t3++) c3[t3] && (n3.bindAttribLocation(this.program, t3, c3[t3]), this.attributes[c3[t3]] = t3);
          if (n3.linkProgram(this.program), !n3.getProgramParameter(this.program, n3.LINK_STATUS)) throw new Error(`Program failed to link: ${n3.getProgramInfoLog(this.program)}`);
          n3.deleteShader(y3), n3.deleteShader(x3);
          for (let t3 = 0; t3 < m3.length; t3++) {
            const e3 = m3[t3];
            if (e3 && !b3[e3]) {
              const t4 = n3.getUniformLocation(this.program, e3);
              t4 && (b3[e3] = t4);
            }
          }
          this.fixedUniforms = a3(e2, b3), this.terrainUniforms = ((e3, i4) => ({ u_depth: new t2.aL(e3, i4.u_depth), u_terrain: new t2.aL(e3, i4.u_terrain), u_terrain_dim: new t2.aM(e3, i4.u_terrain_dim), u_terrain_matrix: new t2.aN(e3, i4.u_terrain_matrix), u_terrain_unpack: new t2.aO(e3, i4.u_terrain_unpack), u_terrain_exaggeration: new t2.aM(e3, i4.u_terrain_exaggeration) }))(e2, b3), this.binderUniforms = s3 ? s3.getUniforms(e2, b3) : [];
        }
        draw(t3, e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3, _3, p3, m3, f3, g3) {
          const v3 = t3.gl;
          if (this.failedToCreate) return;
          if (t3.program.set(this.program), t3.setDepthMode(i3), t3.setStencilMode(s3), t3.setColorMode(a3), t3.setCullFace(o3), n3) {
            t3.activeTexture.set(v3.TEXTURE2), v3.bindTexture(v3.TEXTURE_2D, n3.depthTexture), t3.activeTexture.set(v3.TEXTURE3), v3.bindTexture(v3.TEXTURE_2D, n3.texture);
            for (const t4 in this.terrainUniforms) this.terrainUniforms[t4].set(n3[t4]);
          }
          for (const t4 in this.fixedUniforms) this.fixedUniforms[t4].set(r3[t4]);
          p3 && p3.setUniforms(t3, this.binderUniforms, d3, { zoom: _3 });
          let x3 = 0;
          switch (e2) {
            case v3.LINES:
              x3 = 2;
              break;
            case v3.TRIANGLES:
              x3 = 3;
              break;
            case v3.LINE_STRIP:
              x3 = 1;
          }
          for (const i4 of u3.get()) {
            const s4 = i4.vaos || (i4.vaos = {});
            (s4[l3] || (s4[l3] = new le2())).bind(t3, this, h3, p3 ? p3.getPaintVertexBuffers() : [], c3, i4.vertexOffset, m3, f3, g3), v3.drawElements(e2, i4.primitiveLength * x3, v3.UNSIGNED_SHORT, i4.primitiveOffset * x3 * 2);
          }
        }
      }
      function ue2(t3, e2, i3) {
        const s3 = 1 / St(i3, 1, e2.transform.tileZoom), a3 = Math.pow(2, i3.tileID.overscaledZ), o3 = i3.tileSize * Math.pow(2, e2.transform.tileZoom) / a3, r3 = o3 * (i3.tileID.canonical.x + i3.tileID.wrap * a3), n3 = o3 * i3.tileID.canonical.y;
        return { u_image: 0, u_texsize: i3.imageAtlasTexture.size, u_scale: [s3, t3.fromScale, t3.toScale], u_fade: t3.t, u_pixel_coord_upper: [r3 >> 16, n3 >> 16], u_pixel_coord_lower: [65535 & r3, 65535 & n3] };
      }
      const de2 = (e2, i3, s3, a3) => {
        const o3 = i3.style.light, r3 = o3.properties.get("position"), n3 = [r3.x, r3.y, r3.z], l3 = function() {
          var e3 = new t2.A(9);
          return t2.A != Float32Array && (e3[1] = 0, e3[2] = 0, e3[3] = 0, e3[5] = 0, e3[6] = 0, e3[7] = 0), e3[0] = 1, e3[4] = 1, e3[8] = 1, e3;
        }();
        "viewport" === o3.properties.get("anchor") && function(t3, e3) {
          var i4 = Math.sin(e3), s4 = Math.cos(e3);
          t3[0] = s4, t3[1] = i4, t3[2] = 0, t3[3] = -i4, t3[4] = s4, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1;
        }(l3, -i3.transform.angle), function(t3, e3, i4) {
          var s4 = e3[0], a4 = e3[1], o4 = e3[2];
          t3[0] = s4 * i4[0] + a4 * i4[3] + o4 * i4[6], t3[1] = s4 * i4[1] + a4 * i4[4] + o4 * i4[7], t3[2] = s4 * i4[2] + a4 * i4[5] + o4 * i4[8];
        }(n3, n3, l3);
        const h3 = o3.properties.get("color");
        return { u_matrix: e2, u_lightpos: n3, u_lightintensity: o3.properties.get("intensity"), u_lightcolor: [h3.r, h3.g, h3.b], u_vertical_gradient: +s3, u_opacity: a3 };
      }, _e2 = (e2, i3, s3, a3, o3, r3, n3) => t2.e(de2(e2, i3, s3, a3), ue2(r3, i3, n3), { u_height_factor: -Math.pow(2, o3.overscaledZ) / n3.tileSize / 8 }), pe2 = (t3) => ({ u_matrix: t3 }), me2 = (e2, i3, s3, a3) => t2.e(pe2(e2), ue2(s3, i3, a3)), fe2 = (t3, e2) => ({ u_matrix: t3, u_world: e2 }), ge2 = (e2, i3, s3, a3, o3) => t2.e(me2(e2, i3, s3, a3), { u_world: o3 }), ve2 = (t3, e2, i3, s3) => {
        const a3 = t3.transform;
        let o3, r3;
        if ("map" === s3.paint.get("circle-pitch-alignment")) {
          const t4 = St(i3, 1, a3.zoom);
          o3 = true, r3 = [t4, t4];
        } else o3 = false, r3 = a3.pixelsToGLUnits;
        return { u_camera_to_center_distance: a3.cameraToCenterDistance, u_scale_with_map: +("map" === s3.paint.get("circle-pitch-scale")), u_matrix: t3.translatePosMatrix(e2.posMatrix, i3, s3.paint.get("circle-translate"), s3.paint.get("circle-translate-anchor")), u_pitch_with_map: +o3, u_device_pixel_ratio: t3.pixelRatio, u_extrude_scale: r3 };
      }, xe2 = (t3, e2, i3) => {
        const s3 = St(i3, 1, e2.zoom), a3 = Math.pow(2, e2.zoom - i3.tileID.overscaledZ), o3 = i3.tileID.overscaleFactor();
        return { u_matrix: t3, u_camera_to_center_distance: e2.cameraToCenterDistance, u_pixels_to_tile_units: s3, u_extrude_scale: [e2.pixelsToGLUnits[0] / (s3 * a3), e2.pixelsToGLUnits[1] / (s3 * a3)], u_overscale_factor: o3 };
      }, ye2 = (t3, e2, i3 = 1) => ({ u_matrix: t3, u_color: e2, u_overlay: 0, u_overlay_scale: i3 }), be2 = (t3) => ({ u_matrix: t3 }), we2 = (t3, e2, i3, s3) => ({ u_matrix: t3, u_extrude_scale: St(e2, 1, i3), u_intensity: s3 });
      function Te2(e2, i3) {
        const s3 = Math.pow(2, i3.canonical.z), a3 = i3.canonical.y;
        return [new t2.U(0, a3 / s3).toLngLat().lat, new t2.U(0, (a3 + 1) / s3).toLngLat().lat];
      }
      const Ie2 = (t3, e2, i3, s3) => {
        const a3 = t3.transform;
        return { u_matrix: De2(t3, e2, i3, s3), u_ratio: 1 / St(e2, 1, a3.zoom), u_device_pixel_ratio: t3.pixelRatio, u_units_to_pixels: [1 / a3.pixelsToGLUnits[0], 1 / a3.pixelsToGLUnits[1]] };
      }, Ee2 = (e2, i3, s3, a3, o3) => t2.e(Ie2(e2, i3, s3, o3), { u_image: 0, u_image_height: a3 }), Se2 = (t3, e2, i3, s3, a3) => {
        const o3 = t3.transform, r3 = Pe2(e2, o3);
        return { u_matrix: De2(t3, e2, i3, a3), u_texsize: e2.imageAtlasTexture.size, u_ratio: 1 / St(e2, 1, o3.zoom), u_device_pixel_ratio: t3.pixelRatio, u_image: 0, u_scale: [r3, s3.fromScale, s3.toScale], u_fade: s3.t, u_units_to_pixels: [1 / o3.pixelsToGLUnits[0], 1 / o3.pixelsToGLUnits[1]] };
      }, Ce2 = (e2, i3, s3, a3, o3, r3) => {
        const n3 = e2.lineAtlas, l3 = Pe2(i3, e2.transform), h3 = "round" === s3.layout.get("line-cap"), c3 = n3.getDash(a3.from, h3), u3 = n3.getDash(a3.to, h3), d3 = c3.width * o3.fromScale, _3 = u3.width * o3.toScale;
        return t2.e(Ie2(e2, i3, s3, r3), { u_patternscale_a: [l3 / d3, -c3.height / 2], u_patternscale_b: [l3 / _3, -u3.height / 2], u_sdfgamma: n3.width / (256 * Math.min(d3, _3) * e2.pixelRatio) / 2, u_image: 0, u_tex_y_a: c3.y, u_tex_y_b: u3.y, u_mix: o3.t });
      };
      function Pe2(t3, e2) {
        return 1 / St(t3, 1, e2.tileZoom);
      }
      function De2(t3, e2, i3, s3) {
        return t3.translatePosMatrix(s3 ? s3.posMatrix : e2.tileID.posMatrix, e2, i3.paint.get("line-translate"), i3.paint.get("line-translate-anchor"));
      }
      const Me2 = (t3, e2, i3, s3, a3) => {
        return { u_matrix: t3, u_tl_parent: e2, u_scale_parent: i3, u_buffer_scale: 1, u_fade_t: s3.mix, u_opacity: s3.opacity * a3.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a3.paint.get("raster-brightness-min"), u_brightness_high: a3.paint.get("raster-brightness-max"), u_saturation_factor: (r3 = a3.paint.get("raster-saturation"), r3 > 0 ? 1 - 1 / (1.001 - r3) : -r3), u_contrast_factor: (o3 = a3.paint.get("raster-contrast"), o3 > 0 ? 1 / (1 - o3) : 1 + o3), u_spin_weights: ze2(a3.paint.get("raster-hue-rotate")) };
        var o3, r3;
      };
      function ze2(t3) {
        t3 *= Math.PI / 180;
        const e2 = Math.sin(t3), i3 = Math.cos(t3);
        return [(2 * i3 + 1) / 3, (-Math.sqrt(3) * e2 - i3 + 1) / 3, (Math.sqrt(3) * e2 - i3 + 1) / 3];
      }
      const Le2 = (t3, e2, i3, s3, a3, o3, r3, n3, l3, h3) => {
        const c3 = a3.transform;
        return { u_is_size_zoom_constant: +("constant" === t3 || "source" === t3), u_is_size_feature_constant: +("constant" === t3 || "camera" === t3), u_size_t: e2 ? e2.uSizeT : 0, u_size: e2 ? e2.uSize : 0, u_camera_to_center_distance: c3.cameraToCenterDistance, u_pitch: c3.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i3, u_aspect_ratio: c3.width / c3.height, u_fade_change: a3.options.fadeDuration ? a3.symbolFadeChange : 1, u_matrix: o3, u_label_plane_matrix: r3, u_coord_matrix: n3, u_is_text: +l3, u_pitch_with_map: +s3, u_texsize: h3, u_texture: 0 };
      }, Ae2 = (e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3) => {
        const d3 = o3.transform;
        return t2.e(Le2(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3), { u_gamma_scale: a3 ? Math.cos(d3._pitch) * d3.cameraToCenterDistance : 1, u_device_pixel_ratio: o3.pixelRatio, u_is_halo: +u3 });
      }, Re2 = (e2, i3, s3, a3, o3, r3, n3, l3, h3, c3) => t2.e(Ae2(e2, i3, s3, a3, o3, r3, n3, l3, true, h3, true), { u_texsize_icon: c3, u_texture_icon: 1 }), ke2 = (t3, e2, i3) => ({ u_matrix: t3, u_opacity: e2, u_color: i3 }), Fe2 = (e2, i3, s3, a3, o3, r3) => t2.e(function(t3, e3, i4, s4) {
        const a4 = i4.imageManager.getPattern(t3.from.toString()), o4 = i4.imageManager.getPattern(t3.to.toString()), { width: r4, height: n3 } = i4.imageManager.getPixelSize(), l3 = Math.pow(2, s4.tileID.overscaledZ), h3 = s4.tileSize * Math.pow(2, i4.transform.tileZoom) / l3, c3 = h3 * (s4.tileID.canonical.x + s4.tileID.wrap * l3), u3 = h3 * s4.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: a4.tl, u_pattern_br_a: a4.br, u_pattern_tl_b: o4.tl, u_pattern_br_b: o4.br, u_texsize: [r4, n3], u_mix: e3.t, u_pattern_size_a: a4.displaySize, u_pattern_size_b: o4.displaySize, u_scale_a: e3.fromScale, u_scale_b: e3.toScale, u_tile_units_to_pixels: 1 / St(s4, 1, i4.transform.tileZoom), u_pixel_coord_upper: [c3 >> 16, u3 >> 16], u_pixel_coord_lower: [65535 & c3, 65535 & u3] };
      }(a3, r3, s3, o3), { u_matrix: e2, u_opacity: i3 }), Be2 = { fillExtrusion: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_lightpos: new t2.aP(e2, i3.u_lightpos), u_lightintensity: new t2.aM(e2, i3.u_lightintensity), u_lightcolor: new t2.aP(e2, i3.u_lightcolor), u_vertical_gradient: new t2.aM(e2, i3.u_vertical_gradient), u_opacity: new t2.aM(e2, i3.u_opacity) }), fillExtrusionPattern: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_lightpos: new t2.aP(e2, i3.u_lightpos), u_lightintensity: new t2.aM(e2, i3.u_lightintensity), u_lightcolor: new t2.aP(e2, i3.u_lightcolor), u_vertical_gradient: new t2.aM(e2, i3.u_vertical_gradient), u_height_factor: new t2.aM(e2, i3.u_height_factor), u_image: new t2.aL(e2, i3.u_image), u_texsize: new t2.aQ(e2, i3.u_texsize), u_pixel_coord_upper: new t2.aQ(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t2.aQ(e2, i3.u_pixel_coord_lower), u_scale: new t2.aP(e2, i3.u_scale), u_fade: new t2.aM(e2, i3.u_fade), u_opacity: new t2.aM(e2, i3.u_opacity) }), fill: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix) }), fillPattern: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_image: new t2.aL(e2, i3.u_image), u_texsize: new t2.aQ(e2, i3.u_texsize), u_pixel_coord_upper: new t2.aQ(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t2.aQ(e2, i3.u_pixel_coord_lower), u_scale: new t2.aP(e2, i3.u_scale), u_fade: new t2.aM(e2, i3.u_fade) }), fillOutline: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_world: new t2.aQ(e2, i3.u_world) }), fillOutlinePattern: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_world: new t2.aQ(e2, i3.u_world), u_image: new t2.aL(e2, i3.u_image), u_texsize: new t2.aQ(e2, i3.u_texsize), u_pixel_coord_upper: new t2.aQ(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t2.aQ(e2, i3.u_pixel_coord_lower), u_scale: new t2.aP(e2, i3.u_scale), u_fade: new t2.aM(e2, i3.u_fade) }), circle: (e2, i3) => ({ u_camera_to_center_distance: new t2.aM(e2, i3.u_camera_to_center_distance), u_scale_with_map: new t2.aL(e2, i3.u_scale_with_map), u_pitch_with_map: new t2.aL(e2, i3.u_pitch_with_map), u_extrude_scale: new t2.aQ(e2, i3.u_extrude_scale), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_matrix: new t2.aN(e2, i3.u_matrix) }), collisionBox: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_camera_to_center_distance: new t2.aM(e2, i3.u_camera_to_center_distance), u_pixels_to_tile_units: new t2.aM(e2, i3.u_pixels_to_tile_units), u_extrude_scale: new t2.aQ(e2, i3.u_extrude_scale), u_overscale_factor: new t2.aM(e2, i3.u_overscale_factor) }), collisionCircle: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_inv_matrix: new t2.aN(e2, i3.u_inv_matrix), u_camera_to_center_distance: new t2.aM(e2, i3.u_camera_to_center_distance), u_viewport_size: new t2.aQ(e2, i3.u_viewport_size) }), debug: (e2, i3) => ({ u_color: new t2.aR(e2, i3.u_color), u_matrix: new t2.aN(e2, i3.u_matrix), u_overlay: new t2.aL(e2, i3.u_overlay), u_overlay_scale: new t2.aM(e2, i3.u_overlay_scale) }), clippingMask: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix) }), heatmap: (e2, i3) => ({ u_extrude_scale: new t2.aM(e2, i3.u_extrude_scale), u_intensity: new t2.aM(e2, i3.u_intensity), u_matrix: new t2.aN(e2, i3.u_matrix) }), heatmapTexture: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_world: new t2.aQ(e2, i3.u_world), u_image: new t2.aL(e2, i3.u_image), u_color_ramp: new t2.aL(e2, i3.u_color_ramp), u_opacity: new t2.aM(e2, i3.u_opacity) }), hillshade: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_image: new t2.aL(e2, i3.u_image), u_latrange: new t2.aQ(e2, i3.u_latrange), u_light: new t2.aQ(e2, i3.u_light), u_shadow: new t2.aR(e2, i3.u_shadow), u_highlight: new t2.aR(e2, i3.u_highlight), u_accent: new t2.aR(e2, i3.u_accent) }), hillshadePrepare: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_image: new t2.aL(e2, i3.u_image), u_dimension: new t2.aQ(e2, i3.u_dimension), u_zoom: new t2.aM(e2, i3.u_zoom), u_unpack: new t2.aO(e2, i3.u_unpack) }), line: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_ratio: new t2.aM(e2, i3.u_ratio), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_units_to_pixels: new t2.aQ(e2, i3.u_units_to_pixels) }), lineGradient: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_ratio: new t2.aM(e2, i3.u_ratio), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_units_to_pixels: new t2.aQ(e2, i3.u_units_to_pixels), u_image: new t2.aL(e2, i3.u_image), u_image_height: new t2.aM(e2, i3.u_image_height) }), linePattern: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_texsize: new t2.aQ(e2, i3.u_texsize), u_ratio: new t2.aM(e2, i3.u_ratio), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_image: new t2.aL(e2, i3.u_image), u_units_to_pixels: new t2.aQ(e2, i3.u_units_to_pixels), u_scale: new t2.aP(e2, i3.u_scale), u_fade: new t2.aM(e2, i3.u_fade) }), lineSDF: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_ratio: new t2.aM(e2, i3.u_ratio), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_units_to_pixels: new t2.aQ(e2, i3.u_units_to_pixels), u_patternscale_a: new t2.aQ(e2, i3.u_patternscale_a), u_patternscale_b: new t2.aQ(e2, i3.u_patternscale_b), u_sdfgamma: new t2.aM(e2, i3.u_sdfgamma), u_image: new t2.aL(e2, i3.u_image), u_tex_y_a: new t2.aM(e2, i3.u_tex_y_a), u_tex_y_b: new t2.aM(e2, i3.u_tex_y_b), u_mix: new t2.aM(e2, i3.u_mix) }), raster: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_tl_parent: new t2.aQ(e2, i3.u_tl_parent), u_scale_parent: new t2.aM(e2, i3.u_scale_parent), u_buffer_scale: new t2.aM(e2, i3.u_buffer_scale), u_fade_t: new t2.aM(e2, i3.u_fade_t), u_opacity: new t2.aM(e2, i3.u_opacity), u_image0: new t2.aL(e2, i3.u_image0), u_image1: new t2.aL(e2, i3.u_image1), u_brightness_low: new t2.aM(e2, i3.u_brightness_low), u_brightness_high: new t2.aM(e2, i3.u_brightness_high), u_saturation_factor: new t2.aM(e2, i3.u_saturation_factor), u_contrast_factor: new t2.aM(e2, i3.u_contrast_factor), u_spin_weights: new t2.aP(e2, i3.u_spin_weights) }), symbolIcon: (e2, i3) => ({ u_is_size_zoom_constant: new t2.aL(e2, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t2.aL(e2, i3.u_is_size_feature_constant), u_size_t: new t2.aM(e2, i3.u_size_t), u_size: new t2.aM(e2, i3.u_size), u_camera_to_center_distance: new t2.aM(e2, i3.u_camera_to_center_distance), u_pitch: new t2.aM(e2, i3.u_pitch), u_rotate_symbol: new t2.aL(e2, i3.u_rotate_symbol), u_aspect_ratio: new t2.aM(e2, i3.u_aspect_ratio), u_fade_change: new t2.aM(e2, i3.u_fade_change), u_matrix: new t2.aN(e2, i3.u_matrix), u_label_plane_matrix: new t2.aN(e2, i3.u_label_plane_matrix), u_coord_matrix: new t2.aN(e2, i3.u_coord_matrix), u_is_text: new t2.aL(e2, i3.u_is_text), u_pitch_with_map: new t2.aL(e2, i3.u_pitch_with_map), u_texsize: new t2.aQ(e2, i3.u_texsize), u_texture: new t2.aL(e2, i3.u_texture) }), symbolSDF: (e2, i3) => ({ u_is_size_zoom_constant: new t2.aL(e2, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t2.aL(e2, i3.u_is_size_feature_constant), u_size_t: new t2.aM(e2, i3.u_size_t), u_size: new t2.aM(e2, i3.u_size), u_camera_to_center_distance: new t2.aM(e2, i3.u_camera_to_center_distance), u_pitch: new t2.aM(e2, i3.u_pitch), u_rotate_symbol: new t2.aL(e2, i3.u_rotate_symbol), u_aspect_ratio: new t2.aM(e2, i3.u_aspect_ratio), u_fade_change: new t2.aM(e2, i3.u_fade_change), u_matrix: new t2.aN(e2, i3.u_matrix), u_label_plane_matrix: new t2.aN(e2, i3.u_label_plane_matrix), u_coord_matrix: new t2.aN(e2, i3.u_coord_matrix), u_is_text: new t2.aL(e2, i3.u_is_text), u_pitch_with_map: new t2.aL(e2, i3.u_pitch_with_map), u_texsize: new t2.aQ(e2, i3.u_texsize), u_texture: new t2.aL(e2, i3.u_texture), u_gamma_scale: new t2.aM(e2, i3.u_gamma_scale), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_is_halo: new t2.aL(e2, i3.u_is_halo) }), symbolTextAndIcon: (e2, i3) => ({ u_is_size_zoom_constant: new t2.aL(e2, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t2.aL(e2, i3.u_is_size_feature_constant), u_size_t: new t2.aM(e2, i3.u_size_t), u_size: new t2.aM(e2, i3.u_size), u_camera_to_center_distance: new t2.aM(e2, i3.u_camera_to_center_distance), u_pitch: new t2.aM(e2, i3.u_pitch), u_rotate_symbol: new t2.aL(e2, i3.u_rotate_symbol), u_aspect_ratio: new t2.aM(e2, i3.u_aspect_ratio), u_fade_change: new t2.aM(e2, i3.u_fade_change), u_matrix: new t2.aN(e2, i3.u_matrix), u_label_plane_matrix: new t2.aN(e2, i3.u_label_plane_matrix), u_coord_matrix: new t2.aN(e2, i3.u_coord_matrix), u_is_text: new t2.aL(e2, i3.u_is_text), u_pitch_with_map: new t2.aL(e2, i3.u_pitch_with_map), u_texsize: new t2.aQ(e2, i3.u_texsize), u_texsize_icon: new t2.aQ(e2, i3.u_texsize_icon), u_texture: new t2.aL(e2, i3.u_texture), u_texture_icon: new t2.aL(e2, i3.u_texture_icon), u_gamma_scale: new t2.aM(e2, i3.u_gamma_scale), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_is_halo: new t2.aL(e2, i3.u_is_halo) }), background: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_opacity: new t2.aM(e2, i3.u_opacity), u_color: new t2.aR(e2, i3.u_color) }), backgroundPattern: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_opacity: new t2.aM(e2, i3.u_opacity), u_image: new t2.aL(e2, i3.u_image), u_pattern_tl_a: new t2.aQ(e2, i3.u_pattern_tl_a), u_pattern_br_a: new t2.aQ(e2, i3.u_pattern_br_a), u_pattern_tl_b: new t2.aQ(e2, i3.u_pattern_tl_b), u_pattern_br_b: new t2.aQ(e2, i3.u_pattern_br_b), u_texsize: new t2.aQ(e2, i3.u_texsize), u_mix: new t2.aM(e2, i3.u_mix), u_pattern_size_a: new t2.aQ(e2, i3.u_pattern_size_a), u_pattern_size_b: new t2.aQ(e2, i3.u_pattern_size_b), u_scale_a: new t2.aM(e2, i3.u_scale_a), u_scale_b: new t2.aM(e2, i3.u_scale_b), u_pixel_coord_upper: new t2.aQ(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t2.aQ(e2, i3.u_pixel_coord_lower), u_tile_units_to_pixels: new t2.aM(e2, i3.u_tile_units_to_pixels) }), terrain: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_texture: new t2.aL(e2, i3.u_texture), u_ele_delta: new t2.aM(e2, i3.u_ele_delta) }), terrainDepth: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_ele_delta: new t2.aM(e2, i3.u_ele_delta) }), terrainCoords: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_texture: new t2.aL(e2, i3.u_texture), u_terrain_coords_id: new t2.aM(e2, i3.u_terrain_coords_id), u_ele_delta: new t2.aM(e2, i3.u_ele_delta) }) };
      class Oe2 {
        constructor(t3, e2, i3) {
          this.context = t3;
          const s3 = t3.gl;
          this.buffer = s3.createBuffer(), this.dynamicDraw = Boolean(i3), this.context.unbindVAO(), t3.bindElementBuffer.set(this.buffer), s3.bufferData(s3.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? s3.DYNAMIC_DRAW : s3.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(t3) {
          const e2 = this.context.gl;
          if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t3.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Ne2 = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class Ue2 {
        constructor(t3, e2, i3, s3) {
          this.length = e2.length, this.attributes = i3, this.itemSize = e2.bytesPerElement, this.dynamicDraw = s3, this.context = t3;
          const a3 = t3.gl;
          this.buffer = a3.createBuffer(), t3.bindVertexBuffer.set(this.buffer), a3.bufferData(a3.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? a3.DYNAMIC_DRAW : a3.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(t3) {
          if (t3.length !== this.length) throw new Error(`Length of new data is ${t3.length}, which doesn't match current length of ${this.length}`);
          const e2 = this.context.gl;
          this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t3.arrayBuffer);
        }
        enableAttributes(t3, e2) {
          for (let i3 = 0; i3 < this.attributes.length; i3++) {
            const s3 = e2.attributes[this.attributes[i3].name];
            void 0 !== s3 && t3.enableVertexAttribArray(s3);
          }
        }
        setVertexAttribPointers(t3, e2, i3) {
          for (let s3 = 0; s3 < this.attributes.length; s3++) {
            const a3 = this.attributes[s3], o3 = e2.attributes[a3.name];
            void 0 !== o3 && t3.vertexAttribPointer(o3, a3.components, t3[Ne2[a3.type]], false, this.itemSize, a3.offset + this.itemSize * (i3 || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Ze2 = /* @__PURE__ */ new WeakMap();
      function Ge2(t3) {
        var e2;
        if (Ze2.has(t3)) return Ze2.get(t3);
        {
          const i3 = null === (e2 = t3.getParameter(t3.VERSION)) || void 0 === e2 ? void 0 : e2.startsWith("WebGL 2.0");
          return Ze2.set(t3, i3), i3;
        }
      }
      class je2 {
        constructor(t3) {
          this.gl = t3.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        }
        get() {
          return this.current;
        }
        set(t3) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class Ve extends je2 {
        getDefault() {
          return t2.aT.transparent;
        }
        set(t3) {
          const e2 = this.current;
          (t3.r !== e2.r || t3.g !== e2.g || t3.b !== e2.b || t3.a !== e2.a || this.dirty) && (this.gl.clearColor(t3.r, t3.g, t3.b, t3.a), this.current = t3, this.dirty = false);
        }
      }
      class qe extends je2 {
        getDefault() {
          return 1;
        }
        set(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.clearDepth(t3), this.current = t3, this.dirty = false);
        }
      }
      class $e2 extends je2 {
        getDefault() {
          return 0;
        }
        set(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.clearStencil(t3), this.current = t3, this.dirty = false);
        }
      }
      class We2 extends je2 {
        getDefault() {
          return [true, true, true, true];
        }
        set(t3) {
          const e2 = this.current;
          (t3[0] !== e2[0] || t3[1] !== e2[1] || t3[2] !== e2[2] || t3[3] !== e2[3] || this.dirty) && (this.gl.colorMask(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
        }
      }
      class He2 extends je2 {
        getDefault() {
          return true;
        }
        set(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.depthMask(t3), this.current = t3, this.dirty = false);
        }
      }
      class Xe extends je2 {
        getDefault() {
          return 255;
        }
        set(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.stencilMask(t3), this.current = t3, this.dirty = false);
        }
      }
      class Ke extends je2 {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(t3) {
          const e2 = this.current;
          (t3.func !== e2.func || t3.ref !== e2.ref || t3.mask !== e2.mask || this.dirty) && (this.gl.stencilFunc(t3.func, t3.ref, t3.mask), this.current = t3, this.dirty = false);
        }
      }
      class Qe extends je2 {
        getDefault() {
          const t3 = this.gl;
          return [t3.KEEP, t3.KEEP, t3.KEEP];
        }
        set(t3) {
          const e2 = this.current;
          (t3[0] !== e2[0] || t3[1] !== e2[1] || t3[2] !== e2[2] || this.dirty) && (this.gl.stencilOp(t3[0], t3[1], t3[2]), this.current = t3, this.dirty = false);
        }
      }
      class Ye extends je2 {
        getDefault() {
          return false;
        }
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          const e2 = this.gl;
          t3 ? e2.enable(e2.STENCIL_TEST) : e2.disable(e2.STENCIL_TEST), this.current = t3, this.dirty = false;
        }
      }
      class Je extends je2 {
        getDefault() {
          return [0, 1];
        }
        set(t3) {
          const e2 = this.current;
          (t3[0] !== e2[0] || t3[1] !== e2[1] || this.dirty) && (this.gl.depthRange(t3[0], t3[1]), this.current = t3, this.dirty = false);
        }
      }
      class ti extends je2 {
        getDefault() {
          return false;
        }
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          const e2 = this.gl;
          t3 ? e2.enable(e2.DEPTH_TEST) : e2.disable(e2.DEPTH_TEST), this.current = t3, this.dirty = false;
        }
      }
      class ei extends je2 {
        getDefault() {
          return this.gl.LESS;
        }
        set(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.depthFunc(t3), this.current = t3, this.dirty = false);
        }
      }
      class ii extends je2 {
        getDefault() {
          return false;
        }
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          const e2 = this.gl;
          t3 ? e2.enable(e2.BLEND) : e2.disable(e2.BLEND), this.current = t3, this.dirty = false;
        }
      }
      class si extends je2 {
        getDefault() {
          const t3 = this.gl;
          return [t3.ONE, t3.ZERO];
        }
        set(t3) {
          const e2 = this.current;
          (t3[0] !== e2[0] || t3[1] !== e2[1] || this.dirty) && (this.gl.blendFunc(t3[0], t3[1]), this.current = t3, this.dirty = false);
        }
      }
      class ai extends je2 {
        getDefault() {
          return t2.aT.transparent;
        }
        set(t3) {
          const e2 = this.current;
          (t3.r !== e2.r || t3.g !== e2.g || t3.b !== e2.b || t3.a !== e2.a || this.dirty) && (this.gl.blendColor(t3.r, t3.g, t3.b, t3.a), this.current = t3, this.dirty = false);
        }
      }
      class oi extends je2 {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.blendEquation(t3), this.current = t3, this.dirty = false);
        }
      }
      class ri extends je2 {
        getDefault() {
          return false;
        }
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          const e2 = this.gl;
          t3 ? e2.enable(e2.CULL_FACE) : e2.disable(e2.CULL_FACE), this.current = t3, this.dirty = false;
        }
      }
      class ni extends je2 {
        getDefault() {
          return this.gl.BACK;
        }
        set(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.cullFace(t3), this.current = t3, this.dirty = false);
        }
      }
      class li extends je2 {
        getDefault() {
          return this.gl.CCW;
        }
        set(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.frontFace(t3), this.current = t3, this.dirty = false);
        }
      }
      class hi extends je2 {
        getDefault() {
          return null;
        }
        set(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.useProgram(t3), this.current = t3, this.dirty = false);
        }
      }
      class ci extends je2 {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.activeTexture(t3), this.current = t3, this.dirty = false);
        }
      }
      class ui extends je2 {
        getDefault() {
          const t3 = this.gl;
          return [0, 0, t3.drawingBufferWidth, t3.drawingBufferHeight];
        }
        set(t3) {
          const e2 = this.current;
          (t3[0] !== e2[0] || t3[1] !== e2[1] || t3[2] !== e2[2] || t3[3] !== e2[3] || this.dirty) && (this.gl.viewport(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
        }
      }
      class di extends je2 {
        getDefault() {
          return null;
        }
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          const e2 = this.gl;
          e2.bindFramebuffer(e2.FRAMEBUFFER, t3), this.current = t3, this.dirty = false;
        }
      }
      class _i extends je2 {
        getDefault() {
          return null;
        }
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          const e2 = this.gl;
          e2.bindRenderbuffer(e2.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
        }
      }
      class pi extends je2 {
        getDefault() {
          return null;
        }
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          const e2 = this.gl;
          e2.bindTexture(e2.TEXTURE_2D, t3), this.current = t3, this.dirty = false;
        }
      }
      class mi extends je2 {
        getDefault() {
          return null;
        }
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          const e2 = this.gl;
          e2.bindBuffer(e2.ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
        }
      }
      class fi extends je2 {
        getDefault() {
          return null;
        }
        set(t3) {
          const e2 = this.gl;
          e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
        }
      }
      class gi extends je2 {
        getDefault() {
          return null;
        }
        set(t3) {
          var e2;
          if (t3 === this.current && !this.dirty) return;
          const i3 = this.gl;
          Ge2(i3) ? i3.bindVertexArray(t3) : null === (e2 = i3.getExtension("OES_vertex_array_object")) || void 0 === e2 || e2.bindVertexArrayOES(t3), this.current = t3, this.dirty = false;
        }
      }
      class vi extends je2 {
        getDefault() {
          return 4;
        }
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          const e2 = this.gl;
          e2.pixelStorei(e2.UNPACK_ALIGNMENT, t3), this.current = t3, this.dirty = false;
        }
      }
      class xi extends je2 {
        getDefault() {
          return false;
        }
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          const e2 = this.gl;
          e2.pixelStorei(e2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t3), this.current = t3, this.dirty = false;
        }
      }
      class yi extends je2 {
        getDefault() {
          return false;
        }
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          const e2 = this.gl;
          e2.pixelStorei(e2.UNPACK_FLIP_Y_WEBGL, t3), this.current = t3, this.dirty = false;
        }
      }
      class bi extends je2 {
        constructor(t3, e2) {
          super(t3), this.context = t3, this.parent = e2;
        }
        getDefault() {
          return null;
        }
      }
      class wi extends bi {
        setDirty() {
          this.dirty = true;
        }
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const e2 = this.gl;
          e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t3, 0), this.current = t3, this.dirty = false;
        }
      }
      class Ti extends bi {
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const e2 = this.gl;
          e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_ATTACHMENT, e2.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
        }
      }
      class Ii extends bi {
        set(t3) {
          if (t3 === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const e2 = this.gl;
          e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_STENCIL_ATTACHMENT, e2.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
        }
      }
      class Ei {
        constructor(t3, e2, i3, s3, a3) {
          this.context = t3, this.width = e2, this.height = i3;
          const o3 = t3.gl, r3 = this.framebuffer = o3.createFramebuffer();
          if (this.colorAttachment = new wi(t3, r3), s3) this.depthAttachment = a3 ? new Ii(t3, r3) : new Ti(t3, r3);
          else if (a3) throw new Error("Stencil cannot be setted without depth");
          if (o3.checkFramebufferStatus(o3.FRAMEBUFFER) !== o3.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
        }
        destroy() {
          const t3 = this.context.gl, e2 = this.colorAttachment.get();
          if (e2 && t3.deleteTexture(e2), this.depthAttachment) {
            const e3 = this.depthAttachment.get();
            e3 && t3.deleteRenderbuffer(e3);
          }
          t3.deleteFramebuffer(this.framebuffer);
        }
      }
      class Si {
        constructor(t3, e2, i3) {
          this.blendFunction = t3, this.blendColor = e2, this.mask = i3;
        }
      }
      Si.Replace = [1, 0], Si.disabled = new Si(Si.Replace, t2.aT.transparent, [false, false, false, false]), Si.unblended = new Si(Si.Replace, t2.aT.transparent, [true, true, true, true]), Si.alphaBlended = new Si([1, 771], t2.aT.transparent, [true, true, true, true]);
      class Ci {
        constructor(t3) {
          var e2, i3;
          if (this.gl = t3, this.clearColor = new Ve(this), this.clearDepth = new qe(this), this.clearStencil = new $e2(this), this.colorMask = new We2(this), this.depthMask = new He2(this), this.stencilMask = new Xe(this), this.stencilFunc = new Ke(this), this.stencilOp = new Qe(this), this.stencilTest = new Ye(this), this.depthRange = new Je(this), this.depthTest = new ti(this), this.depthFunc = new ei(this), this.blend = new ii(this), this.blendFunc = new si(this), this.blendColor = new ai(this), this.blendEquation = new oi(this), this.cullFace = new ri(this), this.cullFaceSide = new ni(this), this.frontFace = new li(this), this.program = new hi(this), this.activeTexture = new ci(this), this.viewport = new ui(this), this.bindFramebuffer = new di(this), this.bindRenderbuffer = new _i(this), this.bindTexture = new pi(this), this.bindVertexBuffer = new mi(this), this.bindElementBuffer = new fi(this), this.bindVertexArray = new gi(this), this.pixelStoreUnpack = new vi(this), this.pixelStoreUnpackPremultiplyAlpha = new xi(this), this.pixelStoreUnpackFlipY = new yi(this), this.extTextureFilterAnisotropic = t3.getExtension("EXT_texture_filter_anisotropic") || t3.getExtension("MOZ_EXT_texture_filter_anisotropic") || t3.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t3.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t3.getParameter(t3.MAX_TEXTURE_SIZE), Ge2(t3)) {
            this.HALF_FLOAT = t3.HALF_FLOAT;
            const s3 = t3.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = null !== (e2 = t3.RGBA16F) && void 0 !== e2 ? e2 : null == s3 ? void 0 : s3.RGBA16F_EXT, this.RGB16F = null !== (i3 = t3.RGB16F) && void 0 !== i3 ? i3 : null == s3 ? void 0 : s3.RGB16F_EXT, t3.getExtension("EXT_color_buffer_float");
          } else {
            t3.getExtension("EXT_color_buffer_half_float"), t3.getExtension("OES_texture_half_float_linear");
            const e3 = t3.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = null == e3 ? void 0 : e3.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }
        createIndexBuffer(t3, e2) {
          return new Oe2(this, t3, e2);
        }
        createVertexBuffer(t3, e2, i3) {
          return new Ue2(this, t3, e2, i3);
        }
        createRenderbuffer(t3, e2, i3) {
          const s3 = this.gl, a3 = s3.createRenderbuffer();
          return this.bindRenderbuffer.set(a3), s3.renderbufferStorage(s3.RENDERBUFFER, t3, e2, i3), this.bindRenderbuffer.set(null), a3;
        }
        createFramebuffer(t3, e2, i3, s3) {
          return new Ei(this, t3, e2, i3, s3);
        }
        clear({ color: t3, depth: e2, stencil: i3 }) {
          const s3 = this.gl;
          let a3 = 0;
          t3 && (a3 |= s3.COLOR_BUFFER_BIT, this.clearColor.set(t3), this.colorMask.set([true, true, true, true])), void 0 !== e2 && (a3 |= s3.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e2), this.depthMask.set(true)), void 0 !== i3 && (a3 |= s3.STENCIL_BUFFER_BIT, this.clearStencil.set(i3), this.stencilMask.set(255)), s3.clear(a3);
        }
        setCullFace(t3) {
          false === t3.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t3.mode), this.frontFace.set(t3.frontFace));
        }
        setDepthMode(t3) {
          t3.func !== this.gl.ALWAYS || t3.mask ? (this.depthTest.set(true), this.depthFunc.set(t3.func), this.depthMask.set(t3.mask), this.depthRange.set(t3.range)) : this.depthTest.set(false);
        }
        setStencilMode(t3) {
          t3.test.func !== this.gl.ALWAYS || t3.mask ? (this.stencilTest.set(true), this.stencilMask.set(t3.mask), this.stencilOp.set([t3.fail, t3.depthFail, t3.pass]), this.stencilFunc.set({ func: t3.test.func, ref: t3.ref, mask: t3.test.mask })) : this.stencilTest.set(false);
        }
        setColorMode(e2) {
          t2.aG(e2.blendFunction, Si.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e2.blendFunction), this.blendColor.set(e2.blendColor)), this.colorMask.set(e2.mask);
        }
        createVertexArray() {
          var t3;
          return Ge2(this.gl) ? this.gl.createVertexArray() : null === (t3 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t3 ? void 0 : t3.createVertexArrayOES();
        }
        deleteVertexArray(t3) {
          var e2;
          return Ge2(this.gl) ? this.gl.deleteVertexArray(t3) : null === (e2 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e2 ? void 0 : e2.deleteVertexArrayOES(t3);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      class Pi {
        constructor(t3, e2, i3) {
          this.func = t3, this.mask = e2, this.range = i3;
        }
      }
      Pi.ReadOnly = false, Pi.ReadWrite = true, Pi.disabled = new Pi(519, Pi.ReadOnly, [0, 1]);
      const Di = 7680;
      class Mi {
        constructor(t3, e2, i3, s3, a3, o3) {
          this.test = t3, this.ref = e2, this.mask = i3, this.fail = s3, this.depthFail = a3, this.pass = o3;
        }
      }
      Mi.disabled = new Mi({ func: 519, mask: 0 }, 0, 0, Di, Di, Di);
      class zi {
        constructor(t3, e2, i3) {
          this.enable = t3, this.mode = e2, this.frontFace = i3;
        }
      }
      let Li;
      function Ai(e2, i3, s3, a3, o3, r3, n3) {
        const l3 = e2.context, h3 = l3.gl, c3 = e2.useProgram("collisionBox"), u3 = [];
        let d3 = 0, _3 = 0;
        for (let p4 = 0; p4 < a3.length; p4++) {
          const m4 = a3[p4], f4 = i3.getTile(m4), g4 = f4.getBucket(s3);
          if (!g4) continue;
          let v4 = m4.posMatrix;
          0 === o3[0] && 0 === o3[1] || (v4 = e2.translatePosMatrix(m4.posMatrix, f4, o3, r3));
          const x4 = n3 ? g4.textCollisionBox : g4.iconCollisionBox, y3 = g4.collisionCircleArray;
          if (y3.length > 0) {
            const i4 = t2.Z(), s4 = v4;
            t2.aU(i4, g4.placementInvProjMatrix, e2.transform.glCoordMatrix), t2.aU(i4, i4, g4.placementViewportMatrix), u3.push({ circleArray: y3, circleOffset: _3, transform: s4, invTransform: i4, coord: m4 }), d3 += y3.length / 4, _3 = d3;
          }
          x4 && c3.draw(l3, h3.LINES, Pi.disabled, Mi.disabled, e2.colorModeForRenderPass(), zi.disabled, xe2(v4, e2.transform, f4), e2.style.map.terrain && e2.style.map.terrain.getTerrainData(m4), s3.id, x4.layoutVertexBuffer, x4.indexBuffer, x4.segments, null, e2.transform.zoom, null, null, x4.collisionVertexBuffer);
        }
        if (!n3 || !u3.length) return;
        const p3 = e2.useProgram("collisionCircle"), m3 = new t2.aV();
        m3.resize(4 * d3), m3._trim();
        let f3 = 0;
        for (const t3 of u3) for (let e3 = 0; e3 < t3.circleArray.length / 4; e3++) {
          const i4 = 4 * e3, s4 = t3.circleArray[i4 + 0], a4 = t3.circleArray[i4 + 1], o4 = t3.circleArray[i4 + 2], r4 = t3.circleArray[i4 + 3];
          m3.emplace(f3++, s4, a4, o4, r4, 0), m3.emplace(f3++, s4, a4, o4, r4, 1), m3.emplace(f3++, s4, a4, o4, r4, 2), m3.emplace(f3++, s4, a4, o4, r4, 3);
        }
        (!Li || Li.length < 2 * d3) && (Li = function(e3) {
          const i4 = 2 * e3, s4 = new t2.aX();
          s4.resize(i4), s4._trim();
          for (let t3 = 0; t3 < i4; t3++) {
            const e4 = 6 * t3;
            s4.uint16[e4 + 0] = 4 * t3 + 0, s4.uint16[e4 + 1] = 4 * t3 + 1, s4.uint16[e4 + 2] = 4 * t3 + 2, s4.uint16[e4 + 3] = 4 * t3 + 2, s4.uint16[e4 + 4] = 4 * t3 + 3, s4.uint16[e4 + 5] = 4 * t3 + 0;
          }
          return s4;
        }(d3));
        const g3 = l3.createIndexBuffer(Li, true), v3 = l3.createVertexBuffer(m3, t2.aW.members, true);
        for (const i4 of u3) {
          const a4 = { u_matrix: i4.transform, u_inv_matrix: i4.invTransform, u_camera_to_center_distance: (x3 = e2.transform).cameraToCenterDistance, u_viewport_size: [x3.width, x3.height] };
          p3.draw(l3, h3.TRIANGLES, Pi.disabled, Mi.disabled, e2.colorModeForRenderPass(), zi.disabled, a4, e2.style.map.terrain && e2.style.map.terrain.getTerrainData(i4.coord), s3.id, v3, g3, t2.S.simpleSegment(0, 2 * i4.circleOffset, i4.circleArray.length, i4.circleArray.length / 2), null, e2.transform.zoom, null, null, null);
        }
        var x3;
        v3.destroy(), g3.destroy();
      }
      zi.disabled = new zi(false, 1029, 2305), zi.backCCW = new zi(true, 1029, 2305);
      const Ri = t2.ao(new Float32Array(16));
      function ki(e2, i3, s3, a3, o3, r3) {
        const { horizontalAlign: n3, verticalAlign: l3 } = t2.au(e2);
        return new t2.P((-(n3 - 0.5) * i3 / o3 + a3[0]) * r3, (-(l3 - 0.5) * s3 / o3 + a3[1]) * r3);
      }
      function Fi(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3) {
        const d3 = e2.text.placedSymbolArray, _3 = e2.text.dynamicLayoutVertexArray, p3 = e2.icon.dynamicLayoutVertexArray, m3 = {};
        _3.clear();
        for (let p4 = 0; p4 < d3.length; p4++) {
          const f3 = d3.get(p4), g3 = f3.hidden || !f3.crossTileID || e2.allowVerticalPlacement && !f3.placedOrientation ? null : a3[f3.crossTileID];
          if (g3) {
            const a4 = new t2.P(f3.anchorX, f3.anchorY), d4 = ht(a4, s3 ? n3 : r3, u3), p5 = ct(o3.cameraToCenterDistance, d4.signedDistanceFromCamera);
            let v3 = t2.aj(e2.textSizeData, h3, f3) * p5 / t2.ap;
            s3 && (v3 *= e2.tilePixelRatio / l3);
            const { width: x3, height: y3, anchor: b3, textOffset: w3, textBoxScale: T3 } = g3, I3 = ki(b3, x3, y3, w3, T3, v3), E3 = s3 ? ht(a4.add(I3), r3, u3).point : d4.point.add(i3 ? I3.rotate(-o3.angle) : I3), S3 = e2.allowVerticalPlacement && f3.placedOrientation === t2.ai.vertical ? Math.PI / 2 : 0;
            for (let e3 = 0; e3 < f3.numGlyphs; e3++) t2.ak(_3, E3, S3);
            c3 && f3.associatedIconIndex >= 0 && (m3[f3.associatedIconIndex] = { shiftedAnchor: E3, angle: S3 });
          } else wt(f3.numGlyphs, _3);
        }
        if (c3) {
          p3.clear();
          const i4 = e2.icon.placedSymbolArray;
          for (let e3 = 0; e3 < i4.length; e3++) {
            const s4 = i4.get(e3);
            if (s4.hidden) wt(s4.numGlyphs, p3);
            else {
              const i5 = m3[e3];
              if (i5) for (let e4 = 0; e4 < s4.numGlyphs; e4++) t2.ak(p3, i5.shiftedAnchor, i5.angle);
              else wt(s4.numGlyphs, p3);
            }
          }
          e2.icon.dynamicLayoutVertexBuffer.updateData(p3);
        }
        e2.text.dynamicLayoutVertexBuffer.updateData(_3);
      }
      function Bi(t3, e2, i3) {
        return i3.iconsInText && e2 ? "symbolTextAndIcon" : t3 ? "symbolSDF" : "symbolIcon";
      }
      function Oi(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3) {
        const _3 = e2.context, p3 = _3.gl, m3 = e2.transform, f3 = "map" === l3, g3 = "map" === h3, v3 = "viewport" !== l3 && "point" !== s3.layout.get("symbol-placement"), x3 = f3 && !g3 && !v3, y3 = !s3.layout.get("symbol-sort-key").isConstant();
        let b3 = false;
        const w3 = e2.depthModeForSublayer(0, Pi.ReadOnly), T3 = s3._unevaluatedLayout.hasValue("text-variable-anchor") || s3._unevaluatedLayout.hasValue("text-variable-anchor-offset"), I3 = [];
        for (const l4 of a3) {
          const a4 = i3.getTile(l4), h4 = a4.getBucket(s3);
          if (!h4) continue;
          const u4 = o3 ? h4.text : h4.icon;
          if (!u4 || !u4.segments.get().length || !u4.hasVisibleVertices) continue;
          const d4 = u4.programConfigurations.get(s3.id), _4 = o3 || h4.sdfIcons, w4 = o3 ? h4.textSizeData : h4.iconSizeData, E3 = g3 || 0 !== m3.pitch, S3 = e2.useProgram(Bi(_4, o3, h4), d4), C3 = t2.ah(w4, m3.zoom), P3 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(l4);
          let D3, M3, z3, L3, A3 = [0, 0], R3 = null;
          if (o3) M3 = a4.glyphAtlasTexture, z3 = p3.LINEAR, D3 = a4.glyphAtlasTexture.size, h4.iconsInText && (A3 = a4.imageAtlasTexture.size, R3 = a4.imageAtlasTexture, L3 = E3 || e2.options.rotating || e2.options.zooming || "composite" === w4.kind || "camera" === w4.kind ? p3.LINEAR : p3.NEAREST);
          else {
            const t3 = 1 !== s3.layout.get("icon-size").constantOr(0) || h4.iconsNeedLinear;
            M3 = a4.imageAtlasTexture, z3 = _4 || e2.options.rotating || e2.options.zooming || t3 || E3 ? p3.LINEAR : p3.NEAREST, D3 = a4.imageAtlasTexture.size;
          }
          const k3 = St(a4, 1, e2.transform.zoom), F3 = nt(l4.posMatrix, g3, f3, e2.transform, k3), B3 = lt(l4.posMatrix, g3, f3, e2.transform, k3), O3 = T3 && h4.hasTextData(), N3 = "none" !== s3.layout.get("icon-text-fit") && O3 && h4.hasIconData();
          if (v3) {
            const t3 = e2.style.map.terrain ? (t4, i5) => e2.style.map.terrain.getElevation(l4, t4, i5) : null, i4 = "map" === s3.layout.get("text-rotation-alignment");
            dt(h4, l4.posMatrix, e2, o3, F3, B3, g3, c3, i4, t3);
          }
          const U3 = e2.translatePosMatrix(l4.posMatrix, a4, r3, n3), Z3 = v3 || o3 && T3 || N3 ? Ri : F3, G3 = e2.translatePosMatrix(B3, a4, r3, n3, true), j3 = _4 && 0 !== s3.paint.get(o3 ? "text-halo-width" : "icon-halo-width").constantOr(1);
          let V3;
          V3 = _4 ? h4.iconsInText ? Re2(w4.kind, C3, x3, g3, e2, U3, Z3, G3, D3, A3) : Ae2(w4.kind, C3, x3, g3, e2, U3, Z3, G3, o3, D3, true) : Le2(w4.kind, C3, x3, g3, e2, U3, Z3, G3, o3, D3);
          const q3 = { program: S3, buffers: u4, uniformValues: V3, atlasTexture: M3, atlasTextureIcon: R3, atlasInterpolation: z3, atlasInterpolationIcon: L3, isSDF: _4, hasHalo: j3 };
          if (y3 && h4.canOverlap) {
            b3 = true;
            const e3 = u4.segments.get();
            for (const i4 of e3) I3.push({ segments: new t2.S([i4]), sortKey: i4.sortKey, state: q3, terrainData: P3 });
          } else I3.push({ segments: u4.segments, sortKey: 0, state: q3, terrainData: P3 });
        }
        b3 && I3.sort((t3, e3) => t3.sortKey - e3.sortKey);
        for (const t3 of I3) {
          const i4 = t3.state;
          if (_3.activeTexture.set(p3.TEXTURE0), i4.atlasTexture.bind(i4.atlasInterpolation, p3.CLAMP_TO_EDGE), i4.atlasTextureIcon && (_3.activeTexture.set(p3.TEXTURE1), i4.atlasTextureIcon && i4.atlasTextureIcon.bind(i4.atlasInterpolationIcon, p3.CLAMP_TO_EDGE)), i4.isSDF) {
            const a4 = i4.uniformValues;
            i4.hasHalo && (a4.u_is_halo = 1, Ni(i4.buffers, t3.segments, s3, e2, i4.program, w3, u3, d3, a4, t3.terrainData)), a4.u_is_halo = 0;
          }
          Ni(i4.buffers, t3.segments, s3, e2, i4.program, w3, u3, d3, i4.uniformValues, t3.terrainData);
        }
      }
      function Ni(t3, e2, i3, s3, a3, o3, r3, n3, l3, h3) {
        const c3 = s3.context;
        a3.draw(c3, c3.gl.TRIANGLES, o3, r3, n3, zi.disabled, l3, h3, i3.id, t3.layoutVertexBuffer, t3.indexBuffer, e2, i3.paint, s3.transform.zoom, t3.programConfigurations.get(i3.id), t3.dynamicLayoutVertexBuffer, t3.opacityVertexBuffer);
      }
      function Ui(t3, e2, i3, s3, a3) {
        if (!i3 || !s3 || !s3.imageAtlas) return;
        const o3 = s3.imageAtlas.patternPositions;
        let r3 = o3[i3.to.toString()], n3 = o3[i3.from.toString()];
        if (!r3 && n3 && (r3 = n3), !n3 && r3 && (n3 = r3), !r3 || !n3) {
          const t4 = a3.getPaintProperty(e2);
          r3 = o3[t4], n3 = o3[t4];
        }
        r3 && n3 && t3.setConstantPatternPositions(r3, n3);
      }
      function Zi(t3, e2, i3, s3, a3, o3, r3) {
        const n3 = t3.context.gl, l3 = "fill-pattern", h3 = i3.paint.get(l3), c3 = h3 && h3.constantOr(1), u3 = i3.getCrossfadeParameters();
        let d3, _3, p3, m3, f3;
        r3 ? (_3 = c3 && !i3.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", d3 = n3.LINES) : (_3 = c3 ? "fillPattern" : "fill", d3 = n3.TRIANGLES);
        const g3 = h3.constantOr(null);
        for (const h4 of s3) {
          const s4 = e2.getTile(h4);
          if (c3 && !s4.patternsLoaded()) continue;
          const v3 = s4.getBucket(i3);
          if (!v3) continue;
          const x3 = v3.programConfigurations.get(i3.id), y3 = t3.useProgram(_3, x3), b3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(h4);
          c3 && (t3.context.activeTexture.set(n3.TEXTURE0), s4.imageAtlasTexture.bind(n3.LINEAR, n3.CLAMP_TO_EDGE), x3.updatePaintBuffers(u3)), Ui(x3, l3, g3, s4, i3);
          const w3 = b3 ? h4 : null, T3 = t3.translatePosMatrix(w3 ? w3.posMatrix : h4.posMatrix, s4, i3.paint.get("fill-translate"), i3.paint.get("fill-translate-anchor"));
          if (r3) {
            m3 = v3.indexBuffer2, f3 = v3.segments2;
            const e3 = [n3.drawingBufferWidth, n3.drawingBufferHeight];
            p3 = "fillOutlinePattern" === _3 && c3 ? ge2(T3, t3, u3, s4, e3) : fe2(T3, e3);
          } else m3 = v3.indexBuffer, f3 = v3.segments, p3 = c3 ? me2(T3, t3, u3, s4) : pe2(T3);
          y3.draw(t3.context, d3, a3, t3.stencilModeForClipping(h4), o3, zi.disabled, p3, b3, i3.id, v3.layoutVertexBuffer, m3, f3, i3.paint, t3.transform.zoom, x3);
        }
      }
      function Gi(t3, e2, i3, s3, a3, o3, r3) {
        const n3 = t3.context, l3 = n3.gl, h3 = "fill-extrusion-pattern", c3 = i3.paint.get(h3), u3 = c3.constantOr(1), d3 = i3.getCrossfadeParameters(), _3 = i3.paint.get("fill-extrusion-opacity"), p3 = c3.constantOr(null);
        for (const c4 of s3) {
          const s4 = e2.getTile(c4), m3 = s4.getBucket(i3);
          if (!m3) continue;
          const f3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(c4), g3 = m3.programConfigurations.get(i3.id), v3 = t3.useProgram(u3 ? "fillExtrusionPattern" : "fillExtrusion", g3);
          u3 && (t3.context.activeTexture.set(l3.TEXTURE0), s4.imageAtlasTexture.bind(l3.LINEAR, l3.CLAMP_TO_EDGE), g3.updatePaintBuffers(d3)), Ui(g3, h3, p3, s4, i3);
          const x3 = t3.translatePosMatrix(c4.posMatrix, s4, i3.paint.get("fill-extrusion-translate"), i3.paint.get("fill-extrusion-translate-anchor")), y3 = i3.paint.get("fill-extrusion-vertical-gradient"), b3 = u3 ? _e2(x3, t3, y3, _3, c4, d3, s4) : de2(x3, t3, y3, _3);
          v3.draw(n3, n3.gl.TRIANGLES, a3, o3, r3, zi.backCCW, b3, f3, i3.id, m3.layoutVertexBuffer, m3.indexBuffer, m3.segments, i3.paint, t3.transform.zoom, g3, t3.style.map.terrain && m3.centroidVertexBuffer);
        }
      }
      function ji(t3, e2, i3, s3, a3, o3, r3) {
        const n3 = t3.context, l3 = n3.gl, h3 = i3.fbo;
        if (!h3) return;
        const c3 = t3.useProgram("hillshade"), u3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(e2);
        n3.activeTexture.set(l3.TEXTURE0), l3.bindTexture(l3.TEXTURE_2D, h3.colorAttachment.get()), c3.draw(n3, l3.TRIANGLES, a3, o3, r3, zi.disabled, ((t4, e3, i4, s4) => {
          const a4 = i4.paint.get("hillshade-shadow-color"), o4 = i4.paint.get("hillshade-highlight-color"), r4 = i4.paint.get("hillshade-accent-color");
          let n4 = i4.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          "viewport" === i4.paint.get("hillshade-illumination-anchor") && (n4 -= t4.transform.angle);
          const l4 = !t4.options.moving;
          return { u_matrix: s4 ? s4.posMatrix : t4.transform.calculatePosMatrix(e3.tileID.toUnwrapped(), l4), u_image: 0, u_latrange: Te2(0, e3.tileID), u_light: [i4.paint.get("hillshade-exaggeration"), n4], u_shadow: a4, u_highlight: o4, u_accent: r4 };
        })(t3, i3, s3, u3 ? e2 : null), u3, s3.id, t3.rasterBoundsBuffer, t3.quadTriangleIndexBuffer, t3.rasterBoundsSegments);
      }
      function Vi(e2, i3, s3, a3, o3, r3) {
        const n3 = e2.context, l3 = n3.gl, h3 = i3.dem;
        if (h3 && h3.data) {
          const c3 = h3.dim, u3 = h3.stride, d3 = h3.getPixels();
          if (n3.activeTexture.set(l3.TEXTURE1), n3.pixelStoreUnpackPremultiplyAlpha.set(false), i3.demTexture = i3.demTexture || e2.getTileTexture(u3), i3.demTexture) {
            const t3 = i3.demTexture;
            t3.update(d3, { premultiply: false }), t3.bind(l3.NEAREST, l3.CLAMP_TO_EDGE);
          } else i3.demTexture = new x2(n3, d3, l3.RGBA, { premultiply: false }), i3.demTexture.bind(l3.NEAREST, l3.CLAMP_TO_EDGE);
          n3.activeTexture.set(l3.TEXTURE0);
          let _3 = i3.fbo;
          if (!_3) {
            const t3 = new x2(n3, { width: c3, height: c3, data: null }, l3.RGBA);
            t3.bind(l3.LINEAR, l3.CLAMP_TO_EDGE), _3 = i3.fbo = n3.createFramebuffer(c3, c3, true, false), _3.colorAttachment.set(t3.texture);
          }
          n3.bindFramebuffer.set(_3.framebuffer), n3.viewport.set([0, 0, c3, c3]), e2.useProgram("hillshadePrepare").draw(n3, l3.TRIANGLES, a3, o3, r3, zi.disabled, ((e3, i4) => {
            const s4 = i4.stride, a4 = t2.Z();
            return t2.aS(a4, 0, t2.N, -t2.N, 0, 0, 1), t2.$(a4, a4, [0, -t2.N, 0]), { u_matrix: a4, u_image: 1, u_dimension: [s4, s4], u_zoom: e3.overscaledZ, u_unpack: i4.getUnpackVector() };
          })(i3.tileID, h3), null, s3.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments), i3.needsHillshadePrepare = false;
        }
      }
      function qi(e2, i3, s3, a3, o3, r3) {
        const n3 = a3.paint.get("raster-fade-duration");
        if (!r3 && n3 > 0) {
          const a4 = t2.h.now(), r4 = (a4 - e2.timeAdded) / n3, l3 = i3 ? (a4 - i3.timeAdded) / n3 : -1, h3 = s3.getSource(), c3 = o3.coveringZoomLevel({ tileSize: h3.tileSize, roundZoom: h3.roundZoom }), u3 = !i3 || Math.abs(i3.tileID.overscaledZ - c3) > Math.abs(e2.tileID.overscaledZ - c3), d3 = u3 && e2.refreshedUponExpiration ? 1 : t2.ad(u3 ? r4 : 1 - l3, 0, 1);
          return e2.refreshedUponExpiration && r4 >= 1 && (e2.refreshedUponExpiration = false), i3 ? { opacity: 1, mix: 1 - d3 } : { opacity: d3, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const $i = new t2.aT(1, 0, 0, 1), Wi = new t2.aT(0, 1, 0, 1), Hi = new t2.aT(0, 0, 1, 1), Xi = new t2.aT(1, 0, 1, 1), Ki = new t2.aT(0, 1, 1, 1);
      function Qi(t3, e2, i3, s3) {
        Ji(t3, 0, e2 + i3 / 2, t3.transform.width, i3, s3);
      }
      function Yi(t3, e2, i3, s3) {
        Ji(t3, e2 - i3 / 2, 0, i3, t3.transform.height, s3);
      }
      function Ji(t3, e2, i3, s3, a3, o3) {
        const r3 = t3.context, n3 = r3.gl;
        n3.enable(n3.SCISSOR_TEST), n3.scissor(e2 * t3.pixelRatio, i3 * t3.pixelRatio, s3 * t3.pixelRatio, a3 * t3.pixelRatio), r3.clear({ color: o3 }), n3.disable(n3.SCISSOR_TEST);
      }
      function ts(e2, i3, s3) {
        const a3 = e2.context, o3 = a3.gl, r3 = s3.posMatrix, n3 = e2.useProgram("debug"), l3 = Pi.disabled, h3 = Mi.disabled, c3 = e2.colorModeForRenderPass(), u3 = "$debug", d3 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(s3);
        a3.activeTexture.set(o3.TEXTURE0);
        const _3 = i3.getTileByID(s3.key).latestRawTileData, p3 = Math.floor((_3 && _3.byteLength || 0) / 1024), m3 = i3.getTile(s3).tileSize, f3 = 512 / Math.min(m3, 512) * (s3.overscaledZ / e2.transform.zoom) * 0.5;
        let g3 = s3.canonical.toString();
        s3.overscaledZ !== s3.canonical.z && (g3 += ` => ${s3.overscaledZ}`), function(t3, e3) {
          t3.initDebugOverlayCanvas();
          const i4 = t3.debugOverlayCanvas, s4 = t3.context.gl, a4 = t3.debugOverlayCanvas.getContext("2d");
          a4.clearRect(0, 0, i4.width, i4.height), a4.shadowColor = "white", a4.shadowBlur = 2, a4.lineWidth = 1.5, a4.strokeStyle = "white", a4.textBaseline = "top", a4.font = "bold 36px Open Sans, sans-serif", a4.fillText(e3, 5, 5), a4.strokeText(e3, 5, 5), t3.debugOverlayTexture.update(i4), t3.debugOverlayTexture.bind(s4.LINEAR, s4.CLAMP_TO_EDGE);
        }(e2, `${g3} ${p3}kB`), n3.draw(a3, o3.TRIANGLES, l3, h3, Si.alphaBlended, zi.disabled, ye2(r3, t2.aT.transparent, f3), null, u3, e2.debugBuffer, e2.quadTriangleIndexBuffer, e2.debugSegments), n3.draw(a3, o3.LINE_STRIP, l3, h3, c3, zi.disabled, ye2(r3, t2.aT.red), d3, u3, e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
      }
      function es(t3, e2, i3) {
        const s3 = t3.context, a3 = s3.gl, o3 = t3.colorModeForRenderPass(), r3 = new Pi(a3.LEQUAL, Pi.ReadWrite, t3.depthRangeFor3D), n3 = t3.useProgram("terrain"), l3 = e2.getTerrainMesh();
        s3.bindFramebuffer.set(null), s3.viewport.set([0, 0, t3.width, t3.height]);
        for (const h3 of i3) {
          const i4 = t3.renderToTexture.getTexture(h3), c3 = e2.getTerrainData(h3.tileID);
          s3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_2D, i4.texture);
          const u3 = { u_matrix: t3.transform.calculatePosMatrix(h3.tileID.toUnwrapped()), u_texture: 0, u_ele_delta: e2.getMeshFrameDelta(t3.transform.zoom) };
          n3.draw(s3, a3.TRIANGLES, r3, Mi.disabled, o3, zi.backCCW, u3, c3, "terrain", l3.vertexBuffer, l3.indexBuffer, l3.segments);
        }
      }
      class is {
        constructor(e2, i3) {
          this.context = new Ci(e2), this.transform = i3, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t2.Z(), renderTime: 0 }, this.setup(), this.numSublayers = K2.maxUnderzooming + K2.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Yt();
        }
        resize(t3, e2, i3) {
          if (this.width = Math.floor(t3 * i3), this.height = Math.floor(e2 * i3), this.pixelRatio = i3, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const t4 of this.style._order) this.style._layers[t4].resize();
        }
        setup() {
          const e2 = this.context, i3 = new t2.a_();
          i3.emplaceBack(0, 0), i3.emplaceBack(t2.N, 0), i3.emplaceBack(0, t2.N), i3.emplaceBack(t2.N, t2.N), this.tileExtentBuffer = e2.createVertexBuffer(i3, ae2.members), this.tileExtentSegments = t2.S.simpleSegment(0, 0, 4, 2);
          const s3 = new t2.a_();
          s3.emplaceBack(0, 0), s3.emplaceBack(t2.N, 0), s3.emplaceBack(0, t2.N), s3.emplaceBack(t2.N, t2.N), this.debugBuffer = e2.createVertexBuffer(s3, ae2.members), this.debugSegments = t2.S.simpleSegment(0, 0, 4, 5);
          const a3 = new t2.V();
          a3.emplaceBack(0, 0, 0, 0), a3.emplaceBack(t2.N, 0, t2.N, 0), a3.emplaceBack(0, t2.N, 0, t2.N), a3.emplaceBack(t2.N, t2.N, t2.N, t2.N), this.rasterBoundsBuffer = e2.createVertexBuffer(a3, O2.members), this.rasterBoundsSegments = t2.S.simpleSegment(0, 0, 4, 2);
          const o3 = new t2.a_();
          o3.emplaceBack(0, 0), o3.emplaceBack(1, 0), o3.emplaceBack(0, 1), o3.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(o3, ae2.members), this.viewportSegments = t2.S.simpleSegment(0, 0, 4, 2);
          const r3 = new t2.a$();
          r3.emplaceBack(0), r3.emplaceBack(1), r3.emplaceBack(3), r3.emplaceBack(2), r3.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(r3);
          const n3 = new t2.b0();
          n3.emplaceBack(0, 1, 2), n3.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(n3);
          const l3 = this.context.gl;
          this.stencilClearMode = new Mi({ func: l3.ALWAYS, mask: 0 }, 0, 255, l3.ZERO, l3.ZERO, l3.ZERO);
        }
        clearStencil() {
          const e2 = this.context, i3 = e2.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          const s3 = t2.Z();
          t2.aS(s3, 0, this.width, this.height, 0, 0, 1), t2.a0(s3, s3, [i3.drawingBufferWidth, i3.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e2, i3.TRIANGLES, Pi.disabled, this.stencilClearMode, Si.disabled, zi.disabled, be2(s3), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(t3, e2) {
          if (this.currentStencilSource === t3.source || !t3.isTileClipped() || !e2 || !e2.length) return;
          this.currentStencilSource = t3.source;
          const i3 = this.context, s3 = i3.gl;
          this.nextStencilID + e2.length > 256 && this.clearStencil(), i3.setColorMode(Si.disabled), i3.setDepthMode(Pi.disabled);
          const a3 = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const t4 of e2) {
            const e3 = this._tileClippingMaskIDs[t4.key] = this.nextStencilID++, o3 = this.style.map.terrain && this.style.map.terrain.getTerrainData(t4);
            a3.draw(i3, s3.TRIANGLES, Pi.disabled, new Mi({ func: s3.ALWAYS, mask: 0 }, e3, 255, s3.KEEP, s3.KEEP, s3.REPLACE), Si.disabled, zi.disabled, be2(t4.posMatrix), o3, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const t3 = this.nextStencilID++, e2 = this.context.gl;
          return new Mi({ func: e2.NOTEQUAL, mask: 255 }, t3, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
        }
        stencilModeForClipping(t3) {
          const e2 = this.context.gl;
          return new Mi({ func: e2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t3.key], 0, e2.KEEP, e2.KEEP, e2.REPLACE);
        }
        stencilConfigForOverlap(t3) {
          const e2 = this.context.gl, i3 = t3.sort((t4, e3) => e3.overscaledZ - t4.overscaledZ), s3 = i3[i3.length - 1].overscaledZ, a3 = i3[0].overscaledZ - s3 + 1;
          if (a3 > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + a3 > 256 && this.clearStencil();
            const t4 = {};
            for (let i4 = 0; i4 < a3; i4++) t4[i4 + s3] = new Mi({ func: e2.GEQUAL, mask: 255 }, i4 + this.nextStencilID, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
            return this.nextStencilID += a3, [t4, i3];
          }
          return [{ [s3]: Mi.disabled }, i3];
        }
        colorModeForRenderPass() {
          const e2 = this.context.gl;
          if (this._showOverdrawInspector) {
            const i3 = 1 / 8;
            return new Si([e2.CONSTANT_COLOR, e2.ONE], new t2.aT(i3, i3, i3, 0), [true, true, true, true]);
          }
          return "opaque" === this.renderPass ? Si.unblended : Si.alphaBlended;
        }
        depthModeForSublayer(t3, e2, i3) {
          if (!this.opaquePassEnabledForLayer()) return Pi.disabled;
          const s3 = 1 - ((1 + this.currentLayer) * this.numSublayers + t3) * this.depthEpsilon;
          return new Pi(i3 || this.context.gl.LEQUAL, e2, [s3, s3]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(e2, i3) {
          this.style = e2, this.options = i3, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(t2.h.now()), this.imageManager.beginFrame();
          const s3 = this.style._order, a3 = this.style.sourceCaches, o3 = {}, r3 = {}, n3 = {};
          for (const t3 in a3) {
            const e3 = a3[t3];
            e3.used && e3.prepare(this.context), o3[t3] = e3.getVisibleCoordinates(), r3[t3] = o3[t3].slice().reverse(), n3[t3] = e3.getVisibleCoordinates(true).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let t3 = 0; t3 < s3.length; t3++) if (this.style._layers[s3[t3]].is3D()) {
            this.opaquePassCutoff = t3;
            break;
          }
          if (this.renderToTexture) {
            this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0;
            const e3 = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime);
            (this.terrainFacilitator.dirty || !t2.b1(this.terrainFacilitator.matrix, this.transform.projMatrix) || e3.length) && (t2.b2(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(e4, i4) {
              const s4 = e4.context, a4 = s4.gl, o4 = Si.unblended, r4 = new Pi(a4.LEQUAL, Pi.ReadWrite, [0, 1]), n4 = i4.getTerrainMesh(), l3 = i4.sourceCache.getRenderableTiles(), h3 = e4.useProgram("terrainDepth");
              s4.bindFramebuffer.set(i4.getFramebuffer("depth").framebuffer), s4.viewport.set([0, 0, e4.width / devicePixelRatio, e4.height / devicePixelRatio]), s4.clear({ color: t2.aT.transparent, depth: 1 });
              for (const t3 of l3) {
                const l4 = i4.getTerrainData(t3.tileID), c3 = { u_matrix: e4.transform.calculatePosMatrix(t3.tileID.toUnwrapped()), u_ele_delta: i4.getMeshFrameDelta(e4.transform.zoom) };
                h3.draw(s4, a4.TRIANGLES, r4, Mi.disabled, o4, zi.backCCW, c3, l4, "terrain", n4.vertexBuffer, n4.indexBuffer, n4.segments);
              }
              s4.bindFramebuffer.set(null), s4.viewport.set([0, 0, e4.width, e4.height]);
            }(this, this.style.map.terrain), function(e4, i4) {
              const s4 = e4.context, a4 = s4.gl, o4 = Si.unblended, r4 = new Pi(a4.LEQUAL, Pi.ReadWrite, [0, 1]), n4 = i4.getTerrainMesh(), l3 = i4.getCoordsTexture(), h3 = i4.sourceCache.getRenderableTiles(), c3 = e4.useProgram("terrainCoords");
              s4.bindFramebuffer.set(i4.getFramebuffer("coords").framebuffer), s4.viewport.set([0, 0, e4.width / devicePixelRatio, e4.height / devicePixelRatio]), s4.clear({ color: t2.aT.transparent, depth: 1 }), i4.coordsIndex = [];
              for (const t3 of h3) {
                const h4 = i4.getTerrainData(t3.tileID);
                s4.activeTexture.set(a4.TEXTURE0), a4.bindTexture(a4.TEXTURE_2D, l3.texture);
                const u3 = { u_matrix: e4.transform.calculatePosMatrix(t3.tileID.toUnwrapped()), u_terrain_coords_id: (255 - i4.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i4.getMeshFrameDelta(e4.transform.zoom) };
                c3.draw(s4, a4.TRIANGLES, r4, Mi.disabled, o4, zi.backCCW, u3, h4, "terrain", n4.vertexBuffer, n4.indexBuffer, n4.segments), i4.coordsIndex.push(t3.tileID.key);
              }
              s4.bindFramebuffer.set(null), s4.viewport.set([0, 0, e4.width, e4.height]);
            }(this, this.style.map.terrain));
          }
          this.renderPass = "offscreen";
          for (const t3 of s3) {
            const e3 = this.style._layers[t3];
            if (!e3.hasOffscreenPass() || e3.isHidden(this.transform.zoom)) continue;
            const i4 = r3[e3.source];
            ("custom" === e3.type || i4.length) && this.renderLayer(this, a3[e3.source], e3, i4);
          }
          if (this.context.bindFramebuffer.set(null), this.context.clear({ color: i3.showOverdrawInspector ? t2.aT.black : t2.aT.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i3.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e2._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = s3.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const t3 = this.style._layers[s3[this.currentLayer]], e3 = a3[t3.source], i4 = o3[t3.source];
            this._renderTileClippingMasks(t3, i4), this.renderLayer(this, e3, t3, i4);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < s3.length; this.currentLayer++) {
            const t3 = this.style._layers[s3[this.currentLayer]], e3 = a3[t3.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(t3)) continue;
            const i4 = ("symbol" === t3.type ? n3 : r3)[t3.source];
            this._renderTileClippingMasks(t3, o3[t3.source]), this.renderLayer(this, e3, t3, i4);
          }
          if (this.options.showTileBoundaries) {
            const t3 = function(t4, e3) {
              let i4 = null;
              const s4 = Object.values(t4._layers).flatMap((i5) => i5.source && !i5.isHidden(e3) ? [t4.sourceCaches[i5.source]] : []), a4 = s4.filter((t5) => "vector" === t5.getSource().type), o4 = s4.filter((t5) => "vector" !== t5.getSource().type), r4 = (t5) => {
                (!i4 || i4.getSource().maxzoom < t5.getSource().maxzoom) && (i4 = t5);
              };
              return a4.forEach((t5) => r4(t5)), i4 || o4.forEach((t5) => r4(t5)), i4;
            }(this.style, this.transform.zoom);
            t3 && function(t4, e3, i4) {
              for (let s4 = 0; s4 < i4.length; s4++) ts(t4, e3, i4[s4]);
            }(this, t3, t3.getVisibleCoordinates());
          }
          this.options.showPadding && function(t3) {
            const e3 = t3.transform.padding;
            Qi(t3, t3.transform.height - (e3.top || 0), 3, $i), Qi(t3, e3.bottom || 0, 3, Wi), Yi(t3, e3.left || 0, 3, Hi), Yi(t3, t3.transform.width - (e3.right || 0), 3, Xi);
            const i4 = t3.transform.centerPoint;
            !function(t4, e4, i5, s4) {
              Ji(t4, e4 - 1, i5 - 10, 2, 20, s4), Ji(t4, e4 - 10, i5 - 1, 20, 2, s4);
            }(t3, i4.x, t3.transform.height - i4.y, Ki);
          }(this), this.context.setDefault();
        }
        renderLayer(e2, i3, s3, a3) {
          if (!s3.isHidden(this.transform.zoom) && ("background" === s3.type || "custom" === s3.type || (a3 || []).length)) switch (this.id = s3.id, s3.type) {
            case "symbol":
              !function(e3, i4, s4, a4, o3) {
                if ("translucent" !== e3.renderPass) return;
                const r3 = Mi.disabled, n3 = e3.colorModeForRenderPass();
                (s4._unevaluatedLayout.hasValue("text-variable-anchor") || s4._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e4, i5, s5, a5, o4, r4, n4) {
                  const l3 = i5.transform, h3 = "map" === o4, c3 = "map" === r4;
                  for (const o5 of e4) {
                    const e5 = a5.getTile(o5), r5 = e5.getBucket(s5);
                    if (!r5 || !r5.text || !r5.text.segments.get().length) continue;
                    const u3 = t2.ah(r5.textSizeData, l3.zoom), d3 = St(e5, 1, i5.transform.zoom), _3 = nt(o5.posMatrix, c3, h3, i5.transform, d3), p3 = "none" !== s5.layout.get("icon-text-fit") && r5.hasIconData();
                    if (u3) {
                      const t3 = Math.pow(2, l3.zoom - e5.tileID.overscaledZ);
                      Fi(r5, h3, c3, n4, l3, _3, o5.posMatrix, t3, u3, p3, i5.style.map.terrain ? (t4, e6) => i5.style.map.terrain.getElevation(o5, t4, e6) : null);
                    }
                  }
                }(a4, e3, s4, i4, s4.layout.get("text-rotation-alignment"), s4.layout.get("text-pitch-alignment"), o3), 0 !== s4.paint.get("icon-opacity").constantOr(1) && Oi(e3, i4, s4, a4, false, s4.paint.get("icon-translate"), s4.paint.get("icon-translate-anchor"), s4.layout.get("icon-rotation-alignment"), s4.layout.get("icon-pitch-alignment"), s4.layout.get("icon-keep-upright"), r3, n3), 0 !== s4.paint.get("text-opacity").constantOr(1) && Oi(e3, i4, s4, a4, true, s4.paint.get("text-translate"), s4.paint.get("text-translate-anchor"), s4.layout.get("text-rotation-alignment"), s4.layout.get("text-pitch-alignment"), s4.layout.get("text-keep-upright"), r3, n3), i4.map.showCollisionBoxes && (Ai(e3, i4, s4, a4, s4.paint.get("text-translate"), s4.paint.get("text-translate-anchor"), true), Ai(e3, i4, s4, a4, s4.paint.get("icon-translate"), s4.paint.get("icon-translate-anchor"), false));
              }(e2, i3, s3, a3, this.style.placement.variableOffsets);
              break;
            case "circle":
              !function(e3, i4, s4, a4) {
                if ("translucent" !== e3.renderPass) return;
                const o3 = s4.paint.get("circle-opacity"), r3 = s4.paint.get("circle-stroke-width"), n3 = s4.paint.get("circle-stroke-opacity"), l3 = !s4.layout.get("circle-sort-key").isConstant();
                if (0 === o3.constantOr(1) && (0 === r3.constantOr(1) || 0 === n3.constantOr(1))) return;
                const h3 = e3.context, c3 = h3.gl, u3 = e3.depthModeForSublayer(0, Pi.ReadOnly), d3 = Mi.disabled, _3 = e3.colorModeForRenderPass(), p3 = [];
                for (let o4 = 0; o4 < a4.length; o4++) {
                  const r4 = a4[o4], n4 = i4.getTile(r4), h4 = n4.getBucket(s4);
                  if (!h4) continue;
                  const c4 = h4.programConfigurations.get(s4.id), u4 = e3.useProgram("circle", c4), d4 = h4.layoutVertexBuffer, _4 = h4.indexBuffer, m3 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(r4), f3 = { programConfiguration: c4, program: u4, layoutVertexBuffer: d4, indexBuffer: _4, uniformValues: ve2(e3, r4, n4, s4), terrainData: m3 };
                  if (l3) {
                    const e4 = h4.segments.get();
                    for (const i5 of e4) p3.push({ segments: new t2.S([i5]), sortKey: i5.sortKey, state: f3 });
                  } else p3.push({ segments: h4.segments, sortKey: 0, state: f3 });
                }
                l3 && p3.sort((t3, e4) => t3.sortKey - e4.sortKey);
                for (const t3 of p3) {
                  const { programConfiguration: i5, program: a5, layoutVertexBuffer: o4, indexBuffer: r4, uniformValues: n4, terrainData: l4 } = t3.state;
                  a5.draw(h3, c3.TRIANGLES, u3, d3, _3, zi.disabled, n4, l4, s4.id, o4, r4, t3.segments, s4.paint, e3.transform.zoom, i5);
                }
              }(e2, i3, s3, a3);
              break;
            case "heatmap":
              !function(e3, i4, s4, a4) {
                if (0 !== s4.paint.get("heatmap-opacity")) if ("offscreen" === e3.renderPass) {
                  const o3 = e3.context, r3 = o3.gl, n3 = Mi.disabled, l3 = new Si([r3.ONE, r3.ONE], t2.aT.transparent, [true, true, true, true]);
                  !function(t3, e4, i5) {
                    const s5 = t3.gl;
                    t3.activeTexture.set(s5.TEXTURE1), t3.viewport.set([0, 0, e4.width / 4, e4.height / 4]);
                    let a5 = i5.heatmapFbo;
                    if (a5) s5.bindTexture(s5.TEXTURE_2D, a5.colorAttachment.get()), t3.bindFramebuffer.set(a5.framebuffer);
                    else {
                      const o4 = s5.createTexture();
                      s5.bindTexture(s5.TEXTURE_2D, o4), s5.texParameteri(s5.TEXTURE_2D, s5.TEXTURE_WRAP_S, s5.CLAMP_TO_EDGE), s5.texParameteri(s5.TEXTURE_2D, s5.TEXTURE_WRAP_T, s5.CLAMP_TO_EDGE), s5.texParameteri(s5.TEXTURE_2D, s5.TEXTURE_MIN_FILTER, s5.LINEAR), s5.texParameteri(s5.TEXTURE_2D, s5.TEXTURE_MAG_FILTER, s5.LINEAR), a5 = i5.heatmapFbo = t3.createFramebuffer(e4.width / 4, e4.height / 4, false, false), function(t4, e5, i6, s6) {
                        var a6, o5;
                        const r4 = t4.gl, n4 = null !== (a6 = t4.HALF_FLOAT) && void 0 !== a6 ? a6 : r4.UNSIGNED_BYTE, l4 = null !== (o5 = t4.RGBA16F) && void 0 !== o5 ? o5 : r4.RGBA;
                        r4.texImage2D(r4.TEXTURE_2D, 0, l4, e5.width / 4, e5.height / 4, 0, r4.RGBA, n4, null), s6.colorAttachment.set(i6);
                      }(t3, e4, o4, a5);
                    }
                  }(o3, e3, s4), o3.clear({ color: t2.aT.transparent });
                  for (let t3 = 0; t3 < a4.length; t3++) {
                    const h3 = a4[t3];
                    if (i4.hasRenderableParent(h3)) continue;
                    const c3 = i4.getTile(h3), u3 = c3.getBucket(s4);
                    if (!u3) continue;
                    const d3 = u3.programConfigurations.get(s4.id), _3 = e3.useProgram("heatmap", d3), { zoom: p3 } = e3.transform;
                    _3.draw(o3, r3.TRIANGLES, Pi.disabled, n3, l3, zi.disabled, we2(h3.posMatrix, c3, p3, s4.paint.get("heatmap-intensity")), null, s4.id, u3.layoutVertexBuffer, u3.indexBuffer, u3.segments, s4.paint, e3.transform.zoom, d3);
                  }
                  o3.viewport.set([0, 0, e3.width, e3.height]);
                } else "translucent" === e3.renderPass && (e3.context.setColorMode(e3.colorModeForRenderPass()), function(e4, i5) {
                  const s5 = e4.context, a5 = s5.gl, o3 = i5.heatmapFbo;
                  if (!o3) return;
                  s5.activeTexture.set(a5.TEXTURE0), a5.bindTexture(a5.TEXTURE_2D, o3.colorAttachment.get()), s5.activeTexture.set(a5.TEXTURE1);
                  let r3 = i5.colorRampTexture;
                  r3 || (r3 = i5.colorRampTexture = new x2(s5, i5.colorRamp, a5.RGBA)), r3.bind(a5.LINEAR, a5.CLAMP_TO_EDGE), e4.useProgram("heatmapTexture").draw(s5, a5.TRIANGLES, Pi.disabled, Mi.disabled, e4.colorModeForRenderPass(), zi.disabled, ((e5, i6, s6, a6) => {
                    const o4 = t2.Z();
                    t2.aS(o4, 0, e5.width, e5.height, 0, 0, 1);
                    const r4 = e5.context.gl;
                    return { u_matrix: o4, u_world: [r4.drawingBufferWidth, r4.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i6.paint.get("heatmap-opacity") };
                  })(e4, i5), null, i5.id, e4.viewportBuffer, e4.quadTriangleIndexBuffer, e4.viewportSegments, i5.paint, e4.transform.zoom);
                }(e3, s4));
              }(e2, i3, s3, a3);
              break;
            case "line":
              !function(e3, i4, s4, a4) {
                if ("translucent" !== e3.renderPass) return;
                const o3 = s4.paint.get("line-opacity"), r3 = s4.paint.get("line-width");
                if (0 === o3.constantOr(1) || 0 === r3.constantOr(1)) return;
                const n3 = e3.depthModeForSublayer(0, Pi.ReadOnly), l3 = e3.colorModeForRenderPass(), h3 = s4.paint.get("line-dasharray"), c3 = s4.paint.get("line-pattern"), u3 = c3.constantOr(1), d3 = s4.paint.get("line-gradient"), _3 = s4.getCrossfadeParameters(), p3 = u3 ? "linePattern" : h3 ? "lineSDF" : d3 ? "lineGradient" : "line", m3 = e3.context, f3 = m3.gl;
                let g3 = true;
                for (const o4 of a4) {
                  const a5 = i4.getTile(o4);
                  if (u3 && !a5.patternsLoaded()) continue;
                  const r4 = a5.getBucket(s4);
                  if (!r4) continue;
                  const v3 = r4.programConfigurations.get(s4.id), y3 = e3.context.program.get(), b3 = e3.useProgram(p3, v3), w3 = g3 || b3.program !== y3, T3 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(o4), I3 = c3.constantOr(null);
                  if (I3 && a5.imageAtlas) {
                    const t3 = a5.imageAtlas, e4 = t3.patternPositions[I3.to.toString()], i5 = t3.patternPositions[I3.from.toString()];
                    e4 && i5 && v3.setConstantPatternPositions(e4, i5);
                  }
                  const E3 = T3 ? o4 : null, S3 = u3 ? Se2(e3, a5, s4, _3, E3) : h3 ? Ce2(e3, a5, s4, h3, _3, E3) : d3 ? Ee2(e3, a5, s4, r4.lineClipsArray.length, E3) : Ie2(e3, a5, s4, E3);
                  if (u3) m3.activeTexture.set(f3.TEXTURE0), a5.imageAtlasTexture.bind(f3.LINEAR, f3.CLAMP_TO_EDGE), v3.updatePaintBuffers(_3);
                  else if (h3 && (w3 || e3.lineAtlas.dirty)) m3.activeTexture.set(f3.TEXTURE0), e3.lineAtlas.bind(m3);
                  else if (d3) {
                    const a6 = r4.gradients[s4.id];
                    let n4 = a6.texture;
                    if (s4.gradientVersion !== a6.version) {
                      let l4 = 256;
                      if (s4.stepInterpolant) {
                        const s5 = i4.getSource().maxzoom, a7 = o4.canonical.z === s5 ? Math.ceil(1 << e3.transform.maxZoom - o4.canonical.z) : 1;
                        l4 = t2.ad(t2.aY(r4.maxLineLength / t2.N * 1024 * a7), 256, m3.maxTextureSize);
                      }
                      a6.gradient = t2.aZ({ expression: s4.gradientExpression(), evaluationKey: "lineProgress", resolution: l4, image: a6.gradient || void 0, clips: r4.lineClipsArray }), a6.texture ? a6.texture.update(a6.gradient) : a6.texture = new x2(m3, a6.gradient, f3.RGBA), a6.version = s4.gradientVersion, n4 = a6.texture;
                    }
                    m3.activeTexture.set(f3.TEXTURE0), n4.bind(s4.stepInterpolant ? f3.NEAREST : f3.LINEAR, f3.CLAMP_TO_EDGE);
                  }
                  b3.draw(m3, f3.TRIANGLES, n3, e3.stencilModeForClipping(o4), l3, zi.disabled, S3, T3, s4.id, r4.layoutVertexBuffer, r4.indexBuffer, r4.segments, s4.paint, e3.transform.zoom, v3, r4.layoutVertexBuffer2), g3 = false;
                }
              }(e2, i3, s3, a3);
              break;
            case "fill":
              !function(e3, i4, s4, a4) {
                const o3 = s4.paint.get("fill-color"), r3 = s4.paint.get("fill-opacity");
                if (0 === r3.constantOr(1)) return;
                const n3 = e3.colorModeForRenderPass(), l3 = s4.paint.get("fill-pattern"), h3 = e3.opaquePassEnabledForLayer() && !l3.constantOr(1) && 1 === o3.constantOr(t2.aT.transparent).a && 1 === r3.constantOr(0) ? "opaque" : "translucent";
                if (e3.renderPass === h3) {
                  const t3 = e3.depthModeForSublayer(1, "opaque" === e3.renderPass ? Pi.ReadWrite : Pi.ReadOnly);
                  Zi(e3, i4, s4, a4, t3, n3, false);
                }
                if ("translucent" === e3.renderPass && s4.paint.get("fill-antialias")) {
                  const t3 = e3.depthModeForSublayer(s4.getPaintProperty("fill-outline-color") ? 2 : 0, Pi.ReadOnly);
                  Zi(e3, i4, s4, a4, t3, n3, true);
                }
              }(e2, i3, s3, a3);
              break;
            case "fill-extrusion":
              !function(t3, e3, i4, s4) {
                const a4 = i4.paint.get("fill-extrusion-opacity");
                if (0 !== a4 && "translucent" === t3.renderPass) {
                  const o3 = new Pi(t3.context.gl.LEQUAL, Pi.ReadWrite, t3.depthRangeFor3D);
                  if (1 !== a4 || i4.paint.get("fill-extrusion-pattern").constantOr(1)) Gi(t3, e3, i4, s4, o3, Mi.disabled, Si.disabled), Gi(t3, e3, i4, s4, o3, t3.stencilModeFor3D(), t3.colorModeForRenderPass());
                  else {
                    const a5 = t3.colorModeForRenderPass();
                    Gi(t3, e3, i4, s4, o3, Mi.disabled, a5);
                  }
                }
              }(e2, i3, s3, a3);
              break;
            case "hillshade":
              !function(t3, e3, i4, s4) {
                if ("offscreen" !== t3.renderPass && "translucent" !== t3.renderPass) return;
                const a4 = t3.context, o3 = t3.depthModeForSublayer(0, Pi.ReadOnly), r3 = t3.colorModeForRenderPass(), [n3, l3] = "translucent" === t3.renderPass ? t3.stencilConfigForOverlap(s4) : [{}, s4];
                for (const s5 of l3) {
                  const a5 = e3.getTile(s5);
                  void 0 !== a5.needsHillshadePrepare && a5.needsHillshadePrepare && "offscreen" === t3.renderPass ? Vi(t3, a5, i4, o3, Mi.disabled, r3) : "translucent" === t3.renderPass && ji(t3, s5, a5, i4, o3, n3[s5.overscaledZ], r3);
                }
                a4.viewport.set([0, 0, t3.width, t3.height]);
              }(e2, i3, s3, a3);
              break;
            case "raster":
              !function(t3, e3, i4, s4) {
                if ("translucent" !== t3.renderPass) return;
                if (0 === i4.paint.get("raster-opacity")) return;
                if (!s4.length) return;
                const a4 = t3.context, o3 = a4.gl, r3 = e3.getSource(), n3 = t3.useProgram("raster"), l3 = t3.colorModeForRenderPass(), [h3, c3] = r3 instanceof N2 ? [{}, s4] : t3.stencilConfigForOverlap(s4), u3 = c3[c3.length - 1].overscaledZ, d3 = !t3.options.moving;
                for (const s5 of c3) {
                  const c4 = t3.depthModeForSublayer(s5.overscaledZ - u3, 1 === i4.paint.get("raster-opacity") ? Pi.ReadWrite : Pi.ReadOnly, o3.LESS), _3 = e3.getTile(s5);
                  _3.registerFadeDuration(i4.paint.get("raster-fade-duration"));
                  const p3 = e3.findLoadedParent(s5, 0), m3 = qi(_3, p3, e3, i4, t3.transform, t3.style.map.terrain);
                  let f3, g3;
                  const v3 = "nearest" === i4.paint.get("raster-resampling") ? o3.NEAREST : o3.LINEAR;
                  a4.activeTexture.set(o3.TEXTURE0), _3.texture.bind(v3, o3.CLAMP_TO_EDGE, o3.LINEAR_MIPMAP_NEAREST), a4.activeTexture.set(o3.TEXTURE1), p3 ? (p3.texture.bind(v3, o3.CLAMP_TO_EDGE, o3.LINEAR_MIPMAP_NEAREST), f3 = Math.pow(2, p3.tileID.overscaledZ - _3.tileID.overscaledZ), g3 = [_3.tileID.canonical.x * f3 % 1, _3.tileID.canonical.y * f3 % 1]) : _3.texture.bind(v3, o3.CLAMP_TO_EDGE, o3.LINEAR_MIPMAP_NEAREST);
                  const x3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(s5), y3 = x3 ? s5 : null, b3 = y3 ? y3.posMatrix : t3.transform.calculatePosMatrix(s5.toUnwrapped(), d3), w3 = Me2(b3, g3 || [0, 0], f3 || 1, m3, i4);
                  r3 instanceof N2 ? n3.draw(a4, o3.TRIANGLES, c4, Mi.disabled, l3, zi.disabled, w3, x3, i4.id, r3.boundsBuffer, t3.quadTriangleIndexBuffer, r3.boundsSegments) : n3.draw(a4, o3.TRIANGLES, c4, h3[s5.overscaledZ], l3, zi.disabled, w3, x3, i4.id, t3.rasterBoundsBuffer, t3.quadTriangleIndexBuffer, t3.rasterBoundsSegments);
                }
              }(e2, i3, s3, a3);
              break;
            case "background":
              !function(t3, e3, i4, s4) {
                const a4 = i4.paint.get("background-color"), o3 = i4.paint.get("background-opacity");
                if (0 === o3) return;
                const r3 = t3.context, n3 = r3.gl, l3 = t3.transform, h3 = l3.tileSize, c3 = i4.paint.get("background-pattern");
                if (t3.isPatternMissing(c3)) return;
                const u3 = !c3 && 1 === a4.a && 1 === o3 && t3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (t3.renderPass !== u3) return;
                const d3 = Mi.disabled, _3 = t3.depthModeForSublayer(0, "opaque" === u3 ? Pi.ReadWrite : Pi.ReadOnly), p3 = t3.colorModeForRenderPass(), m3 = t3.useProgram(c3 ? "backgroundPattern" : "background"), f3 = s4 || l3.coveringTiles({ tileSize: h3, terrain: t3.style.map.terrain });
                c3 && (r3.activeTexture.set(n3.TEXTURE0), t3.imageManager.bind(t3.context));
                const g3 = i4.getCrossfadeParameters();
                for (const e4 of f3) {
                  const l4 = s4 ? e4.posMatrix : t3.transform.calculatePosMatrix(e4.toUnwrapped()), u4 = c3 ? Fe2(l4, o3, t3, c3, { tileID: e4, tileSize: h3 }, g3) : ke2(l4, o3, a4), f4 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(e4);
                  m3.draw(r3, n3.TRIANGLES, _3, d3, p3, zi.disabled, u4, f4, i4.id, t3.tileExtentBuffer, t3.quadTriangleIndexBuffer, t3.tileExtentSegments);
                }
              }(e2, 0, s3, a3);
              break;
            case "custom":
              !function(t3, e3, i4) {
                const s4 = t3.context, a4 = i4.implementation;
                if ("offscreen" === t3.renderPass) {
                  const e4 = a4.prerender;
                  e4 && (t3.setCustomLayerDefaults(), s4.setColorMode(t3.colorModeForRenderPass()), e4.call(a4, s4.gl, t3.transform.customLayerMatrix()), s4.setDirty(), t3.setBaseState());
                } else if ("translucent" === t3.renderPass) {
                  t3.setCustomLayerDefaults(), s4.setColorMode(t3.colorModeForRenderPass()), s4.setStencilMode(Mi.disabled);
                  const e4 = "3d" === a4.renderingMode ? new Pi(t3.context.gl.LEQUAL, Pi.ReadWrite, t3.depthRangeFor3D) : t3.depthModeForSublayer(0, Pi.ReadOnly);
                  s4.setDepthMode(e4), a4.render(s4.gl, t3.transform.customLayerMatrix()), s4.setDirty(), t3.setBaseState(), s4.bindFramebuffer.set(null);
                }
              }(e2, 0, s3);
          }
        }
        translatePosMatrix(e2, i3, s3, a3, o3) {
          if (!s3[0] && !s3[1]) return e2;
          const r3 = o3 ? "map" === a3 ? this.transform.angle : 0 : "viewport" === a3 ? -this.transform.angle : 0;
          if (r3) {
            const t3 = Math.sin(r3), e3 = Math.cos(r3);
            s3 = [s3[0] * e3 - s3[1] * t3, s3[0] * t3 + s3[1] * e3];
          }
          const n3 = [o3 ? s3[0] : St(i3, s3[0], this.transform.zoom), o3 ? s3[1] : St(i3, s3[1], this.transform.zoom), 0], l3 = new Float32Array(16);
          return t2.$(l3, e2, n3), l3;
        }
        saveTileTexture(t3) {
          const e2 = this._tileTextures[t3.size[0]];
          e2 ? e2.push(t3) : this._tileTextures[t3.size[0]] = [t3];
        }
        getTileTexture(t3) {
          const e2 = this._tileTextures[t3];
          return e2 && e2.length > 0 ? e2.pop() : null;
        }
        isPatternMissing(t3) {
          if (!t3) return false;
          if (!t3.from || !t3.to) return true;
          const e2 = this.imageManager.getPattern(t3.from.toString()), i3 = this.imageManager.getPattern(t3.to.toString());
          return !e2 || !i3;
        }
        useProgram(t3, e2) {
          this.cache = this.cache || {};
          const i3 = t3 + (e2 ? e2.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
          return this.cache[i3] || (this.cache[i3] = new ce2(this.context, re2[t3], e2, Be2[t3], this._showOverdrawInspector, this.style.map.terrain)), this.cache[i3];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const t3 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t3.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new x2(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: t3, drawingBufferHeight: e2 } = this.context.gl;
          return this.width !== t3 || this.height !== e2;
        }
      }
      class ss2 {
        constructor(t3, e2) {
          this.points = t3, this.planes = e2;
        }
        static fromInvProjectionMatrix(e2, i3, s3) {
          const a3 = Math.pow(2, s3), o3 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((s4) => {
            const o4 = 1 / (s4 = t2.ag([], s4, e2))[3] / i3 * a3;
            return t2.b3(s4, s4, [o4, o4, 1 / s4[3], o4]);
          }), r3 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
            const e3 = function(t4, e4) {
              var i5 = e4[0], s5 = e4[1], a5 = e4[2], o4 = i5 * i5 + s5 * s5 + a5 * a5;
              return o4 > 0 && (o4 = 1 / Math.sqrt(o4)), t4[0] = e4[0] * o4, t4[1] = e4[1] * o4, t4[2] = e4[2] * o4, t4;
            }([], function(t4, e4, i5) {
              var s5 = e4[0], a5 = e4[1], o4 = e4[2], r4 = i5[0], n3 = i5[1], l3 = i5[2];
              return t4[0] = a5 * l3 - o4 * n3, t4[1] = o4 * r4 - s5 * l3, t4[2] = s5 * n3 - a5 * r4, t4;
            }([], m2([], o3[t3[0]], o3[t3[1]]), m2([], o3[t3[2]], o3[t3[1]]))), i4 = -((s4 = e3)[0] * (a4 = o3[t3[1]])[0] + s4[1] * a4[1] + s4[2] * a4[2]);
            var s4, a4;
            return e3.concat(i4);
          });
          return new ss2(o3, r3);
        }
      }
      class as {
        constructor(t3, e2) {
          this.min = t3, this.max = e2, this.center = function(t4, e3, i3) {
            return t4[0] = 0.5 * e3[0], t4[1] = 0.5 * e3[1], t4[2] = 0.5 * e3[2], t4;
          }([], function(t4, e3, i3) {
            return t4[0] = e3[0] + i3[0], t4[1] = e3[1] + i3[1], t4[2] = e3[2] + i3[2], t4;
          }([], this.min, this.max));
        }
        quadrant(t3) {
          const e2 = [t3 % 2 == 0, t3 < 2], i3 = _2(this.min), s3 = _2(this.max);
          for (let t4 = 0; t4 < e2.length; t4++) i3[t4] = e2[t4] ? this.min[t4] : this.center[t4], s3[t4] = e2[t4] ? this.center[t4] : this.max[t4];
          return s3[2] = this.max[2], new as(i3, s3);
        }
        distanceX(t3) {
          return Math.max(Math.min(this.max[0], t3[0]), this.min[0]) - t3[0];
        }
        distanceY(t3) {
          return Math.max(Math.min(this.max[1], t3[1]), this.min[1]) - t3[1];
        }
        intersects(e2) {
          const i3 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
          let s3 = true;
          for (let a3 = 0; a3 < e2.planes.length; a3++) {
            const o3 = e2.planes[a3];
            let r3 = 0;
            for (let e3 = 0; e3 < i3.length; e3++) t2.b4(o3, i3[e3]) >= 0 && r3++;
            if (0 === r3) return 0;
            r3 !== i3.length && (s3 = false);
          }
          if (s3) return 2;
          for (let t3 = 0; t3 < 3; t3++) {
            let i4 = Number.MAX_VALUE, s4 = -Number.MAX_VALUE;
            for (let a3 = 0; a3 < e2.points.length; a3++) {
              const o3 = e2.points[a3][t3] - this.min[t3];
              i4 = Math.min(i4, o3), s4 = Math.max(s4, o3);
            }
            if (s4 < 0 || i4 > this.max[t3] - this.min[t3]) return 0;
          }
          return 1;
        }
      }
      class os {
        constructor(t3 = 0, e2 = 0, i3 = 0, s3 = 0) {
          if (isNaN(t3) || t3 < 0 || isNaN(e2) || e2 < 0 || isNaN(i3) || i3 < 0 || isNaN(s3) || s3 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = t3, this.bottom = e2, this.left = i3, this.right = s3;
        }
        interpolate(e2, i3, s3) {
          return null != i3.top && null != e2.top && (this.top = t2.B.number(e2.top, i3.top, s3)), null != i3.bottom && null != e2.bottom && (this.bottom = t2.B.number(e2.bottom, i3.bottom, s3)), null != i3.left && null != e2.left && (this.left = t2.B.number(e2.left, i3.left, s3)), null != i3.right && null != e2.right && (this.right = t2.B.number(e2.right, i3.right, s3)), this;
        }
        getCenter(e2, i3) {
          const s3 = t2.ad((this.left + e2 - this.right) / 2, 0, e2), a3 = t2.ad((this.top + i3 - this.bottom) / 2, 0, i3);
          return new t2.P(s3, a3);
        }
        equals(t3) {
          return this.top === t3.top && this.bottom === t3.bottom && this.left === t3.left && this.right === t3.right;
        }
        clone() {
          return new os(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      class rs {
        constructor(e2, i3, s3, a3, o3) {
          this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === o3 || !!o3, this._minZoom = e2 || 0, this._maxZoom = i3 || 22, this._minPitch = null == s3 ? 0 : s3, this._maxPitch = null == a3 ? 60 : a3, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t2.L(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new os(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._minEleveationForCurrentTile = 0;
        }
        clone() {
          const t3 = new rs(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return t3.apply(this), t3;
        }
        apply(t3) {
          this.tileSize = t3.tileSize, this.latRange = t3.latRange, this.width = t3.width, this.height = t3.height, this._center = t3._center, this._elevation = t3._elevation, this._minEleveationForCurrentTile = t3._minEleveationForCurrentTile, this.zoom = t3.zoom, this.angle = t3.angle, this._fov = t3._fov, this._pitch = t3._pitch, this._unmodified = t3._unmodified, this._edgeInsets = t3._edgeInsets.clone(), this._calcMatrices();
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(t3) {
          this._minZoom !== t3 && (this._minZoom = t3, this.zoom = Math.max(this.zoom, t3));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(t3) {
          this._maxZoom !== t3 && (this._maxZoom = t3, this.zoom = Math.min(this.zoom, t3));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(t3) {
          this._minPitch !== t3 && (this._minPitch = t3, this.pitch = Math.max(this.pitch, t3));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(t3) {
          this._maxPitch !== t3 && (this._maxPitch = t3, this.pitch = Math.min(this.pitch, t3));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(t3) {
          void 0 === t3 ? t3 = true : null === t3 && (t3 = false), this._renderWorldCopies = t3;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new t2.P(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(e2) {
          const i3 = -t2.b5(e2, -180, 180) * Math.PI / 180;
          this.angle !== i3 && (this._unmodified = false, this.angle = i3, this._calcMatrices(), this.rotationMatrix = function() {
            var e3 = new t2.A(4);
            return t2.A != Float32Array && (e3[1] = 0, e3[2] = 0), e3[0] = 1, e3[3] = 1, e3;
          }(), function(t3, e3, i4) {
            var s3 = e3[0], a3 = e3[1], o3 = e3[2], r3 = e3[3], n3 = Math.sin(i4), l3 = Math.cos(i4);
            t3[0] = s3 * l3 + o3 * n3, t3[1] = a3 * l3 + r3 * n3, t3[2] = s3 * -n3 + o3 * l3, t3[3] = a3 * -n3 + r3 * l3;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(e2) {
          const i3 = t2.ad(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== i3 && (this._unmodified = false, this._pitch = i3, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(t3) {
          t3 = Math.max(0.01, Math.min(60, t3)), this._fov !== t3 && (this._unmodified = false, this._fov = t3 / 180 * Math.PI, this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(t3) {
          const e2 = Math.min(Math.max(t3, this.minZoom), this.maxZoom);
          this._zoom !== e2 && (this._unmodified = false, this._zoom = e2, this.tileZoom = Math.max(0, Math.floor(e2)), this.scale = this.zoomScale(e2), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        set center(t3) {
          t3.lat === this._center.lat && t3.lng === this._center.lng || (this._unmodified = false, this._center = t3, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(t3) {
          t3 !== this._elevation && (this._elevation = t3, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(t3) {
          this._edgeInsets.equals(t3) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t3, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        isPaddingEqual(t3) {
          return this._edgeInsets.equals(t3);
        }
        interpolatePadding(t3, e2, i3) {
          this._unmodified = false, this._edgeInsets.interpolate(t3, e2, i3), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(t3) {
          const e2 = (t3.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t3.tileSize));
          return Math.max(0, e2);
        }
        getVisibleUnwrappedCoordinates(e2) {
          const i3 = [new t2.b6(0, e2)];
          if (this._renderWorldCopies) {
            const s3 = this.pointCoordinate(new t2.P(0, 0)), a3 = this.pointCoordinate(new t2.P(this.width, 0)), o3 = this.pointCoordinate(new t2.P(this.width, this.height)), r3 = this.pointCoordinate(new t2.P(0, this.height)), n3 = Math.floor(Math.min(s3.x, a3.x, o3.x, r3.x)), l3 = Math.floor(Math.max(s3.x, a3.x, o3.x, r3.x)), h3 = 1;
            for (let s4 = n3 - h3; s4 <= l3 + h3; s4++) 0 !== s4 && i3.push(new t2.b6(s4, e2));
          }
          return i3;
        }
        coveringTiles(e2) {
          var i3, s3;
          let a3 = this.coveringZoomLevel(e2);
          const o3 = a3;
          if (void 0 !== e2.minzoom && a3 < e2.minzoom) return [];
          void 0 !== e2.maxzoom && a3 > e2.maxzoom && (a3 = e2.maxzoom);
          const r3 = this.pointCoordinate(this.getCameraPoint()), n3 = t2.U.fromLngLat(this.center), l3 = Math.pow(2, a3), h3 = [l3 * r3.x, l3 * r3.y, 0], c3 = [l3 * n3.x, l3 * n3.y, 0], u3 = ss2.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, a3);
          let d3 = e2.minzoom || 0;
          !e2.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (d3 = a3);
          const _3 = e2.terrain ? 2 / Math.min(this.tileSize, e2.tileSize) * this.tileSize : 3, p3 = (t3) => ({ aabb: new as([t3 * l3, 0, 0], [(t3 + 1) * l3, l3, 0]), zoom: 0, x: 0, y: 0, wrap: t3, fullyVisible: false }), m3 = [], g3 = [], v3 = a3, x3 = e2.reparseOverscaled ? o3 : a3;
          if (this._renderWorldCopies) for (let t3 = 1; t3 <= 3; t3++) m3.push(p3(-t3)), m3.push(p3(t3));
          for (m3.push(p3(0)); m3.length > 0; ) {
            const a4 = m3.pop(), o4 = a4.x, r4 = a4.y;
            let n4 = a4.fullyVisible;
            if (!n4) {
              const t3 = a4.aabb.intersects(u3);
              if (0 === t3) continue;
              n4 = 2 === t3;
            }
            const l4 = e2.terrain ? h3 : c3, p4 = a4.aabb.distanceX(l4), y3 = a4.aabb.distanceY(l4), b3 = Math.max(Math.abs(p4), Math.abs(y3));
            if (a4.zoom === v3 || b3 > _3 + (1 << v3 - a4.zoom) - 2 && a4.zoom >= d3) {
              const e3 = v3 - a4.zoom, i4 = h3[0] - 0.5 - (o4 << e3), s4 = h3[1] - 0.5 - (r4 << e3);
              g3.push({ tileID: new t2.O(a4.zoom === v3 ? x3 : a4.zoom, a4.wrap, a4.zoom, o4, r4), distanceSq: f2([c3[0] - 0.5 - o4, c3[1] - 0.5 - r4]), tileDistanceToCamera: Math.sqrt(i4 * i4 + s4 * s4) });
            } else for (let l5 = 0; l5 < 4; l5++) {
              const h4 = (o4 << 1) + l5 % 2, c4 = (r4 << 1) + (l5 >> 1), u4 = a4.zoom + 1;
              let d4 = a4.aabb.quadrant(l5);
              if (e2.terrain) {
                const o5 = new t2.O(u4, a4.wrap, u4, h4, c4), r5 = e2.terrain.getMinMaxElevation(o5), n5 = null !== (i3 = r5.minElevation) && void 0 !== i3 ? i3 : this.elevation, l6 = null !== (s3 = r5.maxElevation) && void 0 !== s3 ? s3 : this.elevation;
                d4 = new as([d4.min[0], d4.min[1], n5], [d4.max[0], d4.max[1], l6]);
              }
              m3.push({ aabb: d4, zoom: u4, x: h4, y: c4, wrap: a4.wrap, fullyVisible: n4 });
            }
          }
          return g3.sort((t3, e3) => t3.distanceSq - e3.distanceSq).map((t3) => t3.tileID);
        }
        resize(t3, e2) {
          this.width = t3, this.height = e2, this.pixelsToGLUnits = [2 / t3, -2 / e2], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(t3) {
          return Math.pow(2, t3);
        }
        scaleZoom(t3) {
          return Math.log(t3) / Math.LN2;
        }
        project(e2) {
          const i3 = t2.ad(e2.lat, -this.maxValidLatitude, this.maxValidLatitude);
          return new t2.P(t2.G(e2.lng) * this.worldSize, t2.H(i3) * this.worldSize);
        }
        unproject(e2) {
          return new t2.U(e2.x / this.worldSize, e2.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        getCameraPosition() {
          return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
        }
        recalculateZoom(e2) {
          const i3 = this.pointLocation(this.centerPoint, e2), s3 = e2.getElevationForLngLatZoom(i3, this.tileZoom);
          if (!(this.elevation - s3)) return;
          const a3 = this.getCameraPosition(), o3 = t2.U.fromLngLat(a3.lngLat, a3.altitude), r3 = t2.U.fromLngLat(i3, s3), n3 = o3.x - r3.x, l3 = o3.y - r3.y, h3 = o3.z - r3.z, c3 = Math.sqrt(n3 * n3 + l3 * l3 + h3 * h3), u3 = this.scaleZoom(this.cameraToCenterDistance / c3 / this.tileSize);
          this._elevation = s3, this._center = i3, this.zoom = u3;
        }
        setLocationAtPoint(e2, i3) {
          const s3 = this.pointCoordinate(i3), a3 = this.pointCoordinate(this.centerPoint), o3 = this.locationCoordinate(e2), r3 = new t2.U(o3.x - (s3.x - a3.x), o3.y - (s3.y - a3.y));
          this.center = this.coordinateLocation(r3), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(t3, e2) {
          return e2 ? this.coordinatePoint(this.locationCoordinate(t3), e2.getElevationForLngLatZoom(t3, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t3));
        }
        pointLocation(t3, e2) {
          return this.coordinateLocation(this.pointCoordinate(t3, e2));
        }
        locationCoordinate(e2) {
          return t2.U.fromLngLat(e2);
        }
        coordinateLocation(t3) {
          return t3 && t3.toLngLat();
        }
        pointCoordinate(e2, i3) {
          if (i3) {
            const t3 = i3.pointCoordinate(e2);
            if (null != t3) return t3;
          }
          const s3 = [e2.x, e2.y, 0, 1], a3 = [e2.x, e2.y, 1, 1];
          t2.ag(s3, s3, this.pixelMatrixInverse), t2.ag(a3, a3, this.pixelMatrixInverse);
          const o3 = s3[3], r3 = a3[3], n3 = s3[1] / o3, l3 = a3[1] / r3, h3 = s3[2] / o3, c3 = a3[2] / r3, u3 = h3 === c3 ? 0 : (0 - h3) / (c3 - h3);
          return new t2.U(t2.B.number(s3[0] / o3, a3[0] / r3, u3) / this.worldSize, t2.B.number(n3, l3, u3) / this.worldSize);
        }
        coordinatePoint(e2, i3 = 0, s3 = this.pixelMatrix) {
          const a3 = [e2.x * this.worldSize, e2.y * this.worldSize, i3, 1];
          return t2.ag(a3, a3, s3), new t2.P(a3[0] / a3[3], a3[1] / a3[3]);
        }
        getBounds() {
          const e2 = Math.max(0, this.height / 2 - this.getHorizon());
          return new L2().extend(this.pointLocation(new t2.P(0, e2))).extend(this.pointLocation(new t2.P(this.width, e2))).extend(this.pointLocation(new t2.P(this.width, this.height))).extend(this.pointLocation(new t2.P(0, this.height)));
        }
        getMaxBounds() {
          return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new L2([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        getHorizon() {
          return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
        }
        setMaxBounds(t3) {
          t3 ? (this.lngRange = [t3.getWest(), t3.getEast()], this.latRange = [t3.getSouth(), t3.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
        }
        calculatePosMatrix(e2, i3 = false) {
          const s3 = e2.key, a3 = i3 ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (a3[s3]) return a3[s3];
          const o3 = e2.canonical, r3 = this.worldSize / this.zoomScale(o3.z), n3 = o3.x + Math.pow(2, o3.z) * e2.wrap, l3 = t2.ao(new Float64Array(16));
          return t2.$(l3, l3, [n3 * r3, o3.y * r3, 0]), t2.a0(l3, l3, [r3 / t2.N, r3 / t2.N, 1]), t2.a1(l3, i3 ? this.alignedProjMatrix : this.projMatrix, l3), a3[s3] = new Float32Array(l3), a3[s3];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining) return;
          this._constraining = true;
          let e2, i3, s3, a3, o3 = -90, r3 = 90, n3 = -180, l3 = 180;
          const h3 = this.size, c3 = this._unmodified;
          if (this.latRange) {
            const i4 = this.latRange;
            o3 = t2.H(i4[1]) * this.worldSize, r3 = t2.H(i4[0]) * this.worldSize, e2 = r3 - o3 < h3.y ? h3.y / (r3 - o3) : 0;
          }
          if (this.lngRange) {
            const e3 = this.lngRange;
            n3 = t2.b5(t2.G(e3[0]) * this.worldSize, 0, this.worldSize), l3 = t2.b5(t2.G(e3[1]) * this.worldSize, 0, this.worldSize), l3 < n3 && (l3 += this.worldSize), i3 = l3 - n3 < h3.x ? h3.x / (l3 - n3) : 0;
          }
          const u3 = this.point, d3 = Math.max(i3 || 0, e2 || 0);
          if (d3) return this.center = this.unproject(new t2.P(i3 ? (l3 + n3) / 2 : u3.x, e2 ? (r3 + o3) / 2 : u3.y)), this.zoom += this.scaleZoom(d3), this._unmodified = c3, void (this._constraining = false);
          if (this.latRange) {
            const t3 = u3.y, e3 = h3.y / 2;
            t3 - e3 < o3 && (a3 = o3 + e3), t3 + e3 > r3 && (a3 = r3 - e3);
          }
          if (this.lngRange) {
            const e3 = (n3 + l3) / 2, i4 = t2.b5(u3.x, e3 - this.worldSize / 2, e3 + this.worldSize / 2), a4 = h3.x / 2;
            i4 - a4 < n3 && (s3 = n3 + a4), i4 + a4 > l3 && (s3 = l3 - a4);
          }
          void 0 === s3 && void 0 === a3 || (this.center = this.unproject(new t2.P(void 0 !== s3 ? s3 : u3.x, void 0 !== a3 ? a3 : u3.y)).wrap()), this._unmodified = c3, this._constraining = false;
        }
        _calcMatrices() {
          if (!this.height) return;
          const e2 = this.centerOffset, i3 = this.point.x, s3 = this.point.y;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = t2.b7(1, this.center.lat) * this.worldSize;
          let a3 = t2.ao(new Float64Array(16));
          t2.a0(a3, a3, [this.width / 2, -this.height / 2, 1]), t2.$(a3, a3, [1, -1, 0]), this.labelPlaneMatrix = a3, a3 = t2.ao(new Float64Array(16)), t2.a0(a3, a3, [1, -1, 1]), t2.$(a3, a3, [-1, -1, 0]), t2.a0(a3, a3, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a3;
          const o3 = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), r3 = Math.min(this.elevation, this._minEleveationForCurrentTile), n3 = o3 - r3 * this._pixelPerMeter / Math.cos(this._pitch), l3 = r3 < 0 ? n3 : o3, h3 = Math.PI / 2 + this._pitch, c3 = this._fov * (0.5 + e2.y / this.height), u3 = Math.sin(c3) * l3 / Math.sin(t2.ad(Math.PI - h3 - c3, 0.01, Math.PI - 0.01)), d3 = this.getHorizon(), _3 = 2 * Math.atan(d3 / this.cameraToCenterDistance) * (0.5 + e2.y / (2 * d3)), p3 = Math.sin(_3) * l3 / Math.sin(t2.ad(Math.PI - h3 - _3, 0.01, Math.PI - 0.01)), m3 = Math.min(u3, p3), f3 = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * m3 + l3), g3 = this.height / 50;
          a3 = new Float64Array(16), t2.b8(a3, this._fov, this.width / this.height, g3, f3), a3[8] = 2 * -e2.x / this.width, a3[9] = 2 * e2.y / this.height, t2.a0(a3, a3, [1, -1, 1]), t2.$(a3, a3, [0, 0, -this.cameraToCenterDistance]), t2.b9(a3, a3, this._pitch), t2.ae(a3, a3, this.angle), t2.$(a3, a3, [-i3, -s3, 0]), this.mercatorMatrix = t2.a0([], a3, [this.worldSize, this.worldSize, this.worldSize]), t2.a0(a3, a3, [1, 1, this._pixelPerMeter]), this.pixelMatrix = t2.a1(new Float64Array(16), this.labelPlaneMatrix, a3), t2.$(a3, a3, [0, 0, -this.elevation]), this.projMatrix = a3, this.invProjMatrix = t2.as([], a3), this.pixelMatrix3D = t2.a1(new Float64Array(16), this.labelPlaneMatrix, a3);
          const v3 = this.width % 2 / 2, x3 = this.height % 2 / 2, y3 = Math.cos(this.angle), b3 = Math.sin(this.angle), w3 = i3 - Math.round(i3) + y3 * v3 + b3 * x3, T3 = s3 - Math.round(s3) + y3 * x3 + b3 * v3, I3 = new Float64Array(a3);
          if (t2.$(I3, I3, [w3 > 0.5 ? w3 - 1 : w3, T3 > 0.5 ? T3 - 1 : T3, 0]), this.alignedProjMatrix = I3, a3 = t2.as(new Float64Array(16), this.pixelMatrix), !a3) throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = a3, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse) return 1;
          const e2 = this.pointCoordinate(new t2.P(0, 0)), i3 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
          return t2.ag(i3, i3, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }
        getCameraPoint() {
          const e2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new t2.P(0, e2));
        }
        getCameraQueryGeometry(e2) {
          const i3 = this.getCameraPoint();
          if (1 === e2.length) return [e2[0], i3];
          {
            let s3 = i3.x, a3 = i3.y, o3 = i3.x, r3 = i3.y;
            for (const t3 of e2) s3 = Math.min(s3, t3.x), a3 = Math.min(a3, t3.y), o3 = Math.max(o3, t3.x), r3 = Math.max(r3, t3.y);
            return [new t2.P(s3, a3), new t2.P(o3, a3), new t2.P(o3, r3), new t2.P(s3, r3), new t2.P(s3, a3)];
          }
        }
      }
      function ns(t3, e2) {
        let i3, s3 = false, a3 = null, o3 = null;
        const r3 = () => {
          a3 = null, s3 && (t3.apply(o3, i3), a3 = setTimeout(r3, e2), s3 = false);
        };
        return (...t4) => (s3 = true, o3 = this, i3 = t4, a3 || r3(), a3);
      }
      class ls {
        constructor(t3) {
          this._getCurrentHash = () => {
            const t4 = window.location.hash.replace("#", "");
            if (this._hashName) {
              let e2;
              return t4.split("&").map((t5) => t5.split("=")).forEach((t5) => {
                t5[0] === this._hashName && (e2 = t5);
              }), (e2 && e2[1] || "").split("/");
            }
            return t4.split("/");
          }, this._onHashChange = () => {
            const t4 = this._getCurrentHash();
            if (t4.length >= 3 && !t4.some((t5) => isNaN(t5))) {
              const e2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t4[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+t4[2], +t4[1]], zoom: +t4[0], bearing: e2, pitch: +(t4[4] || 0) }), true;
            }
            return false;
          }, this._updateHashUnthrottled = () => {
            const t4 = window.location.href.replace(/(#.+)?$/, this.getHashString());
            try {
              window.history.replaceState(window.history.state, null, t4);
            } catch (t5) {
            }
          }, this._updateHash = ns(this._updateHashUnthrottled, 300), this._hashName = t3 && encodeURIComponent(t3);
        }
        addTo(t3) {
          return this._map = t3, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
        }
        getHashString(t3) {
          const e2 = this._map.getCenter(), i3 = Math.round(100 * this._map.getZoom()) / 100, s3 = Math.ceil((i3 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a3 = Math.pow(10, s3), o3 = Math.round(e2.lng * a3) / a3, r3 = Math.round(e2.lat * a3) / a3, n3 = this._map.getBearing(), l3 = this._map.getPitch();
          let h3 = "";
          if (h3 += t3 ? `/${o3}/${r3}/${i3}` : `${i3}/${r3}/${o3}`, (n3 || l3) && (h3 += "/" + Math.round(10 * n3) / 10), l3 && (h3 += `/${Math.round(l3)}`), this._hashName) {
            const t4 = this._hashName;
            let e3 = false;
            const i4 = window.location.hash.slice(1).split("&").map((i5) => {
              const s4 = i5.split("=")[0];
              return s4 === t4 ? (e3 = true, `${s4}=${h3}`) : i5;
            }).filter((t5) => t5);
            return e3 || i4.push(`${t4}=${h3}`), `#${i4.join("&")}`;
          }
          return `#${h3}`;
        }
      }
      const hs = { linearity: 0.3, easing: t2.ba(0, 0, 0.3, 1) }, cs = t2.e({ deceleration: 2500, maxSpeed: 1400 }, hs), us = t2.e({ deceleration: 20, maxSpeed: 1400 }, hs), ds = t2.e({ deceleration: 1e3, maxSpeed: 360 }, hs), _s = t2.e({ deceleration: 1e3, maxSpeed: 90 }, hs);
      class ps {
        constructor(t3) {
          this._map = t3, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(e2) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t2.h.now(), settings: e2 });
        }
        _drainInertiaBuffer() {
          const e2 = this._inertiaBuffer, i3 = t2.h.now();
          for (; e2.length > 0 && i3 - e2[0].time > 160; ) e2.shift();
        }
        _onMoveEnd(e2) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
          const i3 = { zoom: 0, bearing: 0, pitch: 0, pan: new t2.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: t3 } of this._inertiaBuffer) i3.zoom += t3.zoomDelta || 0, i3.bearing += t3.bearingDelta || 0, i3.pitch += t3.pitchDelta || 0, t3.panDelta && i3.pan._add(t3.panDelta), t3.around && (i3.around = t3.around), t3.pinchAround && (i3.pinchAround = t3.pinchAround);
          const s3 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a3 = {};
          if (i3.pan.mag()) {
            const o3 = fs(i3.pan.mag(), s3, t2.e({}, cs, e2 || {}));
            a3.offset = i3.pan.mult(o3.amount / i3.pan.mag()), a3.center = this._map.transform.center, ms(a3, o3);
          }
          if (i3.zoom) {
            const t3 = fs(i3.zoom, s3, us);
            a3.zoom = this._map.transform.zoom + t3.amount, ms(a3, t3);
          }
          if (i3.bearing) {
            const e3 = fs(i3.bearing, s3, ds);
            a3.bearing = this._map.transform.bearing + t2.ad(e3.amount, -179, 179), ms(a3, e3);
          }
          if (i3.pitch) {
            const t3 = fs(i3.pitch, s3, _s);
            a3.pitch = this._map.transform.pitch + t3.amount, ms(a3, t3);
          }
          if (a3.zoom || a3.bearing) {
            const t3 = void 0 === i3.pinchAround ? i3.around : i3.pinchAround;
            a3.around = t3 ? this._map.unproject(t3) : this._map.getCenter();
          }
          return this.clear(), t2.e(a3, { noMoveStart: true });
        }
      }
      function ms(t3, e2) {
        (!t3.duration || t3.duration < e2.duration) && (t3.duration = e2.duration, t3.easing = e2.easing);
      }
      function fs(e2, i3, s3) {
        const { maxSpeed: a3, linearity: o3, deceleration: r3 } = s3, n3 = t2.ad(e2 * o3 / (i3 / 1e3), -a3, a3), l3 = Math.abs(n3) / (r3 * o3);
        return { easing: s3.easing, duration: 1e3 * l3, amount: n3 * (l3 / 2) };
      }
      class gs extends t2.k {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e2, s3, a3, o3 = {}) {
          const r3 = i2.mousePos(s3.getCanvasContainer(), a3), n3 = s3.unproject(r3);
          super(e2, t2.e({ point: r3, lngLat: n3, originalEvent: a3 }, o3)), this._defaultPrevented = false, this.target = s3;
        }
      }
      class vs extends t2.k {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e2, s3, a3) {
          const o3 = "touchend" === e2 ? a3.changedTouches : a3.touches, r3 = i2.touchPos(s3.getCanvasContainer(), o3), n3 = r3.map((t3) => s3.unproject(t3)), l3 = r3.reduce((t3, e3, i3, s4) => t3.add(e3.div(s4.length)), new t2.P(0, 0));
          super(e2, { points: r3, point: l3, lngLats: n3, lngLat: s3.unproject(l3), originalEvent: a3 }), this._defaultPrevented = false;
        }
      }
      class xs extends t2.k {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t3, e2, i3) {
          super(t3, { originalEvent: i3 }), this._defaultPrevented = false;
        }
      }
      class ys {
        constructor(t3, e2) {
          this._map = t3, this._clickTolerance = e2.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(t3) {
          return this._firePreventable(new xs(t3.type, this._map, t3));
        }
        mousedown(t3, e2) {
          return this._mousedownPos = e2, this._firePreventable(new gs(t3.type, this._map, t3));
        }
        mouseup(t3) {
          this._map.fire(new gs(t3.type, this._map, t3));
        }
        click(t3, e2) {
          this._mousedownPos && this._mousedownPos.dist(e2) >= this._clickTolerance || this._map.fire(new gs(t3.type, this._map, t3));
        }
        dblclick(t3) {
          return this._firePreventable(new gs(t3.type, this._map, t3));
        }
        mouseover(t3) {
          this._map.fire(new gs(t3.type, this._map, t3));
        }
        mouseout(t3) {
          this._map.fire(new gs(t3.type, this._map, t3));
        }
        touchstart(t3) {
          return this._firePreventable(new vs(t3.type, this._map, t3));
        }
        touchmove(t3) {
          this._map.fire(new vs(t3.type, this._map, t3));
        }
        touchend(t3) {
          this._map.fire(new vs(t3.type, this._map, t3));
        }
        touchcancel(t3) {
          this._map.fire(new vs(t3.type, this._map, t3));
        }
        _firePreventable(t3) {
          if (this._map.fire(t3), t3.defaultPrevented) return {};
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class bs {
        constructor(t3) {
          this._map = t3;
        }
        reset() {
          this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
        }
        mousemove(t3) {
          this._map.fire(new gs(t3.type, this._map, t3));
        }
        mousedown() {
          this._delayContextMenu = true, this._ignoreContextMenu = false;
        }
        mouseup() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new gs("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(t3) {
          this._delayContextMenu ? this._contextMenuEvent = t3 : this._ignoreContextMenu || this._map.fire(new gs(t3.type, this._map, t3)), this._map.listens("contextmenu") && t3.preventDefault();
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class ws {
        constructor(t3) {
          this._map = t3;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(e2) {
          return this.transform.pointLocation(t2.P.convert(e2), this._map.terrain);
        }
      }
      class Ts {
        constructor(t3, e2) {
          this._map = t3, this._tr = new ws(t3), this._el = t3.getCanvasContainer(), this._container = t3.getContainer(), this._clickTolerance = e2.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = true);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        mousedown(t3, e2) {
          this.isEnabled() && t3.shiftKey && 0 === t3.button && (i2.disableDrag(), this._startPos = this._lastPos = e2, this._active = true);
        }
        mousemoveWindow(t3, e2) {
          if (!this._active) return;
          const s3 = e2;
          if (this._lastPos.equals(s3) || !this._box && s3.dist(this._startPos) < this._clickTolerance) return;
          const a3 = this._startPos;
          this._lastPos = s3, this._box || (this._box = i2.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t3));
          const o3 = Math.min(a3.x, s3.x), r3 = Math.max(a3.x, s3.x), n3 = Math.min(a3.y, s3.y), l3 = Math.max(a3.y, s3.y);
          i2.setTransform(this._box, `translate(${o3}px,${n3}px)`), this._box.style.width = r3 - o3 + "px", this._box.style.height = l3 - n3 + "px";
        }
        mouseupWindow(e2, s3) {
          if (!this._active) return;
          if (0 !== e2.button) return;
          const a3 = this._startPos, o3 = s3;
          if (this.reset(), i2.suppressClick(), a3.x !== o3.x || a3.y !== o3.y) return this._map.fire(new t2.k("boxzoomend", { originalEvent: e2 })), { cameraAnimation: (t3) => t3.fitScreenCoordinates(a3, o3, this._tr.bearing, { linear: true }) };
          this._fireEvent("boxzoomcancel", e2);
        }
        keydown(t3) {
          this._active && 27 === t3.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t3));
        }
        reset() {
          this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (i2.remove(this._box), this._box = null), i2.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(e2, i3) {
          return this._map.fire(new t2.k(e2, { originalEvent: i3 }));
        }
      }
      function Is(t3, e2) {
        if (t3.length !== e2.length) throw new Error(`The number of touches and points are not equal - touches ${t3.length}, points ${e2.length}`);
        const i3 = {};
        for (let s3 = 0; s3 < t3.length; s3++) i3[t3[s3].identifier] = e2[s3];
        return i3;
      }
      class Es {
        constructor(t3) {
          this.reset(), this.numTouches = t3.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
        }
        touchstart(e2, i3, s3) {
          (this.centroid || s3.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e2.timeStamp), s3.length === this.numTouches && (this.centroid = function(e3) {
            const i4 = new t2.P(0, 0);
            for (const t3 of e3) i4._add(t3);
            return i4.div(e3.length);
          }(i3), this.touches = Is(s3, i3)));
        }
        touchmove(t3, e2, i3) {
          if (this.aborted || !this.centroid) return;
          const s3 = Is(i3, e2);
          for (const t4 in this.touches) {
            const e3 = s3[t4];
            (!e3 || e3.dist(this.touches[t4]) > 30) && (this.aborted = true);
          }
        }
        touchend(t3, e2, i3) {
          if ((!this.centroid || t3.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i3.length) {
            const t4 = !this.aborted && this.centroid;
            if (this.reset(), t4) return t4;
          }
        }
      }
      class Ss {
        constructor(t3) {
          this.singleTap = new Es(t3), this.numTaps = t3.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(t3, e2, i3) {
          this.singleTap.touchstart(t3, e2, i3);
        }
        touchmove(t3, e2, i3) {
          this.singleTap.touchmove(t3, e2, i3);
        }
        touchend(t3, e2, i3) {
          const s3 = this.singleTap.touchend(t3, e2, i3);
          if (s3) {
            const e3 = t3.timeStamp - this.lastTime < 500, i4 = !this.lastTap || this.lastTap.dist(s3) < 30;
            if (e3 && i4 || this.reset(), this.count++, this.lastTime = t3.timeStamp, this.lastTap = s3, this.count === this.numTaps) return this.reset(), s3;
          }
        }
      }
      class Cs {
        constructor(t3) {
          this._tr = new ws(t3), this._zoomIn = new Ss({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Ss({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(t3, e2, i3) {
          this._zoomIn.touchstart(t3, e2, i3), this._zoomOut.touchstart(t3, e2, i3);
        }
        touchmove(t3, e2, i3) {
          this._zoomIn.touchmove(t3, e2, i3), this._zoomOut.touchmove(t3, e2, i3);
        }
        touchend(t3, e2, i3) {
          const s3 = this._zoomIn.touchend(t3, e2, i3), a3 = this._zoomOut.touchend(t3, e2, i3), o3 = this._tr;
          return s3 ? (this._active = true, t3.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o3.zoom + 1, around: o3.unproject(s3) }, { originalEvent: t3 }) }) : a3 ? (this._active = true, t3.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o3.zoom - 1, around: o3.unproject(a3) }, { originalEvent: t3 }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Ps {
        constructor(t3) {
          this._enabled = !!t3.enable, this._moveStateManager = t3.moveStateManager, this._clickTolerance = t3.clickTolerance || 1, this._moveFunction = t3.move, this._activateOnStart = !!t3.activateOnStart, t3.assignEvents(this), this.reset();
        }
        reset(t3) {
          this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(t3);
        }
        _move(...t3) {
          const e2 = this._moveFunction(...t3);
          if (e2.bearingDelta || e2.pitchDelta || e2.around || e2.panDelta) return this._active = true, e2;
        }
        dragStart(t3, e2) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t3) && (this._moveStateManager.startMove(t3), this._lastPoint = e2.length ? e2[0] : e2, this._activateOnStart && this._lastPoint && (this._active = true));
        }
        dragMove(t3, e2) {
          if (!this.isEnabled()) return;
          const i3 = this._lastPoint;
          if (!i3) return;
          if (t3.preventDefault(), !this._moveStateManager.isValidMoveEvent(t3)) return void this.reset(t3);
          const s3 = e2.length ? e2[0] : e2;
          return !this._moved && s3.dist(i3) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = s3, this._move(i3, s3));
        }
        dragEnd(t3) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t3) && (this._moved && i2.suppressClick(), this.reset(t3));
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const Ds = { 0: 1, 2: 2 };
      class Ms {
        constructor(t3) {
          this._correctEvent = t3.checkCorrectEvent;
        }
        startMove(t3) {
          const e2 = i2.mouseButton(t3);
          this._eventButton = e2;
        }
        endMove(t3) {
          delete this._eventButton;
        }
        isValidStartEvent(t3) {
          return this._correctEvent(t3);
        }
        isValidMoveEvent(t3) {
          return !function(t4, e2) {
            const i3 = Ds[e2];
            return void 0 === t4.buttons || (t4.buttons & i3) !== i3;
          }(t3, this._eventButton);
        }
        isValidEndEvent(t3) {
          return i2.mouseButton(t3) === this._eventButton;
        }
      }
      class zs {
        constructor() {
          this._firstTouch = void 0;
        }
        _isOneFingerTouch(t3) {
          return 1 === t3.targetTouches.length;
        }
        _isSameTouchEvent(t3) {
          return t3.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(t3) {
          this._firstTouch = t3.targetTouches[0].identifier;
        }
        endMove(t3) {
          delete this._firstTouch;
        }
        isValidStartEvent(t3) {
          return this._isOneFingerTouch(t3);
        }
        isValidMoveEvent(t3) {
          return this._isOneFingerTouch(t3) && this._isSameTouchEvent(t3);
        }
        isValidEndEvent(t3) {
          return this._isOneFingerTouch(t3) && this._isSameTouchEvent(t3);
        }
      }
      const Ls = (t3) => {
        t3.mousedown = t3.dragStart, t3.mousemoveWindow = t3.dragMove, t3.mouseup = t3.dragEnd, t3.contextmenu = function(t4) {
          t4.preventDefault();
        };
      }, As = ({ enable: t3, clickTolerance: e2, bearingDegreesPerPixelMoved: s3 = 0.8 }) => {
        const a3 = new Ms({ checkCorrectEvent: (t4) => 0 === i2.mouseButton(t4) && t4.ctrlKey || 2 === i2.mouseButton(t4) });
        return new Ps({ clickTolerance: e2, move: (t4, e3) => ({ bearingDelta: (e3.x - t4.x) * s3 }), moveStateManager: a3, enable: t3, assignEvents: Ls });
      }, Rs = ({ enable: t3, clickTolerance: e2, pitchDegreesPerPixelMoved: s3 = -0.5 }) => {
        const a3 = new Ms({ checkCorrectEvent: (t4) => 0 === i2.mouseButton(t4) && t4.ctrlKey || 2 === i2.mouseButton(t4) });
        return new Ps({ clickTolerance: e2, move: (t4, e3) => ({ pitchDelta: (e3.y - t4.y) * s3 }), moveStateManager: a3, enable: t3, assignEvents: Ls });
      };
      class ks {
        constructor(t3, e2) {
          this._minTouches = t3.cooperativeGestures ? 2 : 1, this._clickTolerance = t3.clickTolerance || 1, this._map = e2, this.reset();
        }
        reset() {
          this._active = false, this._touches = {}, this._sum = new t2.P(0, 0), setTimeout(() => {
            this._cancelCooperativeMessage = false;
          }, 200);
        }
        touchstart(t3, e2, i3) {
          return this._calculateTransform(t3, e2, i3);
        }
        touchmove(t3, e2, i3) {
          if (this._map._cooperativeGestures && (2 === this._minTouches && i3.length < 2 && !this._cancelCooperativeMessage ? this._map._onCooperativeGesture(t3, false, i3.length) : this._cancelCooperativeMessage || (this._cancelCooperativeMessage = true)), this._active && !(i3.length < this._minTouches)) return t3.preventDefault(), this._calculateTransform(t3, e2, i3);
        }
        touchend(t3, e2, i3) {
          this._calculateTransform(t3, e2, i3), this._active && i3.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(e2, i3, s3) {
          s3.length > 0 && (this._active = true);
          const a3 = Is(s3, i3), o3 = new t2.P(0, 0), r3 = new t2.P(0, 0);
          let n3 = 0;
          for (const t3 in a3) {
            const e3 = a3[t3], i4 = this._touches[t3];
            i4 && (o3._add(e3), r3._add(e3.sub(i4)), n3++, a3[t3] = e3);
          }
          if (this._touches = a3, n3 < this._minTouches || !r3.mag()) return;
          const l3 = r3.div(n3);
          return this._sum._add(l3), this._sum.mag() < this._clickTolerance ? void 0 : { around: o3.div(n3), panDelta: l3 };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Fs {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false, delete this._firstTwoTouches;
        }
        touchstart(t3, e2, i3) {
          this._firstTwoTouches || i3.length < 2 || (this._firstTwoTouches = [i3[0].identifier, i3[1].identifier], this._start([e2[0], e2[1]]));
        }
        touchmove(t3, e2, i3) {
          if (!this._firstTwoTouches) return;
          t3.preventDefault();
          const [s3, a3] = this._firstTwoTouches, o3 = Bs(i3, e2, s3), r3 = Bs(i3, e2, a3);
          if (!o3 || !r3) return;
          const n3 = this._aroundCenter ? null : o3.add(r3).div(2);
          return this._move([o3, r3], n3, t3);
        }
        touchend(t3, e2, s3) {
          if (!this._firstTwoTouches) return;
          const [a3, o3] = this._firstTwoTouches, r3 = Bs(s3, e2, a3), n3 = Bs(s3, e2, o3);
          r3 && n3 || (this._active && i2.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(t3) {
          this._enabled = true, this._aroundCenter = !!t3 && "center" === t3.around;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function Bs(t3, e2, i3) {
        for (let s3 = 0; s3 < t3.length; s3++) if (t3[s3].identifier === i3) return e2[s3];
      }
      function Os(t3, e2) {
        return Math.log(t3 / e2) / Math.LN2;
      }
      class Ns extends Fs {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(t3) {
          this._startDistance = this._distance = t3[0].dist(t3[1]);
        }
        _move(t3, e2) {
          const i3 = this._distance;
          if (this._distance = t3[0].dist(t3[1]), this._active || !(Math.abs(Os(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: Os(this._distance, i3), pinchAround: e2 };
        }
      }
      function Us(t3, e2) {
        return 180 * t3.angleWith(e2) / Math.PI;
      }
      class Zs extends Fs {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(t3) {
          this._startVector = this._vector = t3[0].sub(t3[1]), this._minDiameter = t3[0].dist(t3[1]);
        }
        _move(t3, e2) {
          const i3 = this._vector;
          if (this._vector = t3[0].sub(t3[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: Us(this._vector, i3), pinchAround: e2 };
        }
        _isBelowThreshold(t3) {
          this._minDiameter = Math.min(this._minDiameter, t3.mag());
          const e2 = 25 / (Math.PI * this._minDiameter) * 360, i3 = Us(t3, this._startVector);
          return Math.abs(i3) < e2;
        }
      }
      function Gs(t3) {
        return Math.abs(t3.y) > Math.abs(t3.x);
      }
      class js extends Fs {
        constructor(t3) {
          super(), this._map = t3;
        }
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(t3, e2, i3) {
          super.touchstart(t3, e2, i3), this._currentTouchCount = i3.length;
        }
        _start(t3) {
          this._lastPoints = t3, Gs(t3[0].sub(t3[1])) && (this._valid = false);
        }
        _move(t3, e2, i3) {
          if (this._map._cooperativeGestures && this._currentTouchCount < 3) return;
          const s3 = t3[0].sub(this._lastPoints[0]), a3 = t3[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(s3, a3, i3.timeStamp), this._valid ? (this._lastPoints = t3, this._active = true, { pitchDelta: (s3.y + a3.y) / 2 * -0.5 }) : void 0;
        }
        gestureBeginsVertically(t3, e2, i3) {
          if (void 0 !== this._valid) return this._valid;
          const s3 = t3.mag() >= 2, a3 = e2.mag() >= 2;
          if (!s3 && !a3) return;
          if (!s3 || !a3) return void 0 === this._firstMove && (this._firstMove = i3), i3 - this._firstMove < 100 && void 0;
          const o3 = t3.y > 0 == e2.y > 0;
          return Gs(t3) && Gs(e2) && o3;
        }
      }
      const Vs = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class qs {
        constructor(t3) {
          this._tr = new ws(t3);
          const e2 = Vs;
          this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
        }
        reset() {
          this._active = false;
        }
        keydown(t3) {
          if (t3.altKey || t3.ctrlKey || t3.metaKey) return;
          let e2 = 0, i3 = 0, s3 = 0, a3 = 0, o3 = 0;
          switch (t3.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              e2 = 1;
              break;
            case 189:
            case 109:
            case 173:
              e2 = -1;
              break;
            case 37:
              t3.shiftKey ? i3 = -1 : (t3.preventDefault(), a3 = -1);
              break;
            case 39:
              t3.shiftKey ? i3 = 1 : (t3.preventDefault(), a3 = 1);
              break;
            case 38:
              t3.shiftKey ? s3 = 1 : (t3.preventDefault(), o3 = -1);
              break;
            case 40:
              t3.shiftKey ? s3 = -1 : (t3.preventDefault(), o3 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (i3 = 0, s3 = 0), { cameraAnimation: (r3) => {
            const n3 = this._tr;
            r3.easeTo({ duration: 300, easeId: "keyboardHandler", easing: $s, zoom: e2 ? Math.round(n3.zoom) + e2 * (t3.shiftKey ? 2 : 1) : n3.zoom, bearing: n3.bearing + i3 * this._bearingStep, pitch: n3.pitch + s3 * this._pitchStep, offset: [-a3 * this._panStep, -o3 * this._panStep], center: n3.center }, { originalEvent: t3 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = true;
        }
        enableRotation() {
          this._rotationDisabled = false;
        }
      }
      function $s(t3) {
        return t3 * (2 - t3);
      }
      const Ws = 4.000244140625;
      class Hs {
        constructor(t3, e2) {
          this._onTimeout = (t4) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t4);
          }, this._map = t3, this._tr = new ws(t3), this._el = t3.getCanvasContainer(), this._triggerRenderFrame = e2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(t3) {
          this._defaultZoomRate = t3;
        }
        setWheelZoomRate(t3) {
          this._wheelZoomRate = t3;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || void 0 !== this._finishTimeout;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(t3) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = !!t3 && "center" === t3.around);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        wheel(e2) {
          if (!this.isEnabled()) return;
          if (this._map._cooperativeGestures) {
            if (!e2[this._map._metaKey]) return;
            e2.preventDefault();
          }
          let i3 = e2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY;
          const s3 = t2.h.now(), a3 = s3 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = s3, 0 !== i3 && i3 % Ws == 0 ? this._type = "wheel" : 0 !== i3 && Math.abs(i3) < 4 ? this._type = "trackpad" : a3 > 400 ? (this._type = null, this._lastValue = i3, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(a3 * i3) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i3 += this._lastValue)), e2.shiftKey && i3 && (i3 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= i3, this._active || this._start(e2)), e2.preventDefault();
        }
        _start(e2) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const s3 = i2.mousePos(this._el, e2), a3 = this._tr;
          this._around = t2.L.convert(this._aroundCenter ? a3.center : a3.unproject(s3)), this._aroundPoint = a3.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId) return;
          if (this._frameId = null, !this.isActive()) return;
          const e2 = this._tr.transform;
          if (0 !== this._delta) {
            const t3 = "wheel" === this._type && Math.abs(this._delta) > Ws ? this._wheelZoomRate : this._defaultZoomRate;
            let i4 = 2 / (1 + Math.exp(-Math.abs(this._delta * t3)));
            this._delta < 0 && 0 !== i4 && (i4 = 1 / i4);
            const s4 = "number" == typeof this._targetZoom ? e2.zoomScale(this._targetZoom) : e2.scale;
            this._targetZoom = Math.min(e2.maxZoom, Math.max(e2.minZoom, e2.scaleZoom(s4 * i4))), "wheel" === this._type && (this._startZoom = e2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const i3 = "number" == typeof this._targetZoom ? this._targetZoom : e2.zoom, s3 = this._startZoom, a3 = this._easing;
          let o3, r3 = false;
          if ("wheel" === this._type && s3 && a3) {
            const e3 = Math.min((t2.h.now() - this._lastWheelEventTime) / 200, 1), n3 = a3(e3);
            o3 = t2.B.number(s3, i3, n3), e3 < 1 ? this._frameId || (this._frameId = true) : r3 = true;
          } else o3 = i3, r3 = true;
          return this._active = true, r3 && (this._active = false, this._finishTimeout = setTimeout(() => {
            this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: true, needsRenderFrame: !r3, zoomDelta: o3 - e2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(e2) {
          let i3 = t2.bb;
          if (this._prevEase) {
            const e3 = this._prevEase, s3 = (t2.h.now() - e3.start) / e3.duration, a3 = e3.easing(s3 + 0.01) - e3.easing(s3), o3 = 0.27 / Math.sqrt(a3 * a3 + 1e-4) * 0.01, r3 = Math.sqrt(0.0729 - o3 * o3);
            i3 = t2.ba(o3, r3, 0.25, 1);
          }
          return this._prevEase = { start: t2.h.now(), duration: e2, easing: i3 }, i3;
        }
        reset() {
          this._active = false, this._zooming = false, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }
      class Xs {
        constructor(t3, e2) {
          this._clickZoom = t3, this._tapZoom = e2;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class Ks {
        constructor(t3) {
          this._tr = new ws(t3), this.reset();
        }
        reset() {
          this._active = false;
        }
        dblclick(t3, e2) {
          return t3.preventDefault(), { cameraAnimation: (i3) => {
            i3.easeTo({ duration: 300, zoom: this._tr.zoom + (t3.shiftKey ? -1 : 1), around: this._tr.unproject(e2) }, { originalEvent: t3 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Qs {
        constructor() {
          this._tap = new Ss({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(t3, e2, i3) {
          if (!this._swipePoint) if (this._tapTime) {
            const s3 = e2[0], a3 = t3.timeStamp - this._tapTime < 500, o3 = this._tapPoint.dist(s3) < 30;
            a3 && o3 ? i3.length > 0 && (this._swipePoint = s3, this._swipeTouch = i3[0].identifier) : this.reset();
          } else this._tap.touchstart(t3, e2, i3);
        }
        touchmove(t3, e2, i3) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i3[0].identifier !== this._swipeTouch) return;
              const s3 = e2[0], a3 = s3.y - this._swipePoint.y;
              return this._swipePoint = s3, t3.preventDefault(), this._active = true, { zoomDelta: a3 / 128 };
            }
          } else this._tap.touchmove(t3, e2, i3);
        }
        touchend(t3, e2, i3) {
          if (this._tapTime) this._swipePoint && 0 === i3.length && this.reset();
          else {
            const s3 = this._tap.touchend(t3, e2, i3);
            s3 && (this._tapTime = t3.timeStamp, this._tapPoint = s3);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Ys {
        constructor(t3, e2, i3) {
          this._el = t3, this._mousePan = e2, this._touchPan = i3;
        }
        enable(t3) {
          this._inertiaOptions = t3 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class Js {
        constructor(t3, e2, i3) {
          this._pitchWithRotate = t3.pitchWithRotate, this._mouseRotate = e2, this._mousePitch = i3;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class ta {
        constructor(t3, e2, i3, s3) {
          this._el = t3, this._touchZoom = e2, this._touchRotate = i3, this._tapDragZoom = s3, this._rotationDisabled = false, this._enabled = true;
        }
        enable(t3) {
          this._touchZoom.enable(t3), this._rotationDisabled || this._touchRotate.enable(t3), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const ea = (t3) => t3.zoom || t3.drag || t3.pitch || t3.rotate;
      class ia extends t2.k {
      }
      function sa(t3) {
        return t3.panDelta && t3.panDelta.mag() || t3.zoomDelta || t3.bearingDelta || t3.pitchDelta;
      }
      class aa {
        constructor(t3, e2) {
          this.handleWindowEvent = (t4) => {
            this.handleEvent(t4, `${t4.type}Window`);
          }, this.handleEvent = (t4, e3) => {
            if ("blur" === t4.type) return void this.stop(true);
            this._updatingCamera = true;
            const s4 = "renderFrame" === t4.type ? void 0 : t4, a3 = { needsRenderFrame: false }, o3 = {}, r3 = {}, n3 = t4.touches, l3 = n3 ? this._getMapTouches(n3) : void 0, h3 = l3 ? i2.touchPos(this._el, l3) : i2.mousePos(this._el, t4);
            for (const { handlerName: i3, handler: n4, allowed: c4 } of this._handlers) {
              if (!n4.isEnabled()) continue;
              let u4;
              this._blockedByActive(r3, c4, i3) ? n4.reset() : n4[e3 || t4.type] && (u4 = n4[e3 || t4.type](t4, h3, l3), this.mergeHandlerResult(a3, o3, u4, i3, s4), u4 && u4.needsRenderFrame && this._triggerRenderFrame()), (u4 || n4.isActive()) && (r3[i3] = n4);
            }
            const c3 = {};
            for (const t5 in this._previousActiveHandlers) r3[t5] || (c3[t5] = s4);
            this._previousActiveHandlers = r3, (Object.keys(c3).length || sa(a3)) && (this._changes.push([a3, o3, c3]), this._triggerRenderFrame()), (Object.keys(r3).length || sa(a3)) && this._map._stop(true), this._updatingCamera = false;
            const { cameraAnimation: u3 } = a3;
            u3 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u3(this._map));
          }, this._map = t3, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ps(t3), this._bearingSnap = e2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(e2);
          const s3 = this._el;
          this._listeners = [[s3, "touchstart", { passive: true }], [s3, "touchmove", { passive: false }], [s3, "touchend", void 0], [s3, "touchcancel", void 0], [s3, "mousedown", void 0], [s3, "mousemove", void 0], [s3, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [s3, "mouseover", void 0], [s3, "mouseout", void 0], [s3, "dblclick", void 0], [s3, "click", void 0], [s3, "keydown", { capture: false }], [s3, "keyup", void 0], [s3, "wheel", { passive: false }], [s3, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [t4, e3, s4] of this._listeners) i2.addEventListener(t4, e3, t4 === document ? this.handleWindowEvent : this.handleEvent, s4);
        }
        destroy() {
          for (const [t3, e2, s3] of this._listeners) i2.removeEventListener(t3, e2, t3 === document ? this.handleWindowEvent : this.handleEvent, s3);
        }
        _addDefaultHandlers(t3) {
          const e2 = this._map, s3 = e2.getCanvasContainer();
          this._add("mapEvent", new ys(e2, t3));
          const a3 = e2.boxZoom = new Ts(e2, t3);
          this._add("boxZoom", a3), t3.interactive && t3.boxZoom && a3.enable();
          const o3 = new Cs(e2), r3 = new Ks(e2);
          e2.doubleClickZoom = new Xs(r3, o3), this._add("tapZoom", o3), this._add("clickZoom", r3), t3.interactive && t3.doubleClickZoom && e2.doubleClickZoom.enable();
          const n3 = new Qs();
          this._add("tapDragZoom", n3);
          const l3 = e2.touchPitch = new js(e2);
          this._add("touchPitch", l3), t3.interactive && t3.touchPitch && e2.touchPitch.enable(t3.touchPitch);
          const h3 = As(t3), c3 = Rs(t3);
          e2.dragRotate = new Js(t3, h3, c3), this._add("mouseRotate", h3, ["mousePitch"]), this._add("mousePitch", c3, ["mouseRotate"]), t3.interactive && t3.dragRotate && e2.dragRotate.enable();
          const u3 = (({ enable: t4, clickTolerance: e3 }) => {
            const s4 = new Ms({ checkCorrectEvent: (t5) => 0 === i2.mouseButton(t5) && !t5.ctrlKey });
            return new Ps({ clickTolerance: e3, move: (t5, e4) => ({ around: e4, panDelta: e4.sub(t5) }), activateOnStart: true, moveStateManager: s4, enable: t4, assignEvents: Ls });
          })(t3), d3 = new ks(t3, e2);
          e2.dragPan = new Ys(s3, u3, d3), this._add("mousePan", u3), this._add("touchPan", d3, ["touchZoom", "touchRotate"]), t3.interactive && t3.dragPan && e2.dragPan.enable(t3.dragPan);
          const _3 = new Zs(), p3 = new Ns();
          e2.touchZoomRotate = new ta(s3, p3, _3, n3), this._add("touchRotate", _3, ["touchPan", "touchZoom"]), this._add("touchZoom", p3, ["touchPan", "touchRotate"]), t3.interactive && t3.touchZoomRotate && e2.touchZoomRotate.enable(t3.touchZoomRotate);
          const m3 = e2.scrollZoom = new Hs(e2, () => this._triggerRenderFrame());
          this._add("scrollZoom", m3, ["mousePan"]), t3.interactive && t3.scrollZoom && e2.scrollZoom.enable(t3.scrollZoom);
          const f3 = e2.keyboard = new qs(e2);
          this._add("keyboard", f3), t3.interactive && t3.keyboard && e2.keyboard.enable(), this._add("blockableMapEvent", new bs(e2));
        }
        _add(t3, e2, i3) {
          this._handlers.push({ handlerName: t3, handler: e2, allowed: i3 }), this._handlersById[t3] = e2;
        }
        stop(t3) {
          if (!this._updatingCamera) {
            for (const { handler: t4 } of this._handlers) t4.reset();
            this._inertia.clear(), this._fireEvents({}, {}, t3), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: t3 } of this._handlers) if (t3.isActive()) return true;
          return false;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return Boolean(ea(this._eventsInProgress)) || this.isZooming();
        }
        _blockedByActive(t3, e2, i3) {
          for (const s3 in t3) if (s3 !== i3 && (!e2 || e2.indexOf(s3) < 0)) return true;
          return false;
        }
        _getMapTouches(t3) {
          const e2 = [];
          for (const i3 of t3) this._el.contains(i3.target) && e2.push(i3);
          return e2;
        }
        mergeHandlerResult(e2, i3, s3, a3, o3) {
          if (!s3) return;
          t2.e(e2, s3);
          const r3 = { handlerName: a3, originalEvent: s3.originalEvent || o3 };
          void 0 !== s3.zoomDelta && (i3.zoom = r3), void 0 !== s3.panDelta && (i3.drag = r3), void 0 !== s3.pitchDelta && (i3.pitch = r3), void 0 !== s3.bearingDelta && (i3.rotate = r3);
        }
        _applyChanges() {
          const e2 = {}, i3 = {}, s3 = {};
          for (const [a3, o3, r3] of this._changes) a3.panDelta && (e2.panDelta = (e2.panDelta || new t2.P(0, 0))._add(a3.panDelta)), a3.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + a3.zoomDelta), a3.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + a3.bearingDelta), a3.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + a3.pitchDelta), void 0 !== a3.around && (e2.around = a3.around), void 0 !== a3.pinchAround && (e2.pinchAround = a3.pinchAround), a3.noInertia && (e2.noInertia = a3.noInertia), t2.e(i3, o3), t2.e(s3, r3);
          this._updateMapTransform(e2, i3, s3), this._changes = [];
        }
        _updateMapTransform(t3, e2, i3) {
          const s3 = this._map, a3 = s3._getTransformForUpdate(), o3 = s3.terrain;
          if (!(sa(t3) || o3 && this._terrainMovement)) return this._fireEvents(e2, i3, true);
          let { panDelta: r3, zoomDelta: n3, bearingDelta: l3, pitchDelta: h3, around: c3, pinchAround: u3 } = t3;
          void 0 !== u3 && (c3 = u3), s3._stop(true), c3 = c3 || s3.transform.centerPoint;
          const d3 = a3.pointLocation(r3 ? c3.sub(r3) : c3);
          l3 && (a3.bearing += l3), h3 && (a3.pitch += h3), n3 && (a3.zoom += n3), o3 ? this._terrainMovement || !e2.drag && !e2.zoom ? e2.drag && this._terrainMovement ? a3.center = a3.pointLocation(a3.centerPoint.sub(r3)) : a3.setLocationAtPoint(d3, c3) : (this._terrainMovement = true, this._map._elevationFreeze = true, a3.setLocationAtPoint(d3, c3), this._map.once("moveend", () => {
            this._map._elevationFreeze = false, this._terrainMovement = false, a3.recalculateZoom(s3.terrain);
          })) : a3.setLocationAtPoint(d3, c3), s3._applyUpdatedTransform(a3), this._map._update(), t3.noInertia || this._inertia.record(t3), this._fireEvents(e2, i3, true);
        }
        _fireEvents(e2, i3, s3) {
          const a3 = ea(this._eventsInProgress), o3 = ea(e2), r3 = {};
          for (const t3 in e2) {
            const { originalEvent: i4 } = e2[t3];
            this._eventsInProgress[t3] || (r3[`${t3}start`] = i4), this._eventsInProgress[t3] = e2[t3];
          }
          !a3 && o3 && this._fireEvent("movestart", o3.originalEvent);
          for (const t3 in r3) this._fireEvent(t3, r3[t3]);
          o3 && this._fireEvent("move", o3.originalEvent);
          for (const t3 in e2) {
            const { originalEvent: i4 } = e2[t3];
            this._fireEvent(t3, i4);
          }
          const n3 = {};
          let l3;
          for (const t3 in this._eventsInProgress) {
            const { handlerName: e3, originalEvent: s4 } = this._eventsInProgress[t3];
            this._handlersById[e3].isActive() || (delete this._eventsInProgress[t3], l3 = i3[e3] || s4, n3[`${t3}end`] = l3);
          }
          for (const t3 in n3) this._fireEvent(t3, n3[t3]);
          const h3 = ea(this._eventsInProgress);
          if (s3 && (a3 || o3) && !h3) {
            this._updatingCamera = true;
            const e3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i4 = (t3) => 0 !== t3 && -this._bearingSnap < t3 && t3 < this._bearingSnap;
            !e3 || !e3.essential && t2.h.prefersReducedMotion ? (this._map.fire(new t2.k("moveend", { originalEvent: l3 })), i4(this._map.getBearing()) && this._map.resetNorth()) : (i4(e3.bearing || this._map.getBearing()) && (e3.bearing = 0), e3.freezeElevation = true, this._map.easeTo(e3, { originalEvent: l3 })), this._updatingCamera = false;
          }
        }
        _fireEvent(e2, i3) {
          this._map.fire(new t2.k(e2, i3 ? { originalEvent: i3 } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t3) => {
            delete this._frameId, this.handleEvent(new ia("renderFrame", { timeStamp: t3 })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          void 0 === this._frameId && (this._frameId = this._requestFrame());
        }
      }
      class oa extends t2.E {
        constructor(e2, i3) {
          super(), this._renderFrameCallback = () => {
            const e3 = Math.min((t2.h.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(e3)), e3 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = false, this._zooming = false, this.transform = e2, this._bearingSnap = i3.bearingSnap, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        getCenter() {
          return new t2.L(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(t3, e2) {
          return this.jumpTo({ center: t3 }, e2);
        }
        panBy(e2, i3, s3) {
          return e2 = t2.P.convert(e2).mult(-1), this.panTo(this.transform.center, t2.e({ offset: e2 }, i3), s3);
        }
        panTo(e2, i3, s3) {
          return this.easeTo(t2.e({ center: e2 }, i3), s3);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(t3, e2) {
          return this.jumpTo({ zoom: t3 }, e2), this;
        }
        zoomTo(e2, i3, s3) {
          return this.easeTo(t2.e({ zoom: e2 }, i3), s3);
        }
        zoomIn(t3, e2) {
          return this.zoomTo(this.getZoom() + 1, t3, e2), this;
        }
        zoomOut(t3, e2) {
          return this.zoomTo(this.getZoom() - 1, t3, e2), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(t3, e2) {
          return this.jumpTo({ bearing: t3 }, e2), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(t3, e2) {
          return this.jumpTo({ padding: t3 }, e2), this;
        }
        rotateTo(e2, i3, s3) {
          return this.easeTo(t2.e({ bearing: e2 }, i3), s3);
        }
        resetNorth(e2, i3) {
          return this.rotateTo(0, t2.e({ duration: 1e3 }, e2), i3), this;
        }
        resetNorthPitch(e2, i3) {
          return this.easeTo(t2.e({ bearing: 0, pitch: 0, duration: 1e3 }, e2), i3), this;
        }
        snapToNorth(t3, e2) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t3, e2) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(t3, e2) {
          return this.jumpTo({ pitch: t3 }, e2), this;
        }
        cameraForBounds(t3, e2) {
          t3 = L2.convert(t3);
          const i3 = e2 && e2.bearing || 0;
          return this._cameraForBoxAndBearing(t3.getNorthWest(), t3.getSouthEast(), i3, e2);
        }
        _cameraForBoxAndBearing(e2, i3, s3, a3) {
          const o3 = { top: 0, bottom: 0, right: 0, left: 0 };
          if ("number" == typeof (a3 = t2.e({ padding: o3, offset: [0, 0], maxZoom: this.transform.maxZoom }, a3)).padding) {
            const t3 = a3.padding;
            a3.padding = { top: t3, bottom: t3, right: t3, left: t3 };
          }
          a3.padding = t2.e(o3, a3.padding);
          const r3 = this.transform, n3 = r3.padding, l3 = r3.project(t2.L.convert(e2)), h3 = r3.project(t2.L.convert(i3)), c3 = l3.rotate(-s3 * Math.PI / 180), u3 = h3.rotate(-s3 * Math.PI / 180), d3 = new t2.P(Math.max(c3.x, u3.x), Math.max(c3.y, u3.y)), _3 = new t2.P(Math.min(c3.x, u3.x), Math.min(c3.y, u3.y)), p3 = d3.sub(_3), m3 = (r3.width - (n3.left + n3.right + a3.padding.left + a3.padding.right)) / p3.x, f3 = (r3.height - (n3.top + n3.bottom + a3.padding.top + a3.padding.bottom)) / p3.y;
          if (f3 < 0 || m3 < 0) return void t2.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const g3 = Math.min(r3.scaleZoom(r3.scale * Math.min(m3, f3)), a3.maxZoom), v3 = t2.P.convert(a3.offset), x3 = new t2.P((a3.padding.left - a3.padding.right) / 2, (a3.padding.top - a3.padding.bottom) / 2).rotate(s3 * Math.PI / 180), y3 = v3.add(x3).mult(r3.scale / r3.zoomScale(g3));
          return { center: r3.unproject(l3.add(h3).div(2).sub(y3)), zoom: g3, bearing: s3 };
        }
        fitBounds(t3, e2, i3) {
          return this._fitInternal(this.cameraForBounds(t3, e2), e2, i3);
        }
        fitScreenCoordinates(e2, i3, s3, a3, o3) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t2.P.convert(e2)), this.transform.pointLocation(t2.P.convert(i3)), s3, a3), a3, o3);
        }
        _fitInternal(e2, i3, s3) {
          return e2 ? (delete (i3 = t2.e(e2, i3)).padding, i3.linear ? this.easeTo(i3, s3) : this.flyTo(i3, s3)) : this;
        }
        jumpTo(e2, i3) {
          this.stop();
          const s3 = this._getTransformForUpdate();
          let a3 = false, o3 = false, r3 = false;
          return "zoom" in e2 && s3.zoom !== +e2.zoom && (a3 = true, s3.zoom = +e2.zoom), void 0 !== e2.center && (s3.center = t2.L.convert(e2.center)), "bearing" in e2 && s3.bearing !== +e2.bearing && (o3 = true, s3.bearing = +e2.bearing), "pitch" in e2 && s3.pitch !== +e2.pitch && (r3 = true, s3.pitch = +e2.pitch), null == e2.padding || s3.isPaddingEqual(e2.padding) || (s3.padding = e2.padding), this._applyUpdatedTransform(s3), this.fire(new t2.k("movestart", i3)).fire(new t2.k("move", i3)), a3 && this.fire(new t2.k("zoomstart", i3)).fire(new t2.k("zoom", i3)).fire(new t2.k("zoomend", i3)), o3 && this.fire(new t2.k("rotatestart", i3)).fire(new t2.k("rotate", i3)).fire(new t2.k("rotateend", i3)), r3 && this.fire(new t2.k("pitchstart", i3)).fire(new t2.k("pitch", i3)).fire(new t2.k("pitchend", i3)), this.fire(new t2.k("moveend", i3));
        }
        calculateCameraOptionsFromTo(e2, i3, s3, a3 = 0) {
          const o3 = t2.U.fromLngLat(e2, i3), r3 = t2.U.fromLngLat(s3, a3), n3 = r3.x - o3.x, l3 = r3.y - o3.y, h3 = r3.z - o3.z, c3 = Math.hypot(n3, l3, h3);
          if (0 === c3) throw new Error("Can't calculate camera options with same From and To");
          const u3 = Math.hypot(n3, l3), d3 = this.transform.scaleZoom(this.transform.cameraToCenterDistance / c3 / this.transform.tileSize), _3 = 180 * Math.atan2(n3, -l3) / Math.PI;
          let p3 = 180 * Math.acos(u3 / c3) / Math.PI;
          return p3 = h3 < 0 ? 90 - p3 : 90 + p3, { center: r3.toLngLat(), zoom: d3, pitch: p3, bearing: _3 };
        }
        easeTo(e2, i3) {
          this._stop(false, e2.easeId), (false === (e2 = t2.e({ offset: [0, 0], duration: 500, easing: t2.bb }, e2)).animate || !e2.essential && t2.h.prefersReducedMotion) && (e2.duration = 0);
          const s3 = this._getTransformForUpdate(), a3 = this.getZoom(), o3 = this.getBearing(), r3 = this.getPitch(), n3 = this.getPadding(), l3 = "zoom" in e2 ? +e2.zoom : a3, h3 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, o3) : o3, c3 = "pitch" in e2 ? +e2.pitch : r3, u3 = "padding" in e2 ? e2.padding : s3.padding, d3 = t2.P.convert(e2.offset);
          let _3 = s3.centerPoint.add(d3);
          const p3 = s3.pointLocation(_3), m3 = t2.L.convert(e2.center || p3);
          this._normalizeCenter(m3);
          const f3 = s3.project(p3), g3 = s3.project(m3).sub(f3), v3 = s3.zoomScale(l3 - a3);
          let x3, y3;
          e2.around && (x3 = t2.L.convert(e2.around), y3 = s3.locationPoint(x3));
          const b3 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || l3 !== a3, this._rotating = this._rotating || o3 !== h3, this._pitching = this._pitching || c3 !== r3, this._padding = !s3.isPaddingEqual(u3), this._easeId = e2.easeId, this._prepareEase(i3, e2.noMoveStart, b3), this.terrain && this._prepareElevation(m3), this._ease((p4) => {
            if (this._zooming && (s3.zoom = t2.B.number(a3, l3, p4)), this._rotating && (s3.bearing = t2.B.number(o3, h3, p4)), this._pitching && (s3.pitch = t2.B.number(r3, c3, p4)), this._padding && (s3.interpolatePadding(n3, u3, p4), _3 = s3.centerPoint.add(d3)), this.terrain && !e2.freezeElevation && this._updateElevation(p4), x3) s3.setLocationAtPoint(x3, y3);
            else {
              const t3 = s3.zoomScale(s3.zoom - a3), e3 = l3 > a3 ? Math.min(2, v3) : Math.max(0.5, v3), i4 = Math.pow(e3, 1 - p4), o4 = s3.unproject(f3.add(g3.mult(p4 * i4)).mult(t3));
              s3.setLocationAtPoint(s3.renderWorldCopies ? o4.wrap() : o4, _3);
            }
            this._applyUpdatedTransform(s3), this._fireMoveEvents(i3);
          }, (t3) => {
            this.terrain && this._finalizeElevation(), this._afterEase(i3, t3);
          }, e2), this;
        }
        _prepareEase(e2, i3, s3 = {}) {
          this._moving = true, i3 || s3.moving || this.fire(new t2.k("movestart", e2)), this._zooming && !s3.zooming && this.fire(new t2.k("zoomstart", e2)), this._rotating && !s3.rotating && this.fire(new t2.k("rotatestart", e2)), this._pitching && !s3.pitching && this.fire(new t2.k("pitchstart", e2));
        }
        _prepareElevation(t3) {
          this._elevationCenter = t3, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t3, this.transform.tileZoom), this._elevationFreeze = true;
        }
        _updateElevation(e2) {
          this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          const i3 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (e2 < 1 && i3 !== this._elevationTarget) {
            const t3 = this._elevationTarget - this._elevationStart;
            this._elevationStart += e2 * (t3 - (i3 - (t3 * e2 + this._elevationStart)) / (1 - e2)), this._elevationTarget = i3;
          }
          this.transform.elevation = t2.B.number(this._elevationStart, this._elevationTarget, e2);
        }
        _finalizeElevation() {
          this._elevationFreeze = false, this.transform.recalculateZoom(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _applyUpdatedTransform(t3) {
          if (!this.transformCameraUpdate) return;
          const e2 = t3.clone(), { center: i3, zoom: s3, pitch: a3, bearing: o3, elevation: r3 } = this.transformCameraUpdate(e2);
          i3 && (e2.center = i3), void 0 !== s3 && (e2.zoom = s3), void 0 !== a3 && (e2.pitch = a3), void 0 !== o3 && (e2.bearing = o3), void 0 !== r3 && (e2.elevation = r3), this.transform.apply(e2);
        }
        _fireMoveEvents(e2) {
          this.fire(new t2.k("move", e2)), this._zooming && this.fire(new t2.k("zoom", e2)), this._rotating && this.fire(new t2.k("rotate", e2)), this._pitching && this.fire(new t2.k("pitch", e2));
        }
        _afterEase(e2, i3) {
          if (this._easeId && i3 && this._easeId === i3) return;
          delete this._easeId;
          const s3 = this._zooming, a3 = this._rotating, o3 = this._pitching;
          this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, s3 && this.fire(new t2.k("zoomend", e2)), a3 && this.fire(new t2.k("rotateend", e2)), o3 && this.fire(new t2.k("pitchend", e2)), this.fire(new t2.k("moveend", e2));
        }
        flyTo(e2, i3) {
          if (!e2.essential && t2.h.prefersReducedMotion) {
            const s4 = t2.F(e2, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(s4, i3);
          }
          this.stop(), e2 = t2.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t2.bb }, e2);
          const s3 = this._getTransformForUpdate(), a3 = this.getZoom(), o3 = this.getBearing(), r3 = this.getPitch(), n3 = this.getPadding(), l3 = "zoom" in e2 ? t2.ad(+e2.zoom, s3.minZoom, s3.maxZoom) : a3, h3 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, o3) : o3, c3 = "pitch" in e2 ? +e2.pitch : r3, u3 = "padding" in e2 ? e2.padding : s3.padding, d3 = s3.zoomScale(l3 - a3), _3 = t2.P.convert(e2.offset);
          let p3 = s3.centerPoint.add(_3);
          const m3 = s3.pointLocation(p3), f3 = t2.L.convert(e2.center || m3);
          this._normalizeCenter(f3);
          const g3 = s3.project(m3), v3 = s3.project(f3).sub(g3);
          let x3 = e2.curve;
          const y3 = Math.max(s3.width, s3.height), b3 = y3 / d3, w3 = v3.mag();
          if ("minZoom" in e2) {
            const i4 = t2.ad(Math.min(e2.minZoom, a3, l3), s3.minZoom, s3.maxZoom), o4 = y3 / s3.zoomScale(i4 - a3);
            x3 = Math.sqrt(o4 / w3 * 2);
          }
          const T3 = x3 * x3;
          function I3(t3) {
            const e3 = (b3 * b3 - y3 * y3 + (t3 ? -1 : 1) * T3 * T3 * w3 * w3) / (2 * (t3 ? b3 : y3) * T3 * w3);
            return Math.log(Math.sqrt(e3 * e3 + 1) - e3);
          }
          function E3(t3) {
            return (Math.exp(t3) - Math.exp(-t3)) / 2;
          }
          function S3(t3) {
            return (Math.exp(t3) + Math.exp(-t3)) / 2;
          }
          const C3 = I3(false);
          let P3 = function(t3) {
            return S3(C3) / S3(C3 + x3 * t3);
          }, D3 = function(t3) {
            return y3 * ((S3(C3) * (E3(e3 = C3 + x3 * t3) / S3(e3)) - E3(C3)) / T3) / w3;
            var e3;
          }, M3 = (I3(true) - C3) / x3;
          if (Math.abs(w3) < 1e-6 || !isFinite(M3)) {
            if (Math.abs(y3 - b3) < 1e-6) return this.easeTo(e2, i3);
            const t3 = b3 < y3 ? -1 : 1;
            M3 = Math.abs(Math.log(b3 / y3)) / x3, D3 = function() {
              return 0;
            }, P3 = function(e3) {
              return Math.exp(t3 * x3 * e3);
            };
          }
          return e2.duration = "duration" in e2 ? +e2.duration : 1e3 * M3 / ("screenSpeed" in e2 ? +e2.screenSpeed / x3 : +e2.speed), e2.maxDuration && e2.duration > e2.maxDuration && (e2.duration = 0), this._zooming = true, this._rotating = o3 !== h3, this._pitching = c3 !== r3, this._padding = !s3.isPaddingEqual(u3), this._prepareEase(i3, false), this.terrain && this._prepareElevation(f3), this._ease((d4) => {
            const m4 = d4 * M3, x4 = 1 / P3(m4);
            s3.zoom = 1 === d4 ? l3 : a3 + s3.scaleZoom(x4), this._rotating && (s3.bearing = t2.B.number(o3, h3, d4)), this._pitching && (s3.pitch = t2.B.number(r3, c3, d4)), this._padding && (s3.interpolatePadding(n3, u3, d4), p3 = s3.centerPoint.add(_3)), this.terrain && !e2.freezeElevation && this._updateElevation(d4);
            const y4 = 1 === d4 ? f3 : s3.unproject(g3.add(v3.mult(D3(m4))).mult(x4));
            s3.setLocationAtPoint(s3.renderWorldCopies ? y4.wrap() : y4, p3), this._applyUpdatedTransform(s3), this._fireMoveEvents(i3);
          }, () => {
            this.terrain && this._finalizeElevation(), this._afterEase(i3);
          }, e2), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(t3, e2) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const t4 = this._onEaseEnd;
            delete this._onEaseEnd, t4.call(this, e2);
          }
          if (!t3) {
            const t4 = this.handlers;
            t4 && t4.stop(false);
          }
          return this;
        }
        _ease(e2, i3, s3) {
          false === s3.animate || 0 === s3.duration ? (e2(1), i3()) : (this._easeStart = t2.h.now(), this._easeOptions = s3, this._onEaseFrame = e2, this._onEaseEnd = i3, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(e2, i3) {
          e2 = t2.b5(e2, -180, 180);
          const s3 = Math.abs(e2 - i3);
          return Math.abs(e2 - 360 - i3) < s3 && (e2 -= 360), Math.abs(e2 + 360 - i3) < s3 && (e2 += 360), e2;
        }
        _normalizeCenter(t3) {
          const e2 = this.transform;
          if (!e2.renderWorldCopies || e2.lngRange) return;
          const i3 = t3.lng - e2.center.lng;
          t3.lng += i3 > 180 ? -360 : i3 < -180 ? 360 : 0;
        }
        queryTerrainElevation(e2) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(t2.L.convert(e2), this.transform.tileZoom) - this.transform.elevation : null;
        }
      }
      class ra {
        constructor(t3 = {}) {
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (t4) => {
            !t4 || "metadata" !== t4.sourceDataType && "visibility" !== t4.sourceDataType && "style" !== t4.dataType && "terrain" !== t4.type || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = t3;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(t3) {
          return this._map = t3, this._compact = this.options && this.options.compact, this._container = i2.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = i2.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = i2.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          i2.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(t3, e2) {
          const i3 = this._map._getUIString(`AttributionControl.${e2}`);
          t3.title = i3, t3.setAttribute("aria-label", i3);
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let t3 = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t3 = t3.concat(this.options.customAttribution.map((t4) => "string" != typeof t4 ? "" : t4)) : "string" == typeof this.options.customAttribution && t3.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const t4 = this._map.style.stylesheet;
            this.styleOwner = t4.owner, this.styleId = t4.id;
          }
          const e2 = this._map.style.sourceCaches;
          for (const i4 in e2) {
            const s3 = e2[i4];
            if (s3.used || s3.usedForTerrain) {
              const e3 = s3.getSource();
              e3.attribution && t3.indexOf(e3.attribution) < 0 && t3.push(e3.attribution);
            }
          }
          t3 = t3.filter((t4) => String(t4).trim()), t3.sort((t4, e3) => t4.length - e3.length), t3 = t3.filter((e3, i4) => {
            for (let s3 = i4 + 1; s3 < t3.length; s3++) if (t3[s3].indexOf(e3) >= 0) return false;
            return true;
          });
          const i3 = t3.join(" | ");
          i3 !== this._attribHTML && (this._attribHTML = i3, t3.length ? (this._innerContainer.innerHTML = i3, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }
      class na {
        constructor(t3 = {}) {
          this._updateCompact = () => {
            const t4 = this._container.children;
            if (t4.length) {
              const e2 = t4[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && e2.classList.add("maplibregl-compact") : e2.classList.remove("maplibregl-compact");
            }
          }, this.options = t3;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(t3) {
          this._map = t3, this._compact = this.options && this.options.compact, this._container = i2.create("div", "maplibregl-ctrl");
          const e2 = i2.create("a", "maplibregl-ctrl-logo");
          return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://maplibre.org/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          i2.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
        }
      }
      class la {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        }
        add(t3) {
          const e2 = ++this._id;
          return this._queue.push({ callback: t3, id: e2, cancelled: false }), e2;
        }
        remove(t3) {
          const e2 = this._currentlyRunning, i3 = e2 ? this._queue.concat(e2) : this._queue;
          for (const e3 of i3) if (e3.id === t3) return void (e3.cancelled = true);
        }
        run(t3 = 0) {
          if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
          const e2 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const i3 of e2) if (!i3.cancelled && (i3.callback(t3), this._cleared)) break;
          this._cleared = false, this._currentlyRunning = false;
        }
        clear() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        }
      }
      const ha = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.enableTerrain": "Enable terrain", "TerrainControl.disableTerrain": "Disable terrain" };
      var ca = t2.Q([{ name: "a_pos3d", type: "Int16", components: 3 }]);
      class ua extends t2.E {
        constructor(t3) {
          super(), this.sourceCache = t3, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, t3.usedForTerrain = true, t3.tileSize = this.tileSize * 2 ** this.deltaZoom;
        }
        destruct() {
          this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
        }
        update(e2, i3) {
          this.sourceCache.update(e2, i3), this._renderableTilesKeys = [];
          const s3 = {};
          for (const a3 of e2.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i3 })) s3[a3.key] = true, this._renderableTilesKeys.push(a3.key), this._tiles[a3.key] || (a3.posMatrix = new Float64Array(16), t2.aS(a3.posMatrix, 0, t2.N, 0, t2.N, 0, 1), this._tiles[a3.key] = new W2(a3, this.tileSize));
          for (const t3 in this._tiles) s3[t3] || delete this._tiles[t3];
        }
        freeRtt(t3) {
          for (const e2 in this._tiles) {
            const i3 = this._tiles[e2];
            (!t3 || i3.tileID.equals(t3) || i3.tileID.isChildOf(t3) || t3.isChildOf(i3.tileID)) && (i3.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((t3) => this.getTileByID(t3));
        }
        getTileByID(t3) {
          return this._tiles[t3];
        }
        getTerrainCoords(e2) {
          const i3 = {};
          for (const s3 of this._renderableTilesKeys) {
            const a3 = this._tiles[s3].tileID;
            if (a3.canonical.equals(e2.canonical)) {
              const a4 = e2.clone();
              a4.posMatrix = new Float64Array(16), t2.aS(a4.posMatrix, 0, t2.N, 0, t2.N, 0, 1), i3[s3] = a4;
            } else if (a3.canonical.isChildOf(e2.canonical)) {
              const o3 = e2.clone();
              o3.posMatrix = new Float64Array(16);
              const r3 = a3.canonical.z - e2.canonical.z, n3 = a3.canonical.x - (a3.canonical.x >> r3 << r3), l3 = a3.canonical.y - (a3.canonical.y >> r3 << r3), h3 = t2.N >> r3;
              t2.aS(o3.posMatrix, 0, h3, 0, h3, 0, 1), t2.$(o3.posMatrix, o3.posMatrix, [-n3 * h3, -l3 * h3, 0]), i3[s3] = o3;
            } else if (e2.canonical.isChildOf(a3.canonical)) {
              const o3 = e2.clone();
              o3.posMatrix = new Float64Array(16);
              const r3 = e2.canonical.z - a3.canonical.z, n3 = e2.canonical.x - (e2.canonical.x >> r3 << r3), l3 = e2.canonical.y - (e2.canonical.y >> r3 << r3), h3 = t2.N >> r3;
              t2.aS(o3.posMatrix, 0, t2.N, 0, t2.N, 0, 1), t2.$(o3.posMatrix, o3.posMatrix, [n3 * h3, l3 * h3, 0]), t2.a0(o3.posMatrix, o3.posMatrix, [1 / 2 ** r3, 1 / 2 ** r3, 0]), i3[s3] = o3;
            }
          }
          return i3;
        }
        getSourceTile(t3, e2) {
          const i3 = this.sourceCache._source;
          let s3 = t3.overscaledZ - this.deltaZoom;
          if (s3 > i3.maxzoom && (s3 = i3.maxzoom), s3 < i3.minzoom) return null;
          this._sourceTileCache[t3.key] || (this._sourceTileCache[t3.key] = t3.scaledTo(s3).key);
          let a3 = this.sourceCache.getTileByID(this._sourceTileCache[t3.key]);
          if ((!a3 || !a3.dem) && e2) for (; s3 >= i3.minzoom && (!a3 || !a3.dem); ) a3 = this.sourceCache.getTileByID(t3.scaledTo(s3--).key);
          return a3;
        }
        tilesAfterTime(t3 = Date.now()) {
          return Object.values(this._tiles).filter((e2) => e2.timeAdded >= t3);
        }
      }
      class da {
        constructor(t3, e2, i3) {
          this.painter = t3, this.sourceCache = new ua(e2), this.options = i3, this.exaggeration = "number" == typeof i3.exaggeration ? i3.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(e2, i3, s3, a3 = t2.N) {
          var o3;
          if (!(i3 >= 0 && i3 < a3 && s3 >= 0 && s3 < a3)) return 0;
          const r3 = this.getTerrainData(e2), n3 = null === (o3 = r3.tile) || void 0 === o3 ? void 0 : o3.dem;
          if (!n3) return 0;
          const l3 = function(t3, e3, i4) {
            var s4 = e3[0], a4 = e3[1];
            return t3[0] = i4[0] * s4 + i4[4] * a4 + i4[12], t3[1] = i4[1] * s4 + i4[5] * a4 + i4[13], t3;
          }([], [i3 / a3 * t2.N, s3 / a3 * t2.N], r3.u_terrain_matrix), h3 = [l3[0] * n3.dim, l3[1] * n3.dim], c3 = Math.floor(h3[0]), u3 = Math.floor(h3[1]), d3 = h3[0] - c3, _3 = h3[1] - u3;
          return n3.get(c3, u3) * (1 - d3) * (1 - _3) + n3.get(c3 + 1, u3) * d3 * (1 - _3) + n3.get(c3, u3 + 1) * (1 - d3) * _3 + n3.get(c3 + 1, u3 + 1) * d3 * _3;
        }
        getElevationForLngLatZoom(e2, i3) {
          const { tileID: s3, mercatorX: a3, mercatorY: o3 } = this._getOverscaledTileIDFromLngLatZoom(e2, i3);
          return this.getElevation(s3, a3 % t2.N, o3 % t2.N, t2.N);
        }
        getElevation(e2, i3, s3, a3 = t2.N) {
          return this.getDEMElevation(e2, i3, s3, a3) * this.exaggeration;
        }
        getTerrainData(e2) {
          if (!this._emptyDemTexture) {
            const e3 = this.painter.context, i4 = new t2.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new x2(e3, i4, e3.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new x2(e3, new t2.R({ width: 1, height: 1 }), e3.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t2.ao([]);
          }
          const i3 = this.sourceCache.getSourceTile(e2, true);
          if (i3 && i3.dem && (!i3.demTexture || i3.needsTerrainPrepare)) {
            const t3 = this.painter.context;
            i3.demTexture = this.painter.getTileTexture(i3.dem.stride), i3.demTexture ? i3.demTexture.update(i3.dem.getPixels(), { premultiply: false }) : i3.demTexture = new x2(t3, i3.dem.getPixels(), t3.gl.RGBA, { premultiply: false }), i3.demTexture.bind(t3.gl.NEAREST, t3.gl.CLAMP_TO_EDGE), i3.needsTerrainPrepare = false;
          }
          const s3 = i3 && i3 + i3.tileID.key + e2.key;
          if (s3 && !this._demMatrixCache[s3]) {
            const s4 = this.sourceCache.sourceCache._source.maxzoom;
            let a3 = e2.canonical.z - i3.tileID.canonical.z;
            e2.overscaledZ > e2.canonical.z && (e2.canonical.z >= s4 ? a3 = e2.canonical.z - s4 : t2.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const o3 = e2.canonical.x - (e2.canonical.x >> a3 << a3), r3 = e2.canonical.y - (e2.canonical.y >> a3 << a3), n3 = t2.bc(new Float64Array(16), [1 / (t2.N << a3), 1 / (t2.N << a3), 0]);
            t2.$(n3, n3, [o3 * t2.N, r3 * t2.N, 0]), this._demMatrixCache[e2.key] = { matrix: n3, coord: e2 };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: i3 && i3.dem && i3.dem.dim || 1, u_terrain_matrix: s3 ? this._demMatrixCache[e2.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i3 && i3.dem && i3.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i3 && i3.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i3 };
        }
        getFramebuffer(t3) {
          const e2 = this.painter, i3 = e2.width / devicePixelRatio, s3 = e2.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === i3 && this._fbo.height === s3 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new x2(e2.context, { width: i3, height: s3, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new x2(e2.context, { width: i3, height: s3, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e2.context.createFramebuffer(i3, s3, true, false), this._fbo.depthAttachment.set(e2.context.createRenderbuffer(e2.context.gl.DEPTH_COMPONENT16, i3, s3))), this._fbo.colorAttachment.set("coords" === t3 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const e2 = this.painter.context;
          if (this._coordsTexture) return this._coordsTexture;
          const i3 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let t3 = 0, e3 = 0; t3 < this._coordsTextureSize; t3++) for (let s4 = 0; s4 < this._coordsTextureSize; s4++, e3 += 4) i3[e3 + 0] = 255 & s4, i3[e3 + 1] = 255 & t3, i3[e3 + 2] = s4 >> 8 << 4 | t3 >> 8, i3[e3 + 3] = 0;
          const s3 = new t2.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i3.buffer)), a3 = new x2(e2, s3, e2.gl.RGBA, { premultiply: false });
          return a3.bind(e2.gl.NEAREST, e2.gl.CLAMP_TO_EDGE), this._coordsTexture = a3, a3;
        }
        pointCoordinate(e2) {
          const i3 = new Uint8Array(4), s3 = this.painter.context, a3 = s3.gl;
          s3.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), a3.readPixels(e2.x, this.painter.height / devicePixelRatio - e2.y - 1, 1, 1, a3.RGBA, a3.UNSIGNED_BYTE, i3), s3.bindFramebuffer.set(null);
          const o3 = i3[0] + (i3[2] >> 4 << 8), r3 = i3[1] + ((15 & i3[2]) << 8), n3 = this.coordsIndex[255 - i3[3]], l3 = n3 && this.sourceCache.getTileByID(n3);
          if (!l3) return null;
          const h3 = this._coordsTextureSize, c3 = (1 << l3.tileID.canonical.z) * h3;
          return new t2.U(this._allowMercatorOverflow(e2, (l3.tileID.canonical.x * h3 + o3) / c3), (l3.tileID.canonical.y * h3 + r3) / c3, this.getElevation(l3.tileID, o3, r3, h3));
        }
        getTerrainMesh() {
          if (this._mesh) return this._mesh;
          const e2 = this.painter.context, i3 = new t2.bd(), s3 = new t2.b0(), a3 = this.meshSize, o3 = t2.N / a3, r3 = a3 * a3;
          for (let t3 = 0; t3 <= a3; t3++) for (let e3 = 0; e3 <= a3; e3++) i3.emplaceBack(e3 * o3, t3 * o3, 0);
          for (let t3 = 0; t3 < r3; t3 += a3 + 1) for (let e3 = 0; e3 < a3; e3++) s3.emplaceBack(e3 + t3, a3 + e3 + t3 + 1, a3 + e3 + t3 + 2), s3.emplaceBack(e3 + t3, a3 + e3 + t3 + 2, e3 + t3 + 1);
          const n3 = i3.length, l3 = n3 + 2 * (a3 + 1);
          for (const e3 of [0, 1]) for (let s4 = 0; s4 <= a3; s4++) for (const a4 of [0, 1]) i3.emplaceBack(s4 * o3, e3 * t2.N, a4);
          for (let t3 = 0; t3 < 2 * a3; t3 += 2) s3.emplaceBack(l3 + t3, l3 + t3 + 1, l3 + t3 + 3), s3.emplaceBack(l3 + t3, l3 + t3 + 3, l3 + t3 + 2), s3.emplaceBack(n3 + t3, n3 + t3 + 3, n3 + t3 + 1), s3.emplaceBack(n3 + t3, n3 + t3 + 2, n3 + t3 + 3);
          const h3 = i3.length, c3 = h3 + 2 * (a3 + 1);
          for (const e3 of [0, 1]) for (let s4 = 0; s4 <= a3; s4++) for (const a4 of [0, 1]) i3.emplaceBack(e3 * t2.N, s4 * o3, a4);
          for (let t3 = 0; t3 < 2 * a3; t3 += 2) s3.emplaceBack(h3 + t3, h3 + t3 + 1, h3 + t3 + 3), s3.emplaceBack(h3 + t3, h3 + t3 + 3, h3 + t3 + 2), s3.emplaceBack(c3 + t3, c3 + t3 + 3, c3 + t3 + 1), s3.emplaceBack(c3 + t3, c3 + t3 + 2, c3 + t3 + 3);
          return this._mesh = { indexBuffer: e2.createIndexBuffer(s3), vertexBuffer: e2.createVertexBuffer(i3, ca.members), segments: t2.S.simpleSegment(0, 0, i3.length, s3.length) }, this._mesh;
        }
        getMeshFrameDelta(e2) {
          return 2 * Math.PI * t2.be / Math.pow(2, e2) / 5;
        }
        getMinTileElevationForLngLatZoom(t3, e2) {
          var i3;
          const { tileID: s3 } = this._getOverscaledTileIDFromLngLatZoom(t3, e2);
          return null !== (i3 = this.getMinMaxElevation(s3).minElevation) && void 0 !== i3 ? i3 : 0;
        }
        getMinMaxElevation(t3) {
          const e2 = this.getTerrainData(t3).tile, i3 = { minElevation: null, maxElevation: null };
          return e2 && e2.dem && (i3.minElevation = e2.dem.min * this.exaggeration, i3.maxElevation = e2.dem.max * this.exaggeration), i3;
        }
        _getOverscaledTileIDFromLngLatZoom(e2, i3) {
          const s3 = t2.U.fromLngLat(e2.wrap()), a3 = (1 << i3) * t2.N, o3 = s3.x * a3, r3 = s3.y * a3, n3 = Math.floor(o3 / t2.N), l3 = Math.floor(r3 / t2.N);
          return { tileID: new t2.O(i3, 0, i3, n3, l3), mercatorX: o3, mercatorY: r3 };
        }
        _allowMercatorOverflow(e2, i3) {
          const s3 = e2.x < this.painter.width / 2;
          let a3 = t2.bf(i3);
          const o3 = this.painter.transform.center.lng;
          return s3 && Math.sign(a3) > 0 && Math.sign(o3) < 0 || !s3 && Math.sign(a3) < 0 && Math.sign(o3) > 0 ? (a3 = 360 * Math.sign(o3) + a3, t2.G(a3)) : i3;
        }
      }
      class _a2 {
        constructor(t3, e2, i3) {
          this._context = t3, this._size = e2, this._tileSize = i3, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const t3 of this._objects) t3.texture.destroy(), t3.fbo.destroy();
        }
        _createObject(t3) {
          const e2 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i3 = new x2(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return i3.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), e2.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), e2.colorAttachment.set(i3.texture), { id: t3, fbo: e2, texture: i3, stamp: -1, inUse: false };
        }
        getObjectForId(t3) {
          return this._objects[t3];
        }
        useObject(t3) {
          t3.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((e2) => t3.id !== e2), this._recentlyUsed.push(t3.id);
        }
        stampObject(t3) {
          t3.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const t4 of this._recentlyUsed) if (!this._objects[t4].inUse) return this._objects[t4];
          if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const t3 = this._createObject(this._objects.length);
          return this._objects.push(t3), t3;
        }
        freeObject(t3) {
          t3.inUse = false;
        }
        freeAllObjects() {
          for (const t3 of this._objects) this.freeObject(t3);
        }
        isFull() {
          return !(this._objects.length < this._size) && false === this._objects.some((t3) => !t3.inUse);
        }
      }
      const pa = { background: true, fill: true, line: true, raster: true, hillshade: true };
      class ma {
        constructor(t3, e2) {
          this.painter = t3, this.terrain = e2, this.pool = new _a2(t3.context, 30, e2.sourceCache.tileSize * e2.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(t3) {
          return this.pool.getObjectForId(t3.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(t3, e2) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t3._order.filter((i3) => !t3._layers[i3].isHidden(e2)), this._coordsDescendingInv = {};
          for (const e3 in t3.sourceCaches) {
            this._coordsDescendingInv[e3] = {};
            const i3 = t3.sourceCaches[e3].getVisibleCoordinates();
            for (const t4 of i3) {
              const i4 = this.terrain.sourceCache.getTerrainCoords(t4);
              for (const t5 in i4) this._coordsDescendingInv[e3][t5] || (this._coordsDescendingInv[e3][t5] = []), this._coordsDescendingInv[e3][t5].push(i4[t5]);
            }
          }
          this._coordsDescendingInvStr = {};
          for (const e3 of t3._order) {
            const i3 = t3._layers[e3], s3 = i3.source;
            if (pa[i3.type] && !this._coordsDescendingInvStr[s3]) {
              this._coordsDescendingInvStr[s3] = {};
              for (const t4 in this._coordsDescendingInv[s3]) this._coordsDescendingInvStr[s3][t4] = this._coordsDescendingInv[s3][t4].map((t5) => t5.key).sort().join();
            }
          }
          for (const t4 of this._renderableTiles) for (const e3 in this._coordsDescendingInvStr) {
            const i3 = this._coordsDescendingInvStr[e3][t4.tileID.key];
            i3 && i3 !== t4.rttCoords[e3] && (t4.rtt = []);
          }
        }
        renderLayer(e2) {
          if (e2.isHidden(this.painter.transform.zoom)) return false;
          const i3 = e2.type, s3 = this.painter, a3 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e2.id;
          if (pa[i3] && (this._prevType && pa[this._prevType] || this._stacks.push([]), this._prevType = i3, this._stacks[this._stacks.length - 1].push(e2.id), !a3)) return true;
          if (pa[this._prevType] || pa[i3] && a3) {
            this._prevType = i3;
            const e3 = this._stacks.length - 1, a4 = this._stacks[e3] || [];
            for (const i4 of this._renderableTiles) {
              if (this.pool.isFull() && (es(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(i4), i4.rtt[e3]) {
                const t3 = this.pool.getObjectForId(i4.rtt[e3].id);
                if (t3.stamp === i4.rtt[e3].stamp) {
                  this.pool.useObject(t3);
                  continue;
                }
              }
              const o3 = this.pool.getOrCreateFreeObject();
              this.pool.useObject(o3), this.pool.stampObject(o3), i4.rtt[e3] = { id: o3.id, stamp: o3.stamp }, s3.context.bindFramebuffer.set(o3.fbo.framebuffer), s3.context.clear({ color: t2.aT.transparent, stencil: 0 }), s3.currentStencilSource = void 0;
              for (let t3 = 0; t3 < a4.length; t3++) {
                const e4 = s3.style._layers[a4[t3]], r3 = e4.source ? this._coordsDescendingInv[e4.source][i4.tileID.key] : [i4.tileID];
                s3.context.viewport.set([0, 0, o3.fbo.width, o3.fbo.height]), s3._renderTileClippingMasks(e4, r3), s3.renderLayer(s3, s3.style.sourceCaches[e4.source], e4, r3), e4.source && (i4.rttCoords[e4.source] = this._coordsDescendingInvStr[e4.source][i4.tileID.key]);
              }
            }
            return es(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), pa[i3];
          }
          return false;
        }
      }
      const fa = e, ga = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: void 0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, maxTileCacheZoomLevels: t2.c.MAX_TILE_CACHE_ZOOM_LEVELS, localIdeographFontFamily: "sans-serif", transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, validateStyle: true, maxCanvasSize: [4096, 4096] }, va = (t3) => {
        t3.touchstart = t3.dragStart, t3.touchmoveWindow = t3.dragMove, t3.touchend = t3.dragEnd;
      }, xa = { showCompass: true, showZoom: true, visualizePitch: false };
      class ya {
        constructor(e2, s3, a3 = false) {
          this.mousedown = (e3) => {
            this.startMouse(t2.e({}, e3, { ctrlKey: true, preventDefault: () => e3.preventDefault() }), i2.mousePos(this.element, e3)), i2.addEventListener(window, "mousemove", this.mousemove), i2.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (t3) => {
            this.moveMouse(t3, i2.mousePos(this.element, t3));
          }, this.mouseup = (t3) => {
            this.mouseRotate.dragEnd(t3), this.mousePitch && this.mousePitch.dragEnd(t3), this.offTemp();
          }, this.touchstart = (t3) => {
            1 !== t3.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = i2.touchPos(this.element, t3.targetTouches)[0], this.startTouch(t3, this._startPos), i2.addEventListener(window, "touchmove", this.touchmove, { passive: false }), i2.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (t3) => {
            1 !== t3.targetTouches.length ? this.reset() : (this._lastPos = i2.touchPos(this.element, t3.targetTouches)[0], this.moveTouch(t3, this._lastPos));
          }, this.touchend = (t3) => {
            0 === t3.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10;
          const o3 = e2.dragRotate._mouseRotate.getClickTolerance(), r3 = e2.dragRotate._mousePitch.getClickTolerance();
          this.element = s3, this.mouseRotate = As({ clickTolerance: o3, enable: true }), this.touchRotate = (({ enable: t3, clickTolerance: e3, bearingDegreesPerPixelMoved: i3 = 0.8 }) => {
            const s4 = new zs();
            return new Ps({ clickTolerance: e3, move: (t4, e4) => ({ bearingDelta: (e4.x - t4.x) * i3 }), moveStateManager: s4, enable: t3, assignEvents: va });
          })({ clickTolerance: o3, enable: true }), this.map = e2, a3 && (this.mousePitch = Rs({ clickTolerance: r3, enable: true }), this.touchPitch = (({ enable: t3, clickTolerance: e3, pitchDegreesPerPixelMoved: i3 = -0.5 }) => {
            const s4 = new zs();
            return new Ps({ clickTolerance: e3, move: (t4, e4) => ({ pitchDelta: (e4.y - t4.y) * i3 }), moveStateManager: s4, enable: t3, assignEvents: va });
          })({ clickTolerance: r3, enable: true })), i2.addEventListener(s3, "mousedown", this.mousedown), i2.addEventListener(s3, "touchstart", this.touchstart, { passive: false }), i2.addEventListener(s3, "touchcancel", this.reset);
        }
        startMouse(t3, e2) {
          this.mouseRotate.dragStart(t3, e2), this.mousePitch && this.mousePitch.dragStart(t3, e2), i2.disableDrag();
        }
        startTouch(t3, e2) {
          this.touchRotate.dragStart(t3, e2), this.touchPitch && this.touchPitch.dragStart(t3, e2), i2.disableDrag();
        }
        moveMouse(t3, e2) {
          const i3 = this.map, { bearingDelta: s3 } = this.mouseRotate.dragMove(t3, e2) || {};
          if (s3 && i3.setBearing(i3.getBearing() + s3), this.mousePitch) {
            const { pitchDelta: s4 } = this.mousePitch.dragMove(t3, e2) || {};
            s4 && i3.setPitch(i3.getPitch() + s4);
          }
        }
        moveTouch(t3, e2) {
          const i3 = this.map, { bearingDelta: s3 } = this.touchRotate.dragMove(t3, e2) || {};
          if (s3 && i3.setBearing(i3.getBearing() + s3), this.touchPitch) {
            const { pitchDelta: s4 } = this.touchPitch.dragMove(t3, e2) || {};
            s4 && i3.setPitch(i3.getPitch() + s4);
          }
        }
        off() {
          const t3 = this.element;
          i2.removeEventListener(t3, "mousedown", this.mousedown), i2.removeEventListener(t3, "touchstart", this.touchstart, { passive: false }), i2.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), i2.removeEventListener(window, "touchend", this.touchend), i2.removeEventListener(t3, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          i2.enableDrag(), i2.removeEventListener(window, "mousemove", this.mousemove), i2.removeEventListener(window, "mouseup", this.mouseup), i2.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), i2.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let ba;
      function wa(e2, i3, s3) {
        if (e2 = new t2.L(e2.lng, e2.lat), i3) {
          const a3 = new t2.L(e2.lng - 360, e2.lat), o3 = new t2.L(e2.lng + 360, e2.lat), r3 = s3.locationPoint(e2).distSqr(i3);
          s3.locationPoint(a3).distSqr(i3) < r3 ? e2 = a3 : s3.locationPoint(o3).distSqr(i3) < r3 && (e2 = o3);
        }
        for (; Math.abs(e2.lng - s3.center.lng) > 180; ) {
          const t3 = s3.locationPoint(e2);
          if (t3.x >= 0 && t3.y >= 0 && t3.x <= s3.width && t3.y <= s3.height) break;
          e2.lng > s3.center.lng ? e2.lng -= 360 : e2.lng += 360;
        }
        return e2;
      }
      const Ta = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function Ia(t3, e2, i3) {
        const s3 = t3.classList;
        for (const t4 in Ta) s3.remove(`maplibregl-${i3}-anchor-${t4}`);
        s3.add(`maplibregl-${i3}-anchor-${e2}`);
      }
      class Ea extends t2.E {
        constructor(e2) {
          if (super(), this._onKeyPress = (t3) => {
            const e3 = t3.code, i3 = t3.charCode || t3.keyCode;
            "Space" !== e3 && "Enter" !== e3 && 32 !== i3 && 13 !== i3 || this.togglePopup();
          }, this._onMapClick = (t3) => {
            const e3 = t3.originalEvent.target, i3 = this._element;
            this._popup && (e3 === i3 || i3.contains(e3)) && this.togglePopup();
          }, this._update = (t3) => {
            if (!this._map) return;
            const e3 = this._map.loaded() && !this._map.isMoving();
            ("terrain" === (null == t3 ? void 0 : t3.type) || "render" === (null == t3 ? void 0 : t3.type) && !e3) && this._map.once("render", this._update), this._map.transform.renderWorldCopies && (this._lngLat = wa(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
            let s3 = "";
            "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? s3 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (s3 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let a3 = "";
            "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? a3 = "rotateX(0deg)" : "map" === this._pitchAlignment && (a3 = `rotateX(${this._map.getPitch()}deg)`), t3 && "moveend" !== t3.type || (this._pos = this._pos.round()), i2.setTransform(this._element, `${Ta[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${a3} ${s3}`), this._map.terrain && !this._opacityTimeout && (this._opacityTimeout = setTimeout(() => {
              const t4 = this._map.unproject(this._pos), e4 = 40075016686e-3 * Math.abs(Math.cos(this._lngLat.lat * Math.PI / 180)) / Math.pow(2, this._map.transform.tileZoom + 8);
              this._element.style.opacity = t4.distanceTo(this._lngLat) > 20 * e4 ? "0.2" : "1.0", this._opacityTimeout = null;
            }, 100));
          }, this._onMove = (e3) => {
            if (!this._isDragging) {
              const t3 = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = e3.point.dist(this._pointerdownPos) >= t3;
            }
            this._isDragging && (this._pos = e3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t2.k("dragstart"))), this.fire(new t2.k("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t2.k("dragend")), this._state = "inactive";
          }, this._addDragHandler = (t3) => {
            this._element.contains(t3.originalEvent.target) && (t3.preventDefault(), this._positionDelta = t3.point.sub(this._pos).add(this._offset), this._pointerdownPos = t3.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = e2 && e2.anchor || "center", this._color = e2 && e2.color || "#3FB1CE", this._scale = e2 && e2.scale || 1, this._draggable = e2 && e2.draggable || false, this._clickTolerance = e2 && e2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = e2 && e2.rotation || 0, this._rotationAlignment = e2 && e2.rotationAlignment || "auto", this._pitchAlignment = e2 && e2.pitchAlignment && "auto" !== e2.pitchAlignment ? e2.pitchAlignment : this._rotationAlignment, e2 && e2.element) this._element = e2.element, this._offset = t2.P.convert(e2 && e2.offset || [0, 0]);
          else {
            this._defaultMarker = true, this._element = i2.create("div"), this._element.setAttribute("aria-label", "Map marker");
            const s3 = i2.createNS("http://www.w3.org/2000/svg", "svg"), a3 = 41, o3 = 27;
            s3.setAttributeNS(null, "display", "block"), s3.setAttributeNS(null, "height", `${a3}px`), s3.setAttributeNS(null, "width", `${o3}px`), s3.setAttributeNS(null, "viewBox", `0 0 ${o3} ${a3}`);
            const r3 = i2.createNS("http://www.w3.org/2000/svg", "g");
            r3.setAttributeNS(null, "stroke", "none"), r3.setAttributeNS(null, "stroke-width", "1"), r3.setAttributeNS(null, "fill", "none"), r3.setAttributeNS(null, "fill-rule", "evenodd");
            const n3 = i2.createNS("http://www.w3.org/2000/svg", "g");
            n3.setAttributeNS(null, "fill-rule", "nonzero");
            const l3 = i2.createNS("http://www.w3.org/2000/svg", "g");
            l3.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l3.setAttributeNS(null, "fill", "#000000");
            const h3 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const t3 of h3) {
              const e3 = i2.createNS("http://www.w3.org/2000/svg", "ellipse");
              e3.setAttributeNS(null, "opacity", "0.04"), e3.setAttributeNS(null, "cx", "10.5"), e3.setAttributeNS(null, "cy", "5.80029008"), e3.setAttributeNS(null, "rx", t3.rx), e3.setAttributeNS(null, "ry", t3.ry), l3.appendChild(e3);
            }
            const c3 = i2.createNS("http://www.w3.org/2000/svg", "g");
            c3.setAttributeNS(null, "fill", this._color);
            const u3 = i2.createNS("http://www.w3.org/2000/svg", "path");
            u3.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), c3.appendChild(u3);
            const d3 = i2.createNS("http://www.w3.org/2000/svg", "g");
            d3.setAttributeNS(null, "opacity", "0.25"), d3.setAttributeNS(null, "fill", "#000000");
            const _3 = i2.createNS("http://www.w3.org/2000/svg", "path");
            _3.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d3.appendChild(_3);
            const p3 = i2.createNS("http://www.w3.org/2000/svg", "g");
            p3.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p3.setAttributeNS(null, "fill", "#FFFFFF");
            const m3 = i2.createNS("http://www.w3.org/2000/svg", "g");
            m3.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const f3 = i2.createNS("http://www.w3.org/2000/svg", "circle");
            f3.setAttributeNS(null, "fill", "#000000"), f3.setAttributeNS(null, "opacity", "0.25"), f3.setAttributeNS(null, "cx", "5.5"), f3.setAttributeNS(null, "cy", "5.5"), f3.setAttributeNS(null, "r", "5.4999962");
            const g3 = i2.createNS("http://www.w3.org/2000/svg", "circle");
            g3.setAttributeNS(null, "fill", "#FFFFFF"), g3.setAttributeNS(null, "cx", "5.5"), g3.setAttributeNS(null, "cy", "5.5"), g3.setAttributeNS(null, "r", "5.4999962"), m3.appendChild(f3), m3.appendChild(g3), n3.appendChild(l3), n3.appendChild(c3), n3.appendChild(d3), n3.appendChild(p3), n3.appendChild(m3), s3.appendChild(n3), s3.setAttributeNS(null, "height", a3 * this._scale + "px"), s3.setAttributeNS(null, "width", o3 * this._scale + "px"), this._element.appendChild(s3), this._offset = t2.P.convert(e2 && e2.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (t3) => {
            t3.preventDefault();
          }), this._element.addEventListener("mousedown", (t3) => {
            t3.preventDefault();
          }), Ia(this._element, this._anchor, "marker"), e2 && e2.className) for (const t3 of e2.className.split(" ")) this._element.classList.add(t3);
          this._popup = null;
        }
        addTo(t3) {
          return this.remove(), this._map = t3, t3.getCanvasContainer().appendChild(this._element), t3.on("move", this._update), t3.on("moveend", this._update), t3.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), i2.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(e2) {
          return this._lngLat = t2.L.convert(e2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(t3) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t3) {
            if (!("offset" in t3.options)) {
              const e2 = 38.1, i3 = 13.5, s3 = Math.abs(i3) / Math.SQRT2;
              t3.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -e2], "bottom-left": [s3, -1 * (e2 - i3 + s3)], "bottom-right": [-s3, -1 * (e2 - i3 + s3)], left: [i3, -1 * (e2 - i3)], right: [-i3, -1 * (e2 - i3)] } : this._offset;
            }
            this._popup = t3, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const t3 = this._popup;
          return t3 ? (t3.isOpen() ? t3.remove() : t3.addTo(this._map), this) : this;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(e2) {
          return this._offset = t2.P.convert(e2), this._update(), this;
        }
        addClassName(t3) {
          this._element.classList.add(t3);
        }
        removeClassName(t3) {
          this._element.classList.remove(t3);
        }
        toggleClassName(t3) {
          return this._element.classList.toggle(t3);
        }
        setDraggable(t3) {
          return this._draggable = !!t3, this._map && (t3 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(t3) {
          return this._rotation = t3 || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(t3) {
          return this._rotationAlignment = t3 || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(t3) {
          return this._pitchAlignment = t3 && "auto" !== t3 ? t3 : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
      }
      const Sa = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
      let Ca = 0, Pa = false;
      const Da = { maxWidth: 100, unit: "metric" };
      function Ma(t3, e2, i3) {
        const s3 = i3 && i3.maxWidth || 100, a3 = t3._container.clientHeight / 2, o3 = t3.unproject([0, a3]), r3 = t3.unproject([s3, a3]), n3 = o3.distanceTo(r3);
        if (i3 && "imperial" === i3.unit) {
          const i4 = 3.2808 * n3;
          i4 > 5280 ? za(e2, s3, i4 / 5280, t3._getUIString("ScaleControl.Miles")) : za(e2, s3, i4, t3._getUIString("ScaleControl.Feet"));
        } else i3 && "nautical" === i3.unit ? za(e2, s3, n3 / 1852, t3._getUIString("ScaleControl.NauticalMiles")) : n3 >= 1e3 ? za(e2, s3, n3 / 1e3, t3._getUIString("ScaleControl.Kilometers")) : za(e2, s3, n3, t3._getUIString("ScaleControl.Meters"));
      }
      function za(t3, e2, i3, s3) {
        const a3 = function(t4) {
          const e3 = Math.pow(10, `${Math.floor(t4)}`.length - 1);
          let i4 = t4 / e3;
          return i4 = i4 >= 10 ? 10 : i4 >= 5 ? 5 : i4 >= 3 ? 3 : i4 >= 2 ? 2 : i4 >= 1 ? 1 : function(t5) {
            const e4 = Math.pow(10, Math.ceil(-Math.log(t5) / Math.LN10));
            return Math.round(t5 * e4) / e4;
          }(i4), e3 * i4;
        }(i3);
        t3.style.width = e2 * (a3 / i3) + "px", t3.innerHTML = `${a3}&nbsp;${s3}`;
      }
      const La = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, Aa = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function Ra(e2) {
        if (e2) {
          if ("number" == typeof e2) {
            const i3 = Math.round(Math.abs(e2) / Math.SQRT2);
            return { center: new t2.P(0, 0), top: new t2.P(0, e2), "top-left": new t2.P(i3, i3), "top-right": new t2.P(-i3, i3), bottom: new t2.P(0, -e2), "bottom-left": new t2.P(i3, -i3), "bottom-right": new t2.P(-i3, -i3), left: new t2.P(e2, 0), right: new t2.P(-e2, 0) };
          }
          if (e2 instanceof t2.P || Array.isArray(e2)) {
            const i3 = t2.P.convert(e2);
            return { center: i3, top: i3, "top-left": i3, "top-right": i3, bottom: i3, "bottom-left": i3, "bottom-right": i3, left: i3, right: i3 };
          }
          return { center: t2.P.convert(e2.center || [0, 0]), top: t2.P.convert(e2.top || [0, 0]), "top-left": t2.P.convert(e2["top-left"] || [0, 0]), "top-right": t2.P.convert(e2["top-right"] || [0, 0]), bottom: t2.P.convert(e2.bottom || [0, 0]), "bottom-left": t2.P.convert(e2["bottom-left"] || [0, 0]), "bottom-right": t2.P.convert(e2["bottom-right"] || [0, 0]), left: t2.P.convert(e2.left || [0, 0]), right: t2.P.convert(e2.right || [0, 0]) };
        }
        return Ra(new t2.P(0, 0));
      }
      const ka = { extend: (e2, ...i3) => t2.e(e2, ...i3), run(t3) {
        t3();
      }, logToElement(t3, e2 = false, i3 = "log") {
        const s3 = window.document.getElementById(i3);
        s3 && (e2 && (s3.innerHTML = ""), s3.innerHTML += `<br>${t3}`);
      } }, Fa = e;
      class Ba {
        static get version() {
          return Fa;
        }
        static get workerCount() {
          return tt.workerCount;
        }
        static set workerCount(t3) {
          tt.workerCount = t3;
        }
        static get maxParallelImageRequests() {
          return t2.c.MAX_PARALLEL_IMAGE_REQUESTS;
        }
        static set maxParallelImageRequests(e2) {
          t2.c.MAX_PARALLEL_IMAGE_REQUESTS = e2;
        }
        static get workerUrl() {
          return t2.c.WORKER_URL;
        }
        static set workerUrl(e2) {
          t2.c.WORKER_URL = e2;
        }
        static addProtocol(e2, i3) {
          t2.c.REGISTERED_PROTOCOLS[e2] = i3;
        }
        static removeProtocol(e2) {
          delete t2.c.REGISTERED_PROTOCOLS[e2];
        }
      }
      return Ba.Map = class extends oa {
        constructor(e2) {
          if (t2.bg.mark(t2.bh.create), null != (e2 = t2.e({}, ga, e2)).minZoom && null != e2.maxZoom && e2.minZoom > e2.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (null != e2.minPitch && null != e2.maxPitch && e2.minPitch > e2.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (null != e2.minPitch && e2.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (null != e2.maxPitch && e2.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (super(new rs(e2.minZoom, e2.maxZoom, e2.minPitch, e2.maxPitch, e2.renderWorldCopies), { bearingSnap: e2.bearingSnap }), this._cooperativeGesturesOnWheel = (t3) => {
            this._onCooperativeGesture(t3, t3[this._metaKey], 1);
          }, this._contextLost = (e3) => {
            e3.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t2.k("webglcontextlost", { originalEvent: e3 }));
          }, this._contextRestored = (e3) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new t2.k("webglcontextrestored", { originalEvent: e3 }));
          }, this._onMapScroll = (t3) => {
            if (t3.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = e2.interactive, this._cooperativeGestures = e2.cooperativeGestures, this._metaKey = 0 === navigator.platform.indexOf("Mac") ? "metaKey" : "ctrlKey", this._maxTileCacheSize = e2.maxTileCacheSize, this._maxTileCacheZoomLevels = e2.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = e2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e2.preserveDrawingBuffer, this._antialias = e2.antialias, this._trackResize = e2.trackResize, this._bearingSnap = e2.bearingSnap, this._refreshExpiredTiles = e2.refreshExpiredTiles, this._fadeDuration = e2.fadeDuration, this._crossSourceCollisions = e2.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e2.collectResourceTiming, this._renderTaskQueue = new la(), this._controls = [], this._mapId = t2.a2(), this._locale = t2.e({}, ha, e2.locale), this._clickTolerance = e2.clickTolerance, this._overridePixelRatio = e2.pixelRatio, this._maxCanvasSize = e2.maxCanvasSize, this.transformCameraUpdate = e2.transformCameraUpdate, this._imageQueueHandle = h2.addThrottleControl(() => this.isMoving()), this._requestManager = new u2(e2.transformRequest), "string" == typeof e2.container) {
            if (this._container = document.getElementById(e2.container), !this._container) throw new Error(`Container '${e2.container}' not found.`);
          } else {
            if (!(e2.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = e2.container;
          }
          if (e2.maxBounds && this.setMaxBounds(e2.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
            this.painter.terrainFacilitator.dirty = true, this._update(true);
          }), this.once("idle", () => {
            this._idleTriggered = true;
          }), "undefined" != typeof window) {
            addEventListener("online", this._onWindowOnline, false);
            let t3 = false;
            const e3 = ns((t4) => {
              this._trackResize && !this._removed && this.resize(t4)._update();
            }, 50);
            this._resizeObserver = new ResizeObserver((i3) => {
              t3 ? e3(i3) : t3 = true;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new aa(this, e2), this._cooperativeGestures && this._setupCooperativeGestures(), this._hash = e2.hash && new ls("string" == typeof e2.hash && e2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e2.center, zoom: e2.zoom, bearing: e2.bearing, pitch: e2.pitch }), e2.bounds && (this.resize(), this.fitBounds(e2.bounds, t2.e({}, e2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e2.localIdeographFontFamily, this._validateStyle = e2.validateStyle, e2.style && this.setStyle(e2.style, { localIdeographFontFamily: e2.localIdeographFontFamily }), e2.attributionControl && this.addControl(new ra({ customAttribution: e2.customAttribution })), e2.maplibreLogo && this.addControl(new na(), e2.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (e3) => {
            this._update("style" === e3.dataType), this.fire(new t2.k(`${e3.dataType}data`, e3));
          }), this.on("dataloading", (e3) => {
            this.fire(new t2.k(`${e3.dataType}dataloading`, e3));
          }), this.on("dataabort", (e3) => {
            this.fire(new t2.k("sourcedataabort", e3));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(e2, i3) {
          if (void 0 === i3 && (i3 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd) return this.fire(new t2.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const s3 = e2.onAdd(this);
          this._controls.push(e2);
          const a3 = this._controlPositions[i3];
          return -1 !== i3.indexOf("bottom") ? a3.insertBefore(s3, a3.firstChild) : a3.appendChild(s3), this;
        }
        removeControl(e2) {
          if (!e2 || !e2.onRemove) return this.fire(new t2.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const i3 = this._controls.indexOf(e2);
          return i3 > -1 && this._controls.splice(i3, 1), e2.onRemove(this), this;
        }
        hasControl(t3) {
          return this._controls.indexOf(t3) > -1;
        }
        calculateCameraOptionsFromTo(t3, e2, i3, s3) {
          return null == s3 && this.terrain && (s3 = this.terrain.getElevationForLngLatZoom(i3, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(t3, e2, i3, s3);
        }
        resize(e2) {
          var i3;
          const s3 = this._containerDimensions(), a3 = s3[0], o3 = s3[1], r3 = this._getClampedPixelRatio(a3, o3);
          if (this._resizeCanvas(a3, o3, r3), this.painter.resize(a3, o3, r3), this.painter.overLimit()) {
            const t3 = this.painter.context.gl;
            this._maxCanvasSize = [t3.drawingBufferWidth, t3.drawingBufferHeight];
            const e3 = this._getClampedPixelRatio(a3, o3);
            this._resizeCanvas(a3, o3, e3), this.painter.resize(a3, o3, e3);
          }
          this.transform.resize(a3, o3), null === (i3 = this._requestedCameraState) || void 0 === i3 || i3.resize(a3, o3);
          const n3 = !this._moving;
          return n3 && (this.stop(), this.fire(new t2.k("movestart", e2)).fire(new t2.k("move", e2))), this.fire(new t2.k("resize", e2)), n3 && this.fire(new t2.k("moveend", e2)), this;
        }
        _getClampedPixelRatio(t3, e2) {
          const { 0: i3, 1: s3 } = this._maxCanvasSize, a3 = this.getPixelRatio(), o3 = t3 * a3, r3 = e2 * a3;
          return Math.min(o3 > i3 ? i3 / o3 : 1, r3 > s3 ? s3 / r3 : 1) * a3;
        }
        getPixelRatio() {
          var t3;
          return null !== (t3 = this._overridePixelRatio) && void 0 !== t3 ? t3 : devicePixelRatio;
        }
        setPixelRatio(t3) {
          this._overridePixelRatio = t3, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(t3) {
          return this.transform.setMaxBounds(L2.convert(t3)), this._update();
        }
        setMinZoom(t3) {
          if ((t3 = null == t3 ? -2 : t3) >= -2 && t3 <= this.transform.maxZoom) return this.transform.minZoom = t3, this._update(), this.getZoom() < t3 && this.setZoom(t3), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(t3) {
          if ((t3 = null == t3 ? 22 : t3) >= this.transform.minZoom) return this.transform.maxZoom = t3, this._update(), this.getZoom() > t3 && this.setZoom(t3), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(t3) {
          if ((t3 = null == t3 ? 0 : t3) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (t3 >= 0 && t3 <= this.transform.maxPitch) return this.transform.minPitch = t3, this._update(), this.getPitch() < t3 && this.setPitch(t3), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(t3) {
          if ((t3 = null == t3 ? 60 : t3) > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (t3 >= this.transform.minPitch) return this.transform.maxPitch = t3, this._update(), this.getPitch() > t3 && this.setPitch(t3), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(t3) {
          return this.transform.renderWorldCopies = t3, this._update();
        }
        getCooperativeGestures() {
          return this._cooperativeGestures;
        }
        setCooperativeGestures(t3) {
          return this._cooperativeGestures = t3, this._cooperativeGestures ? this._setupCooperativeGestures() : this._destroyCooperativeGestures(), this;
        }
        project(e2) {
          return this.transform.locationPoint(t2.L.convert(e2), this.style && this.terrain);
        }
        unproject(e2) {
          return this.transform.pointLocation(t2.P.convert(e2), this.terrain);
        }
        isMoving() {
          var t3;
          return this._moving || (null === (t3 = this.handlers) || void 0 === t3 ? void 0 : t3.isMoving());
        }
        isZooming() {
          var t3;
          return this._zooming || (null === (t3 = this.handlers) || void 0 === t3 ? void 0 : t3.isZooming());
        }
        isRotating() {
          var t3;
          return this._rotating || (null === (t3 = this.handlers) || void 0 === t3 ? void 0 : t3.isRotating());
        }
        _createDelegatedListener(t3, e2, i3) {
          if ("mouseenter" === t3 || "mouseover" === t3) {
            let s3 = false;
            const a3 = (a4) => {
              const o3 = this.getLayer(e2) ? this.queryRenderedFeatures(a4.point, { layers: [e2] }) : [];
              o3.length ? s3 || (s3 = true, i3.call(this, new gs(t3, this, a4.originalEvent, { features: o3 }))) : s3 = false;
            };
            return { layer: e2, listener: i3, delegates: { mousemove: a3, mouseout: () => {
              s3 = false;
            } } };
          }
          if ("mouseleave" === t3 || "mouseout" === t3) {
            let s3 = false;
            const a3 = (a4) => {
              (this.getLayer(e2) ? this.queryRenderedFeatures(a4.point, { layers: [e2] }) : []).length ? s3 = true : s3 && (s3 = false, i3.call(this, new gs(t3, this, a4.originalEvent)));
            }, o3 = (e3) => {
              s3 && (s3 = false, i3.call(this, new gs(t3, this, e3.originalEvent)));
            };
            return { layer: e2, listener: i3, delegates: { mousemove: a3, mouseout: o3 } };
          }
          {
            const s3 = (t4) => {
              const s4 = this.getLayer(e2) ? this.queryRenderedFeatures(t4.point, { layers: [e2] }) : [];
              s4.length && (t4.features = s4, i3.call(this, t4), delete t4.features);
            };
            return { layer: e2, listener: i3, delegates: { [t3]: s3 } };
          }
        }
        on(t3, e2, i3) {
          if (void 0 === i3) return super.on(t3, e2);
          const s3 = this._createDelegatedListener(t3, e2, i3);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t3] = this._delegatedListeners[t3] || [], this._delegatedListeners[t3].push(s3);
          for (const t4 in s3.delegates) this.on(t4, s3.delegates[t4]);
          return this;
        }
        once(t3, e2, i3) {
          if (void 0 === i3) return super.once(t3, e2);
          const s3 = this._createDelegatedListener(t3, e2, i3);
          for (const t4 in s3.delegates) this.once(t4, s3.delegates[t4]);
          return this;
        }
        off(t3, e2, i3) {
          return void 0 === i3 ? super.off(t3, e2) : (this._delegatedListeners && this._delegatedListeners[t3] && ((s3) => {
            const a3 = this._delegatedListeners[t3];
            for (let t4 = 0; t4 < a3.length; t4++) {
              const s4 = a3[t4];
              if (s4.layer === e2 && s4.listener === i3) {
                for (const t5 in s4.delegates) this.off(t5, s4.delegates[t5]);
                return a3.splice(t4, 1), this;
              }
            }
          })(), this);
        }
        queryRenderedFeatures(e2, i3) {
          if (!this.style) return [];
          let s3;
          const a3 = e2 instanceof t2.P || Array.isArray(e2), o3 = a3 ? e2 : [[0, 0], [this.transform.width, this.transform.height]];
          if (i3 = i3 || (a3 ? {} : e2) || {}, o3 instanceof t2.P || "number" == typeof o3[0]) s3 = [t2.P.convert(o3)];
          else {
            const e3 = t2.P.convert(o3[0]), i4 = t2.P.convert(o3[1]);
            s3 = [e3, new t2.P(i4.x, e3.y), i4, new t2.P(e3.x, i4.y), e3];
          }
          return this.style.queryRenderedFeatures(s3, i3, this.transform);
        }
        querySourceFeatures(t3, e2) {
          return this.style.querySourceFeatures(t3, e2);
        }
        setStyle(e2, i3) {
          return false !== (i3 = t2.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i3)).diff && i3.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e2 ? (this._diffStyle(e2, i3), this) : (this._localIdeographFontFamily = i3.localIdeographFontFamily, this._updateStyle(e2, i3));
        }
        setTransformRequest(t3) {
          return this._requestManager.setTransformRequest(t3), this;
        }
        _getUIString(t3) {
          const e2 = this._locale[t3];
          if (null == e2) throw new Error(`Missing UI string '${t3}'`);
          return e2;
        }
        _updateStyle(t3, e2) {
          if (e2.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(t3, e2));
          const i3 = this.style && e2.transformStyle ? this.style.serialize() : void 0;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!t3)), t3 ? (this.style = new se2(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t3 ? this.style.loadURL(t3, e2, i3) : this.style.loadJSON(t3, e2, i3), this) : (delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new se2(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(e2, i3) {
          if ("string" == typeof e2) {
            const s3 = this._requestManager.transformRequest(e2, c2.Style);
            t2.f(s3, (e3, s4) => {
              e3 ? this.fire(new t2.j(e3)) : s4 && this._updateDiff(s4, i3);
            });
          } else "object" == typeof e2 && this._updateDiff(e2, i3);
        }
        _updateDiff(e2, i3) {
          try {
            this.style.setState(e2, i3) && this._update(true);
          } catch (s3) {
            t2.w(`Unable to perform style diff: ${s3.message || s3.error || s3}.  Rebuilding the style from scratch.`), this._updateStyle(e2, i3);
          }
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : t2.w("There is no style added to the map.");
        }
        addSource(t3, e2) {
          return this._lazyInitEmptyStyle(), this.style.addSource(t3, e2), this._update(true);
        }
        isSourceLoaded(e2) {
          const i3 = this.style && this.style.sourceCaches[e2];
          if (void 0 !== i3) return i3.loaded();
          this.fire(new t2.j(new Error(`There is no source with ID '${e2}'`)));
        }
        setTerrain(e2) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e2) {
            const i3 = this.style.sourceCaches[e2.source];
            if (!i3) throw new Error(`cannot load terrain, because there exists no source with ID: ${e2.source}`);
            for (const i4 in this.style._layers) {
              const s3 = this.style._layers[i4];
              "hillshade" === s3.type && s3.source === e2.source && t2.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new da(this.painter, i3, e2), this.painter.renderToTexture = new ma(this.painter, this.terrain), this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (t3) => {
              "style" === t3.dataType ? this.terrain.sourceCache.freeRtt() : "source" === t3.dataType && t3.tile && (t3.sourceId !== e2.source || this._elevationFreeze || (this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(t3.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform._minEleveationForCurrentTile = 0, this.transform.elevation = 0;
          return this.fire(new t2.k("terrain", { terrain: e2 })), this;
        }
        getTerrain() {
          var t3, e2;
          return null !== (e2 = null === (t3 = this.terrain) || void 0 === t3 ? void 0 : t3.options) && void 0 !== e2 ? e2 : null;
        }
        areTilesLoaded() {
          const t3 = this.style && this.style.sourceCaches;
          for (const e2 in t3) {
            const i3 = t3[e2]._tiles;
            for (const t4 in i3) {
              const e3 = i3[t4];
              if ("loaded" !== e3.state && "errored" !== e3.state) return false;
            }
          }
          return true;
        }
        addSourceType(t3, e2, i3) {
          return this._lazyInitEmptyStyle(), this.style.addSourceType(t3, e2, i3);
        }
        removeSource(t3) {
          return this.style.removeSource(t3), this._update(true);
        }
        getSource(t3) {
          return this.style.getSource(t3);
        }
        addImage(e2, i3, s3 = {}) {
          const { pixelRatio: a3 = 1, sdf: o3 = false, stretchX: r3, stretchY: n3, content: l3 } = s3;
          if (this._lazyInitEmptyStyle(), !(i3 instanceof HTMLImageElement || t2.a(i3))) {
            if (void 0 === i3.width || void 0 === i3.height) return this.fire(new t2.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: s4, height: h3, data: c3 } = i3, u3 = i3;
              return this.style.addImage(e2, { data: new t2.R({ width: s4, height: h3 }, new Uint8Array(c3)), pixelRatio: a3, stretchX: r3, stretchY: n3, content: l3, sdf: o3, version: 0, userImage: u3 }), u3.onAdd && u3.onAdd(this, e2), this;
            }
          }
          {
            const { width: s4, height: h3, data: c3 } = t2.h.getImageData(i3);
            this.style.addImage(e2, { data: new t2.R({ width: s4, height: h3 }, c3), pixelRatio: a3, stretchX: r3, stretchY: n3, content: l3, sdf: o3, version: 0 });
          }
        }
        updateImage(e2, i3) {
          const s3 = this.style.getImage(e2);
          if (!s3) return this.fire(new t2.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const a3 = i3 instanceof HTMLImageElement || t2.a(i3) ? t2.h.getImageData(i3) : i3, { width: o3, height: r3, data: n3 } = a3;
          if (void 0 === o3 || void 0 === r3) return this.fire(new t2.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (o3 !== s3.data.width || r3 !== s3.data.height) return this.fire(new t2.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const l3 = !(i3 instanceof HTMLImageElement || t2.a(i3));
          return s3.data.replace(n3, l3), this.style.updateImage(e2, s3), this;
        }
        getImage(t3) {
          return this.style.getImage(t3);
        }
        hasImage(e2) {
          return e2 ? !!this.style.getImage(e2) : (this.fire(new t2.j(new Error("Missing required image id"))), false);
        }
        removeImage(t3) {
          this.style.removeImage(t3);
        }
        loadImage(t3, e2) {
          h2.getImage(this._requestManager.transformRequest(t3, c2.Image), e2);
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(t3, e2) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(t3, e2), this._update(true);
        }
        moveLayer(t3, e2) {
          return this.style.moveLayer(t3, e2), this._update(true);
        }
        removeLayer(t3) {
          return this.style.removeLayer(t3), this._update(true);
        }
        getLayer(t3) {
          return this.style.getLayer(t3);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(t3, e2, i3) {
          return this.style.setLayerZoomRange(t3, e2, i3), this._update(true);
        }
        setFilter(t3, e2, i3 = {}) {
          return this.style.setFilter(t3, e2, i3), this._update(true);
        }
        getFilter(t3) {
          return this.style.getFilter(t3);
        }
        setPaintProperty(t3, e2, i3, s3 = {}) {
          return this.style.setPaintProperty(t3, e2, i3, s3), this._update(true);
        }
        getPaintProperty(t3, e2) {
          return this.style.getPaintProperty(t3, e2);
        }
        setLayoutProperty(t3, e2, i3, s3 = {}) {
          return this.style.setLayoutProperty(t3, e2, i3, s3), this._update(true);
        }
        getLayoutProperty(t3, e2) {
          return this.style.getLayoutProperty(t3, e2);
        }
        setGlyphs(t3, e2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(t3, e2), this._update(true);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(t3, e2, i3 = {}) {
          return this._lazyInitEmptyStyle(), this.style.addSprite(t3, e2, i3, (t4) => {
            t4 || this._update(true);
          }), this;
        }
        removeSprite(t3) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(t3), this._update(true);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(t3, e2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSprite(t3, e2, (t4) => {
            t4 || this._update(true);
          }), this;
        }
        setLight(t3, e2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(t3, e2), this._update(true);
        }
        getLight() {
          return this.style.getLight();
        }
        setFeatureState(t3, e2) {
          return this.style.setFeatureState(t3, e2), this._update();
        }
        removeFeatureState(t3, e2) {
          return this.style.removeFeatureState(t3, e2), this._update();
        }
        getFeatureState(t3) {
          return this.style.getFeatureState(t3);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let t3 = 0, e2 = 0;
          return this._container && (t3 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t3, e2];
        }
        _setupContainer() {
          const t3 = this._container;
          t3.classList.add("maplibregl-map");
          const e2 = this._canvasContainer = i2.create("div", "maplibregl-canvas-container", t3);
          this._interactive && e2.classList.add("maplibregl-interactive"), this._canvas = i2.create("canvas", "maplibregl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
          const s3 = this._containerDimensions(), a3 = this._getClampedPixelRatio(s3[0], s3[1]);
          this._resizeCanvas(s3[0], s3[1], a3);
          const o3 = this._controlContainer = i2.create("div", "maplibregl-control-container", t3), r3 = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t4) => {
            r3[t4] = i2.create("div", `maplibregl-ctrl-${t4} `, o3);
          }), this._container.addEventListener("scroll", this._onMapScroll, false);
        }
        _setupCooperativeGestures() {
          this._cooperativeGesturesScreen = i2.create("div", "maplibregl-cooperative-gesture-screen", this._container);
          let t3 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.windowsHelpText ? this._cooperativeGestures.windowsHelpText : "Use Ctrl + scroll to zoom the map";
          0 === navigator.platform.indexOf("Mac") && (t3 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.macHelpText ? this._cooperativeGestures.macHelpText : "Use ⌘ + scroll to zoom the map"), this._cooperativeGesturesScreen.innerHTML = `
            <div class="maplibregl-desktop-message">${t3}</div>
            <div class="maplibregl-mobile-message">${"boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.mobileHelpText ? this._cooperativeGestures.mobileHelpText : "Use two fingers to move the map"}</div>
        `, this._cooperativeGesturesScreen.setAttribute("aria-hidden", "true"), this._canvasContainer.addEventListener("wheel", this._cooperativeGesturesOnWheel, false), this._canvasContainer.classList.add("maplibregl-cooperative-gestures");
        }
        _destroyCooperativeGestures() {
          i2.remove(this._cooperativeGesturesScreen), this._canvasContainer.removeEventListener("wheel", this._cooperativeGesturesOnWheel, false), this._canvasContainer.classList.remove("maplibregl-cooperative-gestures");
        }
        _resizeCanvas(t3, e2, i3) {
          this._canvas.width = Math.floor(i3 * t3), this._canvas.height = Math.floor(i3 * e2), this._canvas.style.width = `${t3}px`, this._canvas.style.height = `${e2}px`;
        }
        _setupPainter() {
          const t3 = { alpha: true, stencil: true, depth: true, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false };
          let e2 = null;
          this._canvas.addEventListener("webglcontextcreationerror", (i4) => {
            e2 = { requestedAttributes: t3 }, i4 && (e2.statusMessage = i4.statusMessage, e2.type = i4.type);
          }, { once: true });
          const i3 = this._canvas.getContext("webgl2", t3) || this._canvas.getContext("webgl", t3);
          if (!i3) {
            const t4 = "Failed to initialize WebGL";
            throw e2 ? (e2.message = t4, new Error(JSON.stringify(e2))) : new Error(t4);
          }
          this.painter = new is(i3, this.transform), s2.testSupport(i3);
        }
        _onCooperativeGesture(t3, e2, i3) {
          return !e2 && i3 < 2 && (this._cooperativeGesturesScreen.classList.add("maplibregl-show"), setTimeout(() => {
            this._cooperativeGesturesScreen.classList.remove("maplibregl-show");
          }, 100)), false;
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(t3) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || t3, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(t3) {
          return this._update(), this._renderTaskQueue.add(t3);
        }
        _cancelRenderFrame(t3) {
          this._renderTaskQueue.remove(t3);
        }
        _render(e2) {
          const i3 = this._idleTriggered ? this._fadeDuration : 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e2), this._removed) return;
          let s3 = false;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            const e3 = this.transform.zoom, a4 = t2.h.now();
            this.style.zoomHistory.update(e3, a4);
            const o3 = new t2.a8(e3, { now: a4, fadeDuration: i3, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), r3 = o3.crossFadingFactor();
            1 === r3 && r3 === this._crossFadingFactor || (s3 = true, this._crossFadingFactor = r3), this.style.update(o3);
          }
          this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform._minEleveationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, i3, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: i3, showPadding: this.showPadding }), this.fire(new t2.k("render")), this.loaded() && !this._loaded && (this._loaded = true, t2.bg.mark(t2.bh.load), this.fire(new t2.k("load"))), this.style && (this.style.hasTransitions() || s3) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const a3 = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return a3 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t2.k("idle")), !this._loaded || this._fullyLoaded || a3 || (this._fullyLoaded = true, t2.bg.mark(t2.bh.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;
        }
        remove() {
          var e2;
          this._hash && this._hash.remove();
          for (const t3 of this._controls) t3.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, false), h2.removeThrottleControl(this._imageQueueHandle), null === (e2 = this._resizeObserver) || void 0 === e2 || e2.disconnect();
          const s3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
          s3 && s3.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), i2.remove(this._canvasContainer), i2.remove(this._controlContainer), this._cooperativeGestures && this._destroyCooperativeGestures(), this._container.classList.remove("maplibregl-map"), t2.bg.clearMetrics(), this._removed = true, this.fire(new t2.k("remove"));
        }
        triggerRepaint() {
          this.style && !this._frame && (this._frame = t2.h.frame((e2) => {
            t2.bg.frame(e2), this._frame = null, this._render(e2);
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(t3) {
          this._showTileBoundaries !== t3 && (this._showTileBoundaries = t3, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(t3) {
          this._showPadding !== t3 && (this._showPadding = t3, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(t3) {
          this._showCollisionBoxes !== t3 && (this._showCollisionBoxes = t3, t3 ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(t3) {
          this._showOverdrawInspector !== t3 && (this._showOverdrawInspector = t3, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(t3) {
          this._repaint !== t3 && (this._repaint = t3, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(t3) {
          this._vertices = t3, this._update();
        }
        get version() {
          return fa;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
      }, Ba.NavigationControl = class {
        constructor(e2) {
          this._updateZoomButtons = () => {
            const t3 = this._map.getZoom(), e3 = t3 === this._map.getMaxZoom(), i3 = t3 === this._map.getMinZoom();
            this._zoomInButton.disabled = e3, this._zoomOutButton.disabled = i3, this._zoomInButton.setAttribute("aria-disabled", e3.toString()), this._zoomOutButton.setAttribute("aria-disabled", i3.toString());
          }, this._rotateCompassArrow = () => {
            const t3 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = t3;
          }, this._setButtonTitle = (t3, e3) => {
            const i3 = this._map._getUIString(`NavigationControl.${e3}`);
            t3.title = i3, t3.setAttribute("aria-label", i3);
          }, this.options = t2.e({}, xa, e2), this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t3) => this._map.zoomIn({}, { originalEvent: t3 })), i2.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t3) => this._map.zoomOut({}, { originalEvent: t3 })), i2.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t3) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t3 }) : this._map.resetNorth({}, { originalEvent: t3 });
          }), this._compassIcon = i2.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(t3) {
          return this._map = t3, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ya(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          i2.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(t3, e2) {
          const s3 = i2.create("button", t3, this._container);
          return s3.type = "button", s3.addEventListener("click", e2), s3;
        }
      }, Ba.GeolocateControl = class extends t2.E {
        constructor(e2) {
          super(), this._onSuccess = (e3) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(e3)) return this._setErrorState(), this.fire(new t2.k("outofmaxbounds", e3)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = e3, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t2.k("geolocate", e3)), this._finish();
            }
          }, this._updateCamera = (e3) => {
            const i3 = new t2.L(e3.coords.longitude, e3.coords.latitude), s3 = e3.coords.accuracy, a3 = this._map.getBearing(), o3 = t2.e({ bearing: a3 }, this.options.fitBoundsOptions), r3 = L2.fromLngLat(i3, s3);
            this._map.fitBounds(r3, o3, { geolocateSource: true });
          }, this._updateMarker = (e3) => {
            if (e3) {
              const i3 = new t2.L(e3.coords.longitude, e3.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i3).addTo(this._map), this._userLocationDotMarker.setLngLat(i3).addTo(this._map), this._accuracy = e3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (e3) => {
            if (this._map) {
              if (this.options.trackUserLocation) if (1 === e3.code) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = t3, this._geolocateButton.setAttribute("aria-label", t3), void 0 !== this._geolocationWatchID && this._clearWatch();
              } else {
                if (3 === e3.code && Pa) return;
                this._setErrorState();
              }
              "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t2.k("error", e3)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, this._setupUI = (e3) => {
            if (this._map) {
              if (this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this._geolocateButton = i2.create("button", "maplibregl-ctrl-geolocate", this._container), i2.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === e3) {
                t2.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4);
              } else {
                const t3 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.title = t3, this._geolocateButton.setAttribute("aria-label", t3);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = i2.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Ea({ element: this._dotElement }), this._circleElement = i2.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ea({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e4) => {
                e4.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e4.originalEvent && "resize" === e4.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t2.k("trackuserlocationend")));
              });
            }
          }, this.options = t2.e({}, Sa, e2);
        }
        onAdd(t3) {
          return this._map = t3, this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), function(t4, e2 = false) {
            void 0 === ba || e2 ? void 0 !== window.navigator.permissions ? window.navigator.permissions.query({ name: "geolocation" }).then((e3) => {
              ba = "denied" !== e3.state, t4(ba);
            }).catch(() => {
              ba = !!window.navigator.geolocation, t4(ba);
            }) : (ba = !!window.navigator.geolocation, t4(ba)) : t4(ba);
          }(this._setupUI), this._container;
        }
        onRemove() {
          void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), i2.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ca = 0, Pa = false;
        }
        _isOutOfMapMaxBounds(t3) {
          const e2 = this._map.getMaxBounds(), i3 = t3.coords;
          return e2 && (i3.longitude < e2.getWest() || i3.longitude > e2.getEast() || i3.latitude < e2.getSouth() || i3.latitude > e2.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const t3 = this._map.getBounds(), e2 = t3.getSouthEast(), i3 = t3.getNorthEast(), s3 = e2.distanceTo(i3), a3 = Math.ceil(this._accuracy / (s3 / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${a3}px`, this._circleElement.style.height = `${a3}px`;
        }
        trigger() {
          if (!this._setup) return t2.w("Geolocate control triggered before added to a map"), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new t2.k("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                Ca--, Pa = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t2.k("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t2.k("trackuserlocationstart"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
            else if (void 0 === this._geolocationWatchID) {
              let t3;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ca++, Ca > 1 ? (t3 = { maximumAge: 6e5, timeout: 0 }, Pa = true) : (t3 = this.options.positionOptions, Pa = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t3);
            }
          } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return true;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, Ba.AttributionControl = ra, Ba.LogoControl = na, Ba.ScaleControl = class {
        constructor(e2) {
          this._onMove = () => {
            Ma(this._map, this._container, this.options);
          }, this.setUnit = (t3) => {
            this.options.unit = t3, Ma(this._map, this._container, this.options);
          }, this.options = t2.e({}, Da, e2);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(t3) {
          return this._map = t3, this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", t3.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          i2.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }
      }, Ba.FullscreenControl = class extends t2.E {
        constructor(e2 = {}) {
          super(), this._onFullscreenChange = () => {
            (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = false, e2 && e2.container && (e2.container instanceof HTMLElement ? this._container = e2.container : t2.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(t3) {
          return this._map = t3, this._container || (this._container = this._map.getContainer()), this._controlContainer = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          i2.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const t3 = this._fullscreenButton = i2.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          i2.create("span", "maplibregl-ctrl-icon", t3).setAttribute("aria-hidden", "true"), t3.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const t3 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", t3), this._fullscreenButton.title = t3;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t2.k("fullscreenstart")), this._map._cooperativeGestures && (this._prevCooperativeGestures = this._map._cooperativeGestures, this._map.setCooperativeGestures())) : (this.fire(new t2.k("fullscreenend")), this._prevCooperativeGestures && (this._map.setCooperativeGestures(this._prevCooperativeGestures), delete this._prevCooperativeGestures));
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, Ba.TerrainControl = class {
        constructor(t3) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.disableTerrain")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.enableTerrain"));
          }, this.options = t3;
        }
        onAdd(t3) {
          return this._map = t3, this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = i2.create("button", "maplibregl-ctrl-terrain", this._container), i2.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          i2.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
        }
      }, Ba.Popup = class extends t2.E {
        constructor(e2) {
          super(), this.remove = () => (this._content && i2.remove(this._content), this._container && (i2.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t2.k("close")), this), this._onMouseUp = (t3) => {
            this._update(t3.point);
          }, this._onMouseMove = (t3) => {
            this._update(t3.point);
          }, this._onDrag = (t3) => {
            this._update(t3.point);
          }, this._update = (t3) => {
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
            if (!this._container) {
              if (this._container = i2.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = i2.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const t4 of this.options.className.split(" ")) this._container.classList.add(t4);
              this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = wa(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !t3) return;
            const e3 = this._pos = this._trackPointer && t3 ? t3 : this._map.project(this._lngLat);
            let s3 = this.options.anchor;
            const a3 = Ra(this.options.offset);
            if (!s3) {
              const t4 = this._container.offsetWidth, i3 = this._container.offsetHeight;
              let o4;
              o4 = e3.y + a3.bottom.y < i3 ? ["top"] : e3.y > this._map.transform.height - i3 ? ["bottom"] : [], e3.x < t4 / 2 ? o4.push("left") : e3.x > this._map.transform.width - t4 / 2 && o4.push("right"), s3 = 0 === o4.length ? "bottom" : o4.join("-");
            }
            const o3 = e3.add(a3[s3]).round();
            i2.setTransform(this._container, `${Ta[s3]} translate(${o3.x}px,${o3.y}px)`), Ia(this._container, s3, "popup");
          }, this._onClose = () => {
            this.remove();
          }, this.options = t2.e(Object.create(La), e2);
        }
        addTo(e2) {
          return this._map && this.remove(), this._map = e2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t2.k("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(e2) {
          return this._lngLat = t2.L.convert(e2), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(t3) {
          return this.setDOMContent(document.createTextNode(t3));
        }
        setHTML(t3) {
          const e2 = document.createDocumentFragment(), i3 = document.createElement("body");
          let s3;
          for (i3.innerHTML = t3; s3 = i3.firstChild, s3; ) e2.appendChild(s3);
          return this.setDOMContent(e2);
        }
        getMaxWidth() {
          var t3;
          return null === (t3 = this._container) || void 0 === t3 ? void 0 : t3.style.maxWidth;
        }
        setMaxWidth(t3) {
          return this.options.maxWidth = t3, this._update(), this;
        }
        setDOMContent(t3) {
          if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else this._content = i2.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(t3), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(t3) {
          this._container && this._container.classList.add(t3);
        }
        removeClassName(t3) {
          this._container && this._container.classList.remove(t3);
        }
        setOffset(t3) {
          return this.options.offset = t3, this._update(), this;
        }
        toggleClassName(t3) {
          if (this._container) return this._container.classList.toggle(t3);
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = i2.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          const t3 = this._container.querySelector(Aa);
          t3 && t3.focus();
        }
      }, Ba.Marker = Ea, Ba.Style = se2, Ba.LngLat = t2.L, Ba.LngLatBounds = L2, Ba.Point = t2.P, Ba.MercatorCoordinate = t2.U, Ba.Evented = t2.E, Ba.AJAXError = t2.bi, Ba.config = t2.c, Ba.CanvasSource = Z2, Ba.GeoJSONSource = B2, Ba.ImageSource = N2, Ba.RasterDEMTileSource = F2, Ba.RasterTileSource = k2, Ba.VectorTileSource = R2, Ba.VideoSource = U2, Ba.setRTLTextPlugin = t2.bj, Ba.getRTLTextPluginStatus = t2.bk, Ba.prewarm = function() {
        st().acquire(J2);
      }, Ba.clearPrewarmedResources = function() {
        const t3 = it;
        t3 && (t3.isPreloaded() && 1 === t3.numActive() ? (t3.release(J2), it = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, ka.extend(Ba, { isSafari: t2.ac, getPerformanceMetrics: t2.bg.getPerformanceMetrics }), Ba;
    });
    var maplibregl$1 = maplibregl;
    return maplibregl$1;
  });
})(maplibreGl);
var maplibreGlExports = maplibreGl.exports;
class LogicalLayerDefaultRenderer {
  constructor() {
    __publicField(this, "errorSetter", (e) => {
      console.warn(
        "Hook for renderer errors not installed. You must add it in logical layer by setErrorState method"
      );
    });
    /** Call it in renderer */
    __publicField(this, "onError", (e) => {
      if (e instanceof Error) {
        this.errorSetter(e);
      } else if (typeof e === "string") {
        this.errorSetter(new Error(e));
      } else {
        this.errorSetter(new Error("unknown"));
      }
    });
  }
  /** Call it in logical layer atom */
  setErrorState(cb) {
    this.errorSetter = cb;
  }
  setupExtension(atom2) {
    return;
  }
  willInit(args) {
    return;
  }
  willMount(args) {
    return;
  }
  willUnMount(args) {
    return;
  }
  willHide(args) {
    return;
  }
  willUnhide(args) {
    return;
  }
  willLegendUpdate(args) {
    return;
  }
  willSourceUpdate(args) {
    return;
  }
  willDestroy(args) {
    return;
  }
}
const LAYER_BIVARIATE_PREFIX = "bivariate-layer-";
const SOURCE_BIVARIATE_PREFIX = "bivariate-source-";
const categoriesSettings = {
  overlay: {
    name: TranslationService.t("categories.overlays"),
    openByDefault: true,
    mutuallyExclusive: false,
    order: 1
  },
  base: {
    name: TranslationService.t("categories.basemap"),
    openByDefault: false,
    mutuallyExclusive: true,
    order: 2
  }
};
const groupSettings = {
  layersInSelectedArea: {
    name: TranslationService.t("groups.layers_in_selected_area"),
    openByDefault: true,
    mutuallyExclusive: false,
    order: 0
  },
  user_layers: {
    name: TranslationService.t("groups.your_layers"),
    openByDefault: true,
    mutuallyExclusive: false,
    order: 1
  },
  bivariate: {
    name: TranslationService.t("groups.kontur_analytics"),
    openByDefault: true,
    mutuallyExclusive: true,
    order: 2
  },
  qa: {
    name: TranslationService.t("groups.qa"),
    openByDefault: true,
    mutuallyExclusive: false,
    order: 3
  },
  osmbasedmap: {
    name: TranslationService.t("groups.osmbasedmap"),
    openByDefault: false,
    mutuallyExclusive: false,
    order: 4
  },
  other: {
    name: TranslationService.t("groups.other"),
    openByDefault: false,
    mutuallyExclusive: false,
    order: 999
  },
  elevation: {
    name: TranslationService.t("groups.elevation"),
    openByDefault: true,
    mutuallyExclusive: false
  },
  photo: {
    name: TranslationService.t("groups.photo"),
    openByDefault: true,
    mutuallyExclusive: false
  },
  map: {
    name: TranslationService.t("groups.map"),
    openByDefault: true,
    mutuallyExclusive: false
  }
};
const layerTypesOrdered = [
  "background",
  "raster",
  "hillshade",
  "heatmap",
  "fill",
  "fill-extrusion",
  "line",
  "circle",
  "symbol",
  "custom"
];
class LayersOrderManager {
  constructor() {
    __publicField(this, "_baseMapFirstLayerIdx", null);
    __publicField(this, "_map", null);
    __publicField(this, "_layersSettings", null);
    __publicField(this, "_layersParentsIds", null);
    __publicField(this, "_unsubscribe", []);
    __publicField(this, "_typesOrder", [...layerTypesOrdered]);
    __publicField(this, "_awaitingTasks", /* @__PURE__ */ new Set());
  }
  init(map, mapLibreParentsIds2, layersSettingsAtom2) {
    this._map = map;
    this._unsubscribe.push(
      layersSettingsAtom2.subscribe(
        (layersSetting) => this._layersSettings = layersSetting
      )
    );
    this._layersParentsIds = mapLibreParentsIds2;
    this._baseMapFirstLayerIdx = (map.getStyle().layers ?? []).length - 1;
    this._awaitingTasks.forEach((task) => {
      this._awaitingTasks.delete(task);
      task(map);
    });
  }
  destroy() {
    this._unsubscribe.forEach((fn) => fn());
  }
  getIdToMountOnTypesTop(type, id, cb) {
    this._asyncWrap(type, id, cb, this._getIdToMountOnTypesTopSync.bind(this));
  }
  getIdToMountOnTypesBottom(type, id, cb) {
    this._asyncWrap(type, id, cb, this._getIdToMountOnTypesBottomSync.bind(this));
  }
  _getIdToMountOnTypesTopSync(map, type, id) {
    var _a2, _b, _c, _d;
    const orderedLayers = this._getMountedOrderedLayers(map);
    if (!(orderedLayers == null ? void 0 : orderedLayers.size)) return;
    const mountedLayersOfGivenType = orderedLayers.get(type);
    const givenLayerParentKey = (_a2 = this._layersParentsIds) == null ? void 0 : _a2.get(id);
    const givenLayerSettings = (_c = (_b = this._layersSettings) == null ? void 0 : _b.get(givenLayerParentKey || "")) == null ? void 0 : _c.data;
    if (!givenLayerSettings) {
      console.warn("settings were not found for layer ", type, id);
      return;
    }
    const givenCategory = givenLayerSettings.category;
    const higherLayerOfGivenType = mountedLayersOfGivenType == null ? void 0 : mountedLayersOfGivenType.find((searchingLayer) => {
      if (givenCategory === "base") return searchingLayer.category !== "base";
      if (givenCategory === "overlay") return searchingLayer.category === void 0;
    });
    if (givenCategory && higherLayerOfGivenType) {
      return higherLayerOfGivenType.layer.id;
    }
    if (!higherLayerOfGivenType || !givenCategory) {
      const higherMountedType = this._typesOrder.slice(this._typesOrder.indexOf(type) + 1).find((higherType) => {
        var _a3;
        return (_a3 = orderedLayers.get(higherType)) == null ? void 0 : _a3.length;
      });
      if (!higherMountedType) return void 0;
      const higherMountedLayer = (_d = orderedLayers.get(higherMountedType)) == null ? void 0 : _d[0].layer.id;
      return higherMountedLayer;
    }
  }
  _getIdToMountOnTypesBottomSync(map, type, id) {
    var _a2, _b, _c, _d;
    const orderedLayers = this._getMountedOrderedLayers(map);
    if (!(orderedLayers == null ? void 0 : orderedLayers.size)) return;
    const mountedLayersOfGivenType = orderedLayers.get(type);
    const givenLayerParentKey = (_a2 = this._layersParentsIds) == null ? void 0 : _a2.get(id);
    const givenLayerSettings = (_c = (_b = this._layersSettings) == null ? void 0 : _b.get(givenLayerParentKey || "")) == null ? void 0 : _c.data;
    if (!givenLayerSettings) {
      console.warn("settings were not found for layer ", type, id);
      return;
    }
    const givenCategory = givenLayerSettings.category;
    const firstLayerOfNextCategory = (() => {
      if (givenCategory === "base") return mountedLayersOfGivenType == null ? void 0 : mountedLayersOfGivenType[0];
      if (givenCategory === "overlay")
        return mountedLayersOfGivenType == null ? void 0 : mountedLayersOfGivenType.find(
          (searchingLayer) => searchingLayer.category === "overlay" || searchingLayer.category === void 0
        );
      if (givenCategory === void 0)
        return mountedLayersOfGivenType == null ? void 0 : mountedLayersOfGivenType.find(
          (searchingLayer) => searchingLayer.category === void 0
        );
    })();
    if (firstLayerOfNextCategory) return firstLayerOfNextCategory.layer.id;
    if (!(mountedLayersOfGivenType == null ? void 0 : mountedLayersOfGivenType.length) || !firstLayerOfNextCategory) {
      const higherMountedType = this._typesOrder.slice(this._typesOrder.indexOf(type) + 1).find((higherType) => {
        var _a3;
        return (_a3 = orderedLayers.get(higherType)) == null ? void 0 : _a3.length;
      });
      if (!higherMountedType) return void 0;
      const higherMountedLayer = (_d = orderedLayers.get(higherMountedType)) == null ? void 0 : _d[0].layer.id;
      return higherMountedLayer;
    }
  }
  _getMountedOrderedLayers(map) {
    if (this._baseMapFirstLayerIdx === null) return;
    const allLayers = map.getStyle().layers ?? [];
    if (allLayers.length === 0) {
      return void 0;
    }
    const customLayers = allLayers.slice(this._baseMapFirstLayerIdx + 1);
    if (!customLayers.length) return void 0;
    const mountedOrderedLayers = /* @__PURE__ */ new Map();
    customLayers.forEach((layer) => {
      var _a2, _b, _c, _d;
      const layerParentId = (_a2 = this._layersParentsIds) == null ? void 0 : _a2.get(layer.id);
      if (!layerParentId) return console.warn("id was not found for", layer.id, layer);
      const orderedLayersUnderSameType = mountedOrderedLayers.get(layer.type) || [];
      orderedLayersUnderSameType.push({
        layer,
        category: (_d = (_c = (_b = this._layersSettings) == null ? void 0 : _b.get(layerParentId)) == null ? void 0 : _c.data) == null ? void 0 : _d.category
      });
      mountedOrderedLayers.set(layer.type, orderedLayersUnderSameType);
    });
    return mountedOrderedLayers;
  }
  _asyncWrap(type, id, cb, syncFunction) {
    const map = this._map;
    if (map === null || this._baseMapFirstLayerIdx === null) {
      this._awaitingTasks.add((map2) => {
        cb(syncFunction(map2, type, id));
      });
    } else {
      cb(syncFunction(map, type, id));
    }
  }
}
const layersOrderManager = new LayersOrderManager();
const mapLibreParentsIds = /* @__PURE__ */ new Map();
function layerByOrder(map, layersOrderManager$1 = layersOrderManager) {
  function addAboveLayerWithSameType(maplibreLayer, uiLayerId) {
    mapLibreParentsIds.set(maplibreLayer.id, uiLayerId);
    layersOrderManager$1.getIdToMountOnTypesTop(
      maplibreLayer.type,
      maplibreLayer.id,
      (id) => map.addLayer(maplibreLayer, id)
    );
  }
  function addUnderLayerWithSameType(maplibreLayer, uiLayerId) {
    mapLibreParentsIds.set(maplibreLayer.id, uiLayerId);
    layersOrderManager$1.getIdToMountOnTypesBottom(
      maplibreLayer.type,
      maplibreLayer.id,
      (id) => map.addLayer(maplibreLayer, id)
    );
  }
  function addAboveAllExistingLayers(maplibreLayer, uiLayerId) {
    mapLibreParentsIds.set(maplibreLayer.id, uiLayerId);
    map.addLayer(maplibreLayer, void 0);
  }
  return {
    addAboveLayerWithSameType,
    addUnderLayerWithSameType,
    addAboveAllExistingLayers
  };
}
const waitMapEvent = (map, event2) => new Promise((res, rej) => {
  try {
    map.on(event2, res);
  } catch (error2) {
    rej(error2);
  }
});
function mapLoaded(map) {
  if (!map._loaded) {
    return waitMapEvent(map, "load");
  }
  return;
}
const defaultListeners = {
  click: [],
  mousemove: [],
  mouseleave: []
};
function registerMapListener(eventType, listener, priority1to100 = 50, layerId) {
  mapListenersAtom.addMapListener.dispatch(eventType, listener, priority1to100);
  return () => {
    mapListenersAtom.removeMapListener.dispatch(eventType, listener);
  };
}
const mapListenersAtom = createAtom(
  {
    addMapListener: (eventType, listener, priority) => ({
      eventType,
      listener,
      priority
    }),
    removeMapListener: (eventType, listener) => ({
      eventType,
      listener
    })
  },
  ({ onAction }, state = defaultListeners) => {
    onAction("addMapListener", ({ eventType, listener, priority }) => {
      const listenerCategory = [...state[eventType]];
      if (!listenerCategory.length) listenerCategory.push({ listener, priority });
      else
        for (let i2 = 0; i2 < listenerCategory.length; i2++) {
          const listenerWrap = listenerCategory[i2];
          if (priority < listenerWrap.priority) {
            listenerCategory.splice(i2, 0, { listener, priority });
            break;
          } else if (listenerWrap.priority === priority) {
            listenerCategory.splice(i2 + 1, 0, { listener, priority });
            break;
          } else if (!listenerCategory[i2 + 1]) {
            listenerCategory.push({ listener, priority });
            break;
          } else if (priority > listenerWrap.priority && priority < listenerCategory[i2 + 1].priority) {
            listenerCategory.splice(i2 + 1, 0, { listener, priority });
            break;
          }
        }
      state = { ...state, [eventType]: listenerCategory };
    });
    onAction(
      "removeMapListener",
      ({ eventType, listener }) => state[eventType] = state[eventType].filter((l2) => l2.listener !== listener)
    );
    return state;
  },
  "[Shared state] mapListenersAtom"
);
const tootipRoot = "_tootipRoot_i3o78_1";
const hexagon = "_hexagon_i3o78_5";
const labels = "_labels_i3o78_28";
const column$2 = "_column_i3o78_34";
const bivariateHexagonPopupContentRoot$1 = "_bivariateHexagonPopupContentRoot_i3o78_45";
const s$6 = {
  tootipRoot,
  hexagon,
  labels,
  column: column$2,
  bivariateHexagonPopupContentRoot: bivariateHexagonPopupContentRoot$1
};
const bivariateHexagonPopupContentRoot = s$6.bivariateHexagonPopupContentRoot;
const getXIndicatorLabelByindex = (index2) => {
  if (isBottomSide(index2)) return LOW;
  if (isTopSide(index2)) return HIGH;
  return MEDIUM;
};
const getYIndicatorLabelByindex = (index2) => {
  if (isLeftSide(index2)) return LOW;
  if (isRightSide(index2)) return HIGH;
  return MEDIUM;
};
const MapHexTooltip = ({
  hexagonColor,
  axis: axis2,
  cellIndex,
  cellLabel,
  values
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$6.tootipRoot, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$6.hexagon, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { background: hexagonColor }, children: cellLabel }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$6.labels, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$6.column, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: axis2.x.label || formatBivariateAxisLabel(axis2.x.quotients) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: axis2.y.label || formatBivariateAxisLabel(axis2.y.quotients) })
      ] }),
      values && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$6.column, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: values.x }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: values.y })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$6.column, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: getXIndicatorLabelByindex(cellIndex) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: getYIndicatorLabelByindex(cellIndex) })
      ] })
    ] })
  ] });
};
createAtom(
  {
    set: (episodeId) => episodeId,
    reset: () => null
  },
  ({ onAction }, state = null) => {
    onAction("set", (episodeId) => state = { id: episodeId });
    onAction("reset", () => state = null);
    return state;
  },
  "[Shared state] currentEpisodeAtom"
);
function getMapPaddings(map, debug = false) {
  const blankSpaceEl = document.getElementById(configRepo.get().mapBlankSpaceId);
  if (blankSpaceEl === null) {
    console.warn("getMapPaddings::Cannot find map blank space element");
    return {
      top: 0,
      bottom: 0,
      right: 0,
      left: 0
    };
  }
  const mapCanvasEl = map._canvas;
  if (!mapCanvasEl) {
    console.warn("getMapPaddings::Cannot find map canvas element");
    return {
      top: 0,
      bottom: 0,
      right: 0,
      left: 0
    };
  }
  const blankRect = blankSpaceEl.getBoundingClientRect();
  const mapRect = mapCanvasEl.getBoundingClientRect();
  const top = Math.max(blankRect.top - mapRect.top, 0);
  const right = Math.max(mapRect.right - blankRect.right, 0);
  const bottom = Math.max(mapRect.bottom - blankRect.bottom, 0);
  const left = Math.max(blankRect.left - mapRect.left, 0);
  return { top, right, bottom, left };
}
function getCameraForBbox(bbox, map) {
  const camera = map.cameraForBounds(bbox, {
    padding: getMapPaddings(map)
  });
  if (!camera) {
    return map.cameraForBounds(bbox);
  }
  return camera;
}
const mountedLayersAtom = createMapAtom(
  /* @__PURE__ */ new Map(),
  "mountedLayers"
);
let _lastUpdatedState_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = mountedLayersAtom.getState();
mountedLayersAtom.subscribe((s2) => {
  _lastUpdatedState_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = s2;
});
const currentMapAtom = createAtom(
  {
    setMap: (map) => map,
    resetMap: () => null
  },
  ({ onAction, schedule }, state = null) => {
    onAction("setMap", (map) => {
      if (map !== state) {
        state = map;
        schedule((dispatch) => {
          dispatch(mountedLayersAtom.clear());
        });
      }
    });
    onAction("resetMap", () => {
      state = null;
      schedule((dispatch) => {
        dispatch(mountedLayersAtom.clear());
      });
    });
    return state;
  },
  "[Shared state] currentMapAtom"
);
createAtom(
  {
    setCurrentMapPosition: (mapPosition) => mapPosition,
    setCurrentMapBbox: (mapBbox) => mapBbox
  },
  ({ onAction }, state = null) => {
    onAction("setCurrentMapPosition", (position) => {
      if (state === null || !("lng" in state)) {
        state = position;
      } else {
        const { lat, lng, zoom } = position;
        if ("lng" in state && (state.lat !== lat || state.lng !== lng || state.zoom !== zoom)) {
          state = position;
        }
      }
    });
    onAction("setCurrentMapBbox", (bbox) => {
      var _a2;
      const position = { bbox: bbox.flat() };
      const prev = state;
      if (prev === null || !("bbox" in prev)) {
        state = position;
      } else {
        if ("bbox" in prev && ((_a2 = prev == null ? void 0 : prev.bbox) == null ? void 0 : _a2.some((coord, i2) => coord !== position.bbox[i2]))) {
          state = position;
        }
      }
      const map = currentMapAtom.getState();
      if (!map) return;
      const cam = getCameraForBbox(bbox, map);
      if (cam.center && "lng" in cam.center) {
        const { zoom } = cam;
        const { lat, lng } = cam.center;
        if (prev == null || "lng" in prev && (prev.lat !== lat || prev.lng !== lng || prev.zoom !== zoom)) {
          state = { ...position, lat, lng, zoom };
        }
      }
    });
    return state;
  },
  "[Shared state] currentMapPositionAtom"
);
createAtom(
  {
    setUser: (user = configRepo.get().initialUser) => user
  },
  ({ onAction }, state = configRepo.get().initialUser) => {
    onAction("setUser", (usr) => {
      if (usr) {
        state = usr;
      } else {
        state = configRepo.get().initialUser;
      }
    });
    return state;
  },
  "[Shared state] currentUserAtom"
);
const defaultSettings$1 = categoriesSettings;
const settingsMock$1 = new Proxy(defaultSettings$1, {
  get(target, prop, receiver) {
    const originalValue = Reflect.get(target, prop, receiver);
    if (originalValue) return originalValue;
    return {
      name: prop,
      openByDefault: true,
      mutuallyExclusive: false,
      order: 100
    };
  },
  set(target, prop, val, receiver) {
    return Reflect.set(target, prop, val, receiver);
  }
});
const layersCategoriesSettingsAtom = createAtom(
  {},
  ({}, state = settingsMock$1) => {
    return state;
  },
  "layersCategoriesSettingsAtom"
);
const defaultSettings = groupSettings;
const settingsMock = new Proxy(defaultSettings, {
  get(target, prop, receiver) {
    const originalValue = Reflect.get(target, prop, receiver);
    if (originalValue) return originalValue;
    return {
      name: prop,
      openByDefault: true,
      mutuallyExclusive: false,
      order: 100
    };
  },
  set(target, prop, val, receiver) {
    return Reflect.set(target, prop, val, receiver);
  }
});
const layersGroupsSettingsAtom = createAtom(
  {},
  ({}, state = settingsMock) => {
    return state;
  },
  "layersGroupsSettingsAtom"
);
const episodesPanelState = createAtom(
  {
    open: () => null,
    close: () => null
  },
  ({ onAction }, state = { isOpen: false }) => {
    onAction("open", () => state = { ...state, isOpen: true });
    onAction("close", () => state = { ...state, isOpen: false });
    return state;
  },
  "episodesPanelState"
);
const FeatureFlag = AppFeature;
const featureFlagsAtom = createAtom(
  {},
  (_2, state = { ...configRepo.get().features }) => {
    return state;
  },
  "[Shared state] featureFlagsAtom"
);
const SOURCE_LAYER_BIVARIATE = "stats";
const FALLBACK_BIVARIATE_MIN_ZOOM = 0;
const FALLBACK_BIVARIATE_MAX_ZOOM = 22;
const FEATURE_STATES = {
  hover: "hover",
  active: "active"
};
const H3_HOVER_LAYER = {
  type: "line",
  layout: {},
  paint: {
    "line-color": [
      "case",
      // prettier-ignore :active
      ["==", ["feature-state", FEATURE_STATES.active], true],
      "rgba(5, 22, 38, 1)",
      // prettier-ignore :hover
      ["==", ["feature-state", FEATURE_STATES.hover], true],
      "rgba(5, 22, 38, 0.4)",
      // not selected
      "rgba(0, 0, 0, 0)"
    ],
    "line-width": 1
  }
};
const DEFAULT_GREEN = "rgba(90, 200, 127, 0.5)";
const DEFAULT_RED = "rgba(228, 26, 28, 0.5)";
const sentimentDefault = ["bad", "good"];
const sentimentReversed = ["good", "bad"];
var double = { exports: {} };
double.exports;
(function(module) {
  var hasTypedArrays = false;
  if (typeof Float64Array !== "undefined") {
    var DOUBLE_VIEW = new Float64Array(1), UINT_VIEW = new Uint32Array(DOUBLE_VIEW.buffer);
    DOUBLE_VIEW[0] = 1;
    hasTypedArrays = true;
    if (UINT_VIEW[1] === 1072693248) {
      let toDoubleLE = function(lo, hi) {
        UINT_VIEW[0] = lo;
        UINT_VIEW[1] = hi;
        return DOUBLE_VIEW[0];
      }, lowUintLE = function(n2) {
        DOUBLE_VIEW[0] = n2;
        return UINT_VIEW[0];
      }, highUintLE = function(n2) {
        DOUBLE_VIEW[0] = n2;
        return UINT_VIEW[1];
      };
      module.exports = function doubleBitsLE(n2) {
        DOUBLE_VIEW[0] = n2;
        return [UINT_VIEW[0], UINT_VIEW[1]];
      };
      module.exports.pack = toDoubleLE;
      module.exports.lo = lowUintLE;
      module.exports.hi = highUintLE;
    } else if (UINT_VIEW[0] === 1072693248) {
      let toDoubleBE = function(lo, hi) {
        UINT_VIEW[1] = lo;
        UINT_VIEW[0] = hi;
        return DOUBLE_VIEW[0];
      }, lowUintBE = function(n2) {
        DOUBLE_VIEW[0] = n2;
        return UINT_VIEW[1];
      }, highUintBE = function(n2) {
        DOUBLE_VIEW[0] = n2;
        return UINT_VIEW[0];
      };
      module.exports = function doubleBitsBE(n2) {
        DOUBLE_VIEW[0] = n2;
        return [UINT_VIEW[1], UINT_VIEW[0]];
      };
      module.exports.pack = toDoubleBE;
      module.exports.lo = lowUintBE;
      module.exports.hi = highUintBE;
    } else {
      hasTypedArrays = false;
    }
  }
  if (!hasTypedArrays) {
    let toDouble = function(lo, hi) {
      buffer.writeUInt32LE(lo, 0, true);
      buffer.writeUInt32LE(hi, 4, true);
      return buffer.readDoubleLE(0, true);
    }, lowUint = function(n2) {
      buffer.writeDoubleLE(n2, 0, true);
      return buffer.readUInt32LE(0, true);
    }, highUint = function(n2) {
      buffer.writeDoubleLE(n2, 0, true);
      return buffer.readUInt32LE(4, true);
    };
    var buffer = new Buffer(8);
    module.exports = function doubleBits2(n2) {
      buffer.writeDoubleLE(n2, 0, true);
      return [buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true)];
    };
    module.exports.pack = toDouble;
    module.exports.lo = lowUint;
    module.exports.hi = highUint;
  }
  module.exports.sign = function(n2) {
    return module.exports.hi(n2) >>> 31;
  };
  module.exports.exponent = function(n2) {
    var b2 = module.exports.hi(n2);
    return (b2 << 1 >>> 21) - 1023;
  };
  module.exports.fraction = function(n2) {
    var lo = module.exports.lo(n2);
    var hi = module.exports.hi(n2);
    var b2 = hi & (1 << 20) - 1;
    if (hi & 2146435072) {
      b2 += 1 << 20;
    }
    return [lo, b2];
  };
  module.exports.denormalized = function(n2) {
    var hi = module.exports.hi(n2);
    return !(hi & 2146435072);
  };
})(double);
var doubleExports = double.exports;
var doubleBits = doubleExports;
var SMALLEST_DENORM = Math.pow(2, -1074);
var UINT_MAX = -1 >>> 0;
var nextafter_1 = nextafter;
function nextafter(x2, y2) {
  if (isNaN(x2) || isNaN(y2)) {
    return NaN;
  }
  if (x2 === y2) {
    return x2;
  }
  if (x2 === 0) {
    if (y2 < 0) {
      return -SMALLEST_DENORM;
    } else {
      return SMALLEST_DENORM;
    }
  }
  var hi = doubleBits.hi(x2);
  var lo = doubleBits.lo(x2);
  if (y2 > x2 === x2 > 0) {
    if (lo === UINT_MAX) {
      hi += 1;
      lo = 0;
    } else {
      lo += 1;
    }
  } else {
    if (lo === 0) {
      lo = UINT_MAX;
      hi -= 1;
    } else {
      lo -= 1;
    }
  }
  return doubleBits.pack(lo, hi);
}
const nextafter$1 = /* @__PURE__ */ getDefaultExportFromCjs(nextafter_1);
class MapMath {
  constructor() {
    __publicField(this, "add", (x2, y2) => ["+", x2, y2]);
    __publicField(this, "sub", (x2, y2) => ["-", x2, y2]);
    __publicField(this, "mult", (x2, y2) => ["*", x2, y2]);
    __publicField(this, "div", (x2, y2) => ["/", x2, y2]);
    __publicField(this, "log", (x2) => ["ln", x2]);
    __publicField(this, "log10", (x2) => ["log10", x2]);
    __publicField(this, "sqrt", (x2) => ["sqrt", x2]);
    __publicField(this, "cbrt", (x2) => this.mult(this.sign(x2), ["^", this.abs(x2), 1 / 3]));
    __publicField(this, "abs", (x2) => ["abs", x2]);
    __publicField(this, "sign", (x2) => ["case", ["<", x2, 0], -1, 1]);
    __publicField(this, "clamp", (x2, min2, max2) => [
      "let",
      "clampedX",
      ["to-number", x2, Number.POSITIVE_INFINITY],
      [
        "case",
        ["<", ["var", "clampedX"], min2],
        min2,
        [">", ["var", "clampedX"], max2],
        max2,
        ["var", "clampedX"]
      ]
    ]);
    __publicField(this, "min", (v1, v2) => [
      "let",
      "v1",
      ["to-number", v1, Number.POSITIVE_INFINITY],
      "v2",
      ["to-number", v2, Number.POSITIVE_INFINITY],
      ["case", ["<", ["var", "v2"], ["var", "v1"]], ["var", "v2"], ["var", "v1"]]
    ]);
    __publicField(this, "max", (v1, v2) => [
      "let",
      "v1",
      ["to-number", v1, Number.NEGATIVE_INFINITY],
      "v2",
      ["to-number", v2, Number.NEGATIVE_INFINITY],
      ["case", [">", ["var", "v2"], ["var", "v1"]], ["var", "v2"], ["var", "v1"]]
    ]);
  }
}
class JsMath {
  constructor() {
    __publicField(this, "add", (x2, y2) => x2 + y2);
    __publicField(this, "sub", (x2, y2) => x2 - y2);
    __publicField(this, "mult", (x2, y2) => x2 * y2);
    __publicField(this, "div", (x2, y2) => x2 / y2);
    __publicField(this, "log", (x2) => Math.log(x2));
    __publicField(this, "log10", (x2) => Math.log10(x2));
    __publicField(this, "sqrt", (x2) => Math.sqrt(x2));
    __publicField(this, "cbrt", (x2) => Math.cbrt(x2));
    __publicField(this, "abs", (x2) => Math.abs(x2));
    __publicField(this, "sign", (x2) => Math.sign(x2));
    __publicField(this, "clamp", (x2, min2, max2) => {
      if (x2 < min2) {
        return min2;
      }
      if (x2 > max2) {
        return max2;
      }
      return x2;
    });
    __publicField(this, "min", (v1, v2) => Math.min(v1, v2));
    __publicField(this, "max", (v1, v2) => Math.max(v1, v2));
  }
}
const equalSentiments = (a2, b2) => a2.length === b2.length && a2.every((x2, i2) => x2 === b2[i2]);
const nextFloatValueInDirection = (value, direction, transformation) => {
  const deltaAdjustmentFunctions = {
    cube_root: (x2) => Math.cbrt(x2),
    square_root: (x2) => Math.sqrt(x2),
    log: (x2) => 10 * x2,
    log_epsilon: (x2) => 10 * x2
  };
  const sign = Math.sign(direction - value);
  const nextNumber = nextafter$1(value, direction);
  const delta = Math.abs(value - nextNumber);
  if (delta < 1 && transformation && deltaAdjustmentFunctions[transformation]) {
    let adjustedDelta = deltaAdjustmentFunctions[transformation](delta);
    if (adjustedDelta > 1) {
      adjustedDelta = 0.1;
    }
    return value + sign * adjustedDelta;
  }
  return nextNumber;
};
class Calculations {
  constructor(operations) {
    __publicField(this, "math");
    this.math = operations;
  }
  rate({ num, den }) {
    return this.math.div(num, den);
  }
  normalize({ x: x2, min: min2, max: max2 }) {
    return this.math.div(this.math.sub(x2, min2), this.math.sub(max2, min2));
  }
  transform({
    x: x2,
    min: min2,
    max: max2,
    datasetMin,
    transformation
  }) {
    switch (transformation) {
      case "no":
        return {
          tX: x2,
          tMin: min2,
          tMax: max2
        };
      case "square_root":
        return {
          tX: this.math.mult(this.math.sign(x2), this.math.sqrt(this.math.abs(x2))),
          tMin: this.math.mult(this.math.sign(min2), this.math.sqrt(this.math.abs(min2))),
          tMax: this.math.mult(this.math.sign(max2), this.math.sqrt(this.math.abs(max2)))
        };
      case "cube_root":
        return {
          tX: this.math.cbrt(x2),
          tMin: this.math.cbrt(min2),
          tMax: this.math.cbrt(max2)
        };
      case "log":
        if (datasetMin === void 0) {
          throw new Error("Could not find required data for given transformation");
        }
        return {
          tX: this.math.log10(this.math.add(this.math.sub(x2, datasetMin), 1)),
          tMin: this.math.log10(this.math.add(this.math.sub(min2, datasetMin), 1)),
          tMax: this.math.log10(this.math.add(this.math.sub(max2, datasetMin), 1))
        };
      case "log_epsilon":
        if (datasetMin === void 0) {
          throw new Error("Could not find required data for given transformation");
        }
        return {
          tX: this.math.log10(
            this.math.add(this.math.sub(x2, datasetMin), Number.EPSILON)
          ),
          tMin: this.math.log10(
            this.math.add(this.math.sub(min2, datasetMin), Number.EPSILON)
          ),
          tMax: this.math.log10(
            this.math.add(this.math.sub(max2, datasetMin), Number.EPSILON)
          )
        };
    }
  }
  invert(x2) {
    return this.math.sub(1, x2);
  }
  scale(x2, coefficient) {
    return this.math.mult(x2, coefficient);
  }
  clamp(x2, min2, max2) {
    return this.math.clamp(x2, min2, max2);
  }
  min(v1, v2) {
    return this.math.min(v1, v2);
  }
  max(v1, v2) {
    return this.math.max(v1, v2);
  }
}
const inStyleCalculations = new Calculations(new MapMath());
const inViewCalculations = new Calculations(new JsMath());
const calculateLayerPipeline = (operations, getValue) => ({
  axis: axis2,
  range,
  coefficient,
  sentiment,
  transformationFunction,
  transformation,
  normalization,
  outliers,
  datasetStats
}) => {
  const [num, den] = axis2;
  let min2 = range[0];
  const max2 = range[1];
  if (min2 === max2) {
    min2 = nextFloatValueInDirection(
      min2,
      Number.NEGATIVE_INFINITY,
      (transformation == null ? void 0 : transformation.transformation) ?? transformationFunction
    );
  }
  const datasetMin = datasetStats == null ? void 0 : datasetStats.minValue;
  const inverted = equalSentiments(sentiment, sentimentReversed);
  if (!inverted)
    console.assert(
      equalSentiments(sentiment, sentimentDefault),
      "Not inverted equals default"
    );
  const values = getValue({ num, den });
  const rate = operations.rate(values);
  const clamped = outliers === "clamp" ? operations.clamp(rate, min2, max2) : rate;
  let { tX, tMin, tMax } = operations.transform({
    x: clamped,
    min: min2,
    max: max2,
    datasetMin,
    transformation: (transformation == null ? void 0 : transformation.transformation) ?? transformationFunction
  });
  if ((transformation == null ? void 0 : transformation.transformation) && (transformation == null ? void 0 : transformation.transformation) !== "no" && isNumber(transformation.lowerBound) && isNumber(transformation.upperBound)) {
    let lowerBound = transformation.lowerBound;
    const upperBound = transformation.upperBound;
    if (lowerBound === upperBound) {
      lowerBound = nextFloatValueInDirection(lowerBound, Number.NEGATIVE_INFINITY);
    }
    tMin = operations.max(tMin, lowerBound);
    tMax = operations.min(tMax, upperBound);
    if (outliers !== "unmodified") {
      tX = operations.clamp(tX, tMin, tMax);
    }
  }
  const normalized = normalization === "max-min" ? operations.normalize({ x: tX, min: tMin, max: tMax }) : tX;
  const orientated = inverted ? operations.invert(normalized) : normalized;
  const scaled = operations.scale(orientated, coefficient);
  return scaled;
};
const SOURCE_LAYER_MCDA = "stats";
const calculateLayer = calculateLayerPipeline(inStyleCalculations, (axis2) => ({
  num: ["get", axis2.num],
  den: ["get", axis2.den]
}));
function filterSetup(layers2) {
  const conditions = [
    anyCondition(
      ...layers2.map(
        ({ axis: axis2 }) => notEqual(["/", featureProp(axis2[0]), featureProp(axis2[1])], 0)
      )
    )
  ];
  layers2.forEach(({ axis: axis2, range, outliers }) => {
    if (outliers === "hide") {
      conditions.push(
        greaterOrEqual(["/", featureProp(axis2[0]), featureProp(axis2[1])], range[0]),
        lessOrEqual(["/", featureProp(axis2[0]), featureProp(axis2[1])], range[1])
      );
    }
  });
  layers2.forEach(({ axis: axis2, range }) => {
    conditions.push(
      // this checks for 0 in denominator (0 in denominator makes the result === Infinity)
      notEqual(featureProp(axis2[1]), 0)
    );
  });
  if (conditions.length > 1) {
    return allCondition(...conditions);
  }
  return conditions[0];
}
function linearNormalization(layers2) {
  if (layers2.length === 1) {
    return ["/", calculateLayer(layers2.at(0)), layers2.at(0).coefficient];
  } else {
    return ["/", ["+", ...layers2.map(calculateLayer)], sumBy(layers2, "coefficient")];
  }
}
function sentimentPaint({
  colorsConfig,
  mcdaResult,
  absoluteMin,
  absoluteMax
}) {
  const { good = DEFAULT_GREEN, bad = DEFAULT_RED } = colorsConfig.parameters;
  const midpoints = Array.isArray(colorsConfig.parameters.midpoints) ? colorsConfig.parameters.midpoints : [];
  const colorPoints = [
    { value: absoluteMin, color: bad },
    ...midpoints,
    { value: absoluteMax, color: good }
  ];
  return {
    "fill-color": [
      "let",
      "mcdaResult",
      mcdaResult,
      [
        "case",
        [
          "all",
          [">=", ["var", "mcdaResult"], absoluteMin],
          ["<=", ["var", "mcdaResult"], absoluteMax]
        ],
        [
          "interpolate-hcl",
          ["linear"],
          ["var", "mcdaResult"],
          ...colorPoints.flatMap((point) => [point.value, point.color])
        ],
        // paint all values below absoluteMin (0 by default) same as absoluteMin
        ["<", ["var", "mcdaResult"], absoluteMin],
        bad,
        // paint all values above absoluteMax (1 by default) same as absoluteMax
        [">", ["var", "mcdaResult"], absoluteMax],
        good,
        // Default color value. We get here in case of incorrect values (null, NaN etc)
        // Transparent features don't show popups on click
        "transparent"
      ]
    ],
    "fill-opacity": 1,
    "fill-antialias": false
  };
}
function expressionsPaint({
  colorsConfig,
  mcdaResult,
  absoluteMax,
  absoluteMin
}) {
  return Object.entries(colorsConfig.parameters).reduce(
    (acc, [paintProp, expression]) => {
      acc[paintProp] = Array.isArray(expression) ? [
        "let",
        "mcdaResult",
        ["to-number", mcdaResult, -9999],
        // falsy values become -9999,
        "absoluteMax",
        ["to-number", absoluteMax, -9999],
        // falsy values become -9999,
        "absoluteMin",
        ["to-number", absoluteMin, -9999],
        // falsy values become -9999,
        ...expression
      ] : expression;
      return acc;
    },
    {}
  );
}
function generateLayerPaint(props) {
  switch (props.colorsConfig.type) {
    case "sentiments":
      return sentimentPaint(props);
    case "mapLibreExpression":
      return expressionsPaint(props);
  }
}
function createMCDAStyle(config2) {
  const [absoluteMin = 0, absoluteMax = 1] = config2.layers.reduce(
    (acc, l2) => {
      const range = l2.normalization === "no" ? l2.range : [0, 1];
      if (acc.length === 0) return [...range];
      acc[0] = Math.min(acc[0], range[0]);
      acc[1] = Math.min(acc[1], range[1]);
      return acc;
    },
    []
  );
  const mcdaResult = linearNormalization(config2.layers);
  const layerStyle = {
    id: config2.id,
    type: "fill",
    layout: {},
    filter: filterSetup(config2.layers),
    // TODO - MCDA should have separate from bivariate renderer
    paint: generateLayerPaint({
      colorsConfig: config2.colors,
      mcdaResult,
      absoluteMin,
      absoluteMax
    }),
    source: {
      type: "vector",
      tiles: [
        `${adaptTileUrl(
          configRepo.get().bivariateTilesRelativeUrl
        )}{z}/{x}/{y}.mvt?indicatorsClass=${configRepo.get().bivariateTilesIndicatorsClass}`
      ],
      maxzoom: FALLBACK_BIVARIATE_MAX_ZOOM,
      minzoom: FALLBACK_BIVARIATE_MIN_ZOOM
    },
    "source-layer": SOURCE_LAYER_MCDA
  };
  return layerStyle;
}
const styleConfigs = {
  mcda: (config2) => {
    return new Array(createMCDAStyle(config2));
  }
};
const result = "_result_1l50n_1";
const tableBody = "_tableBody_1l50n_6";
const list = "_list_1l50n_10";
const entryName = "_entryName_1l50n_18";
const s$5 = {
  result,
  tableBody,
  list,
  entryName
};
function OneLayerPopup({
  layer,
  normalized,
  resultMCDA
}) {
  var _a2, _b;
  const key = `${layer.axis[0]}-${layer.axis[1]}`;
  const [num, den] = reactExports.useMemo(
    () => layer.axis.map((ax) => capitalize(ax.replaceAll("_", " "))),
    [layer]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: s$5.list, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: s$5.entryName, children: [
        num,
        ":"
      ] }),
      " ",
      parseFloat((_a2 = normalized[key]) == null ? void 0 : _a2.numValue.toFixed(2))
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: s$5.entryName, children: [
        den,
        ":"
      ] }),
      " ",
      parseFloat((_b = normalized[key]) == null ? void 0 : _b.denValue.toFixed(2))
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: s$5.entryName, children: [
        num,
        " / ",
        den,
        ":"
      ] }),
      " ",
      resultMCDA.toFixed(2)
    ] })
  ] });
}
function MultiLayerPopup({ layers: layers2, normalized, resultMCDA }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Layer" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Range" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Coefficient" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Value" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Normalized Value" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { className: s$5.tableBody, children: [
      layers2.map(({ axis: axis2, range, coefficient }) => {
        const [min2, max2] = range;
        const [num, den] = axis2;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
            num,
            " / ",
            den
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
            min2,
            " - ",
            max2
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: coefficient }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: normalized[`${num}-${den}`].val.toFixed(2) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: normalized[`${num}-${den}`].norm.toFixed(2) })
        ] }, `${num}-${den}`);
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("td", { colSpan: 5, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("b", { className: s$5.result, children: [
        "Result: ",
        resultMCDA.toFixed(2)
      ] }) }) })
    ] })
  ] });
}
function PopupMCDA({ layers: layers2, normalized, resultMCDA }) {
  return layers2.length === 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    OneLayerPopup,
    {
      layer: layers2.at(0),
      normalized,
      resultMCDA
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(MultiLayerPopup, { layers: layers2, normalized, resultMCDA });
}
function createTableWithCalculations(feature, layers2) {
  const calculateLayer2 = calculateLayerPipeline(inViewCalculations, ({ num, den }) => {
    var _a2, _b;
    return {
      num: (_a2 = feature.properties) == null ? void 0 : _a2[num],
      den: (_b = feature.properties) == null ? void 0 : _b[den]
    };
  });
  return layers2.reduce((acc, layer) => {
    var _a2, _b, _c, _d;
    const [num, den] = layer.axis;
    const value = ((_a2 = feature.properties) == null ? void 0 : _a2[num]) / ((_b = feature.properties) == null ? void 0 : _b[den]);
    acc[`${num}-${den}`] = {
      val: value,
      norm: calculateLayer2(layer),
      numValue: (_c = feature.properties) == null ? void 0 : _c[num],
      denValue: (_d = feature.properties) == null ? void 0 : _d[den]
    };
    return acc;
  }, {});
}
function calcMcdaIndex(layers2, normalized) {
  const sumNormalized = sumBy(Object.values(normalized), "norm");
  const coeffsSum = sumBy(layers2, "coefficient");
  return sumNormalized / coeffsSum;
}
function generatePopupContent(feature, layers2) {
  const normalized = createTableWithCalculations(feature, layers2);
  const resultMCDA = calcMcdaIndex(layers2, normalized);
  const popupNode = document.createElement("div");
  createRoot(popupNode).render(PopupMCDA({ layers: layers2, normalized, resultMCDA }));
  return popupNode;
}
function setTileScheme(rawUrl, mapSource) {
  const isTMS = rawUrl.includes("{-y}");
  if (isTMS) {
    mapSource.scheme = "tms";
  }
}
function generateLayerFromLegend(legend2, sourceLayer) {
  if (legend2.type === "bivariate") {
    return generateLayerStyleFromBivariateLegend(legend2, sourceLayer);
  }
  throw new Error(`Unexpected legend type '${legend2.type}'`);
}
function fillColorEmptyOrTransparent(feature) {
  var _a2;
  const fillColor = (_a2 = feature.layer.paint) == null ? void 0 : _a2["fill-color"];
  return fillColor ? fillColor.a === 0 : true;
}
function isFeatureVisible(feature) {
  if (fillColorEmptyOrTransparent(feature)) return false;
  return true;
}
function featureHaveId(feature) {
  return haveValue(feature.id);
}
function filterFeatures(sourceId, ev) {
  return ev.target.queryRenderedFeatures(ev.point).filter((f2) => f2.source.includes(sourceId)).filter(isFeatureVisible).filter(featureHaveId);
}
function createFeatureStateHandlers(ctx) {
  const activeFeatures = /* @__PURE__ */ new Set();
  const hoveredFeatures = /* @__PURE__ */ new Set();
  const setFeatureState = (featureId, newState) => {
    const source = ctx.map.getSource(ctx.sourceId);
    if (!source) {
      console.error("map - no source for", ctx.sourceId);
      return;
    }
    ctx.map.setFeatureState(
      { source: ctx.sourceId, id: featureId, sourceLayer: ctx.sourceLayer },
      newState
    );
  };
  return {
    onClick: (ev) => {
      activeFeatures.forEach((featureId) => {
        setFeatureState(featureId, { active: false });
      });
      activeFeatures.clear();
      const features = filterFeatures(ctx.sourceId, ev);
      if (!features.length) {
        return true;
      }
      features.forEach((feature) => {
        setFeatureState(feature.id, { active: true });
        activeFeatures.add(feature.id);
      });
      return true;
    },
    onMouseMove: (ev) => {
      hoveredFeatures.forEach((featureId) => {
        setFeatureState(featureId, { hover: false });
      });
      hoveredFeatures.clear();
      const features = filterFeatures(ctx.sourceId, ev);
      if (!features.length) {
        return true;
      }
      features.forEach((feature) => {
        setFeatureState(feature.id, { hover: true });
        hoveredFeatures.add(feature.id);
      });
      return true;
    },
    onMouseLeave: (ev) => {
      hoveredFeatures.forEach((featureId) => {
        setFeatureState(featureId, { hover: false });
      });
      hoveredFeatures.clear();
      return true;
    },
    reset: () => {
      activeFeatures.forEach((featureId) => {
        setFeatureState(featureId, { active: false });
      });
      activeFeatures.clear();
      hoveredFeatures.forEach((featureId) => {
        setFeatureState(featureId, { hover: false });
      });
      hoveredFeatures.clear();
    }
  };
}
const convertFillColorToRGBA = (fillColor, withTransparency = true) => `rgba(${fillColor.r * 255 * 2},${fillColor.g * 255 * 2},${fillColor.b * 255 * 2}${withTransparency ? "," + fillColor.a : ""})`;
function calcValueByNumeratorDenominator(cellValues, numerator, denominator) {
  const numeratorValue = cellValues[numerator];
  const denominatorValue = cellValues[denominator];
  if (numeratorValue == null || denominatorValue == null) return "0.00";
  if (denominatorValue === 0) return void 0;
  return (numeratorValue / denominatorValue).toFixed(2);
}
class BivariateRenderer extends LogicalLayerDefaultRenderer {
  constructor({
    id,
    layersOrderManager: layersOrderManager2
  }) {
    super();
    __publicField(this, "id");
    __publicField(this, "_layerId");
    __publicField(this, "_sourceId");
    __publicField(this, "_layersOrderManager");
    __publicField(this, "_popup");
    __publicField(this, "_listenersCleaningTasks", /* @__PURE__ */ new Set());
    __publicField(this, "cleanUpListeners", () => {
      this._listenersCleaningTasks.forEach((task) => task());
      this._listenersCleaningTasks.clear();
    });
    /* Active and hover feature state */
    __publicField(this, "_borderLayerId");
    __publicField(this, "resetFeatureStates");
    __publicField(this, "removeBivariatePopupClickHandler");
    __publicField(this, "onMapZoomHandlers", /* @__PURE__ */ new Set());
    __publicField(this, "onMapZoom", (ev) => {
      this.cleanPopup();
    });
    this.id = id;
    this._layersOrderManager = layersOrderManager2;
    this._sourceId = SOURCE_BIVARIATE_PREFIX + this.id;
  }
  async addHoverAndActiveFeatureState(map, style2) {
    await mapLoaded(map);
    const sourceId = this._sourceId;
    const borderLayerId = sourceId + "_border";
    if (map.getLayer(borderLayerId)) {
      return;
    }
    const borderLayerStyle = {
      ...H3_HOVER_LAYER,
      id: borderLayerId,
      source: sourceId,
      "source-layer": SOURCE_LAYER_BIVARIATE
    };
    layerByOrder(map, this._layersOrderManager).addAboveLayerWithSameType(
      borderLayerStyle,
      this.id
    );
    this._borderLayerId = borderLayerId;
    const { onClick, onMouseMove, onMouseLeave, reset } = createFeatureStateHandlers({
      map,
      sourceId,
      sourceLayer: SOURCE_LAYER_BIVARIATE
    });
    this._listenersCleaningTasks.add(registerMapListener("click", onClick, 60));
    this._listenersCleaningTasks.add(registerMapListener("mousemove", onMouseMove, 60));
    this._listenersCleaningTasks.add(registerMapListener("mouseleave", onMouseLeave, 60));
    this.resetFeatureStates = reset;
    this.onMapZoomHandlers.add(this.resetFeatureStates);
  }
  async mountBivariateLayer(map, layer, legend2) {
    const mapSource = {
      type: "vector",
      tiles: layer.source.urls.map((url) => adaptTileUrl(url)),
      minzoom: layer.minZoom || FALLBACK_BIVARIATE_MIN_ZOOM,
      maxzoom: layer.maxZoom || FALLBACK_BIVARIATE_MAX_ZOOM
    };
    setTileScheme(layer.source.urls[0], mapSource);
    await mapLoaded(map);
    if (map.getSource(this._sourceId) === void 0) {
      map.addSource(this._sourceId, mapSource);
    }
    if (legend2) {
      const layerStyle = generateLayerFromLegend(legend2, SOURCE_LAYER_BIVARIATE);
      const layerId = `${LAYER_BIVARIATE_PREFIX + this.id}`;
      if (map.getLayer(layerId)) {
        return;
      }
      const layer2 = { ...layerStyle, id: layerId, source: this._sourceId };
      layerByOrder(map, this._layersOrderManager).addAboveLayerWithSameType(
        layer2,
        this.id
      );
      this._layerId = layer2.id;
    } else {
      throw new Error(`[GenericLayer ${this.id}] Vector layers must have legend`);
    }
  }
  addBivariatePopup(map, legend2) {
    const clickHandler = (ev) => {
      var _a2;
      const features = ev.target.queryRenderedFeatures(ev.point).filter((f2) => f2.source.includes(this._sourceId));
      if (!features.length || !legend2 || !features[0].geometry) return true;
      const [feature] = features;
      if (!isFeatureVisible(feature)) return true;
      if (!feature.properties) return true;
      const showValues = featureFlagsAtom.getState()[FeatureFlag.BIVARIATE_MANAGER];
      const [xNumerator, xDenominator] = legend2.axis.x.quotient;
      const [yNumerator, yDenominator] = legend2.axis.y.quotient;
      const xValue = calcValueByNumeratorDenominator(
        feature.properties,
        xNumerator,
        xDenominator
      );
      const yValue = calcValueByNumeratorDenominator(
        feature.properties,
        yNumerator,
        yDenominator
      );
      if (!xValue || !yValue) return true;
      const fillColor = (_a2 = feature.layer.paint) == null ? void 0 : _a2["fill-color"];
      if (!fillColor) return true;
      const rgba = convertFillColorToRGBA(fillColor);
      const cells2 = invertClusters(legend2.steps, "label");
      const cellLabel = getCellLabelByValue(
        legend2.axis.x.steps,
        legend2.axis.y.steps,
        Number(xValue),
        Number(yValue)
      );
      const cellIndex = cells2.findIndex((i2) => i2.label === cellLabel);
      const popupNode = document.createElement("div");
      createRoot(popupNode).render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          MapHexTooltip,
          {
            cellLabel: cells2[cellIndex].label,
            cellIndex,
            axis: legend2.axis,
            values: showValues ? { x: xValue, y: yValue } : void 0,
            hexagonColor: rgba
          }
        )
      );
      this.cleanPopup();
      this._popup = new maplibreGlExports.Popup({
        closeOnClick: true,
        className: bivariateHexagonPopupContentRoot,
        maxWidth: "none",
        focusAfterOpen: false,
        offset: 15
      }).setLngLat(ev.lngLat).setDOMContent(popupNode).addTo(map);
      this._popup.once("close", () => {
        var _a3;
        (_a3 = this.resetFeatureStates) == null ? void 0 : _a3.call(this);
      });
      return true;
    };
    if (this.removeBivariatePopupClickHandler) {
      this.removeBivariatePopupClickHandler();
      this._listenersCleaningTasks.delete(this.removeBivariatePopupClickHandler);
    }
    const removeClickListener = registerMapListener("click", clickHandler, 60);
    this._listenersCleaningTasks.add(removeClickListener);
    this.removeBivariatePopupClickHandler = removeClickListener;
    this.onMapZoomHandlers.add(this.cleanPopup);
  }
  async mountMCDALayer(map, layer, style2) {
    const mapSource = {
      type: "vector",
      tiles: layer.source.urls.map((url) => adaptTileUrl(url)),
      minzoom: layer.minZoom || 0,
      maxzoom: layer.maxZoom || 22
    };
    setTileScheme(layer.source.urls[0], mapSource);
    await mapLoaded(map);
    if (map.getSource(this._sourceId) === void 0) {
      map.addSource(this._sourceId, mapSource);
    }
    const layerId = `${LAYER_BIVARIATE_PREFIX + this.id}`;
    if (map.getLayer(layerId)) {
      return;
    }
    const layerStyle = styleConfigs.mcda(style2.config)[0];
    const layerRes = { ...layerStyle, id: layerId, source: this._sourceId };
    layerByOrder(map, this._layersOrderManager).addAboveLayerWithSameType(
      layerRes,
      this.id
    );
    this._layerId = layerId;
  }
  addMCDAPopup(map, style2) {
    const clickHandler = (ev) => {
      const features = ev.target.queryRenderedFeatures(ev.point).filter((f2) => f2.source.includes(this._sourceId));
      if (!features.length || !features[0].geometry) return true;
      const [feature] = features;
      if (!isFeatureVisible(feature)) return true;
      const popupNode = generatePopupContent(feature, style2.config.layers);
      dispatchMetricsEvent("mcda_popup");
      this.cleanPopup();
      this._popup = new maplibreGlExports.Popup({
        closeOnClick: true,
        className: bivariateHexagonPopupContentRoot,
        maxWidth: "none",
        focusAfterOpen: false,
        offset: 15
      }).setLngLat(ev.lngLat).setDOMContent(popupNode).addTo(map);
      this._popup.once("close", () => {
        var _a2;
        (_a2 = this.resetFeatureStates) == null ? void 0 : _a2.call(this);
      });
      return true;
    };
    this.cleanUpListeners();
    const removeClickListener = registerMapListener("click", clickHandler, 60);
    this._listenersCleaningTasks.add(removeClickListener);
    this.onMapZoomHandlers.add(this.cleanPopup);
  }
  _updateMap(map, layerData, legend2, isVisible, style2) {
    if (layerData == null) return;
    if ((style2 == null ? void 0 : style2.type) === "mcda") {
      this.mountMCDALayer(map, layerData, style2);
      this.addMCDAPopup(map, style2);
    } else {
      this.mountBivariateLayer(map, layerData, legend2);
      this.addBivariatePopup(map, legend2);
    }
    this.addHoverAndActiveFeatureState(map, style2);
    if (!isVisible) this.willHide({ map });
  }
  cleanPopup() {
    if (this._popup) {
      this._popup.remove();
      this._popup = null;
    }
  }
  /* ========== Hooks ========== */
  willSourceUpdate({ map, state }) {
    if (state.source) {
      console.debug(`[${this.id} layer renderer]: Source updated`);
      this._updateMap(
        map,
        state.source,
        state.legend,
        state.isVisible,
        state.style
      );
    } else {
      console.debug(
        `[${this.id} layer renderer]: Source not available, waiting for next update`
      );
    }
  }
  willMount({ map, state }) {
    map.on("zoom", this.onMapZoom);
    if (state.source) {
      this._updateMap(
        map,
        state.source,
        state.legend,
        state.isVisible,
        state.style
      );
    } else {
      console.debug(
        `[${this.id} layer renderer]: Source not available, waiting for next update`
      );
    }
  }
  willUnMount({ map }) {
    var _a2;
    if (this._layerId && map.getLayer(this._layerId)) {
      map.removeLayer(this._layerId);
      this._layerId = void 0;
    } else {
      console.warn(
        `Can't remove layer with ID: ${this._layerId}. Layer does't exist in map`
      );
    }
    if (this._borderLayerId && map.getLayer(this._borderLayerId)) {
      map.removeLayer(this._borderLayerId);
      this._borderLayerId = void 0;
    } else {
      console.warn(
        `Can't remove layer with ID: ${this._borderLayerId}. Layer does't exist in map`
      );
    }
    this.cleanPopup();
    if (map.getSource(this._sourceId)) {
      map.removeSource(this._sourceId);
    } else {
      console.warn(
        `Can't remove source with ID: ${this._sourceId}. Source does't exist in map`
      );
    }
    this.cleanUpListeners();
    map.off("zoom", this.onMapZoom);
    this.onMapZoomHandlers.clear();
    (_a2 = this.resetFeatureStates) == null ? void 0 : _a2.call(this);
  }
  willHide({ map }) {
    if (this._layerId === void 0 || map === null) return;
    if (map.getLayer(this._layerId) !== void 0) {
      map.setLayoutProperty(this._layerId, "visibility", "none");
      this.cleanPopup();
    } else {
      console.warn(
        `Can't hide layer with ID: ${this._layerId}. Layer doesn't exist on the map`
      );
    }
  }
  willUnhide({ map }) {
    if (this._layerId === void 0 || map === null) return;
    if (map.getLayer(this._layerId) !== void 0) {
      map.setLayoutProperty(this._layerId, "visibility", "visible");
    } else {
      console.warn(
        `Cannot unhide layer with ID: ${this._layerId}. Layer doesn't exist on the map`
      );
    }
  }
  willDestroy({ map }) {
    if (this._layerId === void 0 || this._borderLayerId === void 0 || map === null)
      return;
    if (map.getLayer(this._layerId) !== void 0 || map.getLayer(this._borderLayerId) !== void 0) {
      this.willUnMount({ map });
    }
  }
}
const enabledLayersAtom$1 = createSetAtom(/* @__PURE__ */ new Set(), "enabledLayers");
function downloadObject(data, fileName, indentation) {
  const file = new Blob([JSON.stringify(data, null, indentation)], { type: "json" });
  const a2 = document.createElement("a");
  const url = URL.createObjectURL(file);
  a2.href = url;
  a2.download = fileName;
  document.body.appendChild(a2);
  a2.click();
  clearTimeout(
    setTimeout(function() {
      document.body.removeChild(a2);
      window.URL.revokeObjectURL(url);
    }, 0)
  );
}
const FOCUSED_GEOMETRY_LOGICAL_LAYER_ID = "focused-geometry";
const REFERENCE_AREA_LOGICAL_LAYER_ID = "reference-area";
TranslationService.t(
  "reference_area_layer.settings.name"
);
/*!
 * hash-wasm (https://www.npmjs.com/package/hash-wasm)
 * (c) Dani Biro
 * @license MIT
 */
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
class Mutex {
  constructor() {
    this.mutex = Promise.resolve();
  }
  lock() {
    let begin = () => {
    };
    this.mutex = this.mutex.then(() => new Promise(begin));
    return new Promise((res) => {
      begin = res;
    });
  }
  dispatch(fn) {
    return __awaiter(this, void 0, void 0, function* () {
      const unlock = yield this.lock();
      try {
        return yield Promise.resolve(fn());
      } finally {
        unlock();
      }
    });
  }
}
var _a;
function getGlobal() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  return global;
}
const globalObject = getGlobal();
const nodeBuffer = (_a = globalObject.Buffer) !== null && _a !== void 0 ? _a : null;
const textEncoder = globalObject.TextEncoder ? new globalObject.TextEncoder() : null;
function hexCharCodesToInt(a2, b2) {
  return (a2 & 15) + (a2 >> 6 | a2 >> 3 & 8) << 4 | (b2 & 15) + (b2 >> 6 | b2 >> 3 & 8);
}
function writeHexToUInt8(buf, str) {
  const size = str.length >> 1;
  for (let i2 = 0; i2 < size; i2++) {
    const index2 = i2 << 1;
    buf[i2] = hexCharCodesToInt(str.charCodeAt(index2), str.charCodeAt(index2 + 1));
  }
}
function hexStringEqualsUInt8(str, buf) {
  if (str.length !== buf.length * 2) {
    return false;
  }
  for (let i2 = 0; i2 < buf.length; i2++) {
    const strIndex = i2 << 1;
    if (buf[i2] !== hexCharCodesToInt(str.charCodeAt(strIndex), str.charCodeAt(strIndex + 1))) {
      return false;
    }
  }
  return true;
}
const alpha = "a".charCodeAt(0) - 10;
const digit = "0".charCodeAt(0);
function getDigestHex(tmpBuffer, input, hashLength) {
  let p2 = 0;
  for (let i2 = 0; i2 < hashLength; i2++) {
    let nibble = input[i2] >>> 4;
    tmpBuffer[p2++] = nibble > 9 ? nibble + alpha : nibble + digit;
    nibble = input[i2] & 15;
    tmpBuffer[p2++] = nibble > 9 ? nibble + alpha : nibble + digit;
  }
  return String.fromCharCode.apply(null, tmpBuffer);
}
const getUInt8Buffer = nodeBuffer !== null ? (data) => {
  if (typeof data === "string") {
    const buf = nodeBuffer.from(data, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
  }
  if (nodeBuffer.isBuffer(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.length);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
  throw new Error("Invalid data type!");
} : (data) => {
  if (typeof data === "string") {
    return textEncoder.encode(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
  throw new Error("Invalid data type!");
};
const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const base64Lookup = new Uint8Array(256);
for (let i2 = 0; i2 < base64Chars.length; i2++) {
  base64Lookup[base64Chars.charCodeAt(i2)] = i2;
}
function getDecodeBase64Length(data) {
  let bufferLength = Math.floor(data.length * 0.75);
  const len = data.length;
  if (data[len - 1] === "=") {
    bufferLength -= 1;
    if (data[len - 2] === "=") {
      bufferLength -= 1;
    }
  }
  return bufferLength;
}
function decodeBase64(data) {
  const bufferLength = getDecodeBase64Length(data);
  const len = data.length;
  const bytes = new Uint8Array(bufferLength);
  let p2 = 0;
  for (let i2 = 0; i2 < len; i2 += 4) {
    const encoded1 = base64Lookup[data.charCodeAt(i2)];
    const encoded2 = base64Lookup[data.charCodeAt(i2 + 1)];
    const encoded3 = base64Lookup[data.charCodeAt(i2 + 2)];
    const encoded4 = base64Lookup[data.charCodeAt(i2 + 3)];
    bytes[p2] = encoded1 << 2 | encoded2 >> 4;
    p2 += 1;
    bytes[p2] = (encoded2 & 15) << 4 | encoded3 >> 2;
    p2 += 1;
    bytes[p2] = (encoded3 & 3) << 6 | encoded4 & 63;
    p2 += 1;
  }
  return bytes;
}
const MAX_HEAP = 16 * 1024;
const WASM_FUNC_HASH_LENGTH = 4;
const wasmMutex = new Mutex();
const wasmModuleCache = /* @__PURE__ */ new Map();
function WASMInterface(binary, hashLength) {
  return __awaiter(this, void 0, void 0, function* () {
    let wasmInstance = null;
    let memoryView = null;
    let initialized = false;
    if (typeof WebAssembly === "undefined") {
      throw new Error("WebAssembly is not supported in this environment!");
    }
    const writeMemory = (data, offset2 = 0) => {
      memoryView.set(data, offset2);
    };
    const getMemory = () => memoryView;
    const getExports = () => wasmInstance.exports;
    const setMemorySize = (totalSize) => {
      wasmInstance.exports.Hash_SetMemorySize(totalSize);
      const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      memoryView = new Uint8Array(memoryBuffer, arrayOffset, totalSize);
    };
    const getStateSize = () => {
      const view = new DataView(wasmInstance.exports.memory.buffer);
      const stateSize = view.getUint32(wasmInstance.exports.STATE_SIZE, true);
      return stateSize;
    };
    const loadWASMPromise = wasmMutex.dispatch(() => __awaiter(this, void 0, void 0, function* () {
      if (!wasmModuleCache.has(binary.name)) {
        const asm = decodeBase64(binary.data);
        const promise = WebAssembly.compile(asm);
        wasmModuleCache.set(binary.name, promise);
      }
      const module = yield wasmModuleCache.get(binary.name);
      wasmInstance = yield WebAssembly.instantiate(module, {
        // env: {
        //   emscripten_memcpy_big: (dest, src, num) => {
        //     const memoryBuffer = wasmInstance.exports.memory.buffer;
        //     const memView = new Uint8Array(memoryBuffer, 0);
        //     memView.set(memView.subarray(src, src + num), dest);
        //   },
        //   print_memory: (offset, len) => {
        //     const memoryBuffer = wasmInstance.exports.memory.buffer;
        //     const memView = new Uint8Array(memoryBuffer, 0);
        //     console.log('print_int32', memView.subarray(offset, offset + len));
        //   },
        // },
      });
    }));
    const setupInterface = () => __awaiter(this, void 0, void 0, function* () {
      if (!wasmInstance) {
        yield loadWASMPromise;
      }
      const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      memoryView = new Uint8Array(memoryBuffer, arrayOffset, MAX_HEAP);
    });
    const init = (bits = null) => {
      initialized = true;
      wasmInstance.exports.Hash_Init(bits);
    };
    const updateUInt8Array = (data) => {
      let read = 0;
      while (read < data.length) {
        const chunk = data.subarray(read, read + MAX_HEAP);
        read += chunk.length;
        memoryView.set(chunk);
        wasmInstance.exports.Hash_Update(chunk.length);
      }
    };
    const update = (data) => {
      if (!initialized) {
        throw new Error("update() called before init()");
      }
      const Uint8Buffer = getUInt8Buffer(data);
      updateUInt8Array(Uint8Buffer);
    };
    const digestChars = new Uint8Array(hashLength * 2);
    const digest = (outputType, padding = null) => {
      if (!initialized) {
        throw new Error("digest() called before init()");
      }
      initialized = false;
      wasmInstance.exports.Hash_Final(padding);
      if (outputType === "binary") {
        return memoryView.slice(0, hashLength);
      }
      return getDigestHex(digestChars, memoryView, hashLength);
    };
    const save2 = () => {
      if (!initialized) {
        throw new Error("save() can only be called after init() and before digest()");
      }
      const stateOffset = wasmInstance.exports.Hash_GetState();
      const stateLength = getStateSize();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      const internalState = new Uint8Array(memoryBuffer, stateOffset, stateLength);
      const prefixedState = new Uint8Array(WASM_FUNC_HASH_LENGTH + stateLength);
      writeHexToUInt8(prefixedState, binary.hash);
      prefixedState.set(internalState, WASM_FUNC_HASH_LENGTH);
      return prefixedState;
    };
    const load = (state) => {
      if (!(state instanceof Uint8Array)) {
        throw new Error("load() expects an Uint8Array generated by save()");
      }
      const stateOffset = wasmInstance.exports.Hash_GetState();
      const stateLength = getStateSize();
      const overallLength = WASM_FUNC_HASH_LENGTH + stateLength;
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      if (state.length !== overallLength) {
        throw new Error(`Bad state length (expected ${overallLength} bytes, got ${state.length})`);
      }
      if (!hexStringEqualsUInt8(binary.hash, state.subarray(0, WASM_FUNC_HASH_LENGTH))) {
        throw new Error("This state was written by an incompatible hash implementation");
      }
      const internalState = state.subarray(WASM_FUNC_HASH_LENGTH);
      new Uint8Array(memoryBuffer, stateOffset, stateLength).set(internalState);
      initialized = true;
    };
    const isDataShort = (data) => {
      if (typeof data === "string") {
        return data.length < MAX_HEAP / 4;
      }
      return data.byteLength < MAX_HEAP;
    };
    let canSimplify = isDataShort;
    switch (binary.name) {
      case "argon2":
      case "scrypt":
        canSimplify = () => true;
        break;
      case "blake2b":
      case "blake2s":
        canSimplify = (data, initParam) => initParam <= 512 && isDataShort(data);
        break;
      case "blake3":
        canSimplify = (data, initParam) => initParam === 0 && isDataShort(data);
        break;
      case "xxhash64":
      case "xxhash3":
      case "xxhash128":
        canSimplify = () => false;
        break;
    }
    const calculate = (data, initParam = null, digestParam = null) => {
      if (!canSimplify(data, initParam)) {
        init(initParam);
        update(data);
        return digest("hex", digestParam);
      }
      const buffer = getUInt8Buffer(data);
      memoryView.set(buffer);
      wasmInstance.exports.Hash_Calculate(buffer.length, initParam, digestParam);
      return getDigestHex(digestChars, memoryView, hashLength);
    };
    yield setupInterface();
    return {
      getMemory,
      writeMemory,
      getExports,
      setMemorySize,
      init,
      update,
      digest,
      save: save2,
      load,
      calculate,
      hashLength
    };
  });
}
function lockedCreate(mutex, binary, hashLength) {
  return __awaiter(this, void 0, void 0, function* () {
    const unlock = yield mutex.lock();
    const wasm = yield WASMInterface(binary, hashLength);
    unlock();
    return wasm;
  });
}
new Mutex();
new Mutex();
new Mutex();
new Mutex();
var name$f = "crc32";
var data$f = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwgHAAEBAQIAAwUEAQECAgYOAn8BQZDJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAgtIYXNoX1VwZGF0ZQADCkhhc2hfRmluYWwABA1IYXNoX0dldFN0YXRlAAUOSGFzaF9DYWxjdWxhdGUABgpTVEFURV9TSVpFAwEKkggHBQBBgAkLwwMBA39BgIkBIQFBACECA0AgAUEAQQBBAEEAQQBBAEEAQQAgAkEBcWsgAHEgAkEBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnM2AgAgAUEEaiEBIAJBAWoiAkGAAkcNAAtBACEAA0AgAEGEkQFqIABBhIkBaigCACICQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEmQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYShAWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhKkBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEsQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYS5AWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhMEBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzNgIAIABBBGoiAEH8B0cNAAsLJwACQEEAKAKAyQEgAEYNACAAEAFBACAANgKAyQELQQBBADYChMkBC4gDAQN/QQAoAoTJAUF/cyEBQYAJIQICQCAAQQhJDQBBgAkhAgNAIAJBBGooAgAiA0EOdkH8B3FBgJEBaigCACADQRZ2QfwHcUGAiQFqKAIAcyADQQZ2QfwHcUGAmQFqKAIAcyADQf8BcUECdEGAoQFqKAIAcyACKAIAIAFzIgFBFnZB/AdxQYCpAWooAgBzIAFBDnZB/AdxQYCxAWooAgBzIAFBBnZB/AdxQYC5AWooAgBzIAFB/wFxQQJ0QYDBAWooAgBzIQEgAkEIaiECIABBeGoiAEEHSw0ACwsCQCAARQ0AAkACQCAAQQFxDQAgACEDDAELIAFB/wFxIAItAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQFqIQIgAEF/aiEDCyAAQQFGDQADQCABQf8BcSACLQAAc0ECdEGAiQFqKAIAIAFBCHZzIgFB/wFxIAJBAWotAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQJqIQIgA0F+aiIDDQALC0EAIAFBf3M2AoTJAQsyAQF/QQBBACgChMkBIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyNgKACQsGAEGEyQELWQACQEEAKAKAyQEgAUYNACABEAFBACABNgKAyQELQQBBADYChMkBIAAQA0EAQQAoAoTJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCgAkLCwsBAEGACAsEBAAAAA==";
var hash$f = "d2eba587";
var wasmJson$f = {
  name: name$f,
  data: data$f,
  hash: hash$f
};
const mutex$h = new Mutex();
let wasmCache$h = null;
function crc32(data) {
  if (wasmCache$h === null) {
    return lockedCreate(mutex$h, wasmJson$f, 4).then((wasm) => {
      wasmCache$h = wasm;
      return wasmCache$h.calculate(data, 3988292384);
    });
  }
  try {
    const hash = wasmCache$h.calculate(data, 3988292384);
    return Promise.resolve(hash);
  } catch (err) {
    return Promise.reject(err);
  }
}
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
const focusedGeometryAtom = createAtom(
  {
    setFocusedGeometry: (source, geometry) => ({ source, geometry }),
    _update: (fGeometry) => fGeometry,
    reset: () => null,
    episodesPanelState
  },
  ({ onAction, schedule, create: create2 }, state = null) => {
    onAction("setFocusedGeometry", ({ source, geometry }) => {
      if (source && geometry) {
        dispatchMetricsEvent("select_area");
        schedule(async (dispatch, ctx) => {
          const hash = await crc32(JSON.stringify({ geometry, source }));
          if (!state || !ctx.hash || ctx.hash !== hash) {
            ctx.hash = hash;
            const geometryWithHash = { ...geometry, hash };
            dispatch(create2("_update", { source, geometry: geometryWithHash }));
          }
        });
      } else {
        state = null;
      }
    });
    onAction("reset", () => {
      state = null;
    });
    onAction("_update", (fGeometry) => {
      state = fGeometry;
    });
    return state;
  },
  "[Shared state] focusedGeometryAtom"
);
function updateReferenceArea(referenceAreaGeometry) {
  const referenceAreaConfiguration = { referenceAreaGeometry };
  return updateFeatureConfiguration(
    AppFeature.REFERENCE_AREA,
    referenceAreaConfiguration,
    {
      errorsConfig: { messages: TranslationService.t("reference_area.error_couldnt_save") }
    }
  );
}
function updateFeatureConfiguration(featureId, featureConfiguration, requestConfig) {
  return apiClient.put(
    `/features/${featureId}?appId=${configRepo.get().id}`,
    featureConfiguration,
    true,
    requestConfig
  );
}
const referenceAreaAtom = atom(
  getReferenceAreaFromConfigRepo(),
  "[Shared state] referenceAreaAtom"
);
function getReferenceAreaFromConfigRepo() {
  const features = configRepo.get().features;
  const refAreaGeometry = features[FeatureFlag.REFERENCE_AREA] && typeof features[FeatureFlag.REFERENCE_AREA] === "object" ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    features[FeatureFlag.REFERENCE_AREA].referenceAreaGeometry
  ) : null;
  if ((refAreaGeometry == null ? void 0 : refAreaGeometry.type) === "FeatureCollection" || (refAreaGeometry == null ? void 0 : refAreaGeometry.type) === "Feature") {
    return refAreaGeometry;
  }
  return null;
}
action(async (ctx, geometry) => {
  if (geometry) {
    dispatchMetricsEvent("ref_area");
    const hash = await crc32(JSON.stringify({ geometry }));
    const referenceAreaOld = ctx.get(referenceAreaAtom);
    if (!referenceAreaOld || !referenceAreaOld.hash || referenceAreaOld.hash !== hash) {
      const geometryWithHash = { ...geometry, hash };
      referenceAreaAtom(ctx, geometryWithHash);
    }
  } else {
    referenceAreaAtom(ctx, null);
  }
}, "setReferenceArea");
const resetReferenceArea = action(async (ctx) => {
  await updateReferenceArea(null);
  referenceAreaAtom(ctx, null);
}, "resetReferenceArea");
const hiddenLayersAtom = createSetAtom(/* @__PURE__ */ new Set(), "hiddenLayers");
const layersEditorsAtom = createMapAtom(
  /* @__PURE__ */ new Map(),
  "layersLegends"
);
function deepFreeze(object) {
  if (object && typeof object === "object") {
    const propNames = Object.getOwnPropertyNames(object);
    for (const name of propNames) {
      const value = object[name];
      deepFreeze(value);
    }
    return Object.freeze(object);
  }
  return object;
}
const getMutualExcludedActions = (() => {
  let groupsSettings = null;
  layersGroupsSettingsAtom.subscribe((s2) => groupsSettings = s2);
  let categorySettings = null;
  layersCategoriesSettingsAtom.subscribe((s2) => categorySettings = s2);
  let enabledLayers = null;
  enabledLayersAtom$1.subscribe((s2) => enabledLayers = s2);
  let layersSettings = null;
  layersSettingsAtom$1.subscribe((s2) => layersSettings = s2);
  return (state) => {
    var _a2, _b, _c, _d;
    if (!groupsSettings || !categorySettings || !enabledLayers || !layersSettings) {
      return [];
    }
    const targetLayerCategory = (_a2 = state.settings) == null ? void 0 : _a2.category;
    const targetLayerGroup = (_b = state.settings) == null ? void 0 : _b.group;
    const isInMutuallyExclusiveCategory = targetLayerCategory && ((_c = categorySettings[targetLayerCategory]) == null ? void 0 : _c.mutuallyExclusive);
    const isInMutuallyExclusiveGroup = targetLayerGroup && ((_d = groupsSettings[targetLayerGroup]) == null ? void 0 : _d.mutuallyExclusive);
    if (!isInMutuallyExclusiveCategory && !isInMutuallyExclusiveGroup) {
      return [];
    }
    const mutualExcludeIds = /* @__PURE__ */ new Set();
    enabledLayers.forEach((enabledLayerId) => {
      var _a3, _b2;
      if (state.id === enabledLayerId) return;
      const enabledLayerSettings = layersSettings.get(enabledLayerId);
      if (!enabledLayerSettings) return;
      if (isInMutuallyExclusiveCategory) {
        if (((_a3 = enabledLayerSettings.data) == null ? void 0 : _a3.category) === targetLayerCategory) {
          mutualExcludeIds.add(enabledLayerId);
        }
      } else if (isInMutuallyExclusiveGroup) {
        if (((_b2 = enabledLayerSettings.data) == null ? void 0 : _b2.group) === targetLayerGroup) {
          mutualExcludeIds.add(enabledLayerId);
        }
      }
    });
    return Array.from(mutualExcludeIds).map((id) => enabledLayersAtom$1.delete(id));
  };
})();
const logicalLayerActions = {
  enable: () => null,
  disable: () => null,
  hide: () => null,
  show: () => null,
  download: () => null,
  destroy: () => null,
  clean: () => null
};
const annotatedError = (id) => (...e) => console.error(`[Logical layer: ${id}]:`, ...e);
function createLogicalLayerAtom(id, renderer, registry, customMap) {
  let hasBeenDestroyed = false;
  const logicalLayerAtom = createAtom(
    {
      ...logicalLayerActions,
      layersSettingsAtom: layersSettingsAtom$1,
      layersLegendsAtom,
      layersMetaAtom,
      layersSourcesAtom,
      enabledLayersAtom: enabledLayersAtom$1,
      mountedLayersAtom,
      hiddenLayersAtom,
      layersMenusAtom,
      layersEditorsAtom,
      _patchState: (newState) => newState
    },
    ({ get: get2, onAction, getUnlistedState, onInit, schedule, create: create2 }, state = {
      id,
      error: null,
      isEnabled: false,
      isLoading: false,
      isMounted: false,
      isEditable: false,
      isVisible: true,
      isDownloadable: false,
      settings: null,
      meta: null,
      legend: null,
      source: null,
      contextMenu: null,
      style: null,
      editor: null
    }) => {
      var _a2, _b, _c, _d, _e2, _f, _g;
      const actions = [];
      const map = customMap || getUnlistedState(currentMapAtom);
      const fallbackAsyncState = {
        isLoading: false,
        data: null,
        error: null
      };
      const asyncLayerSettings = get2("layersSettingsAtom").get(id) ?? fallbackAsyncState;
      const asyncLayerMeta = get2("layersMetaAtom").get(id) ?? fallbackAsyncState;
      const asyncLayerLegend = get2("layersLegendsAtom").get(id) ?? fallbackAsyncState;
      const asyncLayerSource = get2("layersSourcesAtom").get(id) ?? fallbackAsyncState;
      const asyncLayerEditor = get2("layersEditorsAtom").get(id) ?? fallbackAsyncState;
      const layersMenus = get2("layersMenusAtom").get(id) ?? null;
      const logError = annotatedError(state.id);
      let mounted = get2("mountedLayersAtom");
      if (_lastUpdatedState_DO_NOT_USE_OR_YOU_WILL_BE_FIRED !== mounted) {
        if (configRepo.get().id === "8906feaf-fc18-4180-bb5f-ff545cf65100") {
          console.debug("Apply workaround");
          mounted = _lastUpdatedState_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        }
      }
      const newState = {
        id: state.id,
        error: state.error,
        isLoading: [
          asyncLayerSettings,
          asyncLayerMeta,
          asyncLayerLegend,
          asyncLayerSource
        ].some((s2) => s2.isLoading),
        isEnabled: get2("enabledLayersAtom").has(id),
        isMounted: mounted.has(id),
        isVisible: !get2("hiddenLayersAtom").has(id),
        isDownloadable: ((_a2 = asyncLayerSource.data) == null ? void 0 : _a2.source.type) === "geojson" || ((_c = (_b = asyncLayerSource.data) == null ? void 0 : _b.style) == null ? void 0 : _c.type) === "mcda",
        isEditable: ((_e2 = (_d = asyncLayerSource.data) == null ? void 0 : _d.style) == null ? void 0 : _e2.type) === "mcda" && !!((_f = asyncLayerSettings.data) == null ? void 0 : _f.ownedByUser),
        settings: deepFreeze(asyncLayerSettings.data),
        meta: deepFreeze(asyncLayerMeta.data),
        legend: deepFreeze(asyncLayerLegend.data),
        source: deepFreeze(asyncLayerSource.data),
        contextMenu: deepFreeze(layersMenus),
        style: ((_g = asyncLayerSource.data) == null ? void 0 : _g.style) ?? null,
        editor: deepFreeze(asyncLayerEditor.data)
      };
      onInit(() => {
        try {
          renderer.willInit({ map, state: { ...newState } });
        } catch (e) {
          logError(e);
          newState.error = e;
        }
      });
      onAction("enable", () => {
        newState.isEnabled = true;
        actions.push(enabledLayersAtom$1.set(id), ...getMutualExcludedActions(state));
      });
      onAction("disable", () => {
        newState.isEnabled = false;
        actions.push(enabledLayersAtom$1.delete(id));
      });
      onAction("hide", () => {
        if (!map) return;
        try {
          renderer.willHide({ map, state: { ...newState } });
          newState.isVisible = false;
          actions.push(hiddenLayersAtom.set(id));
        } catch (e) {
          logError(e);
          newState.error = e;
        }
      });
      onAction("show", () => {
        if (!map) return;
        try {
          renderer.willUnhide({ map, state: { ...newState } });
          newState.isVisible = true;
          actions.push(hiddenLayersAtom.delete(id));
        } catch (e) {
          logError(e);
          newState.error = e;
        }
      });
      onAction("download", () => {
        var _a3, _b2, _c2, _d2;
        try {
          if (!state.isDownloadable) return;
          if (!((_a3 = state.source) == null ? void 0 : _a3.source)) {
            logError("Download failed, source unavailable");
            return;
          }
          if (state.source.source.type === "geojson") {
            downloadObject(
              state.source.source.data,
              `${((_b2 = state.settings) == null ? void 0 : _b2.name) && spacesToUnderscore(state.settings.name) || state.id || "map layer"}_${(/* @__PURE__ */ new Date()).toISOString()}.geojson`
            );
          } else if (((_c2 = state.source.style) == null ? void 0 : _c2.type) === "mcda") {
            downloadObject(
              state.source.style,
              `${((_d2 = state.settings) == null ? void 0 : _d2.name) || state.id || "MCDA"}-${(/* @__PURE__ */ new Date()).toISOString()}.json`,
              2
            );
          } else {
            logError("Only geojson layers or MCDA can be downloaded");
          }
        } catch (e) {
          logError(e);
          newState.error = e;
        }
      });
      onAction("clean", () => {
        if (id === FOCUSED_GEOMETRY_LOGICAL_LAYER_ID) {
          schedule((dispatch) => dispatch(focusedGeometryAtom.reset()));
        }
        if (id === REFERENCE_AREA_LOGICAL_LAYER_ID) {
          resetReferenceArea(store.v3ctx);
        }
      });
      const syncNotFinished = !hasBeenDestroyed && newState.isEnabled !== newState.isMounted;
      const mountStateNotApplied = state.isMounted !== newState.isMounted;
      if (!mountStateNotApplied && syncNotFinished && !newState.isLoading) {
        try {
          if (!newState.isMounted) {
            if (map) {
              renderer.willMount({ map, state: { ...newState } });
              newState.isMounted = true;
              actions.push(mountedLayersAtom.set(id, logicalLayerAtom));
            }
          } else {
            if (map) {
              renderer.willUnMount({
                map,
                state: { ...newState }
              });
              newState.isMounted = false;
              actions.push(mountedLayersAtom.delete(id));
            }
          }
        } catch (e) {
          logError(e);
          newState.error = e;
        }
      }
      if (state.isMounted && newState.isMounted) {
        const legendHaveUpdate = state.legend !== newState.legend;
        if (legendHaveUpdate) {
          if (map)
            try {
              renderer.willLegendUpdate({
                map,
                state: { ...newState }
              });
            } catch (e) {
              logError(e);
              newState.error = e;
            }
        }
        const sourceHaveUpdate = state.source !== newState.source;
        if (sourceHaveUpdate) {
          if (map)
            try {
              renderer.willSourceUpdate({
                map,
                state: { ...newState }
              });
            } catch (e) {
              logError(e);
              newState.error = e;
            }
        }
      }
      onAction("destroy", () => {
        hasBeenDestroyed = true;
        try {
          renderer.willDestroy({ map, state: { ...newState } });
          const layersRegistryState = getUnlistedState(registry);
          if (layersRegistryState.has(state.id)) {
            actions.push(
              registry.unregister(state.id, {
                notifyLayerAboutDestroy: false
                // cancel layer.destroy() call from registry
              })
            );
          }
        } catch (e) {
          logError(e);
          newState.error = e;
        }
      });
      onAction("_patchState", (patch) => {
        Object.assign(newState, patch);
      });
      if (actions.length) {
        schedule((dispatch) => {
          dispatch(actions);
          renderer.setErrorState((e) => {
            logError(e);
            dispatch(create2("_patchState", { error: e.message }));
          });
        });
      }
      return newState;
    },
    { id, decorators: [] }
  );
  return logicalLayerAtom;
}
const cleanUpActionsMap = /* @__PURE__ */ new WeakMap();
const unsubscribes = /* @__PURE__ */ new WeakMap();
const createLayersRegistryAtom = (id) => {
  const atom2 = createAtom(
    {
      register: (r2) => Array.isArray(r2) ? r2 : [r2],
      unregister: (id2, { notifyLayerAboutDestroy } = {}) => ({ ids: Array.isArray(id2) ? id2 : [id2], notifyLayerAboutDestroy }),
      _delete: (id2) => Array.isArray(id2) ? id2 : [id2]
    },
    ({ onAction, create: create2, schedule }, state = /* @__PURE__ */ new Map()) => {
      onAction("register", (requests) => {
        const newState = new Map(state);
        requests.forEach(({ id: id2, renderer, cleanUpActions, map }) => {
          const layerAtom = createLogicalLayerAtom(id2, renderer, atom2, map);
          newState.set(id2, layerAtom);
          if (cleanUpActions) {
            cleanUpActionsMap.set(layerAtom, cleanUpActions);
          }
          unsubscribes.set(
            layerAtom,
            layerAtom.subscribe(() => null)
          );
        });
        state = newState;
      });
      onAction("unregister", ({ ids, notifyLayerAboutDestroy }) => {
        ids.forEach((id2) => {
          const layerAtom = state.get(id2);
          if (layerAtom) {
            schedule((dispatch) => {
              const unsubscribe = unsubscribes.get(layerAtom);
              unsubscribe();
              const actions = [
                ...cleanUpActionsMap.get(layerAtom) || [],
                /* Not clear enabledLayersAtom, because it store only user choices,
                 * and we want to store it even when layer unavailable */
                mountedLayersAtom.delete(id2),
                hiddenLayersAtom.delete(id2),
                /**
                 * notifyLayerAboutDestroy == false means that
                 * this action called from inside layerAtom.destroy()
                 * and not needed to cal it again
                 */
                notifyLayerAboutDestroy && layerAtom.destroy(),
                /* Delete layer from registry in one transaction with other states */
                create2("_delete", id2)
              ].filter((i2) => Boolean(i2));
              dispatch(actions);
            });
          } else {
            console.error(`Attempt unregister not existing layer with id: ${id2}`);
          }
        });
      });
      onAction("_delete", (ids) => {
        const newState = new Map(state);
        ids.forEach((id2) => {
          newState.delete(id2);
        });
        state = newState;
      });
      return state;
    },
    id
  );
  return atom2;
};
const layersRegistryAtom$1 = createLayersRegistryAtom("layersRegistryAtom");
function v3toV2(v3atom, v3Actions, store$1 = store) {
  const v2Atom = createAtom({}, () => {
  }, { store: store$1, v3atom });
  if (v3Actions) {
    Object.entries(v3Actions).map((act) => actionV3ToV2(act, [v2Atom], store$1)).forEach(
      ({ name, actionCreator }) => Object.assign(v2Atom, { [name]: actionCreator })
    );
  }
  return v2Atom;
}
let actionIdCounter = 0;
function actionV3ToV2([name, action$1], targets, store$1 = store) {
  const type = action$1.__reatom.name ?? `name_${actionIdCounter++}`;
  const actionCreator = function(payload) {
    return {
      payload,
      type,
      v3action: action$1,
      targets
    };
  };
  actionCreator.type = type;
  actionCreator.dispatch = (...a2) => store$1.dispatch(actionCreator(...a2));
  actionCreator.v3action = action(type);
  return { name, actionCreator };
}
const ABORT_ERROR_MESSAGE = "Abort error";
const isAbortError = (e) => {
  if (!e) return false;
  if (typeof e === "string") {
    return e === ABORT_ERROR_MESSAGE;
  }
  if (isApiError(e)) {
    return e.problem.kind === "canceled";
  } else if (e instanceof DOMException) {
    return e.name === "AbortError";
  }
  return false;
};
async function abortable(abortController, promise) {
  return new Promise((res, rej) => {
    if (abortController.signal.aborted) {
      rej(new DOMException("Aborted", "AbortError"));
    }
    const onAbort = () => {
      abortController.signal.removeEventListener("abort", onAbort);
      rej(new DOMException("Aborted", "AbortError"));
    };
    abortController.signal.addEventListener("abort", onAbort);
    promise.then(res).catch(rej).finally(() => abortController.signal.removeEventListener("abort", onAbort));
  });
}
function isAtomLike(state) {
  return "loading" in state || "error" in state;
}
function generateErrorMessage(e) {
  if (isAbortError(e)) {
    return ABORT_ERROR_MESSAGE;
  } else {
    return isErrorWithMessage(e) ? e.message : typeof e === "string" ? e : "Unknown";
  }
}
function verboseLog(name, verbose) {
  return (...args) => verbose && console.debug(`[${name}]:`, ...args);
}
const getUniqueId = /* @__PURE__ */ ((mem) => {
  return (newId) => {
    if (!mem.has(newId)) {
      mem.add(newId);
      return newId;
    }
    console.warn(`Atom with name ${newId} already exist. Full page reload recommended`);
    const uniqId = newId + performance.now();
    return getUniqueId(uniqId);
  };
})(/* @__PURE__ */ new Set());
const defaultOptions = {
  inheritState: false,
  store,
  auto: true,
  verbose: false
};
function createAsyncAtom(depsAtom, fetcher, name, resourceAtomOptions = {}) {
  const options = {
    ...resourceAtomOptions,
    auto: resourceAtomOptions.auto ?? defaultOptions.auto,
    inheritState: resourceAtomOptions.inheritState ?? defaultOptions.inheritState,
    store: resourceAtomOptions.store ?? defaultOptions.store,
    verbose: resourceAtomOptions.verbose ?? defaultOptions.verbose
  };
  const debug = verboseLog(name, options.verbose);
  const asyncAtom = atom(
    {
      loading: false,
      data: null,
      error: null,
      lastParams: null,
      dirty: false
    },
    getUniqueId(name)
  );
  let abortController = null;
  let deferredCancel;
  const requestAction = action(async (ctx, params) => {
    if (abortController) {
      await cancelAction(ctx);
    }
    asyncAtom(ctx, (state) => ({
      ...state,
      error: null,
      lastParams: params,
      dirty: true,
      // for unblock refetch
      loading: true
    }));
    try {
      abortController = new AbortController();
      const data = await ctx.schedule(() => {
        if (abortController) {
          return abortable(abortController, fetcher(params, abortController));
        } else {
          throw Error("abortController was reset before it was used");
        }
      });
      abortController.signal.throwIfAborted();
      asyncAtom(ctx, (state) => ({ ...state, data, lastParams: params, loading: false }));
    } catch (error2) {
      asyncAtom(ctx, (state) => ({
        ...state,
        lastParams: params,
        loading: false,
        error: generateErrorMessage(error2)
      }));
      if (isAbortError(error2)) {
        deferredCancel == null ? void 0 : deferredCancel.resolve();
      }
    } finally {
      abortController = null;
    }
  }, "asyncAtom-requestAction");
  const cancelAction = action(async (ctx) => {
    if (abortController) {
      deferredCancel = deferred();
      await ctx.schedule(async () => {
        abortController == null ? void 0 : abortController.abort();
        return await deferredCancel.promise;
      });
    }
  }, "asyncAtom-cancelAction");
  const refetchAction = action((ctx) => {
    const { lastParams, dirty, loading: loading2 } = ctx.get(asyncAtom);
    if (dirty) {
      !loading2 && requestAction(ctx, lastParams);
    } else {
      console.error(`[${name}]:`, "Do not call refetch before request");
    }
  }, "asyncAtom-refetchAction");
  const actions = {
    request: requestAction,
    refetch: refetchAction,
    cancel: cancelAction
  };
  if (depsAtom) {
    const onChange2 = (ctx, depsAtomState) => {
      debug("Deps atom changed");
      if (isObject(depsAtomState)) {
        if (options.inheritState) {
          asyncAtom(ctx, (state) => ({
            ...state,
            loading: depsAtomState.loading || state.loading,
            error: depsAtomState.error || state.error
          }));
        }
        if (isAtomLike(depsAtomState)) {
          if (!depsAtomState.loading && !depsAtomState.error && depsAtomState.dirty) {
            requestAction(ctx, depsAtomState.data);
          }
        } else {
          requestAction(ctx, depsAtomState);
        }
      } else {
        if (depsAtomState !== null) {
          requestAction(ctx, depsAtomState);
        } else {
          console.warn(
            `Resource atom with name ${name} skips running as its dependency state ${depsAtom == null ? void 0 : depsAtom.id} is null`
          );
        }
      }
    };
    depsAtom.subscribe((s2) => null);
    if (options.auto) {
      onChange2(options.store.v3ctx, options.store.getState(depsAtom));
    }
    depsAtom.v3atom.onChange(onChange2);
    return v3toV2(asyncAtom, actions, options.store);
  } else {
    if (options.auto) {
      requestAction(options.store.v3ctx, null);
    }
  }
  return v3toV2(asyncAtom, actions, options.store);
}
function deferred() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    // @ts-expect-error -- `resolve` is defined inside the promise.
    resolve,
    // @ts-expect-error -- `reject` is defined inside the promise.
    reject
  };
}
const IMPORTANT_BIVARIATE_LAYERS = [
  ["count", "area_km2"],
  ["building_count", "area_km2"],
  ["highway_length", "area_km2"],
  ["local_hours", "area_km2"],
  ["avgmax_ts", "one"],
  ["days_mintemp_above_25c_1c", "one"],
  ["population", "area_km2"],
  ["total_hours", "area_km2"],
  ["view_count", "area_km2"]
];
function recursiveCopy(src) {
  const target = Array.isArray(src) ? [] : {};
  for (const prop in src) {
    const value = src[prop];
    if (value && typeof value === "object") {
      target[prop] = recursiveCopy(value);
    } else {
      target[prop] = value;
    }
  }
  return target;
}
const deepCopy = window.structuredClone ?? recursiveCopy;
function cleanupGeometry(geom) {
  var _a2;
  const newGeom = deepCopy(geom);
  if ("properties" in newGeom) {
    newGeom.properties = {};
  }
  if ("features" in newGeom && ((_a2 = newGeom.features) == null ? void 0 : _a2.length)) {
    newGeom.features = newGeom.features.map(
      (feature) => cleanupGeometry(feature)
    );
  }
  return newGeom;
}
function isGeometryEmpty(geom) {
  return !geom || !geom.geometry || geom.geometry.type === "FeatureCollection" && !geom.geometry.features.length;
}
function createBivariateQuery(geom) {
  const body = {
    importantLayers: IMPORTANT_BIVARIATE_LAYERS
  };
  if (geom && !isGeometryEmpty(geom)) body.geoJSON = cleanupGeometry(geom == null ? void 0 : geom.geometry);
  return body;
}
function parseGraphQLErrors(response) {
  if (response.hasOwnProperty("errors") && Array.isArray(response["errors"])) {
    return response["errors"].reduce((acc, errorObj) => {
      if (errorObj.hasOwnProperty("message")) {
        acc.push(errorObj["message"]);
      }
      return acc;
    }, []).join("<br/>");
  }
}
function axisDTOtoAxis(dto) {
  var _a2;
  return {
    ...dto,
    id: dto.quotient.join("|"),
    label: dto.label ? formatCustomBivariateAxisLabel(dto.label, dto.quotients) : formatBivariateAxisLabel(dto.quotients),
    transformation: {
      ...dto.transformation,
      transformation: ((_a2 = dto.transformation) == null ? void 0 : _a2.transformation) ?? "no"
    }
  };
}
const bivariateStatisticsDependencyAtom = v3toV2(
  atom((ctx) => {
    const focusedGeometry = ctx.spy(focusedGeometryAtom.v3atom);
    return { focusedGeometry };
  })
);
let worldStatsCache;
const bivariateStatisticsResourceAtom$1 = createAsyncAtom(
  bivariateStatisticsDependencyAtom,
  async ({ focusedGeometry }, abortController) => {
    if (!(focusedGeometry == null ? void 0 : focusedGeometry.geometry) && worldStatsCache) {
      return worldStatsCache;
    }
    try {
      const body = createBivariateQuery(focusedGeometry);
      const responseData = await apiClient.post("/bivariate_matrix", body, true, {
        signal: abortController.signal,
        retryAfterTimeoutError: {
          times: 2,
          delayMs: 1e3
        }
      });
      if (!responseData) {
        throw new Error(TranslationService.t("no_data_received"));
      }
      const { data } = responseData;
      if (!data) {
        const msg = parseGraphQLErrors(responseData);
        throw new Error(msg || TranslationService.t("no_data_received"));
      }
      const statsDTO = data.polygonStatistic.bivariateStatistic;
      if (!statsDTO || !Array.isArray(statsDTO == null ? void 0 : statsDTO.correlationRates)) {
        throw new Error(TranslationService.t("wrong_data_received"));
      }
      const stat = {
        ...statsDTO,
        axis: statsDTO.axis.map((ax) => axisDTOtoAxis(ax))
      };
      if (isGeometryEmpty(focusedGeometry) && !worldStatsCache) {
        worldStatsCache = stat;
      }
      return stat;
    } catch (e) {
      if (isApiError(e) && e.problem.kind === "canceled") {
        return null;
      }
      throw e;
    }
  },
  "bivariateStatisticsResource"
);
function extractAvailableNumeratorsWithDenominators(stat) {
  const { correlationRates } = stat;
  const x2 = [];
  const y2 = [];
  for (const correlationRate of correlationRates) {
    const xQuotient = correlationRate.x.quotient;
    const xParent = correlationRate.x.parent || xQuotient;
    let xGroup = x2.find((g2) => g2.parent === JSON.stringify(xParent));
    if (!xGroup) {
      xGroup = {
        parent: JSON.stringify(xParent),
        quotients: [xQuotient],
        selectedQuotient: xQuotient
      };
      x2.push(xGroup);
    } else if (!xGroup.quotients.find((q2) => JSON.stringify(q2) === JSON.stringify(xQuotient))) {
      xGroup.quotients.push(xQuotient);
    }
    const yQuotient = correlationRate.y.quotient;
    const yParent = correlationRate.y.parent || yQuotient;
    let yGroup = y2.find((g2) => g2.parent === JSON.stringify(yParent));
    if (!yGroup) {
      yGroup = {
        parent: JSON.stringify(yParent),
        quotients: [yQuotient],
        selectedQuotient: yQuotient
      };
      y2.push(yGroup);
    } else if (!yGroup.quotients.find((q2) => JSON.stringify(q2) === JSON.stringify(yQuotient))) {
      yGroup.quotients.push(yQuotient);
    }
  }
  for (const group of x2) {
    const parent = group.quotients.find((q2) => JSON.stringify(q2) === group.parent);
    if (parent) {
      group.selectedQuotient = parent;
    }
  }
  for (const group of y2) {
    const parent = group.quotients.find((q2) => JSON.stringify(q2) === group.parent);
    if (parent) {
      group.selectedQuotient = parent;
    }
  }
  return { x: x2, y: y2 };
}
const bivariateNumeratorsAtom = atom(
  (ctx, state = { xGroups: [], yGroups: [] }) => {
    const { data: stats, loading: loading2 } = ctx.spy(bivariateStatisticsResourceAtom$1.v3atom);
    if (stats && !loading2) {
      const numerators = extractAvailableNumeratorsWithDenominators(stats);
      return { xGroups: numerators.x, yGroups: numerators.y };
    }
    return state;
  },
  "bivariateNumeratorsAtom"
);
const setNumeratorsAction = action((ctx, nums) => {
  bivariateNumeratorsAtom(ctx, nums);
}, "setNumeratorsAction");
const onCalculateSelectedCell = (xGroups, yGroups, matrixSelection) => {
  const xIndex = xGroups ? xGroups.findIndex(
    (group) => group.selectedQuotient[0] === (matrixSelection == null ? void 0 : matrixSelection.xNumerator) && group.selectedQuotient[1] === (matrixSelection == null ? void 0 : matrixSelection.xDenominator)
  ) : -1;
  const yIndex = yGroups ? yGroups.findIndex(
    (group) => group.selectedQuotient[0] === (matrixSelection == null ? void 0 : matrixSelection.yNumerator) && group.selectedQuotient[1] === (matrixSelection == null ? void 0 : matrixSelection.yDenominator)
  ) : -1;
  return { x: xIndex, y: yIndex };
};
const selectQuotientInGroupByNumDen = (groups2, numId, denId) => {
  const newGroups = [...groups2];
  let selectedQuotient;
  const groupIndex = newGroups.findIndex(({ quotients }) => {
    selectedQuotient = quotients.find(
      (q2) => q2[0] === numId && q2[1] === denId
    );
    return selectedQuotient;
  });
  if (selectedQuotient) {
    newGroups[groupIndex] = { ...newGroups[groupIndex], selectedQuotient };
  }
  return newGroups;
};
const DEFAULT_STATE = {
  xNumerator: null,
  xDenominator: null,
  yNumerator: null,
  yDenominator: null,
  selectedCell: null,
  selectCellCallback: null
};
function formatSelection(xNumerator, xDenominator, yNumerator, yDenominator) {
  return { xNumerator, xDenominator, yNumerator, yDenominator };
}
const enabledLayersAtom = enabledLayersAtom$1.v3atom;
const layersRegistryAtom = layersRegistryAtom$1.v3atom;
const layersRegistryAtom_register = layersRegistryAtom$1.register.v3action;
const layersSettingsAtom = layersSettingsAtom$1.v3atom;
const bivariateStatisticsResourceAtom = bivariateStatisticsResourceAtom$1.v3atom;
let bivariateLayerAtomId;
const bivariateMatrixSelectionAtom = atom(
  DEFAULT_STATE,
  "bivariateMatrixSelectionAtom"
);
const calculateSelectedCellAction = action((ctx) => {
  const { xGroups, yGroups } = ctx.get(bivariateNumeratorsAtom);
  const state = ctx.get(bivariateMatrixSelectionAtom);
  const nextSelectedCell = onCalculateSelectedCell(
    xGroups,
    yGroups,
    formatSelection(
      state.xNumerator,
      state.xDenominator,
      state.yNumerator,
      state.yDenominator
    )
  );
  const currentCell = state.selectedCell;
  if (!currentCell || nextSelectedCell.x !== currentCell.x || nextSelectedCell.y !== currentCell.y) {
    bivariateMatrixSelectionAtom(ctx, { ...state, selectedCell: nextSelectedCell });
  }
}, "calculateSelectedCellAction");
const setSelectCellCallbackAction = action((ctx, selectCellCallback) => {
  bivariateMatrixSelectionAtom(ctx, (state) => ({ ...state, selectCellCallback }));
}, "setSelectCellCallbackAction");
const callSelectCellCallbackAction = action((ctx, objWithXY) => {
  var _a2, _b;
  const { x: x2, y: y2 } = objWithXY;
  (_b = (_a2 = ctx.get(bivariateMatrixSelectionAtom)) == null ? void 0 : _a2.selectCellCallback) == null ? void 0 : _b.call(_a2, x2, y2);
}, "callSelectCellCallbackAction");
const resetSelectionAction = action((ctx) => {
  bivariateMatrixSelectionAtom(ctx, (state) => {
    ctx.schedule(() => {
      var _a2;
      (_a2 = state == null ? void 0 : state.selectCellCallback) == null ? void 0 : _a2.call(state, -1, -1);
    });
    return {
      ...state,
      xNumerator: null,
      xDenominator: null,
      yNumerator: null,
      yDenominator: null,
      selectedCell: null
    };
  });
}, "resetSelectionAction");
action((ctx) => {
  const layer = getEnabledBivariateLayer(ctx);
  if (!layer || !(layer == null ? void 0 : layer.legend)) {
    resetSelectionAction(ctx);
    return;
  }
  const axis2 = layer.legend.axis;
  if (axis2) {
    const preselectionFormatted = formatSelection(
      axis2.x.quotient[0] || null,
      axis2.x.quotient[1] || null,
      axis2.y.quotient[0] || null,
      axis2.y.quotient[1] || null
    );
    const { xGroups, yGroups } = ctx.get(bivariateNumeratorsAtom);
    const nextSelectedCell = onCalculateSelectedCell(
      xGroups,
      yGroups,
      preselectionFormatted
    );
    if (nextSelectedCell.x >= 0 && nextSelectedCell.y >= 0) {
      ctx.schedule(() => {
        presetMatrixSelectionAction(ctx, preselectionFormatted);
        callSelectCellCallbackAction(ctx, nextSelectedCell);
      });
      return;
    }
    let newXGroups = xGroups;
    let newYGroups = yGroups;
    if (nextSelectedCell.x === -1) {
      newXGroups = selectQuotientInGroupByNumDen(
        xGroups,
        axis2.x.quotient[0],
        axis2.x.quotient[1]
      );
    }
    if (nextSelectedCell.y === -1) {
      newYGroups = selectQuotientInGroupByNumDen(
        yGroups,
        axis2.y.quotient[0],
        axis2.y.quotient[1]
      );
    }
    const finishSelection = onCalculateSelectedCell(
      newXGroups,
      newYGroups,
      preselectionFormatted
    );
    ctx.schedule(() => {
      if (finishSelection.x >= 0 && finishSelection.y >= 0) {
        setNumeratorsAction(ctx, { xGroups: newXGroups, yGroups: newYGroups });
        presetMatrixSelectionAction(ctx, preselectionFormatted);
        callSelectCellCallbackAction(ctx, finishSelection);
      } else {
        resetSelectionAction(ctx);
      }
    });
  }
}, "runPreselectionAction");
const presetMatrixSelectionAction = action((ctx, selection) => {
  bivariateMatrixSelectionAtom(ctx, (state) => ({ ...state, ...selection }));
  calculateSelectedCellAction(ctx);
}, "presetMatrixSelectionAction");
const enableBivariateLayerAction = action((ctx, lId) => {
  const registry = ctx.get(layersRegistryAtom);
  const layer = registry.get(lId);
  if (layer) {
    layer.enable.v3action(ctx);
  }
}, "enableBivariateLayerAction");
const disableBivariateLayerAction = action(
  (ctx, bivariateLayerAtomId2) => {
    const registry = ctx.get(layersRegistryAtom);
    if (bivariateLayerAtomId2) {
      const layerAtom = registry.get(bivariateLayerAtomId2);
      layerAtom && layerAtom.destroy.v3action(ctx);
    }
  },
  "disableBivariateLayerAction"
);
action(
  (ctx, xNumerator, xDenominator, yNumerator, yDenominator) => {
    bivariateMatrixSelectionAtom(ctx, (state) => ({
      ...state,
      xNumerator,
      xDenominator,
      yNumerator,
      yDenominator
    }));
    calculateSelectedCellAction(ctx);
    if (xNumerator === null || yNumerator === null) return;
    const { xGroups, yGroups } = ctx.get(bivariateNumeratorsAtom);
    const stats = ctx.get(bivariateStatisticsResourceAtom).data;
    if (stats === null) return;
    if (!xGroups || !yGroups || !xGroups.length || !yGroups.length) return;
    if (!xDenominator || !yDenominator) return;
    const res = generateColorThemeAndBivariateStyle(
      xNumerator,
      xDenominator,
      yNumerator,
      yDenominator,
      stats,
      SOURCE_LAYER_BIVARIATE
    );
    if (res) {
      const [colorTheme, bivariateStyle] = res;
      const legend2 = createBivariateLegend(
        "Bivariate Layer",
        colorTheme,
        xNumerator,
        xDenominator,
        yNumerator,
        yDenominator,
        stats
      );
      if (legend2) {
        const bivStyle = bivariateStyle;
        const biSource = bivStyle.source;
        const id = bivStyle.id;
        const meta2 = createBivariateMeta(
          xNumerator,
          xDenominator,
          yNumerator,
          yDenominator,
          stats
        );
        const source = biSource ? {
          id,
          maxZoom: biSource.maxzoom,
          minZoom: biSource.minzoom,
          source: {
            type: biSource.type,
            urls: biSource.tiles,
            tileSize: 512,
            apiKey: ""
          }
        } : void 0;
        const [updateActions, cleanUpActions] = createUpdateLayerActions([
          {
            id,
            legend: legend2,
            meta: meta2,
            source
          }
        ]);
        const currentSettings = ctx.get(layersSettingsAtom);
        if (!currentSettings.has(id)) {
          updateActions.push(
            ...createUpdateLayerActions([
              {
                id,
                settings: {
                  id,
                  name: "Bivariate Layer",
                  category: "overlay",
                  group: "bivariate",
                  ownedByUser: true
                }
              }
            ]).flat()
          );
        }
        const currentRegistry = ctx.get(layersRegistryAtom);
        if (!currentRegistry.has(id)) {
          disableBivariateLayerAction(ctx, bivariateLayerAtomId);
          bivariateLayerAtomId = id;
          layersRegistryAtom_register(ctx, [
            {
              id,
              renderer: new BivariateRenderer({ id }),
              cleanUpActions
            }
          ]);
          enableBivariateLayerAction(ctx, id);
        }
        if (updateActions.length) {
          store.dispatch(updateActions);
        }
      }
    }
  },
  "setMatrixSelectionAction"
);
function getEnabledBivariateLayer(ctx) {
  const enabledLayers = ctx.get(enabledLayersAtom);
  const registry = ctx.get(layersRegistryAtom);
  const layer = [...enabledLayers].map((layer2) => {
    var _a2;
    return (_a2 = registry.get(layer2)) == null ? void 0 : _a2.getState();
  }).find((layer2) => {
    var _a2;
    return layer2 && layer2.isEnabled && ((_a2 = layer2.legend) == null ? void 0 : _a2.type) === "bivariate";
  });
  return layer;
}
const BivariateMatrixContext = reactExports.createContext(null);
const MATRIX_CELL_SIDE = 37;
const MATRIX_SCALE = 0.7;
const BIVARIATE_MATRIX_WIDTH_SHIFT = MATRIX_CELL_SIDE / Math.sqrt(2);
const BIVARIATE_MATRIX_HEIGHT_SHIFT = MATRIX_CELL_SIDE / Math.sqrt(2);
function useGridStyle(x2, y2, cellSize = 0) {
  const memoizedGridStyle = reactExports.useMemo(
    () => ({
      display: "inline-grid",
      "--cell-size": cellSize === 0 ? "initial" : `${cellSize}px`,
      gridTemplateRows: `repeat(${y2}, ${cellSize === 0 ? "auto" : cellSize + "px"})`,
      gridTemplateColumns: `repeat(${x2}, ${cellSize === 0 ? "auto" : cellSize + "px"})`
    }),
    [x2, y2, cellSize]
  );
  return memoizedGridStyle;
}
function generateCellStyles(maxCols, maxRows) {
  const cellStyles = [];
  for (let i2 = 0; i2 < maxCols; i2++) {
    cellStyles[i2] = [];
    for (let j2 = 0; j2 < maxRows; j2++) {
      cellStyles[i2][j2] = {
        gridColumn: `${i2} / ${i2 + 1}`,
        gridRow: `${j2} / ${j2 + 1}`
      };
    }
  }
  return cellStyles;
}
function useBaseMatrixDimension(xHeadings, yHeadings) {
  const memoizedBaseDimension = reactExports.useMemo(() => {
    if (!xHeadings || !xHeadings.length || !yHeadings || !yHeadings.length) return 0;
    let xLength = calculateStringWidth(xHeadings[0].label);
    for (let i2 = 1; i2 < xHeadings.length; i2++) {
      const iStrWidth = calculateStringWidth(xHeadings[i2].label);
      const shift2 = i2 * BIVARIATE_MATRIX_HEIGHT_SHIFT;
      if (iStrWidth > xLength + shift2) {
        xLength = iStrWidth - shift2;
      }
    }
    let yLength = calculateStringWidth(yHeadings[0].label);
    for (let i2 = 1; i2 < yHeadings.length; i2++) {
      const iStrWidth = calculateStringWidth(yHeadings[i2].label);
      const shift2 = i2 * BIVARIATE_MATRIX_WIDTH_SHIFT;
      if (iStrWidth > yLength + shift2) {
        yLength = iStrWidth - shift2;
      }
    }
    return xLength > yLength ? xLength : yLength;
  }, [xHeadings, yHeadings]);
  return memoizedBaseDimension;
}
const canvas = document.createElement("canvas");
const context = canvas.getContext("2d") || {};
context.font = "normal 13px Roboto";
const QUOTIENT_ICON_SIZE = 30;
const QUOTIENTS_DROPDOWN_SIZE = 90;
function calculateStringWidth(str) {
  return context.measureText(str).width + QUOTIENT_ICON_SIZE + QUOTIENTS_DROPDOWN_SIZE;
}
function calculateHeadingsStyle(baseDimension, vertical, index2) {
  return vertical ? { height: `${baseDimension + index2 * BIVARIATE_MATRIX_HEIGHT_SHIFT}px` } : { width: `${baseDimension + index2 * BIVARIATE_MATRIX_WIDTH_SHIFT}px` };
}
const hoveredCell = "_hoveredCell_kt59d_1";
const valueCell = "_valueCell_kt59d_5";
const rotatedCell = "_rotatedCell_kt59d_19";
const valueFill = "_valueFill_kt59d_28";
const disabled$1 = "_disabled_kt59d_39";
const selectedCol = "_selectedCol_kt59d_43";
const first = "_first_kt59d_48";
const last = "_last_kt59d_52";
const selectedRow = "_selectedRow_kt59d_56";
const styles$6 = {
  hoveredCell,
  valueCell,
  rotatedCell,
  valueFill,
  disabled: disabled$1,
  selectedCol,
  first,
  last,
  selectedRow
};
const BivariateMatrixCell = reactExports.forwardRef(
  ({
    value,
    x: x2,
    y: y2,
    className,
    onMouseOver,
    onMouseOut,
    onClick,
    disabled: disabled2 = false,
    style: style2,
    firstRow,
    firstCol,
    lastRow,
    lastCol
  }, ref) => {
    const containerRef = reactExports.useRef(null);
    let isHovered = false;
    let isFromSelectedRow = false;
    let isFromSelectedCol = false;
    const baseClassNames = clsx(styles$6.valueCell, className, disabled2 && styles$6.disabled);
    function generateClassNames() {
      return `${baseClassNames} ${clsx({
        [styles$6.hoveredCell]: isHovered,
        [styles$6.selectedCol]: isFromSelectedCol,
        [styles$6.selectedRow]: isFromSelectedRow,
        [styles$6.first]: firstRow && isFromSelectedCol || firstCol && isFromSelectedRow,
        [styles$6.last]: lastRow && isFromSelectedCol || lastCol && isFromSelectedRow
      })}`;
    }
    reactExports.useImperativeHandle(ref, () => ({
      setHovered: () => {
        if (containerRef.current) {
          isHovered = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetHovered: () => {
        if (containerRef.current) {
          isHovered = false;
          containerRef.current.className = generateClassNames();
        }
      },
      setSelectedCol: () => {
        if (containerRef.current) {
          isFromSelectedCol = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetSelectedCol: () => {
        if (containerRef.current) {
          isFromSelectedCol = false;
          containerRef.current.className = generateClassNames();
        }
      },
      setSelectedRow: () => {
        if (containerRef.current) {
          isFromSelectedRow = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetSelectedRow: () => {
        if (containerRef.current) {
          isFromSelectedRow = false;
          containerRef.current.className = generateClassNames();
        }
      }
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: containerRef,
        className: baseClassNames,
        style: style2,
        onMouseOver: () => {
          onMouseOver(x2, y2);
        },
        onClick: (e) => {
          onClick(x2, y2, e);
        },
        onMouseOut,
        children: !disabled2 && value !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          Math.abs(value) >= 0.1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: styles$6.valueFill,
              style: { transform: `scale(${Math.abs(value)})` }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.rotatedCell, children: value == null ? void 0 : value.toFixed(3) })
        ] }) : null
      }
    );
  }
);
BivariateMatrixCell.displayName = "BivariateMatrixCell";
const legendSlot = "_legendSlot_i0ppr_6";
const matrixContainer = "_matrixContainer_i0ppr_14";
const rotatedMatrix = "_rotatedMatrix_i0ppr_21";
const styles$5 = {
  legendSlot,
  matrixContainer,
  rotatedMatrix
};
const horConnector = "_horConnector_zzmmn_1";
const vertConnector = "_vertConnector_zzmmn_7";
const connectorBody = "_connectorBody_zzmmn_13";
const hovered$1 = "_hovered_zzmmn_28";
const selected$2 = "_selected_zzmmn_33";
const styles$4 = {
  horConnector,
  vertConnector,
  connectorBody,
  hovered: hovered$1,
  selected: selected$2
};
const BivariateMatrixCellConnector = reactExports.forwardRef(
  ({ type, style: style2 }, ref) => {
    const containerRef = reactExports.useRef(null);
    let isHovered = false;
    let isSelected = false;
    const baseClassNames = styles$4.connectorBody;
    function generateClassNames() {
      return `${baseClassNames} ${clsx({
        [styles$4.hovered]: isHovered,
        [styles$4.selected]: isSelected
      })}`;
    }
    reactExports.useImperativeHandle(ref, () => ({
      setHovered: () => {
        if (containerRef.current) {
          isHovered = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetHovered: () => {
        if (containerRef.current) {
          isHovered = false;
          containerRef.current.className = generateClassNames();
        }
      },
      setSelectedCol: () => {
        if (type === "vertical" && containerRef.current) {
          isSelected = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetSelectedCol: () => {
        if (type === "vertical" && containerRef.current) {
          isSelected = false;
          containerRef.current.className = generateClassNames();
        }
      },
      setSelectedRow: () => {
        if (type === "horizontal" && containerRef.current) {
          isSelected = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetSelectedRow: () => {
        if (type === "horizontal" && containerRef.current) {
          isSelected = false;
          containerRef.current.className = generateClassNames();
        }
      }
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: type === "horizontal" ? styles$4.horConnector : styles$4.vertConnector,
        style: style2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4.connectorBody, ref: containerRef })
      }
    );
  }
);
BivariateMatrixCellConnector.displayName = "BivariateMatrixCellConnector";
const denominatorIcon = "_denominatorIcon_2n0u5_1";
const styles$3 = {
  denominatorIcon
};
const PopulationIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_4777_147920)", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M4.59226 5.6715C4.57385 5.68982 4.55581 5.70848 4.53814 5.72748C4.27818 6.00698 4.09843 6.3591 4.03058 6.74363C4.30836 6.45062 4.50699 6.08183 4.59226 5.6715ZM10.3266 5.66248C10.4117 6.0808 10.6146 6.45633 10.8991 6.75295C10.8325 6.3648 10.6519 6.00926 10.3899 5.7275C10.3693 5.70537 10.3482 5.68368 10.3266 5.66248ZM10.927 7.12889C10.2881 7.58142 9.93487 8.39557 10.1356 9.23105L10.3024 9.92533L10.8712 7.55816C10.9059 7.41385 10.924 7.27018 10.927 7.12889ZM10.8167 12.0655L11.135 13.3906C11.2431 13.8401 11.6451 14.157 12.1074 14.157H12.8928C13.3551 14.157 13.7571 13.8401 13.8651 13.3906L14.8646 9.23105C15.0886 8.29843 14.6225 7.39238 13.8391 6.98624C14.3731 6.58123 14.718 5.93987 14.718 5.21796C14.718 3.99301 13.725 3 12.5001 3C12.1224 3 11.7669 3.09436 11.4556 3.26079C11.4174 3.85333 11.25 4.41104 10.9816 4.90556C11.0898 5.00751 11.1903 5.11726 11.2822 5.23375C11.2821 5.22849 11.2821 5.22323 11.2821 5.21796C11.2821 4.5453 11.8274 4 12.5001 4C13.1727 4 13.718 4.5453 13.718 5.21796C13.718 5.89062 13.1727 6.43592 12.5001 6.43592C12.2381 6.43592 11.9954 6.35321 11.7968 6.21249C11.9482 6.7042 11.975 7.24459 11.8435 7.79175C11.9191 7.77351 11.9983 7.7638 12.0803 7.7638H12.9199C13.5667 7.7638 14.0433 8.36854 13.8922 8.99743L12.8928 13.157L12.1074 13.157L11.3309 9.92533L10.8167 12.0655ZM4.10776 12.0505L3.78577 13.3906C3.67777 13.8401 3.27574 14.157 2.81344 14.157H2.02803C1.56574 14.157 1.16371 13.8401 1.0557 13.3906L0.0562696 9.23105C-0.167809 8.29845 0.298349 7.39241 1.08167 6.98626C0.547652 6.58125 0.202745 5.93988 0.202745 5.21796C0.202745 3.99301 1.19576 3 2.42071 3C2.80138 3 3.15965 3.0959 3.47268 3.26486C3.5114 3.85587 3.67872 4.41215 3.94647 4.90553C3.83535 5.01024 3.73236 5.12317 3.63841 5.24319C3.63858 5.2348 3.63867 5.22639 3.63867 5.21796C3.63867 4.5453 3.09337 4 2.42071 4C1.74804 4 1.20274 4.5453 1.20274 5.21796C1.20274 5.89062 1.74804 6.43592 2.42071 6.43592C2.68679 6.43592 2.93294 6.3506 3.1333 6.20582C2.98006 6.69932 2.95243 7.24213 3.0845 7.79178L3.08494 7.79363C3.00708 7.77418 2.92528 7.7638 2.84055 7.7638H2.00092C1.35413 7.7638 0.877492 8.36854 1.0286 8.99742L2.02803 13.157L2.81344 13.157L3.59353 9.91034L4.10776 12.0505ZM4.62199 9.91034L4.78521 9.23105C4.98518 8.39877 4.63543 7.58765 4.00112 7.13409C4.00445 7.2737 4.02258 7.41562 4.05683 7.55816L4.62199 9.91034Z",
            fill: "black"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M9.46348 3C9.46348 4.10457 8.56805 5 7.46348 5C6.35891 5 5.46348 4.10457 5.46348 3C5.46348 1.89543 6.35891 1 7.46348 1C8.56805 1 9.46348 1.89543 9.46348 3ZM9.52339 5.18101C10.1023 4.63409 10.4635 3.85923 10.4635 3C10.4635 1.34315 9.12033 0 7.46348 0C5.80662 0 4.46348 1.34315 4.46348 3C4.46348 3.85922 4.8247 4.63408 5.40356 5.181C4.4317 5.4836 3.80296 6.50391 4.05627 7.55816L5.68205 14.3245C5.79005 14.774 6.19208 15.0909 6.65437 15.0909H8.27254C8.73483 15.0909 9.13686 14.774 9.24487 14.3245L10.8706 7.55816C11.1239 6.50392 10.4952 5.48363 9.52339 5.18101ZM6.00092 6.09091H8.92599C9.57278 6.09091 10.0494 6.69564 9.89832 7.32453L8.27254 14.0909H6.65437L5.0286 7.32453C4.87749 6.69564 5.35414 6.09091 6.00092 6.09091Z",
            fill: "black"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_4777_147920", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "24", height: "24", fill: "white" }) }) })
    ]
  }
);
const AreaIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 15 15",
    fill: "none",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M14.6012 12.1833C15.0887 12.6708 15.0887 13.4833 14.6012 13.9708L13.7346 14.8375C13.6262 14.9458 13.5179 15 13.3554 15C13.2471 15 13.0846 14.9458 12.9762 14.8375C12.7596 14.6208 12.7596 14.2958 12.9762 14.1333L13.4637 13.6458H3.33874C2.20124 13.6458 1.33457 12.725 1.33457 11.5875V1.4625L0.847072 1.95C0.630406 2.16667 0.305406 2.16667 0.142906 1.95C-0.0195943 1.73333 -0.073761 1.40833 0.142906 1.24583L1.00957 0.379167C1.49707 -0.108333 2.30957 -0.108333 2.79707 0.379167L3.66374 1.24583C3.88041 1.4625 3.88041 1.7875 3.66374 1.95C3.55541 2.05833 3.39291 2.05833 3.28457 2.05833C3.17624 2.05833 3.01374 2.00417 2.90541 1.89583L2.36374 1.35417V11.5875C2.36374 12.1292 2.79707 12.6167 3.39291 12.6167H13.5721L13.0304 12.075C12.8137 11.8583 12.8137 11.5333 13.0304 11.3708C13.2471 11.1542 13.5721 11.1542 13.7346 11.3708L14.6012 12.1833ZM13.4637 0H6.85541C6.58457 0 6.36791 0.216667 6.36791 0.4875C6.36791 0.758333 6.58457 0.975 6.85541 0.975H13.4096C13.6804 0.975 13.8971 1.19167 13.8971 1.4625V8.125C13.8971 8.39583 14.1137 8.6125 14.3846 8.6125C14.6554 8.6125 14.8721 8.39583 14.8721 8.125V1.51667C14.9804 0.704167 14.2762 0 13.4637 0ZM8.45541 9.72083C8.72624 9.72083 8.94291 9.50417 8.94291 9.23333V6.95833C8.94291 6.2 8.29291 5.55 7.53457 5.55C7.20957 5.55 6.88457 5.65833 6.66791 5.875C6.45124 5.65833 6.12624 5.55 5.80124 5.55C5.58457 5.55 5.42207 5.60417 5.25957 5.65833C5.15124 5.55 5.04291 5.49583 4.88041 5.49583C4.60957 5.49583 4.39291 5.7125 4.39291 5.98333V9.17917C4.39291 9.45 4.60957 9.66667 4.88041 9.66667C5.15124 9.66667 5.36791 9.45 5.36791 9.17917V6.95833C5.36791 6.74167 5.53041 6.57917 5.74707 6.57917C5.96374 6.57917 6.12624 6.74167 6.12624 6.95833V9.23333C6.12624 9.50417 6.34291 9.72083 6.61374 9.72083C6.88457 9.72083 7.10124 9.50417 7.10124 9.23333V6.95833C7.10124 6.74167 7.26374 6.57917 7.48041 6.57917C7.69707 6.57917 7.85957 6.74167 7.85957 6.95833V9.23333C7.91374 9.50417 8.18457 9.72083 8.45541 9.72083ZM10.7304 3.7625C10.0804 3.7625 9.53874 4.30417 9.53874 4.95417C9.53874 5.225 9.75541 5.44167 10.0262 5.44167C10.2971 5.44167 10.5137 5.225 10.5137 4.95417C10.5137 4.84583 10.5679 4.79167 10.6762 4.79167C10.7304 4.79167 10.8387 4.84583 10.8387 4.95417C10.8387 5.00833 10.7304 5.225 10.2429 5.76667C9.9179 6.09167 9.64707 6.3625 9.64707 6.3625C9.48457 6.525 9.4304 6.74167 9.53874 6.90417C9.59291 7.12083 9.80957 7.22917 10.0262 7.22917H11.3804C11.6512 7.22917 11.8679 7.0125 11.8679 6.74167C11.8679 6.47083 11.6512 6.25417 11.3804 6.25417H11.2721C11.7054 5.7125 11.9221 5.33333 11.9221 5.00833C11.9221 4.25 11.3804 3.7625 10.7304 3.7625Z",
        fill: "black"
      }
    )
  }
);
const BuildingsIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 15 15",
    fill: "none",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M13.5938 15C14.112 15 14.5312 14.5807 14.5312 14.0625V7.5C14.5312 6.9818 14.112 6.5625 13.5938 6.5625H12.6562V0.9375C12.6562 0.419297 12.237 0 11.7188 0H5.15625C4.63805 0 4.21875 0.419297 4.21875 0.9375V2.8125H1.40625C0.888047 2.8125 0.46875 3.2318 0.46875 3.75V14.0625C0.46875 14.5807 0.888047 15 1.40625 15H13.5938ZM1.40625 3.75H4.21875V5.5H3.5C3.22386 5.5 3 5.72386 3 6C3 6.27614 3.22386 6.5 3.5 6.5H4.21875V8H3.5C3.22386 8 3 8.22386 3 8.5C3 8.77614 3.22386 9 3.5 9H4.21875V10.5H3.5C3.22386 10.5 3 10.7239 3 11C3 11.2761 3.22386 11.5 3.5 11.5H4.21875V14.0625H1.40625V3.75ZM5.15625 0.9375H11.7188V14.0625H8.90625V11.25H7.96875V14.0625H5.15625V0.9375ZM12.6562 7.5H13.5938V14.0625H12.6562V7.5ZM6 9.5C6 9.22386 6.22386 9 6.5 9H10.5C10.7761 9 11 9.22386 11 9.5C11 9.77614 10.7761 10 10.5 10H6.5C6.22386 10 6 9.77614 6 9.5ZM6.5 3C6.22386 3 6 3.22386 6 3.5C6 3.77614 6.22386 4 6.5 4H10.5C10.7761 4 11 3.77614 11 3.5C11 3.22386 10.7761 3 10.5 3H6.5ZM6 7.5C6 7.22386 6.22386 7 6.5 7H10.5C10.7761 7 11 7.22386 11 7.5C11 7.77614 10.7761 8 10.5 8H6.5C6.22386 8 6 7.77614 6 7.5ZM6.5 5C6.22386 5 6 5.22386 6 5.5C6 5.77614 6.22386 6 6.5 6H10.5C10.7761 6 11 5.77614 11 5.5C11 5.22386 10.7761 5 10.5 5H6.5Z",
        fill: "black"
      }
    )
  }
);
const PopulatedAreaIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M14.4949 0.505013C14.7683 0.77838 14.7683 1.2216 14.4949 1.49496L1.49493 14.495C1.22156 14.7683 0.778343 14.7683 0.504977 14.495C0.23161 14.2216 0.23161 13.7784 0.504977 13.505L13.505 0.505013C13.7783 0.231646 14.2216 0.231646 14.4949 0.505013ZM14.495 6.50503C14.7683 6.77839 14.7683 7.22161 14.495 7.49497L7.49497 14.495C7.22161 14.7683 6.77839 14.7683 6.50503 14.495C6.23166 14.2216 6.23166 13.7784 6.50503 13.505L13.505 6.50503C13.7784 6.23166 14.2216 6.23166 14.495 6.50503ZM8.49498 1.49497C8.76834 1.22161 8.76834 0.778392 8.49498 0.505025C8.22161 0.231658 7.77839 0.231658 7.50503 0.505025L0.505025 7.50503C0.231658 7.77839 0.231658 8.22161 0.505025 8.49498C0.778392 8.76834 1.22161 8.76834 1.49497 8.49498L8.49498 1.49497ZM3.49497 0.505025C3.76834 0.778392 3.76834 1.22161 3.49497 1.49497L1.49497 3.49497C1.22161 3.76834 0.778392 3.76834 0.505025 3.49497C0.231658 3.22161 0.231658 2.77839 0.505025 2.50503L2.50503 0.505025C2.77839 0.231658 3.22161 0.231658 3.49497 0.505025ZM14.495 12.495C14.7684 12.2216 14.7684 11.7784 14.495 11.505C14.2217 11.2317 13.7784 11.2317 13.5051 11.505L11.5051 13.505C11.2317 13.7784 11.2317 14.2216 11.5051 14.495C11.7784 14.7683 12.2217 14.7683 12.495 14.495L14.495 12.495Z",
        fill: "black"
      }
    )
  }
);
const OneIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 15 15",
    fill: "none",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M8.60002 4C8.60002 3.75732 8.45384 3.53854 8.22963 3.44567C8.00543 3.3528 7.74736 3.40413 7.57576 3.57573L5.57576 5.57573C5.34145 5.81005 5.34145 6.18995 5.57576 6.42426C5.81007 6.65857 6.18997 6.65857 6.42429 6.42426L7.40002 5.44852V10.4H6.50002C6.16865 10.4 5.90002 10.6686 5.90002 11C5.90002 11.3314 6.16865 11.6 6.50002 11.6H9.50002C9.8314 11.6 10.1 11.3314 10.1 11C10.1 10.6686 9.8314 10.4 9.50002 10.4H8.60002V4Z",
        fill: "black"
      }
    )
  }
);
const TotalRoadsIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 15 15",
    fill: "none",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M2.31257 14.9513C2.38285 14.9835 2.45927 15.0001 2.53658 15C2.66433 14.9997 2.78777 14.9537 2.88462 14.8704C2.98148 14.7871 3.04538 14.672 3.0648 14.5457L5.20765 0.617136C5.22508 0.478692 5.1878 0.338912 5.10375 0.227531C5.0197 0.116151 4.89551 0.0419601 4.75759 0.0207426C4.61968 -0.00047491 4.47893 0.0329551 4.36529 0.113921C4.25164 0.194887 4.17407 0.316999 4.14908 0.454279L2.00622 14.3828C1.99447 14.4593 1.9994 14.5373 2.02067 14.6116C2.04193 14.686 2.07903 14.7548 2.12942 14.8134C2.17981 14.8721 2.24229 14.9191 2.31257 14.9513ZM12.9007 14.8704C12.9975 14.9537 13.121 14.9997 13.2487 15C13.326 15.0001 13.4025 14.9835 13.4727 14.9513C13.543 14.9191 13.6055 14.8721 13.6559 14.8134C13.7063 14.7548 13.7434 14.686 13.7646 14.6116C13.7859 14.5373 13.7908 14.4593 13.7791 14.3828L11.6362 0.454279C11.6112 0.316999 11.5337 0.194887 11.42 0.113921C11.3064 0.0329551 11.1656 -0.00047491 11.0277 0.0207426C10.8898 0.0419601 10.7656 0.116151 10.6816 0.227531C10.5975 0.338912 10.5602 0.478692 10.5777 0.617136L12.7205 14.5457C12.7399 14.672 12.8038 14.7871 12.9007 14.8704ZM8.5 10.5C8.5 10.2239 8.27614 10 8 10C7.72386 10 7.5 10.2239 7.5 10.5V14.5C7.5 14.7761 7.72386 15 8 15C8.27614 15 8.5 14.7761 8.5 14.5V10.5ZM8 4C8.27614 4 8.5 4.22386 8.5 4.5V7.5C8.5 7.77614 8.27614 8 8 8C7.72386 8 7.5 7.77614 7.5 7.5V4.5C7.5 4.22386 7.72386 4 8 4ZM8.5 1C8.5 0.723858 8.27614 0.5 8 0.5C7.72386 0.5 7.5 0.723858 7.5 1V2C7.5 2.27614 7.72386 2.5 8 2.5C8.27614 2.5 8.5 2.27614 8.5 2V1Z",
        fill: "black"
      }
    )
  }
);
const iconMapper = {
  population: /* @__PURE__ */ jsxRuntimeExports.jsx(PopulationIcon, {}),
  area_km2: /* @__PURE__ */ jsxRuntimeExports.jsx(AreaIcon, {}),
  total_building_count: /* @__PURE__ */ jsxRuntimeExports.jsx(BuildingsIcon, {}),
  populated_area_km2: /* @__PURE__ */ jsxRuntimeExports.jsx(PopulatedAreaIcon, {}),
  one: /* @__PURE__ */ jsxRuntimeExports.jsx(OneIcon, {})
};
const tooltipTextMapper = {
  population: TranslationService.t("bivariate.matrix.icon.population"),
  area_km2: TranslationService.t("bivariate.matrix.icon.area_km2"),
  total_building_count: TranslationService.t("bivariate.matrix.icon.total_building_count"),
  populated_area_km2: TranslationService.t("bivariate.matrix.icon.populated_area_km2"),
  one: TranslationService.t("bivariate.matrix.icon.one")
};
const DenominatorIcon = ({ iconId }) => {
  const icon = iconMapper[iconId] || /* @__PURE__ */ jsxRuntimeExports.jsx(TotalRoadsIcon, {});
  const tooltipText = tooltipTextMapper[iconId] || TranslationService.t("bivariate.matrix.icon.roads");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopupTooltipWrapper, { tooltipText, children: ({ showTooltip, hideTooltip }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "span",
    {
      className: styles$3.denominatorIcon,
      onPointerOver: showTooltip,
      onPointerLeave: hideTooltip,
      children: icon
    }
  ) });
};
const createGlobalState = (initialState) => {
  let globalState = initialState;
  const listeners = /* @__PURE__ */ new Set();
  const setGlobalState = (nextGlobalState) => {
    globalState = nextGlobalState;
    listeners.forEach((listener) => listener());
  };
  return () => {
    const [state, setState] = reactExports.useState(globalState);
    reactExports.useEffect(() => {
      const listener = () => {
        setState(globalState);
      };
      listeners.add(listener);
      listener();
      return () => {
        listeners.delete(listener);
      };
    }, []);
    return [state, setGlobalState];
  };
};
const useHeadingGlobalState = createGlobalState({
  headingId: ""
});
const denominators = "_denominators_1m5c6_1";
const row$1 = "_row_1m5c6_5";
const column$1 = "_column_1m5c6_9";
const denominatorSelector = "_denominatorSelector_1m5c6_13";
const disabled = "_disabled_1m5c6_25";
const denominatorsContainer = "_denominatorsContainer_1m5c6_43";
const quotientItem = "_quotientItem_1m5c6_79";
const selected$1 = "_selected_1m5c6_85";
const styles$2 = {
  denominators,
  row: row$1,
  column: column$1,
  denominatorSelector,
  disabled,
  denominatorsContainer,
  quotientItem,
  selected: selected$1
};
const QuotientItem = ({
  numeratorId,
  denominatorId,
  numeratorLabel,
  quality,
  onSelectQuotient,
  isSelected = false
}) => {
  const onClick = (ev) => {
    ev.stopPropagation();
    onSelectQuotient(numeratorId, denominatorId);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: clsx(styles$2.quotientItem, isSelected && styles$2.selected),
      onClick,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DenominatorIcon, { iconId: denominatorId }),
        sessionStorage.getItem("BIVARIATE_QA_MOD") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "qualityLabel", children: quality !== null && quality !== void 0 ? quality : "&nbsp;" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "quotientLabel", children: numeratorLabel })
      ]
    }
  );
};
const SCALING_BACK = 100 / 70;
const MODAL_MARGIN = 5;
const QuotientSelector = reactExports.memo(
  ({
    id,
    quotients,
    selectedQuotient,
    onSelectQuotient,
    type,
    children
  }) => {
    const [headingState, setHeadingState] = useHeadingGlobalState();
    const toggleVisibility = (e) => {
      e.stopPropagation();
      if (headingState.headingId === id) {
        setHeadingState({ headingId: "", width: 0 });
      } else {
        const selectorPosition = e.currentTarget.getBoundingClientRect();
        const wholeRowPosition = e.currentTarget.parentElement.parentElement.getBoundingClientRect();
        const width = Math.ceil(
          (selectorPosition.left - wholeRowPosition.left) * SCALING_BACK + MODAL_MARGIN
        );
        setHeadingState({ headingId: id, width });
      }
    };
    const selectQuotient = reactExports.useCallback(
      (numId, denId) => {
        setHeadingState({ headingId: "" });
        onSelectQuotient(numId, denId);
      },
      [setHeadingState, onSelectQuotient]
    );
    const [selected2, notSelected] = reactExports.useMemo(() => {
      const selectedIndex = quotients.findIndex(
        ({ id: id2 }) => id2[0] === selectedQuotient.id[0] && id2[1] === selectedQuotient.id[1]
      );
      if (selectedIndex >= 0) {
        return [
          quotients[selectedIndex],
          quotients.filter((_2, i2) => i2 !== selectedIndex)
        ];
      }
      return [null, quotients];
    }, [quotients, selectedQuotient.id]);
    const renderQuotientItem = ({ id: id2, label: numeratorLabel, quality }, isSelected) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      QuotientItem,
      {
        onSelectQuotient: selectQuotient,
        quality,
        numeratorId: id2[0],
        denominatorId: id2[1],
        numeratorLabel,
        isSelected
      },
      JSON.stringify(id2)
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: clsx({
          [styles$2.denominators]: true,
          [styles$2.row]: type === "horizontal",
          [styles$2.column]: type === "vertical"
        }),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: toggleVisibility, children }),
          headingState.headingId === id && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: styles$2.denominatorsContainer,
              style: type === "horizontal" ? {
                left: -headingState.width,
                right: 0
              } : {
                top: -headingState.width,
                bottom: 0
              },
              children: [
                selected2 && renderQuotientItem(selected2, true),
                notSelected.map((item) => renderQuotientItem(item, false))
              ]
            }
          )
        ]
      }
    );
  }
);
QuotientSelector.displayName = "QuotientSelector";
const axisRecord = "_axisRecord_1dbhd_8";
const container$1 = "_container_1dbhd_13";
const column = "_column_1dbhd_34";
const row = "_row_1dbhd_43";
const selected = "_selected_1dbhd_110";
const corner = "_corner_1dbhd_142";
const hovered = "_hovered_1dbhd_146";
const verticalText = "_verticalText_1dbhd_173";
const quotientsCountLabel = "_quotientsCountLabel_1dbhd_185";
const styles$1 = {
  axisRecord,
  container: container$1,
  column,
  row,
  selected,
  corner,
  hovered,
  verticalText,
  quotientsCountLabel
};
const getHeadingPositionStyle = (isColum, index2) => {
  const styles2 = {
    gridColumn: isColum ? `${index2 + 3} / ${index2 + 4}` : "1",
    gridRow: isColum ? "1" : `${index2 + 3} / ${index2 + 4}`
  };
  return styles2;
};
const BivariateMatrixHeadingEntry = reactExports.forwardRef(
  ({
    index: index2,
    type,
    className,
    selectedIndex = -1,
    headerCell,
    id,
    onCellHover,
    onCellClick,
    onSelectQuotient,
    baseDimension,
    calculateHeadingsStyle: calculateHeadingsStyle2
  }, ref) => {
    const onMouseOver = () => {
      onCellHover(index2);
    };
    const onMouseOut = () => {
      onCellHover(null);
    };
    const onClick = (ev) => {
      const target = ev.target;
      if (target.tagName === "svg" || target.tagName === "path" || target.className && target.className.indexOf && target.className.indexOf("denominator") !== -1)
        return;
      onCellClick(index2, ev);
    };
    const selectQuotient = reactExports.useCallback(
      (numId, denId) => {
        onSelectQuotient(index2, numId, denId);
      },
      [onSelectQuotient, index2]
    );
    const numberOfAdditionalQuotientsInGroup = headerCell.quotients.length > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.quotientsCountLabel, children: [
      "+",
      headerCell.quotients.length - 1,
      " layers",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Memo$3, {})
    ] }) : null;
    const containerRef = reactExports.useRef(null);
    let isHovered = false;
    let isSelected = false;
    const isHorizontal = type === "horizontal";
    const isVertical = type === "vertical";
    const baseClassNames = clsx({
      [className || ""]: className,
      [styles$1.axisRecord]: true,
      [styles$1.column]: isVertical,
      [styles$1.row]: isHorizontal,
      [styles$1.verticalText]: isVertical,
      horizontal: isHorizontal,
      vertical: isVertical
    });
    function generateClassNames() {
      return `${baseClassNames} ${clsx({
        [styles$1.hovered]: isHovered,
        [styles$1.selected]: isSelected
      })}`;
    }
    reactExports.useImperativeHandle(ref, () => ({
      setHovered: () => {
        if (containerRef.current) {
          isHovered = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetHovered: () => {
        if (containerRef.current) {
          isHovered = false;
          containerRef.current.className = generateClassNames();
        }
      },
      setSelectedCol: () => {
        if (isVertical && containerRef.current) {
          isSelected = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetSelectedCol: () => {
        if (isVertical && containerRef.current) {
          isSelected = false;
          containerRef.current.className = generateClassNames();
        }
      },
      setSelectedRow: () => {
        if (isHorizontal && containerRef.current) {
          isSelected = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetSelectedRow: () => {
        if (isHorizontal && containerRef.current) {
          isSelected = false;
          containerRef.current.className = generateClassNames();
        }
      }
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: containerRef,
        onMouseEnter: onMouseOver,
        onMouseOut,
        onClick,
        style: getHeadingPositionStyle(type === "vertical", index2),
        className: baseClassNames,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: calculateHeadingsStyle2(baseDimension, isVertical, index2),
            className: styles$1.container,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1.corner }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(DenominatorIcon, { iconId: headerCell.selectedQuotient.id[1] }),
              sessionStorage.getItem("BIVARIATE_QA_MOD") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "qualityLabel", children: headerCell.quality ? headerCell.quality : "&nbsp;" }),
              headerCell.label,
              numberOfAdditionalQuotientsInGroup && /* @__PURE__ */ jsxRuntimeExports.jsx(
                QuotientSelector,
                {
                  id: `quotient_${id}`,
                  onSelectQuotient: selectQuotient,
                  selectedQuotient: headerCell.selectedQuotient,
                  quotients: headerCell.quotients,
                  type,
                  children: numberOfAdditionalQuotientsInGroup
                }
              )
            ]
          }
        )
      }
    );
  }
);
BivariateMatrixHeadingEntry.displayName = "BivariateMatrixHeadingEntry";
const axisCaptionRoot = "_axisCaptionRoot_1yhrg_1";
const axisCaptionAnchor = "_axisCaptionAnchor_1yhrg_6";
const axisCaptionBody = "_axisCaptionBody_1yhrg_10";
const tooltipHover = "_tooltipHover_1yhrg_24";
const axisCaptionText = "_axisCaptionText_1yhrg_33";
const popupContent = "_popupContent_1yhrg_47";
const s$4 = {
  axisCaptionRoot,
  axisCaptionAnchor,
  axisCaptionBody,
  tooltipHover,
  axisCaptionText,
  popupContent
};
const AXIS_CAPTIONS_TOOTIP_TEXT = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$4.axisCaptionText, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: TranslationService.t("bivariate.matrix.caption.tooltip.p1") }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: TranslationService.t("bivariate.matrix.caption.tooltip.li1") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: TranslationService.t("bivariate.matrix.caption.tooltip.li2") })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: TranslationService.t("bivariate.matrix.caption.tooltip.b") }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: TranslationService.t("bivariate.matrix.caption.tooltip.p2") }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: TranslationService.t("bivariate.matrix.caption.tooltip.p3") })
] });
const popupClasses = { popupContent: s$4.popupContent };
const AxisCaptions = ({ baseDimension = 0 }) => {
  const rootRef = reactExports.useRef(null);
  reactExports.useLayoutEffect(() => {
    var _a2;
    (_a2 = rootRef.current) == null ? void 0 : _a2.scrollIntoView({ block: "center" });
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$4.axisCaptionRoot, ref: rootRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$4.axisCaptionAnchor, style: { left: -baseDimension }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    PopupTooltipWrapper,
    {
      hoverBehavior: false,
      tooltipId: "axis_caption",
      tooltipText: AXIS_CAPTIONS_TOOTIP_TEXT,
      popupClasses,
      children: ({ showTooltip }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$4.axisCaptionBody, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(LongArrow, { position: "left" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$4.tooltipHover, onClick: showTooltip, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: TranslationService.t("bivariate.matrix.caption.base_axis") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Memo, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: TranslationService.t("bivariate.matrix.caption.annex_axis") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(LongArrow, { position: "right" })
      ] })
    }
  ) }) });
};
const LongArrow = ({ position = "left" }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "6",
    height: "22",
    viewBox: "0 0 6 22",
    fill: "none",
    transform: position === "left" ? "rotate(90)" : "rotate(-90)",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M3 1V20.5",
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M1 18L3 21.5L5 18",
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      )
    ]
  }
);
const CELL_INDEX_X_OFFSET = 3;
const CELL_INDEX_Y_OFFSET = 3;
const MATRIX_CORNERS_OVERFLOW = 15;
const BivariateMatrixControl = ({
  matrix,
  xHeadings,
  yHeadings,
  onSelectCell,
  selectedCell,
  cellSize = 0,
  onSelectQuotient
}) => {
  const containerRef = reactExports.useRef(null);
  const bivariateMatrixContext = reactExports.useContext(BivariateMatrixContext);
  const cellRowReferences = [];
  const cellColumnReferences = [];
  let hoveredColIndex = -1;
  let hoveredRowIndex = -1;
  const selectedColIndex = reactExports.useRef((selectedCell == null ? void 0 : selectedCell.x) ?? -1);
  const selectedRowIndex = reactExports.useRef((selectedCell == null ? void 0 : selectedCell.y) ?? -1);
  const setSelectCellCallback = useAction(setSelectCellCallbackAction);
  const setCellReference = (ref, rowIndex, colIndex) => {
    if (rowIndex >= 0) {
      if (!cellRowReferences[rowIndex]) {
        cellRowReferences[rowIndex] = [];
      }
      cellRowReferences[rowIndex].push(ref);
    }
    if (colIndex >= 0) {
      if (!cellColumnReferences[colIndex]) {
        cellColumnReferences[colIndex] = [];
      }
      cellColumnReferences[colIndex].push(ref);
    }
  };
  const onMouseOver = (x2, y2) => {
    if (hoveredColIndex !== x2) {
      hoveredColIndex = x2;
      if (hoveredColIndex !== -1) {
        const columns = cellColumnReferences[hoveredColIndex];
        if (columns) {
          columns.forEach((clmn) => {
            clmn == null ? void 0 : clmn.setHovered();
          });
        }
      }
    }
    if (hoveredRowIndex !== y2) {
      hoveredRowIndex = y2;
      if (hoveredRowIndex !== -1) {
        const rows = cellRowReferences[hoveredRowIndex];
        if (rows) {
          rows.forEach((rw) => {
            rw == null ? void 0 : rw.setHovered();
          });
        }
      }
    }
  };
  const onMouseOut = () => {
    if (hoveredColIndex !== -1) {
      const columns = cellColumnReferences[hoveredColIndex];
      if (columns) {
        columns.forEach((clmn) => {
          clmn == null ? void 0 : clmn.resetHovered();
        });
      }
      hoveredColIndex = -1;
    }
    if (hoveredRowIndex !== -1) {
      const rows = cellRowReferences[hoveredRowIndex];
      if (rows) {
        rows.forEach((rw) => {
          rw == null ? void 0 : rw.resetHovered();
        });
      }
      hoveredRowIndex = -1;
    }
  };
  const onCellHoverX = (cellIndex) => {
    onMouseOut();
    if (cellIndex) {
      onMouseOver(cellIndex, hoveredRowIndex);
    }
  };
  const onCellHoverY = (cellIndex) => {
    onMouseOut();
    if (cellIndex) {
      onMouseOver(hoveredColIndex, cellIndex);
    }
  };
  const onResetSelected = () => {
    if (selectedColIndex.current !== -1) {
      const columns = cellColumnReferences[selectedColIndex.current];
      if (columns) {
        columns.forEach((clmn) => {
          clmn == null ? void 0 : clmn.resetSelectedCol();
        });
      }
      selectedColIndex.current = -1;
    }
    if (selectedRowIndex.current !== -1) {
      const rows = cellRowReferences[selectedRowIndex.current];
      if (rows) {
        rows.forEach((rw) => {
          rw == null ? void 0 : rw.resetSelectedRow();
        });
      }
      selectedRowIndex.current = -1;
    }
  };
  const onInnerSelect = (x2, y2, e) => {
    onResetSelected();
    onSelectRowCol(x2, y2);
    onSelectCell(x2, y2, e);
  };
  const onOuterSelect = (x2, y2) => {
    onResetSelected();
    onSelectRowCol(x2, y2);
  };
  const onSelectRowCol = (x2, y2) => {
    if (x2 !== -1 && selectedColIndex.current !== x2) {
      selectedColIndex.current = x2;
      const columns = cellColumnReferences[selectedColIndex.current];
      if (columns) {
        columns.forEach((clmn) => {
          clmn == null ? void 0 : clmn.setSelectedCol();
        });
      }
    }
    if (y2 !== -1 && selectedRowIndex.current !== y2) {
      selectedRowIndex.current = y2;
      const rows = cellRowReferences[selectedRowIndex.current];
      if (rows) {
        rows.forEach((rw) => {
          rw == null ? void 0 : rw.setSelectedRow();
        });
      }
    }
  };
  const onCellSelectX = (cellIndex, e) => {
    onInnerSelect(cellIndex, selectedRowIndex.current, e);
  };
  const onCellSelectY = (cellIndex, e) => {
    onInnerSelect(selectedColIndex.current, cellIndex, e);
  };
  const selectQuotientX = reactExports.useCallback(
    (index2, numId, denId, e) => {
      onSelectQuotient(false, index2, numId, denId, e);
    },
    [onSelectQuotient]
  );
  const selectQuotientY = reactExports.useCallback(
    (index2, numId, denId, e) => {
      onSelectQuotient(true, index2, numId, denId, e);
    },
    [onSelectQuotient]
  );
  const baseDimension = useBaseMatrixDimension(xHeadings, yHeadings);
  const rotatedMatrixWrapperSide = Math.sqrt(
    Math.pow(xHeadings.length * MATRIX_CELL_SIDE, 2) + Math.pow(yHeadings.length * MATRIX_CELL_SIDE, 2)
  ) * MATRIX_SCALE + MATRIX_CORNERS_OVERFLOW;
  reactExports.useEffect(() => {
    bivariateMatrixContext == null ? void 0 : bivariateMatrixContext.onMatrixPositionRecalculated(
      baseDimension,
      rotatedMatrixWrapperSide
    );
    if (containerRef.current) containerRef.current.style.visibility = "visible";
  }, [baseDimension]);
  const gridStyle = useGridStyle(xHeadings.length + 1, yHeadings.length + 1, cellSize);
  const matrixContainerStyles = reactExports.useMemo(
    () => ({
      width: rotatedMatrixWrapperSide,
      height: rotatedMatrixWrapperSide
    }),
    [rotatedMatrixWrapperSide]
  );
  const cellStyles = reactExports.useMemo(() => {
    return generateCellStyles(
      xHeadings.length + CELL_INDEX_X_OFFSET,
      yHeadings.length + CELL_INDEX_Y_OFFSET
    );
  }, [xHeadings, yHeadings]);
  reactExports.useEffect(() => {
    setSelectCellCallback(onOuterSelect.bind(void 0));
    if (selectedCell && (selectedCell.x !== -1 || selectedCell.y !== -1)) {
      onOuterSelect(selectedCell.x, selectedCell.y);
    }
  }, [matrix]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: containerRef,
      className: styles$5.matrixContainer,
      style: matrixContainerStyles,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: gridStyle, className: styles$5.rotatedMatrix, children: [
        matrix.map((_row, rowIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          BivariateMatrixCellConnector,
          {
            type: "horizontal",
            style: cellStyles[-1 + CELL_INDEX_X_OFFSET][rowIndex + CELL_INDEX_Y_OFFSET],
            ref: (rf) => setCellReference(rf, rowIndex, -1)
          },
          `${rowIndex}_row_connector`
        )),
        matrix[0].map((_col, colIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          BivariateMatrixCellConnector,
          {
            type: "vertical",
            style: cellStyles[colIndex + CELL_INDEX_X_OFFSET][-1 + CELL_INDEX_Y_OFFSET],
            ref: (rf) => setCellReference(rf, -1, colIndex)
          },
          `${colIndex}_col_connector`
        )),
        matrix.map(
          (row2, rowIndex) => row2.map((val, colIndex) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              BivariateMatrixCell,
              {
                x: colIndex,
                y: rowIndex,
                onClick: onInnerSelect,
                onMouseOver,
                onMouseOut,
                style: cellStyles[colIndex + CELL_INDEX_X_OFFSET][rowIndex + CELL_INDEX_Y_OFFSET],
                ref: (rf) => setCellReference(rf, rowIndex, colIndex),
                value: val === null ? void 0 : val,
                disabled: val === null,
                firstRow: rowIndex === 0,
                firstCol: colIndex === 0,
                lastRow: rowIndex === matrix.length - 1,
                lastCol: colIndex === row2.length - 1
              },
              `matrix_cell_${colIndex}_${rowIndex}`
            );
          })
        ),
        [...yHeadings].reverse().map((entry, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          BivariateMatrixHeadingEntry,
          {
            id: `hor_${yHeadings.length - 1 - index2}`,
            index: yHeadings.length - 1 - index2,
            type: "horizontal",
            selectedIndex: selectedCell == null ? void 0 : selectedCell.y,
            headerCell: entry,
            onCellHover: onCellHoverY,
            onCellClick: onCellSelectY,
            onSelectQuotient: selectQuotientY,
            baseDimension,
            calculateHeadingsStyle,
            ref: (rf) => setCellReference(rf, yHeadings.length - 1 - index2, -1)
          },
          `hor_${yHeadings.length - 1 - index2}`
        )),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AxisCaptions, { baseDimension }),
        xHeadings.map((entry, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          BivariateMatrixHeadingEntry,
          {
            id: `vert_${index2}`,
            index: index2,
            type: "vertical",
            selectedIndex: selectedCell == null ? void 0 : selectedCell.x,
            headerCell: entry,
            onCellHover: onCellHoverX,
            onCellClick: onCellSelectX,
            onSelectQuotient: selectQuotientX,
            baseDimension,
            calculateHeadingsStyle,
            ref: (rf) => setCellReference(rf, -1, index2)
          },
          `vert_${index2}`
        ))
      ] })
    }
  );
};
BivariateMatrixControl.displayName = "BivariateMatrixControl";
const BivariateMatrixControlComponent = reactExports.memo(
  BivariateMatrixControl,
  (oldProps, newProps) => oldProps.matrix === newProps.matrix
);
const mock = {
  xGroups: [
    {
      parent: '["count","area_km2"]',
      quotients: [["count", "area_km2"]],
      selectedQuotient: ["count", "area_km2"]
    },
    {
      parent: '["local_hours","area_km2"]',
      quotients: [
        ["count", "populated_area_km2"],
        ["population_prev", "populated_area_km2"],
        ["gdp", "populated_area_km2"],
        ["population_prev", "area_km2"],
        ["gdp", "area_km2"],
        ["mandays_maxtemp_over_32c_1c", "populated_area_km2"],
        ["building_count", "populated_area_km2"],
        ["mandays_maxtemp_over_32c_1c", "area_km2"],
        ["osm_users", "area_km2"],
        ["total_hours", "populated_area_km2"],
        ["covid19_confirmed", "populated_area_km2"],
        ["covid19_confirmed", "area_km2"],
        ["osm_users", "populated_area_km2"],
        ["local_hours", "area_km2"],
        ["local_hours", "populated_area_km2"]
      ],
      selectedQuotient: ["local_hours", "area_km2"]
    },
    {
      parent: '["building_count","area_km2"]',
      quotients: [["building_count", "area_km2"]],
      selectedQuotient: ["building_count", "area_km2"]
    },
    {
      parent: '["total_hours","area_km2"]',
      quotients: [["total_hours", "area_km2"]],
      selectedQuotient: ["total_hours", "area_km2"]
    },
    {
      parent: '["highway_length","area_km2"]',
      quotients: [
        ["total_road_length", "area_km2"],
        ["highway_length", "area_km2"]
      ],
      selectedQuotient: ["highway_length", "area_km2"]
    },
    {
      parent: '["view_count","area_km2"]',
      quotients: [
        ["view_count", "populated_area_km2"],
        ["view_count_bf2402", "populated_area_km2"],
        ["view_count", "area_km2"],
        ["view_count_bf2402", "area_km2"]
      ],
      selectedQuotient: ["view_count", "area_km2"]
    },
    {
      parent: '["highway_length","populated_area_km2"]',
      quotients: [["highway_length", "populated_area_km2"]],
      selectedQuotient: ["highway_length", "populated_area_km2"]
    },
    {
      parent: '["total_road_length","populated_area_km2"]',
      quotients: [["total_road_length", "populated_area_km2"]],
      selectedQuotient: ["total_road_length", "populated_area_km2"]
    },
    {
      parent: '["man_distance_to_hospital","area_km2"]',
      quotients: [["man_distance_to_hospital", "area_km2"]],
      selectedQuotient: ["man_distance_to_hospital", "area_km2"]
    },
    {
      parent: '["unknown_forest","total_building_count"]',
      quotients: [
        ["total_road_length", "total_building_count"],
        ["unknown_forest", "total_building_count"]
      ],
      selectedQuotient: ["unknown_forest", "total_building_count"]
    },
    {
      parent: '["forest","total_building_count"]',
      quotients: [
        ["highway_length", "total_building_count"],
        ["forest", "total_building_count"]
      ],
      selectedQuotient: ["forest", "total_building_count"]
    },
    {
      parent: '["man_distance_to_hospital","populated_area_km2"]',
      quotients: [["man_distance_to_hospital", "populated_area_km2"]],
      selectedQuotient: ["man_distance_to_hospital", "populated_area_km2"]
    },
    {
      parent: '["man_distance_to_fire_brigade","area_km2"]',
      quotients: [["man_distance_to_fire_brigade", "area_km2"]],
      selectedQuotient: ["man_distance_to_fire_brigade", "area_km2"]
    },
    {
      parent: '["osm_users","population"]',
      quotients: [["osm_users", "population"]],
      selectedQuotient: ["osm_users", "population"]
    },
    {
      parent: '["unknown_forest","population"]',
      quotients: [
        ["total_road_length", "population"],
        ["unknown_forest", "population"]
      ],
      selectedQuotient: ["unknown_forest", "population"]
    },
    {
      parent: '["count","total_building_count"]',
      quotients: [["count", "total_building_count"]],
      selectedQuotient: ["count", "total_building_count"]
    },
    {
      parent: '["highway_length","population"]',
      quotients: [
        ["forest", "population"],
        ["highway_length", "population"]
      ],
      selectedQuotient: ["highway_length", "population"]
    },
    {
      parent: '["man_distance_to_fire_brigade","populated_area_km2"]',
      quotients: [["man_distance_to_fire_brigade", "populated_area_km2"]],
      selectedQuotient: ["man_distance_to_fire_brigade", "populated_area_km2"]
    }
  ],
  yGroups: [
    {
      parent: '["local_hours","area_km2"]',
      quotients: [
        ["population", "populated_area_km2"],
        ["total_building_count", "populated_area_km2"],
        ["count", "populated_area_km2"],
        ["population_prev", "populated_area_km2"],
        ["total_building_count", "area_km2"],
        ["gdp", "populated_area_km2"],
        ["mandays_maxtemp_over_32c_1c", "populated_area_km2"],
        ["population_prev", "area_km2"],
        ["gdp", "area_km2"],
        ["building_count", "populated_area_km2"],
        ["mandays_maxtemp_over_32c_1c", "area_km2"],
        ["total_hours", "populated_area_km2"],
        ["osm_users", "area_km2"],
        ["covid19_confirmed", "populated_area_km2"],
        ["osm_users", "populated_area_km2"],
        ["covid19_confirmed", "area_km2"],
        ["local_hours", "populated_area_km2"],
        ["local_hours", "area_km2"]
      ],
      selectedQuotient: ["local_hours", "area_km2"]
    },
    {
      parent: '["population","area_km2"]',
      quotients: [["population", "area_km2"]],
      selectedQuotient: ["population", "area_km2"]
    },
    {
      parent: '["count","area_km2"]',
      quotients: [["count", "area_km2"]],
      selectedQuotient: ["count", "area_km2"]
    },
    {
      parent: '["building_count","area_km2"]',
      quotients: [["building_count", "area_km2"]],
      selectedQuotient: ["building_count", "area_km2"]
    },
    {
      parent: '["total_hours","area_km2"]',
      quotients: [["total_hours", "area_km2"]],
      selectedQuotient: ["total_hours", "area_km2"]
    },
    {
      parent: '["highway_length","area_km2"]',
      quotients: [
        ["total_road_length", "area_km2"],
        ["highway_length", "area_km2"]
      ],
      selectedQuotient: ["highway_length", "area_km2"]
    },
    {
      parent: '["view_count","area_km2"]',
      quotients: [
        ["view_count", "populated_area_km2"],
        ["view_count_bf2402", "populated_area_km2"],
        ["view_count", "area_km2"],
        ["view_count_bf2402", "area_km2"]
      ],
      selectedQuotient: ["view_count", "area_km2"]
    },
    {
      parent: '["highway_length","populated_area_km2"]',
      quotients: [["highway_length", "populated_area_km2"]],
      selectedQuotient: ["highway_length", "populated_area_km2"]
    },
    {
      parent: '["total_road_length","populated_area_km2"]',
      quotients: [["total_road_length", "populated_area_km2"]],
      selectedQuotient: ["total_road_length", "populated_area_km2"]
    },
    {
      parent: '["man_distance_to_hospital","area_km2"]',
      quotients: [["man_distance_to_hospital", "area_km2"]],
      selectedQuotient: ["man_distance_to_hospital", "area_km2"]
    },
    {
      parent: '["unknown_forest","total_building_count"]',
      quotients: [
        ["total_road_length", "total_building_count"],
        ["unknown_forest", "total_building_count"]
      ],
      selectedQuotient: ["unknown_forest", "total_building_count"]
    },
    {
      parent: '["forest","total_building_count"]',
      quotients: [
        ["highway_length", "total_building_count"],
        ["forest", "total_building_count"]
      ],
      selectedQuotient: ["forest", "total_building_count"]
    },
    {
      parent: '["populated_area_km2","area_km2"]',
      quotients: [["populated_area_km2", "area_km2"]],
      selectedQuotient: ["populated_area_km2", "area_km2"]
    },
    {
      parent: '["count","population"]',
      quotients: [
        ["populated_area_km2", "population"],
        ["count", "population"]
      ],
      selectedQuotient: ["count", "population"]
    },
    {
      parent: '["populated_area_km2","total_building_count"]',
      quotients: [["populated_area_km2", "total_building_count"]],
      selectedQuotient: ["populated_area_km2", "total_building_count"]
    },
    {
      parent: '["man_distance_to_hospital","populated_area_km2"]',
      quotients: [["man_distance_to_hospital", "populated_area_km2"]],
      selectedQuotient: ["man_distance_to_hospital", "populated_area_km2"]
    },
    {
      parent: '["man_distance_to_fire_brigade","area_km2"]',
      quotients: [["man_distance_to_fire_brigade", "area_km2"]],
      selectedQuotient: ["man_distance_to_fire_brigade", "area_km2"]
    },
    {
      parent: '["osm_users","population"]',
      quotients: [["osm_users", "population"]],
      selectedQuotient: ["osm_users", "population"]
    },
    {
      parent: '["unknown_forest","population"]',
      quotients: [
        ["total_road_length", "population"],
        ["unknown_forest", "population"]
      ],
      selectedQuotient: ["unknown_forest", "population"]
    },
    {
      parent: '["forest","population"]',
      quotients: [
        ["highway_length", "population"],
        ["forest", "population"]
      ],
      selectedQuotient: ["forest", "population"]
    },
    {
      parent: '["avg_elevation","one"]',
      quotients: [["avg_elevation", "one"]],
      selectedQuotient: ["avg_elevation", "one"]
    },
    {
      parent: '["man_distance_to_fire_brigade","populated_area_km2"]',
      quotients: [["man_distance_to_fire_brigade", "populated_area_km2"]],
      selectedQuotient: ["man_distance_to_fire_brigade", "populated_area_km2"]
    }
  ],
  matrix: [
    [
      0.6330778143702572,
      null,
      0.5428354424212366,
      0.8125028273732107,
      0.41794744630059005,
      0.49075709882519214,
      0.26266841211785613,
      0.17540431775688137,
      0.2817357956135096,
      -0.08277918866628682,
      -0.07354014808858399,
      0.19952042019781102,
      0.2900699030570146,
      -0.09959194444606909,
      -0.05653224901990311,
      -0.08121946780800145,
      -0.06293349539553206,
      0.210717984018573
    ],
    [
      0.7671266114613431,
      0.4624540160877126,
      0.7461271344307278,
      0.6236796022803118,
      0.4651837775930101,
      0.6983788201180583,
      0.3282268564011803,
      0.23940172696613696,
      0.6102526069773476,
      -0.06854993994184201,
      -0.06300652330464818,
      0.5425853155901724,
      0.5357120339754239,
      -0.12569275885753226,
      -0.05722122475056985,
      -0.044124976285712575,
      -0.07252302728830883,
      0.46170009422253117
    ],
    [
      null,
      0.6330778143702572,
      0.9448400352897224,
      0.8088667700993942,
      0.5478619819586914,
      0.7272525499712613,
      0.39403434829318645,
      0.27693369264722456,
      0.4212553882513244,
      -0.09219840214177631,
      -0.08214624778695,
      0.3334796387999488,
      0.3381396079397914,
      -0.11599438338517783,
      -0.0603311321070773,
      null,
      -0.0709735871498622,
      0.24799941442360907
    ],
    [
      0.9448400352897224,
      0.5428354424212366,
      null,
      0.676324490987385,
      0.495437368648744,
      0.6083458288157841,
      0.3469868158515808,
      0.2430950316469889,
      0.4310608323815133,
      -0.09512147612349764,
      -0.08309756332167413,
      0.3452068134908724,
      0.33210650851954204,
      -0.1245886065474142,
      -0.059708735955503585,
      -0.14339940649431673,
      -0.07375589630648925,
      0.24325119232100342
    ],
    [
      0.8088667700993942,
      0.8125028273732107,
      0.676324490987385,
      null,
      0.5189347708683577,
      0.6884534708417488,
      0.33187782018548295,
      0.2219184858913333,
      0.35395740401150805,
      -0.09412791983951108,
      -0.0863908043684727,
      0.26082399416277346,
      0.349163057602413,
      -0.0749918701328735,
      -0.06355840786694379,
      -0.06179508212619175,
      -0.06748437844937322,
      0.25841056419208985
    ],
    [
      0.5478619819586914,
      0.41794744630059005,
      0.495437368648744,
      0.5189347708683577,
      null,
      0.38324804690465736,
      null,
      0.414339823397522,
      0.3069414868687711,
      -0.10644082342648567,
      -0.10931575987231072,
      0.2754560009958487,
      0.2569523390521722,
      -0.11051731563471724,
      -0.08226769814606767,
      604231582566239e-18,
      null,
      0.20899371630213479
    ],
    [
      0.7272525499712613,
      0.49075709882519214,
      0.6083458288157841,
      0.6884534708417488,
      0.38324804690465736,
      null,
      0.30947144087595235,
      0.22699474527609945,
      0.2830320630422097,
      -0.04226615774405834,
      -0.037742340113614686,
      0.23762065170375052,
      0.23266705566189747,
      -0.05154149468310855,
      -0.02870286844834339,
      -0.031190214624625075,
      -0.03390072345440923,
      0.18581115270615528
    ],
    [
      0.39403434829318645,
      0.26266841211785613,
      0.3469868158515808,
      0.33187782018548295,
      null,
      0.30947144087595235,
      null,
      0.9304780288243525,
      0.13914319427120514,
      0.3291875622555688,
      0.3720654440390036,
      0.1934927693146689,
      0.10623582254983449,
      7285286560751833e-19,
      0.19378449287322094,
      0.32680720759696696,
      null,
      0.16809925893975913
    ],
    [
      0.27693369264722456,
      0.17540431775688137,
      0.2430950316469889,
      0.2219184858913333,
      0.414339823397522,
      0.22699474527609945,
      0.9304780288243525,
      null,
      0.09020847847993732,
      0.42400942691094484,
      0.5064709774524677,
      0.1712970613845418,
      0.06714970974071707,
      0.01180306783229655,
      0.2255650150706005,
      0.3599655140069753,
      0.30252787549965515,
      0.15970052255248204
    ],
    [
      0.4212553882513244,
      0.2817357956135096,
      0.4310608323815133,
      0.35395740401150805,
      0.3069414868687711,
      0.2830320630422097,
      0.13914319427120514,
      0.09020847847993732,
      null,
      -0.06649666693010343,
      -0.06343156740380441,
      null,
      0.6841527486069171,
      -0.13779469419376966,
      -0.0635847915251171,
      -0.026485710953304663,
      -0.08026301675299034,
      0.6178257434320957
    ],
    [
      -0.09219840214177631,
      -0.08277918866628682,
      -0.09512147612349764,
      -0.09412791983951108,
      -0.10644082342648567,
      -0.04226615774405834,
      0.3291875622555688,
      0.42400942691094484,
      -0.06649666693010343,
      null,
      0.7678796845524921,
      0.012760506344240884,
      -0.054701981754940544,
      0.1344540319549378,
      null,
      0.5631324180563558,
      0.3071029030398512,
      0.04014411156301263
    ],
    [
      -0.08214624778695,
      -0.07354014808858399,
      -0.08309756332167413,
      -0.0863908043684727,
      -0.10931575987231072,
      -0.037742340113614686,
      0.3720654440390036,
      0.5064709774524677,
      -0.06343156740380441,
      0.7678796845524921,
      null,
      0.014062866759102748,
      -0.05210682697853124,
      0.11091668928613378,
      0.2990964999949313,
      0.5385399665532266,
      0.22651079092994508,
      0.04521239572328026
    ],
    [
      0.33092297487284617,
      0.306348164358225,
      0.3238400065207823,
      0.3693496848744186,
      0.38871869483912574,
      0.1581862969025989,
      -0.3471496502086163,
      -0.43374811025089965,
      0.33796301073828167,
      -0.3268410473725932,
      -0.3386739643520862,
      0.055679399245274847,
      0.3020796910928048,
      -0.04623557252911246,
      -0.19287576889960628,
      -0.23886314058329716,
      -0.1732637367181755,
      0.02241746611798094
    ],
    [
      null,
      -0.05985205635299918,
      -0.07346388019658537,
      -0.04156216899598115,
      -0.06836488141749311,
      -0.03935680545094748,
      0.12058512533492027,
      0.13212728757237097,
      -0.11270465651638581,
      0.15970627541493335,
      0.13401194122424062,
      -0.12384718246215928,
      -0.10414752849189488,
      0.7574388860132296,
      0.48388350772788513,
      null,
      0.6315662616124519,
      -0.11571785360027256
    ],
    [
      -0.2290337466539601,
      -0.1757661352019487,
      -0.24760184223062584,
      -0.18278999260309406,
      -0.1710761141838468,
      -0.09542438099888385,
      -0.059267030345385996,
      -0.013539781630611262,
      -0.09643066932644401,
      0.43854582251146346,
      0.3609544353566733,
      -0.07178405902927397,
      -0.06341025046618942,
      0.22096261180630974,
      0.10541941385096928,
      0.5599627595822098,
      0.1278673522191922,
      -0.032944279661146915
    ],
    [
      0.3334796387999488,
      0.19952042019781102,
      0.3452068134908724,
      0.26082399416277346,
      0.2754560009958487,
      0.23762065170375052,
      0.1934927693146689,
      0.1712970613845418,
      null,
      0.012760506344240884,
      0.014062866759102748,
      null,
      0.6310066640401927,
      -0.1500265206387344,
      -0.06689746899862688,
      0.01986212506899432,
      -0.08550943488376969,
      0.676555546708353
    ],
    [
      0.3381396079397914,
      0.2900699030570146,
      0.33210650851954204,
      0.349163057602413,
      0.2569523390521722,
      0.23266705566189747,
      0.10623582254983449,
      0.06714970974071707,
      0.6841527486069171,
      -0.054701981754940544,
      -0.05210682697853124,
      0.6310066640401927,
      null,
      -0.12258332045801432,
      -0.0567307219837807,
      -0.022320716664225384,
      -0.07178249009741255,
      null
    ],
    [
      -0.11599438338517783,
      -0.09959194444606909,
      -0.1245886065474142,
      -0.0749918701328735,
      -0.11051731563471724,
      -0.05154149468310855,
      7285286560751833e-19,
      0.01180306783229655,
      -0.13779469419376966,
      0.1344540319549378,
      0.11091668928613378,
      -0.1500265206387344,
      -0.12258332045801432,
      null,
      0.4348018015155649,
      0.1802672705079899,
      0.5785565720280881,
      -0.1349910962529299
    ],
    [
      -0.0603311321070773,
      -0.05653224901990311,
      -0.059708735955503585,
      -0.06355840786694379,
      -0.08226769814606767,
      -0.02870286844834339,
      0.19378449287322094,
      0.2255650150706005,
      -0.0635847915251171,
      null,
      0.2990964999949313,
      -0.06689746899862688,
      -0.0567307219837807,
      0.4348018015155649,
      null,
      0.16176932292012,
      0.7133807791437314,
      -0.05999313994718329
    ],
    [
      -0.06778027180778882,
      -0.06094700100554602,
      -0.06749293269532497,
      -0.07015551687145612,
      -0.09380332086205506,
      -0.03214432503025587,
      0.20746554020517102,
      0.2523547017592986,
      -0.07210328538123267,
      0.4203440217106889,
      null,
      -0.0750002557187531,
      -0.06409549706414985,
      0.49720071299727603,
      0.8986894662282207,
      0.19577005850577103,
      0.7147205376873481,
      -0.06663105366067186
    ],
    [
      -0.1314723477716716,
      -0.10888331650996384,
      -0.12016811312503141,
      -0.14500851581063834,
      -0.14651760866997154,
      -0.0894267074095959,
      -0.10021629943072725,
      -0.02053796018986287,
      -0.08959271152178999,
      0.07728964320941438,
      0.11382059101409457,
      -0.055901670004619375,
      -0.07981810377749747,
      0.12046075802517535,
      0.07334344740483416,
      -0.020568856117619418,
      0.12080907584004444,
      -0.040957057721220644
    ],
    [
      0.24799941442360907,
      0.210717984018573,
      0.24325119232100342,
      0.25841056419208985,
      0.20899371630213479,
      0.18581115270615528,
      0.16809925893975913,
      0.15970052255248204,
      0.6178257434320957,
      0.04014411156301263,
      0.04521239572328026,
      0.676555546708353,
      null,
      -0.1349910962529299,
      -0.05999313994718329,
      0.035960163104143954,
      -0.07699941382657573,
      null
    ]
  ],
  indicators: [
    {
      name: "mhr_index",
      label: "Multi-hazard risk PDC GRVA",
      copyrights: [
        "© 2022 Pacific Disaster Center. https://www.pdc.org/privacy-policy/"
      ],
      direction: [["unimportant"], ["important", "bad"]]
    },
    {
      name: "mhe_index",
      label: "Multi-hazard exposure PDC GRVA",
      copyrights: [
        "© 2022 Pacific Disaster Center. https://www.pdc.org/privacy-policy/"
      ],
      direction: [["unimportant"], ["important", "bad"]]
    },
    {
      name: "coping_capacity_index",
      label: "Coping Capacity PDC GRVA",
      copyrights: [
        "© 2022 Pacific Disaster Center. https://www.pdc.org/privacy-policy/"
      ],
      direction: [["important", "bad"], ["good"]]
    },
    {
      name: "resilience_index",
      label: "Resilience PDC GRVA",
      copyrights: [
        "© 2022 Pacific Disaster Center. https://www.pdc.org/privacy-policy/"
      ],
      direction: [["important", "bad"], ["good"]]
    },
    {
      name: "vulnerability_index",
      label: "Vulnerability PDC GRVA",
      copyrights: [
        "© 2022 Pacific Disaster Center. https://www.pdc.org/privacy-policy/"
      ],
      direction: [["unimportant"], ["important", "bad"]]
    },
    {
      name: "count",
      label: "OSM Objects",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "count_6_months",
      label: "OSM Objects (last 6 months)",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "view_count",
      label: "OSM Map Views",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [
        ["bad", "unimportant"],
        ["good", "important"]
      ]
    },
    {
      name: "avgmax_ts",
      label: "OSM Last Edit Date (avg)",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad", "unimportant"], ["good"]]
    },
    {
      name: "max_ts",
      label: "OSM Last Edit Date (max)",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad", "unimportant"], ["good"]]
    },
    {
      name: "min_ts",
      label: "OSM First Edit Date (min)",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["good"], ["neutral"]]
    },
    {
      name: "osm_users",
      label: "OSM Mappers Edited Here",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "building_count",
      label: "OSM Buildings",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "building_count_6_months",
      label: "OSM Buildings (last 6 months)",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "highway_length",
      label: "OSM Road Length",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "highway_length_6_months",
      label: "OSM Road Length (last 6 months)",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "local_hours",
      label: "OSM Mapping Hours by Local Mappers",
      copyrights: [
        "© Kontur https://kontur.io/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "total_hours",
      label: "OSM Mapping Hours by All Mappers",
      copyrights: [
        "© Kontur https://kontur.io/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "pop_disability_total",
      label: "Population with a disability",
      copyrights: [
        "© United States Census Bureau. 2019 5-Year American Community Survey (ACS). https://www.census.gov/en.html"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "forest",
      label: "Forest Landcover Area",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "pop_not_well_eng_speak",
      label: "Population with a difficulty speaking English",
      copyrights: [
        "© United States Census Bureau. 2019 5-Year American Community Survey (ACS). https://www.census.gov/en.html"
      ],
      direction: [["good"], ["important", "bad"]]
    },
    {
      name: "evergreen_needle_leaved_forest",
      label: "Evergreen Needle-leaved Forest Landcover Area",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "pop_under_5_total",
      label: "Population under age of 5",
      copyrights: [
        "© United States Census Bureau. 2019 5-Year American Community Survey (ACS). https://www.census.gov/en.html"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "shrubs",
      label: "Shrubland Area",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "pop_over_65_total",
      label: "Population over age of 65",
      copyrights: [
        "© United States Census Bureau. 2019 5-Year American Community Survey (ACS). https://www.census.gov/en.html"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "herbage",
      label: "Herbaceous Landcover Area",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "poverty_families_total",
      label: "Families living below poverty line",
      copyrights: [
        "© United States Census Bureau. 2019 5-Year American Community Survey (ACS). https://www.census.gov/en.html"
      ],
      direction: [["unimportant, good"], ["important"]]
    },
    {
      name: "unknown_forest",
      label: "Unknown Forest Type Landcover Area",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "volcanos_count",
      label: "Number of volcanos",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "covid19_vaccines",
      label: "COVID19 Vaccine Acceptance",
      copyrights: ["© Data from Delphi COVIDcast, covidcast.cmu.edu"],
      direction: [["bad"], ["neutral"]]
    },
    {
      name: "covid19_confirmed",
      label: "COVID19 Confirmed Cases",
      copyrights: ["© Data from JHU CSSE COVID-19 Dataset"],
      direction: [["good"], ["bad"]]
    },
    {
      name: "avg_slope",
      label: "Average slope",
      copyrights: ["© Data from General Bathymatric Chart of the Oceans, www.gebco.net"],
      direction: [
        ["good", "unimportant"],
        ["bad", "important"]
      ]
    },
    {
      name: "avg_elevation",
      label: "Average elevation",
      copyrights: ["© Data from General Bathymatric Chart of the Oceans, www.gebco.net"],
      direction: [
        ["good", "unimportant"],
        ["bad", "important"]
      ]
    },
    {
      name: "gdp",
      label: "Gross Domestic Product",
      copyrights: [
        "© Kontur https://kontur.io/",
        "© 2019 The World Bank Group, CC-BY 4.0",
        "Facebook Connectivity Lab and Center for International Earth Science Information Network - CIESIN - Columbia University. 2016. High Resolution Settlement Layer (HRSL). Source imagery for HRSL © 2016 DigitalGlobe. https://dataforgood.fb.com/tools/population-density-maps/",
        "Dataset: Schiavina, Marcello; Freire, Sergio; MacManus, Kytt (2019): GHS population grid multitemporal (1975, 1990, 2000, 2015) R2019A. European Commission, Joint Research Centre (JRC) DOI: 10.2905/42E8BE89-54FF-464E-BE7B-BF9E64DA5218 PID: http://data.europa.eu/89h/0c6b9751-a71f-4062-830b-43c9f432370f Concept & Methodology: Freire, Sergio; MacManus, Kytt; Pesaresi, Martino; Doxsey-Whitfield, Erin; Mills, Jane (2016): Development of new open and free multi-temporal global population grids at 250 m resolution. Geospatial Data in a Changing World; Association of Geographic Information Laboratories in Europe (AGILE). AGILE 2016",
        "Copernicus Global Land Service: Land Cover 100m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, Myroslava Lesiv, Nandin-Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050",
        "Microsoft Buildings: Canada, Tanzania, Uganda, USA: This data is licensed by Microsoft under the Open Data Commons Open Database License (ODbL).",
        "@ OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "population_prev",
      label: "Population (previous version)",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Facebook Connectivity Lab and Center for International Earth Science Information Network - CIESIN - Columbia University. 2016. High Resolution Settlement Layer (HRSL). Source imagery for HRSL © 2016 DigitalGlobe. https://dataforgood.fb.com/tools/population-density-maps/",
        "Dataset: Schiavina, Marcello; Freire, Sergio; MacManus, Kytt (2019): GHS population grid multitemporal (1975, 1990, 2000, 2015) R2019A. European Commission, Joint Research Centre (JRC) DOI: 10.2905/42E8BE89-54FF-464E-BE7B-BF9E64DA5218 PID: http://data.europa.eu/89h/0c6b9751-a71f-4062-830b-43c9f432370f Concept & Methodology: Freire, Sergio; MacManus, Kytt; Pesaresi, Martino; Doxsey-Whitfield, Erin; Mills, Jane (2016): Development of new open and free multi-temporal global population grids at 250 m resolution. Geospatial Data in a Changing World; Association of Geographic Information Laboratories in Europe (AGILE). AGILE 2016",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050",
        "Microsoft Buildings: Australia, Canada, Tanzania, Uganda, USA: This data is licensed by Microsoft under the Open Data Commons Open Database License (ODbL).",
        "NZ Building Outlines data sourced from the LINZ Data Service - https://data.linz.govt.nz/",
        "Geoalert Urban Mapping: Chechnya, Moscow region, Tyva - https://github.com/Geoalert/urban-mapping",
        "Unconstrained Individual countries 2020 (100m resolution): WorldPop - https://www.worldpop.org/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "wildfires",
      label: "Wildfire Days Per Year",
      copyrights: [
        "© NRT VIIRS 375 m Active Fire product VJ114IMGTDL_NRT. Available on-line [https://earthdata.nasa.gov/firms]. doi: 10.5067/FIRMS/VIIRS/VJ114IMGT_NRT.002",
        "NRT VIIRS 375 m Active Fire product VNP14IMGT. Available on-line [https://earthdata.nasa.gov/firms]. doi:10.5067/FIRMS/VIIRS/VNP14IMGT_NRT.002",
        "MODIS Collection 6 NRT Hotspot / Active Fire Detections MCD14DL. Available on-line [https://earthdata.nasa.gov/firms]. doi: 10.5067/FIRMS/MODIS/MCD14DL.NRT.006",
        "MODIS Collection 6 NRT Hotspot / Active Fire Detections MCD14ML. Available on-line [https://earthdata.nasa.gov/firms]. doi: 10.5067/FIRMS/MODIS/MCD14ML"
      ],
      direction: [
        ["good", "unimportant"],
        ["bad", "important"]
      ]
    },
    {
      name: "avg_ndvi",
      label: "Average NDVI, JUN 2019",
      copyrights: [
        "© Data from Sentinel-2 L2A 120m Mosaic, CC-BY 4.0, https://forum.sentinel-hub.com/c/aws-sentinel"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "industrial_area",
      label: "OSM industrial area",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "pop_without_car",
      label: "Population without a car",
      copyrights: [
        "© United States Census Bureau. 2019 5-Year American Community Survey (ACS). https://www.census.gov/en.html"
      ],
      direction: [["neutral"], ["important"]]
    },
    {
      name: "area_km2",
      label: "Area",
      copyrights: ["Concept of areas © Brahmagupta, René Descartes"],
      direction: [["neutral"], ["neutral"]]
    },
    {
      name: "days_maxtemp_over_32c_1c",
      label: "Days above 32C, recent scenario",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "days_maxtemp_over_32c_2c",
      label: "Days above 32C, potential scenario (2C)",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "days_mintemp_above_25c_1c",
      label: "Nights above 25C, recent scenario",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "days_mintemp_above_25c_2c",
      label: "Nights above 25C, potential scenario(2C)",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "days_maxwetbulb_over_32c_1c",
      label: "Days above 32C wet-bulb, recent scenario",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "days_maxwetbulb_over_32c_2c",
      label: "Days above 32C wet-bulb, potential scenario(2C)",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "mandays_maxtemp_over_32c_1c",
      label: "Man-days above 32C, recent scenario",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "man_distance_to_fire_brigade",
      label: "Man-distance to fire brigade",
      copyrights: [
        "© Kontur https://kontur.io/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "man_distance_to_hospital",
      label: "Man-distance to hospitals",
      copyrights: [
        "© Kontur https://kontur.io/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "total_road_length",
      label: "Total Roads length",
      copyrights: [
        "©2019 Facebook, Inc. and its affiliates https://github.com/facebookmicrosites/Open-Mapping-At-Facebook/blob/main/LICENSE.md",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "foursquare_places_count",
      label: "Foursquare Japan places count",
      copyrights: ["©Foursquare Labs Inc", "Sample data"],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "foursquare_visits_count",
      label: "Foursquare Japan visits count",
      copyrights: ["©Foursquare Labs Inc", "Sample data"],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "one",
      label: "1",
      copyrights: ["Numbers © Muḥammad ibn Mūsā al-Khwārizmī"],
      direction: [["neutral"], ["neutral"]]
    },
    {
      name: "populated_area_km2",
      label: "Populated area",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Facebook Connectivity Lab and Center for International Earth Science Information Network - CIESIN - Columbia University. 2016. High Resolution Settlement Layer (HRSL). Source imagery for HRSL © 2016 DigitalGlobe. https://dataforgood.fb.com/tools/population-density-maps/",
        "Dataset: Schiavina, Marcello; Freire, Sergio; MacManus, Kytt (2019): GHS population grid multitemporal (1975, 1990, 2000, 2015) R2019A. European Commission, Joint Research Centre (JRC) DOI: 10.2905/42E8BE89-54FF-464E-BE7B-BF9E64DA5218 PID: http://data.europa.eu/89h/0c6b9751-a71f-4062-830b-43c9f432370f Concept & Methodology: Freire, Sergio; MacManus, Kytt; Pesaresi, Martino; Doxsey-Whitfield, Erin; Mills, Jane (2016): Development of new open and free multi-temporal global population grids at 250 m resolution. Geospatial Data in a Changing World; Association of Geographic Information Laboratories in Europe (AGILE). AGILE 2016",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050",
        "Microsoft Buildings: Australia, Canada, Tanzania, Uganda, USA: This data is licensed by Microsoft under the Open Data Commons Open Database License (ODbL).",
        "NZ Building Outlines data sourced from the LINZ Data Service - https://data.linz.govt.nz/",
        "Geoalert Urban Mapping: Chechnya, Moscow region, Tyva - https://github.com/Geoalert/urban-mapping",
        "Unconstrained Individual countries 2020 (100m resolution): WorldPop - https://www.worldpop.org/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "population",
      label: "Population",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Facebook Connectivity Lab and Center for International Earth Science Information Network - CIESIN - Columbia University. 2016. High Resolution Settlement Layer (HRSL). Source imagery for HRSL © 2016 DigitalGlobe. https://dataforgood.fb.com/tools/population-density-maps/",
        "Dataset: Schiavina, Marcello; Freire, Sergio; MacManus, Kytt (2019): GHS population grid multitemporal (1975, 1990, 2000, 2015) R2019A. European Commission, Joint Research Centre (JRC) DOI: 10.2905/42E8BE89-54FF-464E-BE7B-BF9E64DA5218 PID: http://data.europa.eu/89h/0c6b9751-a71f-4062-830b-43c9f432370f Concept & Methodology: Freire, Sergio; MacManus, Kytt; Pesaresi, Martino; Doxsey-Whitfield, Erin; Mills, Jane (2016): Development of new open and free multi-temporal global population grids at 250 m resolution. Geospatial Data in a Changing World; Association of Geographic Information Laboratories in Europe (AGILE). AGILE 2016",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050",
        "Microsoft Buildings: Australia, Canada, Tanzania, Uganda, USA: This data is licensed by Microsoft under the Open Data Commons Open Database License (ODbL).",
        "NZ Building Outlines data sourced from the LINZ Data Service - https://data.linz.govt.nz/",
        "Geoalert Urban Mapping: Chechnya, Moscow region, Tyva - https://github.com/Geoalert/urban-mapping",
        "Unconstrained Individual countries 2020 (100m resolution): WorldPop - https://www.worldpop.org/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "total_building_count",
      label: "Total Buildings Estimate",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050",
        "Geoalert Urban Mapping: Chechnya, Moscow region, Tyva - https://github.com/Geoalert/urban-mapping",
        "Microsoft Buildings: Australia, Canada, Tanzania, Uganda, USA: This data is licensed by Microsoft under the Open Data Commons Open Database License (ODbL).",
        "NZ Building Outlines data sourced from the LINZ Data Service - https://data.linz.govt.nz/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "view_count_bf2402",
      label: "OSM Map Views 30 days before 24.02.2022",
      copyrights: [
        "© Kontur",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [
        ["bad", "unimportant"],
        ["good", "important"]
      ]
    }
  ]
};
const axisMatrix = "_axisMatrix_caw7e_1";
const styles = {
  axisMatrix
};
const mapHeaderCell = (group, indicators) => {
  var _a2, _b;
  return {
    label: ((_a2 = indicators.find((indicator2) => indicator2.name === group.selectedQuotient[0])) == null ? void 0 : _a2.label) || "",
    selectedQuotient: {
      id: group.selectedQuotient,
      label: (_b = indicators.find((indicator2) => indicator2.name === group.selectedQuotient[1])) == null ? void 0 : _b.label
    },
    quality: "1",
    quotients: group.quotients.map((quotient) => {
      var _a3;
      return {
        id: quotient,
        label: (_a3 = indicators.find((indicator2) => indicator2.name === quotient[0])) == null ? void 0 : _a3.label,
        quality: "1"
      };
    })
  };
};
function BivariateMatrixControlFixture() {
  const headings = reactExports.useMemo(() => {
    if (!mock.indicators || !mock.xGroups || !mock.xGroups.length || !mock.yGroups || !mock.yGroups.length) {
      return null;
    }
    const mapWithIndicators = (group) => (
      // eslint-disable-next-line
      mapHeaderCell(group, mock == null ? void 0 : mock.indicators)
    );
    return {
      x: mock.xGroups.map(mapWithIndicators),
      y: mock.yGroups.map(mapWithIndicators)
    };
  }, [mock]);
  const [selectedCell, setSelectedCell] = reactExports.useState(null);
  const onSelectCellHandler = reactExports.useCallback((x2, y2, e) => {
    console.log("onSelectCellHandler", x2, y2, e);
    setSelectedCell({ x: x2, y: y2 });
  }, []);
  const onSelectQuotient = reactExports.useCallback(
    (horizontal, index2, numId, denId) => {
      console.log("onSelectQuotient", horizontal, index2, numId, denId);
    },
    []
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles.axisMatrix, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BrowserRouter, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BivariateMatrixControlComponent,
      {
        matrix: mock.matrix,
        xHeadings: headings == null ? void 0 : headings.x,
        yHeadings: headings == null ? void 0 : headings.y,
        onSelectCell: onSelectCellHandler,
        selectedCell,
        onSelectQuotient
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PopupTooltip, {})
  ] }) });
}
const fixture5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: BivariateMatrixControlFixture
}, Symbol.toStringTag, { value: "Module" }));
const lazily = (loader) => new Proxy({}, {
  get: (target, componentName) => {
    if (typeof componentName === "string") {
      return reactExports.lazy(() => loader(componentName).then((x2) => ({
        default: x2[componentName]
      })));
    }
  }
});
const GREETINGS_DISABLED_LS_KEY = "bivariate-greetings-disabled";
const container = "_container_zzzsn_1";
const closeButton = "_closeButton_zzzsn_8";
const style = {
  container,
  closeButton
};
const { BivariateGreetings } = lazily(() => __vitePreload(() => import("./BivariateGreetings-BCOl6pZv.js"), true ? __vite__mapDeps([0,1]) : void 0, import.meta.url));
const BivariateGreetingsContainer = ({
  className
}) => {
  const [isComponentShown, setComponentShown] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const greetingsDisabled = localStorage.getItem(GREETINGS_DISABLED_LS_KEY);
    if (!greetingsDisabled && !isComponentShown) {
      setComponentShown(true);
    }
  }, []);
  const onCloseBtnClick = () => {
    setComponentShown(false);
    localStorage.setItem(GREETINGS_DISABLED_LS_KEY, "true");
  };
  return isComponentShown ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clsx(className, style.container), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(BivariateGreetings, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: onCloseBtnClick, className: style.closeButton, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Memo$5, {}) })
  ] }) : null;
};
const BivariateGreetings_fixture = () => /* @__PURE__ */ jsxRuntimeExports.jsx(BivariateGreetingsContainer, {});
const fixture6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: BivariateGreetings_fixture
}, Symbol.toStringTag, { value: "Module" }));
const indicator = "_indicator_16fpk_1";
const indicatorCell = "_indicatorCell_16fpk_9";
const s$3 = {
  indicator,
  indicatorCell
};
const COLORS = ["#FFDF35", "#FFB800", "#FF8A00", "#FF3D00", "#EA2A00"];
const severityToText = (severity) => {
  switch (severity) {
    case "UNKNOWN":
      return TranslationService.t("event_list.severity_unknown");
    case "TERMINATION":
      return TranslationService.t("event_list.severity_termination");
    case "MINOR":
      return TranslationService.t("event_list.severity_minor");
    case "MODERATE":
      return TranslationService.t("event_list.severity_moderate");
    case "SEVERE":
      return TranslationService.t("event_list.severity_severe");
    case "EXTREME":
      return TranslationService.t("event_list.severity_extreme");
  }
};
function SeverityIndicatorGenerator({ severity }) {
  const pivot = {
    UNKNOWN: 0,
    TERMINATION: 1,
    MINOR: 2,
    MODERATE: 3,
    SEVERE: 4,
    EXTREME: 5
  }[severity];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$3.indicator, children: Array.from(new Array(5)).map((_2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: s$3.indicatorCell,
        style: {
          backgroundColor: i2 < pivot ? COLORS[i2] : "var(--faint-weak)"
        }
      },
      i2
    )) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: severityToText(severity) })
  ] });
}
const SeverityIndicator = reactExports.memo(SeverityIndicatorGenerator);
const analytics = "_analytics_mgn54_1";
const analyticsBadge = "_analyticsBadge_mgn54_8";
const s$2 = {
  analytics,
  analyticsBadge
};
const Sub = ({ children }) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: ".7em", verticalAlign: "super", lineHeight: 0 }, children });
const formatNumber = new Intl.NumberFormat().format;
function Statistic({ tooltip, value, icon }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { placement: "bottom", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$2.analyticsBadge, children: [
      icon && icon,
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: s$2.analyticsValue, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { type: "caption", children: value }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: tooltip })
  ] });
}
function Analytics({
  settledArea,
  affectedPeople,
  loss
}) {
  const statistics = reactExports.useMemo(() => {
    const result2 = [];
    if (affectedPeople === 0)
      result2.push({
        tooltip: TranslationService.t("event_list.analytics.affected_people.tooltip"),
        value: TranslationService.t("event_list.analytics.affected_people.value"),
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Memo$2, {})
      });
    if (typeof affectedPeople === "number")
      result2.push({
        tooltip: TranslationService.t("event_list.analytics.affected_people.tooltip"),
        value: formatNumber(affectedPeople),
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Memo$2, {})
      });
    if (typeof settledArea === "number")
      result2.push({
        tooltip: TranslationService.t("event_list.analytics.settled_area_tooltip"),
        value: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          formatNumber(settledArea),
          " km",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Sub, { children: "2" })
        ] }),
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Memo$1, {})
      });
    if (typeof loss === "number")
      result2.push({
        tooltip: TranslationService.t("event_list.analytics.loss_tooltip"),
        value: `$${formatNumber(loss)} estimated loss`
      });
    return result2;
  }, [settledArea, affectedPeople]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$2.analytics, children: statistics.map((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Statistic, { ...props }, nanoid(5))) });
}
const eventCard = "_eventCard_1201x_1";
const active = "_active_1201x_13";
const head = "_head_1201x_23";
const footer = "_footer_1201x_32";
const linkContainer = "_linkContainer_1201x_39";
const markdown = "_markdown_1201x_46";
const s$1 = {
  eventCard,
  active,
  head,
  footer,
  linkContainer,
  markdown
};
const formatTime = (() => {
  const format = new Intl.DateTimeFormat("default", {
    hour: "numeric",
    minute: "numeric",
    year: "numeric",
    month: "short",
    day: "numeric",
    timeZoneName: "short"
  }).format;
  return (date) => format(date);
})();
function EventCard({
  event: event2,
  isActive,
  onClick,
  alternativeActionControl,
  externalUrls,
  showDescription
}) {
  const formattedTime = reactExports.useMemo(
    () => formatTime(new Date(event2.updatedAt)),
    [event2.updatedAt]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      className: clsx(s$1.eventCard, { [s$1.active]: isActive }),
      onClick: () => onClick == null ? void 0 : onClick(event2.eventId),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$1.head, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { type: "heading-05", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: event2.eventName }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SeverityIndicator, { severity: event2.severity })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$1.location, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { type: "caption", children: event2.location }) }),
        showDescription && event2.description && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$1.description, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { type: "caption", children: event2.description }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Analytics,
          {
            settledArea: event2.settledArea,
            affectedPeople: event2.affectedPopulation,
            loss: event2.loss
          }
        ),
        isActive && (externalUrls == null ? void 0 : externalUrls.length) ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$1.linkContainer, children: externalUrls.map((link2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          Markdown,
          {
            options: {
              overrides: { a: ShortLinkRenderer, p: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...props }) }
            },
            className: s$1.markdown,
            children: parseLinksAsTags(link2)
          },
          nanoid(4)
        )) }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$1.footer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { type: "caption", children: TranslationService.t("updated") + ` ${formattedTime}` }),
          alternativeActionControl
        ] })
      ]
    }
  );
}
const event = {
  eventId: "085aa3fc-7f3a-42d3-9acc-db04215e20bf",
  eventName: "Earthquake",
  description: "On 8/9/2024 10:57:37 AM, an earthquake occurred in Japan potentially affecting 39.4 million in 100km. The earthquake had Magnitude 5M, Depth:24.876km.",
  location: "Japan",
  severity: "MODERATE",
  affectedPopulation: 38777564,
  settledArea: 14975.532431108208,
  osmGaps: 0,
  updatedAt: "2024-08-10T05:11:21.231Z",
  externalUrls: [
    "https://www.gdacs.org/report.aspx?eventtype=EQ&eventid=1441158",
    "https://www.gdacs.org/report.aspx?eventid=1441158&episodeid=1587245&eventtype=EQ"
  ],
  bbox: [138.236, 34.495, 140.446, 36.297],
  // centroid: [139.34125, 35.412],
  episodeCount: 1
};
const EventCard_fixture = {
  EventCardFixture() {
    return [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        EventCard,
        {
          event,
          externalUrls: event.externalUrls,
          isActive: true,
          showDescription: true,
          alternativeActionControl: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Alternative action control" })
        },
        1
      )
    ];
  }
};
const fixture7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: EventCard_fixture
}, Symbol.toStringTag, { value: "Module" }));
const LegendGrid = "_LegendGrid_16y0t_1";
const LegendGridCell = "_LegendGridCell_16y0t_10";
const LegendGridCellChanged = "_LegendGridCellChanged_16y0t_17";
const LegendGridCellUndefinedChanged = "_LegendGridCellUndefinedChanged_16y0t_23";
const CircleIndicator = "_CircleIndicator_16y0t_27";
const UndefinedColorsIndicator = "_UndefinedColorsIndicator_16y0t_37";
const s = {
  LegendGrid,
  LegendGridCell,
  LegendGridCellChanged,
  LegendGridCellUndefinedChanged,
  CircleIndicator,
  UndefinedColorsIndicator
};
const MiniLegend = ({ legendSteps, changes = {} }) => {
  const corners = CORNER_POINTS_INDEXES.map((corner2) => legendSteps[corner2]);
  const legendStepsHasUndefinedColor = legendSteps.some((step) => step.isFallbackColor);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s.LegendGrid, children: [
    corners.map((cell2) => {
      var _a2;
      let cellColor = cell2.color;
      let changed = false;
      let cellBorderClass;
      let style2;
      if (changes[cell2.label]) {
        changed = true;
        const nextColor = (_a2 = changes[cell2.label]) == null ? void 0 : _a2.color;
        cellColor = nextColor;
        cellBorderClass = nextColor ? s.LegendGridCellChanged : s.LegendGridCellUndefinedChanged;
      }
      if (cellColor) style2 = { backgroundColor: cellColor };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: clsx(s.LegendGridCell, cellBorderClass),
          style: style2,
          children: changed && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s.CircleIndicator })
        },
        cell2.label
      );
    }),
    legendStepsHasUndefinedColor && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s.UndefinedColorsIndicator, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlarmIcon, {}) })
  ] });
};
const AlarmIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "10", cy: "10", r: "10", fill: "white" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M10 3C6.13438 3 3 6.13438 3 10C3 13.8656 6.13438 17 10 17C13.8656 17 17 13.8656 17 10C17 6.13438 13.8656 3 10 3ZM10 15.8125C6.79063 15.8125 4.1875 13.2094 4.1875 10C4.1875 6.79063 6.79063 4.1875 10 4.1875C13.2094 4.1875 15.8125 6.79063 15.8125 10C15.8125 13.2094 13.2094 15.8125 10 15.8125Z",
          fill: "#F5222D"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M9.25 12.75C9.25 12.9489 9.32902 13.1397 9.46967 13.2803C9.61032 13.421 9.80109 13.5 10 13.5C10.1989 13.5 10.3897 13.421 10.5303 13.2803C10.671 13.1397 10.75 12.9489 10.75 12.75C10.75 12.5511 10.671 12.3603 10.5303 12.2197C10.3897 12.079 10.1989 12 10 12C9.80109 12 9.61032 12.079 9.46967 12.2197C9.32902 12.3603 9.25 12.5511 9.25 12.75ZM9.625 11H10.375C10.4438 11 10.5 10.9438 10.5 10.875V6.625C10.5 6.55625 10.4438 6.5 10.375 6.5H9.625C9.55625 6.5 9.5 6.55625 9.5 6.625V10.875C9.5 10.9438 9.55625 11 9.625 11Z",
          fill: "#F5222D"
        }
      )
    ]
  }
);
const mockResponse = [
  {
    label: "A1",
    color: "rgba(232,232,157,0.5)"
  },
  {
    label: "A2",
    color: "rgba(216,159,88,0.5)"
  },
  {
    label: "A3",
    color: "rgba(228,26,28,0.5)"
  },
  {
    label: "B1",
    color: "rgba(169,218,122,0.5)"
  },
  {
    label: "B2",
    color: "rgba(159,171,87,0.5)"
  },
  {
    label: "B3",
    color: "rgba(140,127,57,0.5)"
  },
  {
    label: "C1",
    color: "rgba(90,200,127,0.5)"
  },
  {
    label: "C2",
    color: "rgba(88,176,117,0.5)"
  },
  {
    label: "C3",
    color: "rgba(83,152,106,0.5)"
  }
];
const MiniLegend_fixture = /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "div",
  {
    style: {
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-start"
    },
    children: [
      "All next colors - undefined",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MiniLegend,
        {
          legendSteps: mockResponse,
          changes: {
            A1: { color: void 0 },
            A3: { color: void 0 },
            C1: { color: void 0 },
            C3: { color: void 0 }
          }
        }
      ),
      "No changes",
      /* @__PURE__ */ jsxRuntimeExports.jsx(MiniLegend, { legendSteps: mockResponse, changes: {} }),
      "All changed",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MiniLegend,
        {
          legendSteps: mockResponse,
          changes: {
            A1: { color: "rgba(173, 169, 200, 0.5)" },
            A3: { color: "rgba(12, 155, 237, 0.5)" },
            C1: { color: "rgba(171, 216, 237, 0.5)" },
            C3: { color: "rgba(83, 152, 106, 0.5)" }
          }
        }
      ),
      "Half of cells changed",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MiniLegend,
        {
          legendSteps: mockResponse,
          changes: {
            A1: { color: "rgba(173, 169, 200, 0.5)" },
            C3: { color: "rgba(83, 152, 106, 0.5)" }
          }
        }
      ),
      "Half of cells changed, half comes incorrect",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MiniLegend,
        {
          legendSteps: mockResponse,
          changes: {
            A1: { color: void 0 },
            A3: { color: "rgba(12, 155, 237, 0.5)" },
            C1: { color: "rgba(173, 169, 200, 0.5)" },
            C3: { color: void 0 }
          }
        }
      )
    ]
  }
);
const fixture8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: MiniLegend_fixture
}, Symbol.toStringTag, { value: "Module" }));
const rendererConfig = {
  "playgroundUrl": "http://127.0.0.1:5000",
  "containerQuerySelector": null
};
const fixtures = {
  "src/features/subscriptions/Plans.fixture.tsx": { module: fixture0 },
  "src/core/pages/StructuredMarkdownRender.fixture.tsx": { module: fixture1 },
  "src/core/pages/PagesDocument.fixture.tsx": { module: fixture2 },
  "src/components/LinkRenderer/LinkRenderer.fixture.tsx": { module: fixture3 },
  "src/components/BivariateLegend/BivariateLegend.fixture.tsx": { module: fixture4 },
  "src/features/bivariate_manager/fixtures/BivariateMatrixControl.fixture.tsx": { module: fixture5 },
  "src/features/bivariate_manager/fixtures/BivariateGreetings.fixture.tsx": { module: fixture6 },
  "src/features/events_list/components/EventCard/EventCard.fixture.tsx": { module: fixture7 },
  "src/features/bivariate_color_manager/components/MiniLegend/MiniLegend.fixture.tsx": { module: fixture8 }
};
const decorators = {};
const moduleWrappers = {
  lazy: false,
  fixtures,
  decorators
};
const _virtual_cosmosImports = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  moduleWrappers,
  rendererConfig
}, Symbol.toStringTag, { value: "Module" }));
export {
  _virtual_cosmosImports as _,
  jsxRuntimeExports as j
};
