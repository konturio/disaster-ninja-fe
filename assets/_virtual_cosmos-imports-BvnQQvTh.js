const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./BivariateGreetings-BRpYZzH9.js","./index-BxuTJfAG.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _config, _readSessionIntercomSetting, _setIntercomSetting;
import { u as useFixtureState, e as extendWithValue, R as React, c as createValue, i as isEqual, r as reactExports, a as requireReact, b as requireReactDom, g as getDefaultExportFromCjs, d as React$1, f as clientExports, _ as __vitePreload } from "./index-BxuTJfAG.js";
function useCurrentInputValue(inputName, defaultValue) {
  const [fixtureState] = useFixtureState("inputs");
  const inputFs = fixtureState && fixtureState[inputName];
  return inputFs && inputFs.type === "standard" ? (
    // Types of fixture state values cannot be guaranteed at run time, which
    // means that tampering with the fixture state can cause runtime errors
    extendWithValue(defaultValue, inputFs.currentValue)
  ) : defaultValue;
}
function useInputFixtureState(inputName, defaultValue) {
  const [, setFixtureState] = useFixtureState("inputs");
  React.useEffect(() => {
    setFixtureState((prevFs) => {
      const inputFs = prevFs && prevFs[inputName];
      if (inputFs && inputFs.type === "standard" && fsValueExtendsBaseValue(inputFs.defaultValue, defaultValue))
        return prevFs;
      return {
        ...prevFs,
        [inputName]: {
          type: "standard",
          defaultValue: createValue(defaultValue),
          currentValue: createValue(defaultValue)
        }
      };
    });
  }, [setFixtureState, inputName, defaultValue]);
}
function fsValueExtendsBaseValue(fsValue, baseValue) {
  return isEqual(baseValue, extendWithValue(baseValue, fsValue));
}
function useSetInputValue(inputName, defaultValue) {
  const [, setFixtureState] = useFixtureState("inputs");
  return React.useCallback((stateChange) => {
    setFixtureState((prevFs) => {
      function getNewState() {
        if (typeof stateChange !== "function")
          return stateChange;
        const stateUpdater = stateChange;
        return stateUpdater(getCurrentValueFromFixtureState(prevFs, inputName, defaultValue));
      }
      return {
        ...prevFs,
        [inputName]: {
          type: "standard",
          defaultValue: createValue(defaultValue),
          currentValue: createValue(getNewState())
        }
      };
    });
  }, [setFixtureState, defaultValue, inputName]);
}
function getCurrentValueFromFixtureState(fixtureState, inputName, defaultValue) {
  const inputFs = fixtureState && fixtureState[inputName];
  return inputFs && inputFs.type === "standard" ? extendWithValue(defaultValue, inputFs.currentValue) : defaultValue;
}
function useFixtureInput(inputName, defaultValue) {
  useInputFixtureState(inputName, defaultValue);
  const currentValue = useCurrentInputValue(inputName, defaultValue);
  const setValue = useSetInputValue(inputName, defaultValue);
  return [currentValue, setValue];
}
function getDefaultSelectValue({ options, defaultValue }) {
  if (typeof defaultValue === "string") {
    return defaultValue;
  }
  const [firstOption] = options;
  if (typeof firstOption === "object") {
    return firstOption.options[0];
  }
  return firstOption;
}
function useCurrentSelectValue(selectName, args) {
  const [fixtureState] = useFixtureState("inputs");
  const inputFs = fixtureState && fixtureState[selectName];
  return inputFs && inputFs.type === "select" ? inputFs.currentValue : getDefaultSelectValue(args);
}
function useSelectFixtureState(selectName, args) {
  const [, setFixtureState] = useFixtureState("inputs");
  const defaultValue = getDefaultSelectValue(args);
  reactExports.useEffect(() => {
    setFixtureState((prevFs) => {
      const inputFs = prevFs && prevFs[selectName];
      if (inputFs && inputFs.type === "select" && inputFs.defaultValue === defaultValue)
        return prevFs;
      return {
        ...prevFs,
        [selectName]: {
          type: "select",
          options: args.options,
          defaultValue,
          currentValue: defaultValue
        }
      };
    });
  }, [JSON.stringify(args.options), defaultValue, selectName, setFixtureState]);
}
function useSetSelectValue(selectName) {
  const [, setFixtureState] = useFixtureState("inputs");
  return reactExports.useCallback((value2) => {
    setFixtureState((prevFs) => {
      const inputFs = prevFs && prevFs[selectName];
      if (!inputFs || inputFs.type !== "select") {
        console.warn(`Invalid fixture state for select: ${selectName}`);
        return prevFs ?? {};
      }
      return {
        ...prevFs,
        [selectName]: {
          ...inputFs,
          currentValue: value2
        }
      };
    });
  }, [selectName, setFixtureState]);
}
function useFixtureSelect(selectName, args) {
  if (!args || !args.options || !args.options.length)
    throw new Error("No options provided to useSelect");
  if (typeof args.options[0] === "object") {
    if (!args.options[0].options.length)
      throw new Error("No options provided to useSelect");
  }
  useSelectFixtureState(selectName, args);
  const currentValue = useCurrentSelectValue(selectName, args);
  const setValue = useSetSelectValue(selectName);
  return [currentValue, setValue];
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f2 = requireReact(), k2 = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n2 = f2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p2 = { key: true, ref: true, __self: true, __source: true };
  function q2(c2, a2, g2) {
    var b2, d2 = {}, e = null, h2 = null;
    void 0 !== g2 && (e = "" + g2);
    void 0 !== a2.key && (e = "" + a2.key);
    void 0 !== a2.ref && (h2 = a2.ref);
    for (b2 in a2) m2.call(a2, b2) && !p2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
    if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
    return { $$typeof: k2, type: c2, key: e, ref: h2, props: d2, _owner: n2.current };
  }
  reactJsxRuntime_production_min.Fragment = l2;
  reactJsxRuntime_production_min.jsx = q2;
  reactJsxRuntime_production_min.jsxs = q2;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
function t() {
  return t = Object.assign ? Object.assign.bind() : function(e) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (e[r2] = n2[r2]);
    }
    return e;
  }, t.apply(this, arguments);
}
const n$1 = ["children", "options"], r$2 = { blockQuote: "0", breakLine: "1", breakThematic: "2", codeBlock: "3", codeFenced: "4", codeInline: "5", footnote: "6", footnoteReference: "7", gfmTask: "8", heading: "9", headingSetext: "10", htmlBlock: "11", htmlComment: "12", htmlSelfClosing: "13", image: "14", link: "15", linkAngleBraceStyleDetector: "16", linkBareUrlDetector: "17", linkMailtoDetector: "18", newlineCoalescer: "19", orderedList: "20", paragraph: "21", ref: "22", refImage: "23", refLink: "24", table: "25", text: "27", textBolded: "28", textEmphasized: "29", textEscaped: "30", textMarked: "31", textStrikethroughed: "32", unorderedList: "33" };
var i$1;
!function(e) {
  e[e.MAX = 0] = "MAX", e[e.HIGH = 1] = "HIGH", e[e.MED = 2] = "MED", e[e.LOW = 3] = "LOW", e[e.MIN = 4] = "MIN";
}(i$1 || (i$1 = {}));
const l = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((e, t2) => (e[t2.toLowerCase()] = t2, e), { class: "className", for: "htmlFor" }), o$2 = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: " ", quot: "“" }, a$1 = ["style", "script"], c$2 = ["src", "href", "data", "formAction", "srcDoc", "action"], s$p = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi, d = /mailto:/i, u = /\n{2,}$/, p = /^(\s*>[\s\S]*?)(?=\n\n|$)/, f$1 = /^ *> ?/gm, h = /^(?:\[!([^\]]*)\]\n)?([\s\S]*)/, m$a = /^ {2,}\n/, g = /^(?:( *[-*_])){3,} *(?:\n *)+\n/, y = /^(?: {1,3})?(`{3,}|~{3,}) *(\S+)? *([^\n]*?)?\n([\s\S]*?)(?:\1\n?|$)/, k = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/, x = /^(`+)((?:\\`|(?!\1)`|[^`])+)\1/, b = /^(?:\n *)*\n/, v = /\r\n?/g, C = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/, $ = /^\[\^([^\]]+)]/, S = /\f/g, w = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/, E = /^\s*?\[(x|\s)\]/, z = /^ *(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, L = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, A = /^([^\n]+)\n *(=|-){3,} *(?:\n *)+\n/, O = /^ *(?!<[a-z][^ >/]* ?\/>)<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>\n?(\s*(?:<\1[^>]*?>[\s\S]*?<\/\1>|(?!<\1\b)[\s\S])*?)<\/\1>(?!<\/\1>)\n*/i, T = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi, B = /^<!--[\s\S]*?(?:-->)/, M = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/, R = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i, I = /^\{.*\}$/, D = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, U = /^<([^ >]+@[^ >]+)>/, N = /^<([^ >]+:\/[^ >]+)>/, j = /-([a-z])?/gi, H = /^(\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/, P = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/, _ = /^!\[([^\]]*)\] ?\[([^\]]*)\]/, F = /^\[([^\]]*)\] ?\[([^\]]*)\]/, W = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/, G = /\t/g, Z = /(^ *\||\| *$)/g, q = /^ *:-+: *$/, Q = /^ *:-+ *$/, V = /^ *-+: *$/, X = "((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|\\\\\\1|[\\s\\S])+?)", J = new RegExp(`^([*_])\\1${X}\\1\\1(?!\\1)`), K = new RegExp(`^([*_])${X}\\1(?!\\1)`), Y = new RegExp(`^(==)${X}\\1`), ee = new RegExp(`^(~~)${X}\\1`), te = /^\\([^0-9A-Za-z\s])/, ne = /\\([^0-9A-Za-z\s])/g, re = /^([\s\S](?:(?!  |[0-9]\.)[^=*_~\-\n<`\\\[!])*)/, ie = /^\n+/, le = /^([ \t]*)/, oe = /\\([^\\])/g, ae = /(?:^|\n)( *)$/, ce = "(?:\\d+\\.)", se = "(?:[*+-])";
function de(e) {
  return "( *)(" + (1 === e ? ce : se) + ") +";
}
const ue = de(1), pe = de(2);
function fe(e) {
  return new RegExp("^" + (1 === e ? ue : pe));
}
const he = fe(1), me = fe(2);
function ge(e) {
  return new RegExp("^" + (1 === e ? ue : pe) + "[^\\n]*(?:\\n(?!\\1" + (1 === e ? ce : se) + " )[^\\n]*)*(\\n|$)", "gm");
}
const ye = ge(1), ke = ge(2);
function xe(e) {
  const t2 = 1 === e ? ce : se;
  return new RegExp("^( *)(" + t2 + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + t2 + " (?!" + t2 + " ))\\n*|\\s*\\n*$)");
}
const be = xe(1), ve = xe(2);
function Ce(e, t2) {
  const n2 = 1 === t2, i2 = n2 ? be : ve, l2 = n2 ? ye : ke, o2 = n2 ? he : me;
  return { match: Me(function(e2, t3) {
    const n3 = ae.exec(t3.prevCapture);
    return n3 && (t3.list || !t3.inline && !t3.simple) ? i2.exec(e2 = n3[1] + e2) : null;
  }), order: 1, parse(e2, t3, r2) {
    const i3 = n2 ? +e2[2] : void 0, a2 = e2[0].replace(u, "\n").match(l2);
    let c2 = false;
    return { items: a2.map(function(e3, n3) {
      const i4 = o2.exec(e3)[0].length, l3 = new RegExp("^ {1," + i4 + "}", "gm"), s2 = e3.replace(l3, "").replace(o2, ""), d2 = n3 === a2.length - 1, u2 = -1 !== s2.indexOf("\n\n") || d2 && c2;
      c2 = u2;
      const p2 = r2.inline, f2 = r2.list;
      let h2;
      r2.list = true, u2 ? (r2.inline = false, h2 = ze(s2) + "\n\n") : (r2.inline = true, h2 = ze(s2));
      const m2 = t3(h2, r2);
      return r2.inline = p2, r2.list = f2, m2;
    }), ordered: n2, start: i3 };
  }, render: (t3, n3, i3) => e(t3.ordered ? "ol" : "ul", { key: i3.key, start: t3.type === r$2.orderedList ? t3.start : void 0 }, t3.items.map(function(t4, r2) {
    return e("li", { key: r2 }, n3(t4, i3));
  })) };
}
const $e = new RegExp(`^\\[((?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`), Se = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/, we = [p, y, k, z, A, L, H, be, ve], Ee = [...we, /^[^\n]+(?:  \n|\n{2,})/, O, B, R];
function ze(e) {
  let t2 = e.length;
  for (; t2 > 0 && e[t2 - 1] <= " "; ) t2--;
  return e.slice(0, t2);
}
function Le(e) {
  return e.replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, "a").replace(/[çÇ]/g, "c").replace(/[ðÐ]/g, "d").replace(/[ÈÉÊËéèêë]/g, "e").replace(/[ÏïÎîÍíÌì]/g, "i").replace(/[Ññ]/g, "n").replace(/[øØœŒÕõÔôÓóÒò]/g, "o").replace(/[ÜüÛûÚúÙù]/g, "u").replace(/[ŸÿÝý]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
}
function Ae(e) {
  return V.test(e) ? "right" : q.test(e) ? "center" : Q.test(e) ? "left" : null;
}
function Oe(e, t2, n2, r2) {
  const i2 = n2.inTable;
  n2.inTable = true;
  let l2 = [[]], o2 = "";
  function a2() {
    if (!o2) return;
    const e2 = l2[l2.length - 1];
    e2.push.apply(e2, t2(o2, n2)), o2 = "";
  }
  return e.trim().split(/(`[^`]*`|\\\||\|)/).filter(Boolean).forEach((e2, t3, n3) => {
    "|" === e2.trim() && (a2(), r2) ? 0 !== t3 && t3 !== n3.length - 1 && l2.push([]) : o2 += e2;
  }), a2(), n2.inTable = i2, l2;
}
function Te(e, t2, n2) {
  n2.inline = true;
  const i2 = e[2] ? e[2].replace(Z, "").split("|").map(Ae) : [], l2 = e[3] ? function(e2, t3, n3) {
    return e2.trim().split("\n").map(function(e3) {
      return Oe(e3, t3, n3, true);
    });
  }(e[3], t2, n2) : [], o2 = Oe(e[1], t2, n2, !!l2.length);
  return n2.inline = false, l2.length ? { align: i2, cells: l2, header: o2, type: r$2.table } : { children: o2, type: r$2.paragraph };
}
function Be(e, t2) {
  return null == e.align[t2] ? {} : { textAlign: e.align[t2] };
}
function Me(e) {
  return e.inline = 1, e;
}
function Re(e) {
  return Me(function(t2, n2) {
    return n2.inline ? e.exec(t2) : null;
  });
}
function Ie(e) {
  return Me(function(t2, n2) {
    return n2.inline || n2.simple ? e.exec(t2) : null;
  });
}
function De(e) {
  return function(t2, n2) {
    return n2.inline || n2.simple ? null : e.exec(t2);
  };
}
function Ue(e) {
  return Me(function(t2) {
    return e.exec(t2);
  });
}
function Ne(e, t2) {
  if (t2.inline || t2.simple) return null;
  let n2 = "";
  e.split("\n").every((e2) => (e2 += "\n", !we.some((t3) => t3.test(e2)) && (n2 += e2, !!e2.trim())));
  const r2 = ze(n2);
  return "" == r2 ? null : [n2, , r2];
}
const je = /(javascript|vbscript|data(?!:image)):/i;
function He(e) {
  try {
    const t2 = decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g, "");
    if (je.test(t2)) return null;
  } catch (e2) {
    return null;
  }
  return e;
}
function Pe(e) {
  return e.replace(oe, "$1");
}
function _e(e, t2, n2) {
  const r2 = n2.inline || false, i2 = n2.simple || false;
  n2.inline = true, n2.simple = true;
  const l2 = e(t2, n2);
  return n2.inline = r2, n2.simple = i2, l2;
}
function Fe(e, t2, n2) {
  const r2 = n2.inline || false, i2 = n2.simple || false;
  n2.inline = false, n2.simple = true;
  const l2 = e(t2, n2);
  return n2.inline = r2, n2.simple = i2, l2;
}
function We(e, t2, n2) {
  const r2 = n2.inline || false;
  n2.inline = false;
  const i2 = e(t2, n2);
  return n2.inline = r2, i2;
}
const Ge = (e, t2, n2) => ({ children: _e(t2, e[2], n2) });
function Ze() {
  return {};
}
function qe() {
  return null;
}
function Qe(...e) {
  return e.filter(Boolean).join(" ");
}
function Ve(e, t2, n2) {
  let r2 = e;
  const i2 = t2.split(".");
  for (; i2.length && (r2 = r2[i2[0]], void 0 !== r2); ) i2.shift();
  return r2 || n2;
}
function Xe(n2 = "", i2 = {}) {
  function u2(e, n3, ...r2) {
    const l2 = Ve(i2.overrides, `${e}.props`, {});
    return i2.createElement(function(e2, t2) {
      const n4 = Ve(t2, e2);
      return n4 ? "function" == typeof n4 || "object" == typeof n4 && "render" in n4 ? n4 : Ve(t2, `${e2}.component`, e2) : e2;
    }(e, i2.overrides), t({}, n3, l2, { className: Qe(null == n3 ? void 0 : n3.className, l2.className) || void 0 }), ...r2);
  }
  function Z2(e) {
    e = e.replace(w, "");
    let t2 = false;
    i2.forceInline ? t2 = true : i2.forceBlock || (t2 = false === W.test(e));
    const n3 = ae2(oe2(t2 ? e : `${ze(e).replace(ie, "")}

`, { inline: t2 }));
    for (; "string" == typeof n3[n3.length - 1] && !n3[n3.length - 1].trim(); ) n3.pop();
    if (null === i2.wrapper) return n3;
    const r2 = i2.wrapper || (t2 ? "span" : "div");
    let l2;
    if (n3.length > 1 || i2.forceWrapper) l2 = n3;
    else {
      if (1 === n3.length) return l2 = n3[0], "string" == typeof l2 ? u2("span", { key: "outer" }, l2) : l2;
      l2 = null;
    }
    return i2.createElement(r2, { key: "outer" }, l2);
  }
  function q2(e, t2) {
    const n3 = t2.match(s$p);
    return n3 ? n3.reduce(function(t3, n4) {
      const r2 = n4.indexOf("=");
      if (-1 !== r2) {
        const o2 = function(e2) {
          return -1 !== e2.indexOf("-") && null === e2.match(M) && (e2 = e2.replace(j, function(e3, t4) {
            return t4.toUpperCase();
          })), e2;
        }(n4.slice(0, r2)).trim(), a2 = function(e2) {
          const t4 = e2[0];
          return ('"' === t4 || "'" === t4) && e2.length >= 2 && e2[e2.length - 1] === t4 ? e2.slice(1, -1) : e2;
        }(n4.slice(r2 + 1).trim()), s2 = l[o2] || o2;
        if ("ref" === s2) return t3;
        const d2 = t3[s2] = function(e2, t4, n5, r3) {
          return "style" === t4 ? function(e3) {
            const t5 = [];
            let n6 = "", r4 = false, i3 = false, l2 = "";
            if (!e3) return t5;
            for (let o4 = 0; o4 < e3.length; o4++) {
              const a3 = e3[o4];
              if ('"' !== a3 && "'" !== a3 || r4 || (i3 ? a3 === l2 && (i3 = false, l2 = "") : (i3 = true, l2 = a3)), "(" === a3 && n6.endsWith("url") ? r4 = true : ")" === a3 && r4 && (r4 = false), ";" !== a3 || i3 || r4) n6 += a3;
              else {
                const e4 = n6.trim();
                if (e4) {
                  const n7 = e4.indexOf(":");
                  if (n7 > 0) {
                    const r5 = e4.slice(0, n7).trim(), i4 = e4.slice(n7 + 1).trim();
                    t5.push([r5, i4]);
                  }
                }
                n6 = "";
              }
            }
            const o3 = n6.trim();
            if (o3) {
              const e4 = o3.indexOf(":");
              if (e4 > 0) {
                const n7 = o3.slice(0, e4).trim(), r5 = o3.slice(e4 + 1).trim();
                t5.push([n7, r5]);
              }
            }
            return t5;
          }(n5).reduce(function(t5, [n6, i3]) {
            return t5[n6.replace(/(-[a-z])/g, (e3) => e3[1].toUpperCase())] = r3(i3, e2, n6), t5;
          }, {}) : -1 !== c$2.indexOf(t4) ? r3(n5, e2, t4) : (n5.match(I) && (n5 = n5.slice(1, n5.length - 1)), "true" === n5 || "false" !== n5 && n5);
        }(e, o2, a2, i2.sanitizer);
        "string" == typeof d2 && (O.test(d2) || R.test(d2)) && (t3[s2] = Z2(d2.trim()));
      } else "style" !== n4 && (t3[l[n4] || n4] = true);
      return t3;
    }, {}) : null;
  }
  i2.overrides = i2.overrides || {}, i2.sanitizer = i2.sanitizer || He, i2.slugify = i2.slugify || Le, i2.namedCodesToUnicode = i2.namedCodesToUnicode ? t({}, o$2, i2.namedCodesToUnicode) : o$2, i2.createElement = i2.createElement || reactExports.createElement;
  const Q2 = [], V2 = {}, X2 = { [r$2.blockQuote]: { match: De(p), order: 1, parse(e, t2, n3) {
    const [, r2, i3] = e[0].replace(f$1, "").match(h);
    return { alert: r2, children: t2(i3, n3) };
  }, render(e, t2, n3) {
    const l2 = { key: n3.key };
    return e.alert && (l2.className = "markdown-alert-" + i2.slugify(e.alert.toLowerCase(), Le), e.children.unshift({ attrs: {}, children: [{ type: r$2.text, text: e.alert }], noInnerParse: true, type: r$2.htmlBlock, tag: "header" })), u2("blockquote", l2, t2(e.children, n3));
  } }, [r$2.breakLine]: { match: Ue(m$a), order: 1, parse: Ze, render: (e, t2, n3) => u2("br", { key: n3.key }) }, [r$2.breakThematic]: { match: De(g), order: 1, parse: Ze, render: (e, t2, n3) => u2("hr", { key: n3.key }) }, [r$2.codeBlock]: { match: De(k), order: 0, parse: (e) => ({ lang: void 0, text: ze(e[0].replace(/^ {4}/gm, "")).replace(ne, "$1") }), render: (e, n3, r2) => u2("pre", { key: r2.key }, u2("code", t({}, e.attrs, { className: e.lang ? `lang-${e.lang}` : "" }), e.text)) }, [r$2.codeFenced]: { match: De(y), order: 0, parse: (e) => ({ attrs: q2("code", e[3] || ""), lang: e[2] || void 0, text: e[4], type: r$2.codeBlock }) }, [r$2.codeInline]: { match: Ie(x), order: 3, parse: (e) => ({ text: e[2].replace(ne, "$1") }), render: (e, t2, n3) => u2("code", { key: n3.key }, e.text) }, [r$2.footnote]: { match: De(C), order: 0, parse: (e) => (Q2.push({ footnote: e[2], identifier: e[1] }), {}), render: qe }, [r$2.footnoteReference]: { match: Re($), order: 1, parse: (e) => ({ target: `#${i2.slugify(e[1], Le)}`, text: e[1] }), render: (e, t2, n3) => u2("a", { key: n3.key, href: i2.sanitizer(e.target, "a", "href") }, u2("sup", { key: n3.key }, e.text)) }, [r$2.gfmTask]: { match: Re(E), order: 1, parse: (e) => ({ completed: "x" === e[1].toLowerCase() }), render: (e, t2, n3) => u2("input", { checked: e.completed, key: n3.key, readOnly: true, type: "checkbox" }) }, [r$2.heading]: { match: De(i2.enforceAtxHeadings ? L : z), order: 1, parse: (e, t2, n3) => ({ children: _e(t2, e[2], n3), id: i2.slugify(e[2], Le), level: e[1].length }), render: (e, t2, n3) => u2(`h${e.level}`, { id: e.id, key: n3.key }, t2(e.children, n3)) }, [r$2.headingSetext]: { match: De(A), order: 0, parse: (e, t2, n3) => ({ children: _e(t2, e[1], n3), level: "=" === e[2] ? 1 : 2, type: r$2.heading }) }, [r$2.htmlBlock]: { match: Ue(O), order: 1, parse(e, t2, n3) {
    const [, r2] = e[3].match(le), i3 = new RegExp(`^${r2}`, "gm"), l2 = e[3].replace(i3, ""), o2 = (c2 = l2, Ee.some((e2) => e2.test(c2)) ? We : _e);
    var c2;
    const s2 = e[1].toLowerCase(), d2 = -1 !== a$1.indexOf(s2), u3 = (d2 ? s2 : e[1]).trim(), p2 = { attrs: q2(u3, e[2]), noInnerParse: d2, tag: u3 };
    return n3.inAnchor = n3.inAnchor || "a" === s2, d2 ? p2.text = e[3] : p2.children = o2(t2, l2, n3), n3.inAnchor = false, p2;
  }, render: (e, n3, r2) => u2(e.tag, t({ key: r2.key }, e.attrs), e.text || (e.children ? n3(e.children, r2) : "")) }, [r$2.htmlSelfClosing]: { match: Ue(R), order: 1, parse(e) {
    const t2 = e[1].trim();
    return { attrs: q2(t2, e[2] || ""), tag: t2 };
  }, render: (e, n3, r2) => u2(e.tag, t({}, e.attrs, { key: r2.key })) }, [r$2.htmlComment]: { match: Ue(B), order: 1, parse: () => ({}), render: qe }, [r$2.image]: { match: Ie(Se), order: 1, parse: (e) => ({ alt: e[1], target: Pe(e[2]), title: e[3] }), render: (e, t2, n3) => u2("img", { key: n3.key, alt: e.alt || void 0, title: e.title || void 0, src: i2.sanitizer(e.target, "img", "src") }) }, [r$2.link]: { match: Re($e), order: 3, parse: (e, t2, n3) => ({ children: Fe(t2, e[1], n3), target: Pe(e[2]), title: e[3] }), render: (e, t2, n3) => u2("a", { key: n3.key, href: i2.sanitizer(e.target, "a", "href"), title: e.title }, t2(e.children, n3)) }, [r$2.linkAngleBraceStyleDetector]: { match: Re(N), order: 0, parse: (e) => ({ children: [{ text: e[1], type: r$2.text }], target: e[1], type: r$2.link }) }, [r$2.linkBareUrlDetector]: { match: Me((e, t2) => t2.inAnchor || i2.disableAutoLink ? null : Re(D)(e, t2)), order: 0, parse: (e) => ({ children: [{ text: e[1], type: r$2.text }], target: e[1], title: void 0, type: r$2.link }) }, [r$2.linkMailtoDetector]: { match: Re(U), order: 0, parse(e) {
    let t2 = e[1], n3 = e[1];
    return d.test(n3) || (n3 = "mailto:" + n3), { children: [{ text: t2.replace("mailto:", ""), type: r$2.text }], target: n3, type: r$2.link };
  } }, [r$2.orderedList]: Ce(u2, 1), [r$2.unorderedList]: Ce(u2, 2), [r$2.newlineCoalescer]: { match: De(b), order: 3, parse: Ze, render: () => "\n" }, [r$2.paragraph]: { match: Me(Ne), order: 3, parse: Ge, render: (e, t2, n3) => u2("p", { key: n3.key }, t2(e.children, n3)) }, [r$2.ref]: { match: Re(P), order: 0, parse: (e) => (V2[e[1]] = { target: e[2], title: e[4] }, {}), render: qe }, [r$2.refImage]: { match: Ie(_), order: 0, parse: (e) => ({ alt: e[1] || void 0, ref: e[2] }), render: (e, t2, n3) => V2[e.ref] ? u2("img", { key: n3.key, alt: e.alt, src: i2.sanitizer(V2[e.ref].target, "img", "src"), title: V2[e.ref].title }) : null }, [r$2.refLink]: { match: Re(F), order: 0, parse: (e, t2, n3) => ({ children: t2(e[1], n3), fallbackChildren: e[0], ref: e[2] }), render: (e, t2, n3) => V2[e.ref] ? u2("a", { key: n3.key, href: i2.sanitizer(V2[e.ref].target, "a", "href"), title: V2[e.ref].title }, t2(e.children, n3)) : u2("span", { key: n3.key }, e.fallbackChildren) }, [r$2.table]: { match: De(H), order: 1, parse: Te, render(e, t2, n3) {
    const r2 = e;
    return u2("table", { key: n3.key }, u2("thead", null, u2("tr", null, r2.header.map(function(e2, i3) {
      return u2("th", { key: i3, style: Be(r2, i3) }, t2(e2, n3));
    }))), u2("tbody", null, r2.cells.map(function(e2, i3) {
      return u2("tr", { key: i3 }, e2.map(function(e3, i4) {
        return u2("td", { key: i4, style: Be(r2, i4) }, t2(e3, n3));
      }));
    })));
  } }, [r$2.text]: { match: Ue(re), order: 4, parse: (e) => ({ text: e[0].replace(T, (e2, t2) => i2.namedCodesToUnicode[t2] ? i2.namedCodesToUnicode[t2] : e2) }), render: (e) => e.text }, [r$2.textBolded]: { match: Ie(J), order: 2, parse: (e, t2, n3) => ({ children: t2(e[2], n3) }), render: (e, t2, n3) => u2("strong", { key: n3.key }, t2(e.children, n3)) }, [r$2.textEmphasized]: { match: Ie(K), order: 3, parse: (e, t2, n3) => ({ children: t2(e[2], n3) }), render: (e, t2, n3) => u2("em", { key: n3.key }, t2(e.children, n3)) }, [r$2.textEscaped]: { match: Ie(te), order: 1, parse: (e) => ({ text: e[1], type: r$2.text }) }, [r$2.textMarked]: { match: Ie(Y), order: 3, parse: Ge, render: (e, t2, n3) => u2("mark", { key: n3.key }, t2(e.children, n3)) }, [r$2.textStrikethroughed]: { match: Ie(ee), order: 3, parse: Ge, render: (e, t2, n3) => u2("del", { key: n3.key }, t2(e.children, n3)) } };
  true === i2.disableParsingRawHTML && (delete X2[r$2.htmlBlock], delete X2[r$2.htmlSelfClosing]);
  const oe2 = function(e) {
    let t2 = Object.keys(e);
    function n3(r2, i3) {
      let l2, o2, a2 = [], c2 = "", s2 = "";
      for (i3.prevCapture = i3.prevCapture || ""; r2; ) {
        let d2 = 0;
        for (; d2 < t2.length; ) {
          if (c2 = t2[d2], l2 = e[c2], i3.inline && !l2.match.inline) {
            d2++;
            continue;
          }
          const u3 = l2.match(r2, i3);
          if (u3) {
            s2 = u3[0], i3.prevCapture += s2, r2 = r2.substring(s2.length), o2 = l2.parse(u3, n3, i3), null == o2.type && (o2.type = c2), a2.push(o2);
            break;
          }
          d2++;
        }
      }
      return i3.prevCapture = "", a2;
    }
    return t2.sort(function(t3, n4) {
      let r2 = e[t3].order, i3 = e[n4].order;
      return r2 !== i3 ? r2 - i3 : t3 < n4 ? -1 : 1;
    }), function(e2, t3) {
      return n3(function(e3) {
        return e3.replace(v, "\n").replace(S, "").replace(G, "    ");
      }(e2), t3);
    };
  }(X2), ae2 = (ce2 = /* @__PURE__ */ function(e, t2) {
    return function(n3, r2, i3) {
      const l2 = e[n3.type].render;
      return t2 ? t2(() => l2(n3, r2, i3), n3, r2, i3) : l2(n3, r2, i3);
    };
  }(X2, i2.renderRule), function e(t2, n3 = {}) {
    if (Array.isArray(t2)) {
      const r2 = n3.key, i3 = [];
      let l2 = false;
      for (let r3 = 0; r3 < t2.length; r3++) {
        n3.key = r3;
        const o2 = e(t2[r3], n3), a2 = "string" == typeof o2;
        a2 && l2 ? i3[i3.length - 1] += o2 : null !== o2 && i3.push(o2), l2 = a2;
      }
      return n3.key = r2, i3;
    }
    return ce2(t2, e, n3);
  });
  var ce2;
  const se2 = Z2(n2);
  return Q2.length ? u2("div", null, se2, u2("footer", { key: "footer" }, Q2.map(function(e) {
    return u2("div", { id: i2.slugify(e.identifier, Le), key: e.identifier }, e.identifier, ae2(oe2(e.footnote, { inline: true })));
  }))) : se2;
}
const Markdown = (t2) => {
  let { children: r2 = "", options: i2 } = t2, l2 = function(e, t3) {
    if (null == e) return {};
    var n2, r3, i3 = {}, l3 = Object.keys(e);
    for (r3 = 0; r3 < l3.length; r3++) t3.indexOf(n2 = l3[r3]) >= 0 || (i3[n2] = e[n2]);
    return i3;
  }(t2, n$1);
  return reactExports.cloneElement(Xe(r2, i2), l2);
};
function r$1(e) {
  var t2, f2, n2 = "";
  if ("string" == typeof e || "number" == typeof e) n2 += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o2 = e.length;
    for (t2 = 0; t2 < o2; t2++) e[t2] && (f2 = r$1(e[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e) e[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++) (e = arguments[f2]) && (t2 = r$1(e)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const SearchIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M14 14L18 18", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round" }), jsxRuntimeExports.jsx("circle", { cx: "10", cy: "10", r: "5", stroke: "currentColor", strokeWidth: "2" })] }));
SearchIcon.displayName = "SearchIcon";
const CallIcon = reactExports.memo((props) => jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", ...props, children: jsxRuntimeExports.jsx("path", { d: "M17.0156 12.375C17.2969 12.375 17.5312 12.4688 17.7188 12.6562C17.9062 12.8438 18 13.0781 18 13.3594V16.8281C18 17.6094 17.6719 18 17.0156 18C12.3594 18 8.35938 16.3281 5.01562 12.9844C1.67188 9.64062 0 5.64062 0 0.984375C0 0.328125 0.390625 0 1.17188 0H4.64062C4.92188 0 5.15625 0.09375 5.34375 0.28125C5.53125 0.46875 5.625 0.703125 5.625 0.984375C5.625 2.20312 5.8125 3.375 6.1875 4.5C6.3125 4.90625 6.23438 5.25 5.95312 5.53125L4.03125 7.21875C5.46875 10.2188 7.76562 12.4844 10.9219 14.0156L12.4688 12.0469C12.6562 11.8594 12.8906 11.7656 13.1719 11.7656C13.3281 11.7656 13.4375 11.7812 13.5 11.8125C14.625 12.1875 15.7969 12.375 17.0156 12.375Z", fill: "currentColor" }) }));
CallIcon.displayName = "CallIcon";
const CloseIcon = reactExports.memo((props) => jsxRuntimeExports.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { d: "M6 6L18 18M6 18L18 6", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round" }) }));
CloseIcon.displayName = "CloseIcon";
const FlameIcon = reactExports.memo((props) => jsxRuntimeExports.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", fill: "currentColor", d: "M6.34315 19.5736C3.21895 16.3384 3.21895 11.0931 6.34315 7.85786L6.44057 7.75698C7.65679 9.8159 8.24605 10.5185 9 11C8.38813 7.49125 9.16738 5.52009 12 2L17.6569 7.85786C20.781 11.0931 20.781 16.3384 17.6569 19.5736C14.5327 22.8088 9.46734 22.8088 6.34315 19.5736ZM9.17157 18.7868C7.60948 17.1692 7.60948 14.5465 9.17157 12.9289L9.22028 12.8785C9.8284 13.9079 10.123 14.2592 10.5 14.5C10.1941 12.7456 10.5837 11.76 12 10L14.8284 12.9289C16.3905 14.5465 16.3905 17.1692 14.8284 18.7868C13.2663 20.4044 10.7337 20.4044 9.17157 18.7868Z" }) }));
FlameIcon.displayName = "FlameIcon";
const FireTruckIcon = reactExports.memo((props) => jsxRuntimeExports.jsx("svg", { width: "15", height: "15", viewBox: "0 0 15 15", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7 2L2 7H1V8H2V9H1V10C1 10.5523 1.44772 11 2 11C2 12.1046 2.89543 13 4 13C5.10457 13 6 12.1046 6 11H9C9 12.1046 9.89543 13 11 13C12.1046 13 13 12.1046 13 11H14V9C14 8.44771 13.5523 8 13 8V7C13 5.89543 12.1046 5 11 5H8V7H4L8 3L7 2ZM3 8V9H4V8H3ZM5 11C5 11.5523 4.55228 12 4 12C3.44772 12 3 11.5523 3 11C3 10.4477 3.44772 10 4 10C4.55228 10 5 10.4477 5 11ZM11 12C11.5523 12 12 11.5523 12 11C12 10.4477 11.5523 10 11 10C10.4477 10 10 10.4477 10 11C10 11.5523 10.4477 12 11 12ZM10 6H11C11.5523 6 12 6.44772 12 7V8H10V6ZM6 8H5V9H6V8ZM7 8H8V9H7V8Z", fill: "currentColor" }) }));
FireTruckIcon.displayName = "FireTruckIcon";
const HydrantIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", ...props, children: [jsxRuntimeExports.jsx("path", { fill: "currentColor", d: "M12 12.4688C12.7754 12.4688 13.4062 13.0996 13.4062 13.875C13.4062 14.6504 12.7754 15.2812 12 15.2812C11.2246 15.2812 10.5938 14.6504 10.5938 13.875C10.5938 13.0996 11.2246 12.4688 12 12.4688ZM12 14.3438C12.2585 14.3438 12.4688 14.1335 12.4688 13.875C12.4688 13.6165 12.2585 13.4062 12 13.4062C11.7415 13.4062 11.5312 13.6165 11.5312 13.875C11.5312 14.1335 11.7415 14.3438 12 14.3438Z" }), jsxRuntimeExports.jsx("path", { fill: "currentColor", d: "M8.25 12.4688H8.71875V11.4506C8.17316 11.2571 7.78125 10.7361 7.78125 10.125C7.78125 9.50519 8.1845 8.97813 8.74231 8.79141C8.87847 7.64309 9.59875 6.67353 10.5938 6.19506V5.40625C10.5938 4.63084 11.2246 4 12 4C12.7754 4 13.4062 4.63084 13.4062 5.40625V6.19503C14.4013 6.6735 15.1215 7.64309 15.2577 8.79138C15.8155 8.97813 16.2188 9.50519 16.2188 10.125C16.2188 10.7361 15.8268 11.2571 15.2812 11.4506V12.4688H15.75C16.0089 12.4688 16.2188 12.6786 16.2188 12.9375V14.8125C16.2188 15.0714 16.0089 15.2812 15.75 15.2812H15.2812V17.2369C15.8268 17.4304 16.2188 17.9514 16.2188 18.5625V19.5312C16.2188 19.7901 16.0089 20 15.75 20H8.25C7.99113 20 7.78125 19.7901 7.78125 19.5312V18.5625C7.78125 17.9514 8.17316 17.4304 8.71875 17.2369V15.2812H8.25C7.99113 15.2812 7.78125 15.0714 7.78125 14.8125V12.9375C7.78125 12.6786 7.99109 12.4688 8.25 12.4688ZM12.4688 5.40625C12.4688 5.14778 12.2585 4.9375 12 4.9375C11.7415 4.9375 11.5312 5.14778 11.5312 5.40625V5.90894C11.6844 5.88672 11.8408 5.875 12 5.875C12.1592 5.875 12.3156 5.88672 12.4688 5.90894V5.40625ZM12 6.8125C10.866 6.8125 9.91769 7.63291 9.70231 8.71875H14.2977C14.0823 7.63291 13.134 6.8125 12 6.8125ZM14.8125 9.65625H9.1875C8.92903 9.65625 8.71875 9.86653 8.71875 10.125C8.71875 10.3835 8.92903 10.5938 9.1875 10.5938H14.8125C15.071 10.5938 15.2812 10.3835 15.2812 10.125C15.2812 9.86653 15.071 9.65625 14.8125 9.65625ZM8.71875 19.0625H15.2812V18.5625C15.2812 18.304 15.071 18.0938 14.8125 18.0938H9.1875C8.92903 18.0938 8.71875 18.304 8.71875 18.5625V19.0625ZM8.71875 14.3437H9.1875C9.44637 14.3437 9.65625 14.5536 9.65625 14.8125V17.1562H14.3438V14.8125C14.3438 14.5536 14.5536 14.3437 14.8125 14.3437H15.2812V13.4062H14.8125C14.5536 13.4062 14.3438 13.1964 14.3438 12.9375V11.5312H9.65625V12.9375C9.65625 13.1963 9.44641 13.4062 9.1875 13.4062H8.71875V14.3437Z" })] }));
HydrantIcon.displayName = "HydrantIcon";
const MarkerIcon = reactExports.memo((props) => jsxRuntimeExports.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", fill: "currentColor", d: "M12 23C12 23 20 15 20 9C20 4.58172 16.4183 1 12 1C7.58172 1 4 4.58172 4 9C4 15 12 23 12 23ZM12 12C13.6569 12 15 10.6569 15 9C15 7.34315 13.6569 6 12 6C10.3431 6 9 7.34315 9 9C9 10.6569 10.3431 12 12 12Z" }) }));
MarkerIcon.displayName = "MarkerIcon";
const DisasterListIcon = reactExports.memo((props) => jsxRuntimeExports.jsx("svg", { width: "17", height: "22", viewBox: "0 0 17 22", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { d: "M1 14.3333C1 17 3.92847 19.5714 5.39271 20.5238C5.23002 20.2063 4.90463 19.2857 4.90463 18.1429C4.90463 17 5.88079 15.7619 6.36887 15.2857C6.36887 15.7619 6.36887 16.7143 6.85695 18.1429C7.34503 19.5714 9.29734 20.5238 10.2735 21C11.575 20.3651 14.2341 18.9134 15.6424 14.3333C16.8138 10.5238 14.8289 7.66667 13.6901 6.71429C13.6901 7.03175 13.4948 7.95238 12.7139 9.09524C11.933 10.2381 10.1108 10.8413 9.29734 11C9.94811 10.2063 11.152 8.04762 10.7616 5.7619C10.3711 3.47619 7.67041 1.63492 6.36887 1C6.85695 2.11111 7.34503 4.90476 5.39271 7.19048C2.95232 10.0476 1 11 1 14.3333Z", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "round", strokeLinejoin: "round" }) }));
DisasterListIcon.displayName = "DisasterListIcon";
const DrawToolsIcon = reactExports.memo((props) => jsxRuntimeExports.jsx("svg", { width: "20", height: "22", viewBox: "0 0 20 22", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { d: "M11.8099 7.75L1.19006 1.25L2.30994 19.25L7.80994 18.25L15.8099 20.75L18.8099 6.25L11.8099 7.75Z", stroke: "currentColor", strokeWidth: "1.3", strokeLinejoin: "round" }) }));
DrawToolsIcon.displayName = "DrawToolsIcon";
const BoundarySelectorIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "18", height: "21", viewBox: "0 0 18 21", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M4.98737 4.07847L3.22876 1.03247", stroke: "currentColor", strokeWidth: "1.3" }), jsxRuntimeExports.jsx("path", { d: "M7.21138 3.78567L8.1217 0.388306", stroke: "currentColor", strokeWidth: "1.3" }), jsxRuntimeExports.jsx("path", { d: "M8.99111 5.15131L12.0371 3.3927", stroke: "currentColor", strokeWidth: "1.3" }), jsxRuntimeExports.jsx("path", { d: "M0.868433 9.84088L3.91443 8.08228", stroke: "currentColor", strokeWidth: "1.3" }), jsxRuntimeExports.jsx("path", { d: "M0.224216 4.94783L3.62158 5.85815", stroke: "currentColor", strokeWidth: "1.3" }), jsxRuntimeExports.jsx("path", { d: "M7.04717 7.60757L16.3557 14.9121L11.6493 15.5786L8.71884 19.3212L7.04717 7.60757Z", stroke: "currentColor", strokeWidth: "1.3" })] }));
BoundarySelectorIcon.displayName = "BoundarySelectorIcon";
const UploadFileIcon = reactExports.memo((props) => jsxRuntimeExports.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", children: jsxRuntimeExports.jsx("path", { stroke: "currentColor", strokeLinecap: "square", strokeLinejoin: "bevel", strokeWidth: "1.3", d: "M12 3v18M3 12h18" }) }));
UploadFileIcon.displayName = "UploadFileIcon";
const AnalyticsPanelIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "18", height: "22", viewBox: "0 0 18 22", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M11 1H3C2.46957 1 1.96086 1.21071 1.58579 1.58579C1.21071 1.96086 1 2.46957 1 3V19C1 19.5304 1.21071 20.0391 1.58579 20.4142C1.96086 20.7893 2.46957 21 3 21H15C15.5304 21 16.0391 20.7893 16.4142 20.4142C16.7893 20.0391 17 19.5304 17 19V7L11 1Z", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M13 16H5", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M13 12H5", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M7 8H6H5", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M11 1V7H17", stroke: "currentColor", fill: "currentColor", strokeWidth: "1.3", strokeLinecap: "round", strokeLinejoin: "round" })] }));
AnalyticsPanelIcon.displayName = "AnalyticsPanelIcon";
const DrawPolygonIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M2 12V4M14 12V4M12 2H4M12 14H4", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" }), jsxRuntimeExports.jsx("rect", { x: "0.65", y: "12.65", width: "2.7", height: "2.7", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" }), jsxRuntimeExports.jsx("rect", { x: "0.65", y: "0.65", width: "2.7", height: "2.7", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" }), jsxRuntimeExports.jsx("rect", { x: "12.65", y: "0.65", width: "2.7", height: "2.7", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" }), jsxRuntimeExports.jsx("rect", { x: "12.65", y: "12.65", width: "2.7", height: "2.7", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" })] }));
DrawPolygonIcon.displayName = "DrawPolygonIcon";
const TrashBinIcon = reactExports.memo((props) => jsxRuntimeExports.jsx("svg", { width: "16", height: "18", viewBox: "0 0 16 18", fill: "none", children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.21857 2.17112C4.21857 1.25985 4.9573 0.521118 5.86857 0.521118H10.1317C11.043 0.521118 11.7817 1.25985 11.7817 2.17112V3.65256H13.4804H14.1304H15.0462C15.4052 3.65256 15.6962 3.94357 15.6962 4.30256C15.6962 4.66154 15.4052 4.95256 15.0462 4.95256H14.1304V15.8288C14.1304 16.7401 13.3917 17.4788 12.4804 17.4788H3.51992C2.60865 17.4788 1.86992 16.7401 1.86992 15.8288V4.95256H0.954199C0.595214 4.95256 0.304199 4.66154 0.304199 4.30256C0.304199 3.94357 0.595214 3.65256 0.954199 3.65256H1.86992H2.51992H4.21857V2.17112ZM5.51857 3.65256H10.4817V2.17112C10.4817 1.97782 10.325 1.82112 10.1317 1.82112H5.86857C5.67527 1.82112 5.51857 1.97782 5.51857 2.17112V3.65256ZM3.16992 4.95256V15.8288C3.16992 16.0221 3.32662 16.1788 3.51992 16.1788H12.4804C12.6737 16.1788 12.8304 16.0221 12.8304 15.8288V4.95256H3.16992ZM6.43429 7.56707C6.79328 7.56707 7.08429 7.85809 7.08429 8.21707V12.9144C7.08429 13.2734 6.79328 13.5644 6.43429 13.5644C6.07531 13.5644 5.78429 13.2734 5.78429 12.9144V8.21707C5.78429 7.85809 6.07531 7.56707 6.43429 7.56707ZM10.2159 8.21707C10.2159 7.85809 9.92486 7.56707 9.56588 7.56707C9.20689 7.56707 8.91588 7.85809 8.91588 8.21707V12.9144C8.91588 13.2734 9.20689 13.5644 9.56588 13.5644C9.92486 13.5644 10.2159 13.2734 10.2159 12.9144V8.21707Z", fill: "currentColor" }) }));
TrashBinIcon.displayName = "TrashBinIcon";
const DrawLineIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M7 17L17 7", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" }), jsxRuntimeExports.jsx("rect", { x: "4.65", y: "16.65", width: "2.7", height: "2.7", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" }), jsxRuntimeExports.jsx("rect", { x: "16.65", y: "4.65", width: "2.7", height: "2.7", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" })] }));
DrawLineIcon.displayName = "DrawLineIcon";
const DrawPointIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "14", height: "18", viewBox: "0 0 14 18", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M13.2944 7.14721C13.2944 12.1644 7.49138 16.8075 7.14721 16.8075C6.80305 16.8075 1 12.1644 1 7.14721C1 3.7522 3.7522 1 7.14721 1C10.5422 1 13.2944 3.7522 13.2944 7.14721Z", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" }), jsxRuntimeExports.jsx("circle", { cx: "7.14746", cy: "7.90381", r: "1.5", fill: "currentColor" })] }));
DrawPointIcon.displayName = "DrawPointIcon";
const InfoIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { fill: "none", width: "14", height: "14", viewBox: "0 0 14 14", ...props, children: [jsxRuntimeExports.jsx("path", { opacity: "0.3", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "M7.00002 12.8334C10.2217 12.8334 12.8334 10.2217 12.8334 7.00002C12.8334 3.77836 10.2217 1.16669 7.00002 1.16669C3.77836 1.16669 1.16669 3.77836 1.16669 7.00002C1.16669 10.2217 3.77836 12.8334 7.00002 12.8334Z" }), jsxRuntimeExports.jsx("path", { opacity: "0.3", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "M7 9.33333V7" }), jsxRuntimeExports.jsx("path", { opacity: "0.3", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "M7 4.66669H7.00667" })] }));
InfoIcon.displayName = "InfoIcon";
const LegendPanelIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "22", height: "22", viewBox: "0 0 22 22", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M11 21C16.5228 21 21 16.5228 21 11C21 5.47715 16.5228 1 11 1C5.47715 1 1 5.47715 1 11C1 16.5228 5.47715 21 11 21Z", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M11 15V11", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M11 7H11.01", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "round", strokeLinejoin: "round" })] }));
LegendPanelIcon.displayName = "LegendPanelIcon ";
const BivariatePanelIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M17 11H11V17H17V11Z", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" }), jsxRuntimeExports.jsx("path", { d: "M7 11H1V17H7V11Z", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" }), jsxRuntimeExports.jsx("path", { d: "M17 1H11V7H17V1Z", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" }), jsxRuntimeExports.jsx("path", { d: "M7 1H1V7H7V1Z", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" })] }));
BivariatePanelIcon.displayName = "BivariatePanelIcon ";
const LayersPanelIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "22", height: "22", viewBox: "0 0 22 22", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M1 16L11 21L21 16", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M1 11L11 16L21 11", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M11 1L1 6L11 11L21 6L11 1Z", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "round", strokeLinejoin: "round" })] }));
LayersPanelIcon.displayName = "LayersPanelIcon";
const EyeBallIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M0.666687 7.99984C0.666687 7.99984 3.33335 2.6665 8.00002 2.6665C12.6667 2.6665 15.3334 7.99984 15.3334 7.99984C15.3334 7.99984 12.6667 13.3332 8.00002 13.3332C3.33335 13.3332 0.666687 7.99984 0.666687 7.99984Z", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M8 10C9.10457 10 10 9.10457 10 8C10 6.89543 9.10457 6 8 6C6.89543 6 6 6.89543 6 8C6 9.10457 6.89543 10 8 10Z", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" })] }));
EyeBallIcon.displayName = "EyeBallIcon";
const EyeBallCrossedIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M6.60002 2.82652C7.05891 2.71911 7.52873 2.66541 8.00002 2.66652C12.6667 2.66652 15.3334 7.99985 15.3334 7.99985C14.9287 8.75692 14.4461 9.46968 13.8934 10.1265M9.41335 9.41319C9.23025 9.60968 9.00945 9.76729 8.76412 9.8766C8.51879 9.98591 8.25395 10.0447 7.98541 10.0494C7.71687 10.0542 7.45013 10.0048 7.20109 9.90418C6.95206 9.80359 6.72583 9.65387 6.53592 9.46396C6.346 9.27404 6.19628 9.04782 6.09569 8.79878C5.9951 8.54975 5.9457 8.283 5.95044 8.01446C5.95518 7.74592 6.01396 7.48108 6.12327 7.23575C6.23258 6.99042 6.39019 6.76962 6.58669 6.58652M11.96 11.9599C10.8204 12.8285 9.43276 13.3098 8.00002 13.3332C3.33335 13.3332 0.666687 7.99985 0.666687 7.99985C1.49595 6.45445 2.64611 5.10426 4.04002 4.03985L11.96 11.9599Z", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M0.666687 0.666504L15.3334 15.3332", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" })] }));
EyeBallCrossedIcon.displayName = "EyeBallCrossedIcon";
const AddLayerIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M3.5 16.5L12 20.5L20.5 16.5", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" }), jsxRuntimeExports.jsx("path", { d: "M12 7.5L3.5 11.5L12 15.5L20.5 11.5L12 7.5Z", stroke: "currentColor", strokeWidth: "1.3", strokeLinecap: "square", strokeLinejoin: "bevel" }), jsxRuntimeExports.jsx("path", { d: "M12 5L18.5 8L16.5 12H12H7.5L5.5 8L12 5Z", fill: "#26303A" }), jsxRuntimeExports.jsx("path", { d: "M12 3V11M8 7H16", stroke: "currentColor", strokeWidth: "1.3" })] }));
AddLayerIcon.displayName = "AddLayerIcon";
const SortIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M4 5H12", stroke: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M4 8H12", stroke: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M4 11H12", stroke: "currentColor" })] }));
SortIcon.displayName = "SortIcon";
const TripleDotIcon = reactExports.memo((props) => jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", children: [jsxRuntimeExports.jsx("path", { d: "M13 7C13.5523 7 14 7.44772 14 8C14 8.55228 13.5523 9 13 9C12.4477 9 12 8.55228 12 8C12 7.44772 12.4477 7 13 7Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M8 7C8.55228 7 9 7.44772 9 8C9 8.55228 8.55228 9 8 9C7.44772 9 7 8.55228 7 8C7 7.44772 7.44772 7 8 7Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M3 7C3.55228 7 4 7.44772 4 8C4 8.55228 3.55228 9 3 9C2.44772 9 2 8.55228 2 8C2 7.44772 2.44772 7 3 7Z", fill: "currentColor" })] }));
TripleDotIcon.displayName = "TripleDotIcon";
const PlayOutlineTv24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.35 9.45221C8.35 8.54037 9.33771 8.13095 10.0195 8.47689L15.0405 11.0247C15.8532 11.437 15.8531 12.563 15.0405 12.9753L10.0195 15.5231C9.33771 15.869 8.35 15.4596 8.35 14.5478V9.45221ZM9.65 9.7472V14.2528L14.0897 12L9.65 9.7472Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0.349998 5.5C0.349998 4.31259 1.31259 3.35 2.5 3.35H21.5C22.6874 3.35 23.65 4.31259 23.65 5.5V18.5C23.65 19.6874 22.6874 20.65 21.5 20.65H2.5C1.31259 20.65 0.349998 19.6874 0.349998 18.5V5.5ZM2.5 4.65C2.03056 4.65 1.65 5.03056 1.65 5.5V18.5C1.65 18.9694 2.03056 19.35 2.5 19.35H21.5C21.9694 19.35 22.35 18.9694 22.35 18.5V5.5C22.35 5.03056 21.9694 4.65 21.5 4.65H2.5Z", fill: "currentColor" })] });
PlayOutlineTv24.displayName = "PlayOutlineTv24";
const Memo$2T = reactExports.memo(PlayOutlineTv24);
const ArrowRight24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.5404 4.54039C11.7942 4.28655 12.2058 4.28655 12.4596 4.54039L19.4596 11.5404C19.7135 11.7942 19.7135 12.2058 19.4596 12.4596L12.4596 19.4596C12.2058 19.7135 11.7942 19.7135 11.5404 19.4596C11.2865 19.2058 11.2865 18.7942 11.5404 18.5404L17.4308 12.65H5.00001C4.64102 12.65 4.35001 12.359 4.35001 12C4.35001 11.641 4.64102 11.35 5.00001 11.35H17.4308L11.5404 5.45963C11.2865 5.20578 11.2865 4.79423 11.5404 4.54039Z", fill: "currentColor" }) });
ArrowRight24.displayName = "ArrowRight24";
const Memo$2S = reactExports.memo(ArrowRight24);
const ArrowLeft24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.4596 4.54039C12.7135 4.79423 12.7135 5.20578 12.4596 5.45963L6.56925 11.35H19C19.359 11.35 19.65 11.641 19.65 12C19.65 12.359 19.359 12.65 19 12.65H6.56925L12.4596 18.5404C12.7135 18.7942 12.7135 19.2058 12.4596 19.4596C12.2058 19.7135 11.7942 19.7135 11.5404 19.4596L4.54039 12.4596C4.28655 12.2058 4.28655 11.7942 4.54039 11.5404L11.5404 4.54039C11.7942 4.28655 12.2058 4.28655 12.4596 4.54039Z", fill: "currentColor" }) });
ArrowLeft24.displayName = "ArrowLeft24";
const Memo$2R = reactExports.memo(ArrowLeft24);
const Database24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.1096 4.34279C3.72825 4.64332 3.65 4.87032 3.65 5.00001C3.65 5.12969 3.72825 5.35669 4.1096 5.65722C4.48361 5.95198 5.0651 6.24585 5.84159 6.50468C7.38777 7.02008 9.56514 7.35001 12 7.35001C14.4349 7.35001 16.6122 7.02008 18.1584 6.50468C18.9349 6.24585 19.5164 5.95198 19.8904 5.65722C20.2717 5.35669 20.35 5.12969 20.35 5.00001C20.35 4.87032 20.2717 4.64332 19.8904 4.34279C19.5164 4.04803 18.9349 3.75416 18.1584 3.49533C16.6122 2.97994 14.4349 2.65001 12 2.65001C9.56514 2.65001 7.38777 2.97994 5.84159 3.49533C5.0651 3.75416 4.48361 4.04803 4.1096 4.34279ZM20.35 6.92345C19.8593 7.2395 19.2514 7.51067 18.5695 7.73797C16.8583 8.30836 14.5357 8.65001 12 8.65001C9.46429 8.65001 7.14167 8.30836 5.43049 7.73797C4.74859 7.51067 4.14074 7.2395 3.65 6.92345V12C3.65 12.1327 3.72892 12.3602 4.10681 12.6596C4.47822 12.9539 5.05649 13.2474 5.83083 13.506C7.37279 14.0207 9.5499 14.35 12 14.35C14.4501 14.35 16.6272 14.0207 18.1692 13.506C18.9435 13.2474 19.5218 12.9539 19.8932 12.6596C20.2711 12.3602 20.35 12.1327 20.35 12V6.92345ZM21.65 5.00001C21.65 4.30127 21.2246 3.73905 20.6951 3.32175C20.1582 2.89868 19.4217 2.54611 18.5695 2.26204C16.8583 1.69165 14.5357 1.35001 12 1.35001C9.46429 1.35001 7.14167 1.69165 5.43049 2.26204C4.5783 2.54611 3.84177 2.89868 3.30493 3.32175C2.77542 3.73905 2.35 4.30127 2.35 5.00001V19C2.35 19.6974 2.77108 20.2598 3.29943 20.6785C3.83428 21.1023 4.5685 21.4551 5.41917 21.7391C7.12721 22.3093 9.4501 22.65 12 22.65C14.5499 22.65 16.8728 22.3093 18.5808 21.7391C19.4315 21.4551 20.1657 21.1023 20.7006 20.6785C21.2289 20.2598 21.65 19.6974 21.65 19V5.00001ZM20.35 13.9284C19.8621 14.243 19.2584 14.5129 18.5808 14.7391C16.8728 15.3093 14.5499 15.65 12 15.65C9.4501 15.65 7.12721 15.3093 5.41917 14.7391C4.7416 14.5129 4.13791 14.243 3.65 13.9284V19C3.65 19.1327 3.72892 19.3602 4.10681 19.6596C4.47822 19.9539 5.05649 20.2474 5.83083 20.506C7.37279 21.0207 9.5499 21.35 12 21.35C14.4501 21.35 16.6272 21.0207 18.1692 20.506C18.9435 20.2474 19.5218 19.9539 19.8932 19.6596C20.2711 19.3602 20.35 19.1327 20.35 19V13.9284Z", fill: "currentColor" }) });
Database24.displayName = "Database24";
const Memo$2Q = reactExports.memo(Database24);
const CornerUpRight24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.5404 3.54039C14.7942 3.28655 15.2058 3.28655 15.4596 3.54039L20.4596 8.54039C20.7135 8.79423 20.7135 9.20578 20.4596 9.45963L15.4596 14.4596C15.2058 14.7135 14.7942 14.7135 14.5404 14.4596C14.2865 14.2058 14.2865 13.7942 14.5404 13.5404L18.4308 9.65001H8.00001C7.11153 9.65001 6.25944 10.003 5.6312 10.6312C5.00295 11.2594 4.65001 12.1115 4.65001 13V20C4.65001 20.359 4.35899 20.65 4.00001 20.65C3.64102 20.65 3.35001 20.359 3.35001 20V13C3.35001 11.7667 3.83992 10.584 4.71196 9.71196C5.584 8.83992 6.76675 8.35001 8.00001 8.35001H18.4308L14.5404 4.45963C14.2865 4.20578 14.2865 3.79423 14.5404 3.54039Z", fill: "currentColor" }) });
CornerUpRight24.displayName = "CornerUpRight24";
const Memo$2P = reactExports.memo(CornerUpRight24);
const AddLayer24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 2.35001C12.359 2.35001 12.65 2.64102 12.65 3.00001V6.35001H16C16.359 6.35001 16.65 6.64102 16.65 7.00001C16.65 7.35899 16.359 7.65001 16 7.65001H12.65V11C12.65 11.359 12.359 11.65 12 11.65C11.641 11.65 11.35 11.359 11.35 11V7.65001H8C7.64101 7.65001 7.35 7.35899 7.35 7.00001C7.35 6.64102 7.64101 6.35001 8 6.35001H11.35V3.00001C11.35 2.64102 11.641 2.35001 12 2.35001ZM16.8745 9.79388C17.0273 9.46907 17.4146 9.32966 17.7394 9.48252L20.7768 10.9119C21.0046 11.0191 21.15 11.2482 21.15 11.5C21.15 11.7518 21.0046 11.9809 20.7768 12.0881L12.2768 16.0881C12.1015 16.1706 11.8985 16.1706 11.7232 16.0881L3.22323 12.0881C2.99541 11.9809 2.85 11.7518 2.85 11.5C2.85 11.2482 2.99541 11.0191 3.22323 10.9119L6.25794 9.48377C6.58276 9.33092 6.96999 9.47032 7.12284 9.79514C7.2757 10.12 7.1363 10.5072 6.81148 10.66L5.02655 11.5L12 14.7816L18.9735 11.5L17.1859 10.6588C16.861 10.5059 16.7216 10.1187 16.8745 9.79388ZM2.91187 16.2232C3.06472 15.8984 3.45195 15.759 3.77677 15.9119L12 19.7816L20.2232 15.9119C20.548 15.759 20.9353 15.8984 21.0881 16.2232C21.241 16.5481 21.1016 16.9353 20.7768 17.0881L12.2768 21.0881C12.1015 21.1706 11.8985 21.1706 11.7232 21.0881L3.22323 17.0881C2.89841 16.9353 2.75901 16.5481 2.91187 16.2232Z", fill: "currentColor" }) });
AddLayer24.displayName = "AddLayer24";
const Memo$2O = reactExports.memo(AddLayer24);
const Location24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("g", { clipPath: "url(#clip0_105_20)", children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.9079 17.2777L17.8494 5.89032C18.0405 5.3382 17.511 4.80876 16.9589 4.99986L5.57154 8.94133C4.9336 9.16213 4.94701 10.069 5.5912 10.2708L9.26499 11.4219C10.2964 11.7451 11.1042 12.5529 11.4273 13.5843L12.5785 17.2581C12.7803 17.9023 13.6871 17.9156 13.9079 17.2777ZM19.0779 6.31553C19.6239 4.73805 18.1112 3.22536 16.5337 3.77137L5.14632 7.71283C3.32366 8.3437 3.36197 10.9346 5.2025 11.5113L8.87629 12.6625C9.50138 12.8583 9.99094 13.3479 10.1868 13.973L11.3379 17.6468C11.9146 19.4873 14.5055 19.5256 15.1364 17.7029L19.0779 6.31553Z", fill: "currentColor" }) }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "clip0_105_20", children: jsxRuntimeExports.jsx("rect", { width: 24, height: 24, rx: 12, fill: "white" }) }) })] });
Location24.displayName = "Location24";
const Memo$2N = reactExports.memo(Location24);
const LocationFilled24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { d: "M16.7861 6.92606C17.4051 6.63177 18.055 7.2787 17.755 7.89487L14.7765 17.0975C14.5223 17.883 13.4143 17.8924 13.1467 17.1113L11.8399 13.9562C11.6337 13.4585 11.2356 13.0651 10.7356 12.8648L7.6745 11.639C6.84402 11.3351 6.86547 10.1532 7.70642 9.87968L16.7861 6.92606Z", fill: "currentColor" }) });
LocationFilled24.displayName = "LocationFilled24";
const Memo$2M = reactExports.memo(LocationFilled24);
const LocationFilled16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { d: "M11.1908 4.61738C11.6034 4.42119 12.0367 4.85247 11.8366 5.26325L9.85101 11.3983C9.68152 11.922 8.94284 11.9283 8.7645 11.4075L8.00068 9.5635C7.79456 9.06588 7.39644 8.67243 6.89642 8.4722L5.11633 7.75937C4.56268 7.55677 4.57698 6.76883 5.13762 6.58646L11.1908 4.61738Z", fill: "currentColor" }) });
LocationFilled16.displayName = "LocationFilled16";
const Memo$2L = reactExports.memo(LocationFilled16);
const Info24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 2.65001C6.83614 2.65001 2.65 6.83614 2.65 12C2.65 17.1639 6.83614 21.35 12 21.35C17.1639 21.35 21.35 17.1639 21.35 12C21.35 6.83614 17.1639 2.65001 12 2.65001ZM1.35 12C1.35 6.11817 6.11817 1.35001 12 1.35001C17.8818 1.35001 22.65 6.11817 22.65 12C22.65 17.8818 17.8818 22.65 12 22.65C6.11817 22.65 1.35 17.8818 1.35 12ZM11.35 8.00001C11.35 7.64102 11.641 7.35001 12 7.35001H12.01C12.369 7.35001 12.66 7.64102 12.66 8.00001C12.66 8.35899 12.369 8.65001 12.01 8.65001H12C11.641 8.65001 11.35 8.35899 11.35 8.00001ZM12 11.35C12.359 11.35 12.65 11.641 12.65 12V16C12.65 16.359 12.359 16.65 12 16.65C11.641 16.65 11.35 16.359 11.35 16V12C11.35 11.641 11.641 11.35 12 11.35Z", fill: "currentColor" }) });
Info24.displayName = "Info24";
const Memo$2K = reactExports.memo(Info24);
const Locate24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_1688_25972)", children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 18.7C15.7003 18.7 18.7 15.7003 18.7 12C18.7 8.2997 15.7003 5.30001 12 5.30001C8.29969 5.30001 5.3 8.2997 5.3 12C5.3 15.7003 8.29969 18.7 12 18.7ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58173 16.4183 4.00001 12 4.00001C7.58172 4.00001 4 7.58173 4 12C4 16.4183 7.58172 20 12 20Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 10.3C12.9389 10.3 13.7 11.0611 13.7 12C13.7 12.9389 12.9389 13.7 12 13.7C11.0611 13.7 10.3 12.9389 10.3 12C10.3 11.0611 11.0611 10.3 12 10.3ZM12 9.00001C13.6569 9.00001 15 10.3432 15 12C15 13.6569 13.6569 15 12 15C10.3431 15 9 13.6569 9 12C9 10.3432 10.3431 9.00001 12 9.00001Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 0.350006C12.359 0.350006 12.65 0.641021 12.65 1.00001V4.00001C12.65 4.35899 12.359 4.65001 12 4.65001C11.641 4.65001 11.35 4.35899 11.35 4.00001V1.00001C11.35 0.641021 11.641 0.350006 12 0.350006ZM0.349998 12C0.349998 11.641 0.641013 11.35 0.999998 11.35H4C4.35898 11.35 4.65 11.641 4.65 12C4.65 12.359 4.35898 12.65 4 12.65H0.999998C0.641013 12.65 0.349998 12.359 0.349998 12ZM19.35 12C19.35 11.641 19.641 11.35 20 11.35H23C23.359 11.35 23.65 11.641 23.65 12C23.65 12.359 23.359 12.65 23 12.65H20C19.641 12.65 19.35 12.359 19.35 12ZM12 19.35C12.359 19.35 12.65 19.641 12.65 20V23C12.65 23.359 12.359 23.65 12 23.65C11.641 23.65 11.35 23.359 11.35 23V20C11.35 19.641 11.641 19.35 12 19.35Z", fill: "currentColor" })] }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "clip0_1688_25972", children: jsxRuntimeExports.jsx("rect", { width: 24, height: 24, fill: "white" }) }) })] });
Locate24.displayName = "Locate24";
const Memo$2J = reactExports.memo(Locate24);
const Loader24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 1.35001C12.359 1.35001 12.65 1.64102 12.65 2.00001V6.00001C12.65 6.35899 12.359 6.65001 12 6.65001C11.641 6.65001 11.35 6.35899 11.35 6.00001V2.00001C11.35 1.64102 11.641 1.35001 12 1.35001ZM4.47038 4.47039C4.72422 4.21655 5.13578 4.21655 5.38962 4.47039L8.21962 7.30039C8.47346 7.55423 8.47346 7.96579 8.21962 8.21963C7.96578 8.47347 7.55422 8.47347 7.30038 8.21963L4.47038 5.38963C4.21654 5.13578 4.21654 4.72423 4.47038 4.47039ZM19.5296 4.47039C19.7835 4.72423 19.7835 5.13578 19.5296 5.38963L16.6996 8.21963C16.4458 8.47347 16.0342 8.47347 15.7804 8.21963C15.5265 7.96579 15.5265 7.55423 15.7804 7.30039L18.6104 4.47039C18.8642 4.21655 19.2758 4.21655 19.5296 4.47039ZM1.35 12C1.35 11.641 1.64101 11.35 2 11.35H6C6.35898 11.35 6.65 11.641 6.65 12C6.65 12.359 6.35898 12.65 6 12.65H2C1.64101 12.65 1.35 12.359 1.35 12ZM17.35 12C17.35 11.641 17.641 11.35 18 11.35H22C22.359 11.35 22.65 11.641 22.65 12C22.65 12.359 22.359 12.65 22 12.65H18C17.641 12.65 17.35 12.359 17.35 12ZM8.21962 15.7804C8.47346 16.0342 8.47346 16.4458 8.21962 16.6996L5.38962 19.5296C5.13578 19.7835 4.72422 19.7835 4.47038 19.5296C4.21654 19.2758 4.21654 18.8642 4.47038 18.6104L7.30038 15.7804C7.55422 15.5265 7.96578 15.5265 8.21962 15.7804ZM15.7804 15.7804C16.0342 15.5265 16.4458 15.5265 16.6996 15.7804L19.5296 18.6104C19.7835 18.8642 19.7835 19.2758 19.5296 19.5296C19.2758 19.7835 18.8642 19.7835 18.6104 19.5296L15.7804 16.6996C15.5265 16.4458 15.5265 16.0342 15.7804 15.7804ZM12 17.35C12.359 17.35 12.65 17.641 12.65 18V22C12.65 22.359 12.359 22.65 12 22.65C11.641 22.65 11.35 22.359 11.35 22V18C11.35 17.641 11.641 17.35 12 17.35Z", fill: "currentColor" }) });
Loader24.displayName = "Loader24";
const Memo$2I = reactExports.memo(Loader24);
const Loading16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.98598 2.74142C9.05221 2.38823 8.81918 2.04465 8.46088 2.01744C8.30877 2.00588 8.15507 2 8 2C4.68629 2 2 4.68629 2 8C2 11.3137 4.68629 14 8 14C11.3137 14 14 11.3137 14 8C14 7.72291 13.9812 7.45021 13.9449 7.1831C13.8964 6.82712 13.5395 6.61511 13.191 6.70225C12.8428 6.78929 12.6358 7.14218 12.6736 7.49906C12.6911 7.66365 12.7 7.83078 12.7 8C12.7 10.5957 10.5957 12.7 8 12.7C5.40426 12.7 3.3 10.5957 3.3 8C3.3 5.40426 5.40426 3.3 8 3.3C8.07433 3.3 8.14825 3.30173 8.22174 3.30514C8.58011 3.32178 8.91987 3.09403 8.98598 2.74142Z", fill: "currentColor" }) });
Loading16.displayName = "Loading16";
const Memo$2H = reactExports.memo(Loading16);
const Measure24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.44038 2.54039C3.69422 2.28655 4.10578 2.28655 4.35962 2.54039L6.75962 4.94039C7.01346 5.19423 7.01346 5.60578 6.75962 5.85963C6.50578 6.11347 6.09422 6.11347 5.84038 5.85963L4.55 4.56924V19.45H19.4308L18.0404 18.0596C17.7865 17.8058 17.7865 17.3942 18.0404 17.1404C18.2942 16.8865 18.7058 16.8865 18.9596 17.1404L21.4596 19.6404C21.7135 19.8942 21.7135 20.3058 21.4596 20.5596L18.9596 23.0596C18.7058 23.3135 18.2942 23.3135 18.0404 23.0596C17.7865 22.8058 17.7865 22.3942 18.0404 22.1404L19.4308 20.75H3.9C3.54101 20.75 3.25 20.459 3.25 20.1V4.56924L1.95962 5.85963C1.70578 6.11347 1.29422 6.11347 1.04038 5.85963C0.786538 5.60578 0.786538 5.19423 1.04038 4.94039L3.44038 2.54039Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10 8.29445C10.359 8.29445 10.65 8.58546 10.65 8.94445V9.0207C11.4123 8.72149 12.3159 8.84249 12.9639 9.38369C14.018 8.37682 15.9036 8.62498 16.5478 10.1282C16.6152 10.2855 16.65 10.4548 16.65 10.626V14C16.65 14.359 16.359 14.65 16 14.65C15.641 14.65 15.35 14.359 15.35 14V10.6335C15.0261 9.89264 13.9739 9.89264 13.65 10.6335V14C13.65 14.359 13.359 14.65 13 14.65C12.641 14.65 12.35 14.359 12.35 14V10.6502C11.9784 9.99782 11.0216 9.99782 10.65 10.6502V14C10.65 14.359 10.359 14.65 10 14.65C9.64102 14.65 9.35 14.359 9.35 14V8.94445C9.35 8.58546 9.64102 8.29445 10 8.29445Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19.2428 4.68117C19.0836 4.50773 18.7987 4.38433 18.5526 4.389C18.0654 4.39825 17.65 4.83367 17.65 5.33334C17.65 5.69233 17.359 5.98334 17 5.98334C16.641 5.98334 16.35 5.69233 16.35 5.33334C16.35 4.16634 17.2922 3.1127 18.5279 3.08924C19.1433 3.07755 19.7869 3.35161 20.2004 3.80192C20.4137 4.03427 20.5857 4.33608 20.6352 4.69327C20.6859 5.05932 20.6002 5.42979 20.3853 5.77004C19.9542 6.45253 19.2993 6.80641 18.8152 7.06802C18.7535 7.10134 18.6946 7.13317 18.6393 7.16399C18.5259 7.22717 18.4215 7.28811 18.3258 7.35001L20 7.35001C20.359 7.35001 20.65 7.64102 20.65 8.00001C20.65 8.35899 20.359 8.65001 20 8.65001L17 8.65001C16.7911 8.65001 16.5949 8.54957 16.4727 8.38007C16.3505 8.21057 16.3173 7.99268 16.3834 7.79446C16.7143 6.80161 17.424 6.35293 18.0065 6.02836C18.0708 5.99254 18.1327 5.95843 18.1923 5.92558C18.7032 5.64408 19.0469 5.4547 19.2862 5.07579C19.352 4.97159 19.3524 4.90733 19.3475 4.87177C19.3414 4.82736 19.3159 4.76071 19.2428 4.68117Z", fill: "currentColor" })] });
Measure24.displayName = "Measure24";
const Memo$2G = reactExports.memo(Measure24);
const Chart24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 6.35C12.359 6.35 12.65 6.64101 12.65 7L12.65 17C12.65 17.359 12.359 17.65 12 17.65C11.641 17.65 11.35 17.359 11.35 17L11.35 7C11.35 6.64101 11.641 6.35 12 6.35ZM17 10.35C17.359 10.35 17.65 10.641 17.65 11V17C17.65 17.359 17.359 17.65 17 17.65C16.641 17.65 16.35 17.359 16.35 17V11C16.35 10.641 16.641 10.35 17 10.35ZM7 11.85C7.35898 11.85 7.65 12.141 7.65 12.5V17C7.65 17.359 7.35898 17.65 7 17.65C6.64101 17.65 6.35 17.359 6.35 17V12.5C6.35 12.141 6.64101 11.85 7 11.85Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 1.7H19C20.8225 1.7 22.3 3.17746 22.3 5V19C22.3 20.8225 20.8225 22.3 19 22.3H5C3.17746 22.3 1.7 20.8225 1.7 19V5C1.7 3.17746 3.17746 1.7 5 1.7ZM5 3C3.89543 3 3 3.89543 3 5V19C3 20.1046 3.89543 21 5 21H19C20.1046 21 21 20.1046 21 19V5C21 3.89543 20.1046 3 19 3H5Z", fill: "currentColor" })] });
Chart24.displayName = "Chart24";
const Memo$2F = reactExports.memo(Chart24);
const ChartColumn24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16 8.35001C16.359 8.35001 16.65 8.64102 16.65 9.00001L16.65 20C16.65 20.359 16.359 20.65 16 20.65C15.641 20.65 15.35 20.359 15.35 20L15.35 9.00001C15.35 8.64102 15.641 8.35001 16 8.35001ZM10 11.35C10.359 11.35 10.65 11.641 10.65 12L10.65 20C10.65 20.359 10.359 20.65 10 20.65C9.64102 20.65 9.35001 20.359 9.35001 20L9.35001 12C9.35001 11.641 9.64102 11.35 10 11.35ZM13 14.35C13.359 14.35 13.65 14.641 13.65 15V20C13.65 20.359 13.359 20.65 13 20.65C12.641 20.65 12.35 20.359 12.35 20V15C12.35 14.641 12.641 14.35 13 14.35ZM7.00001 16.35C7.35899 16.35 7.65001 16.641 7.65001 17V20C7.65001 20.359 7.35899 20.65 7.00001 20.65C6.64102 20.65 6.35001 20.359 6.35001 20L6.35001 17C6.35001 16.641 6.64102 16.35 7.00001 16.35Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.00001 3.35001C4.35899 3.35001 4.65001 3.64102 4.65001 4.00001V19.35H20C20.359 19.35 20.65 19.641 20.65 20C20.65 20.359 20.359 20.65 20 20.65H4.00001C3.82762 20.65 3.66229 20.5815 3.54039 20.4596C3.41849 20.3377 3.35001 20.1724 3.35001 20L3.35001 4.00001C3.35001 3.64102 3.64102 3.35001 4.00001 3.35001Z", fill: "currentColor" })] });
ChartColumn24.displayName = "ChartColumn24";
const Memo$2E = reactExports.memo(ChartColumn24);
const Expand24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.9809 4.63096C12.9809 4.27197 13.2719 3.98096 13.6309 3.98096L19.369 3.98096C19.728 3.98096 20.019 4.27197 20.019 4.63096V10.369C20.019 10.728 19.728 11.019 19.369 11.019C19.01 11.019 18.719 10.728 18.719 10.369V6.2002L14.3836 10.5356C14.1298 10.7895 13.7182 10.7895 13.4644 10.5356C13.2105 10.2818 13.2105 9.87022 13.4644 9.61638L17.7998 5.28096H13.6309C13.2719 5.28096 12.9809 4.98994 12.9809 4.63096ZM4.63095 12.981C4.98993 12.981 5.28095 13.272 5.28095 13.631L5.28095 17.7998L9.61637 13.4644C9.87021 13.2105 10.2818 13.2105 10.5356 13.4644C10.7894 13.7182 10.7894 14.1298 10.5356 14.3836L6.20019 18.719H10.369C10.728 18.719 11.019 19.0101 11.019 19.369C11.019 19.728 10.728 20.019 10.369 20.019H4.63095C4.45856 20.019 4.29323 19.9506 4.17133 19.8287C4.04943 19.7068 3.98095 19.5414 3.98095 19.369L3.98095 13.631C3.98095 13.272 4.27196 12.981 4.63095 12.981Z", fill: "currentColor" }) });
Expand24.displayName = "Expand24";
const Memo$2D = reactExports.memo(Expand24);
const Collapse24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M20.5356 3.46438C20.7894 3.71822 20.7894 4.12978 20.5356 4.38362L15.2002 9.71904H19.369C19.728 9.71904 20.019 10.0101 20.019 10.369C20.019 10.728 19.728 11.019 19.369 11.019H13.6309C13.2719 11.019 12.9809 10.728 12.9809 10.369V4.63096C12.9809 4.27197 13.2719 3.98096 13.6309 3.98096C13.9899 3.98096 14.2809 4.27197 14.2809 4.63096V8.7998L19.6163 3.46438C19.8702 3.21054 20.2817 3.21054 20.5356 3.46438ZM3.98096 13.631C3.98096 13.272 4.27198 12.981 4.63096 12.981H10.3691C10.5414 12.981 10.7068 13.0494 10.8287 13.1713C10.9506 13.2932 11.0191 13.4586 11.0191 13.631L11.019 19.369C11.019 19.728 10.728 20.019 10.369 20.019C10.0101 20.019 9.71905 19.728 9.71905 19.369L9.71905 15.2002L4.38363 20.5356C4.12979 20.7895 3.71823 20.7895 3.46439 20.5356C3.21055 20.2818 3.21055 19.8702 3.46439 19.6164L8.79981 14.281H4.63096C4.27198 14.281 3.98096 13.9899 3.98096 13.631Z", fill: "currentColor" }) });
Collapse24.displayName = "Collapse24";
const Memo$2C = reactExports.memo(Collapse24);
const Collapse224 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 1.92883C12.3589 1.92883 12.65 2.21985 12.65 2.57883V9.12425L15.5978 6.17643C15.8516 5.92259 16.2632 5.92259 16.517 6.17643C16.7709 6.43028 16.7709 6.84183 16.517 7.09567L12.4596 11.1531C12.3377 11.275 12.1724 11.3435 12 11.3435C11.8276 11.3435 11.6622 11.275 11.5403 11.1531L7.48291 7.09567C7.22907 6.84183 7.22907 6.43028 7.48291 6.17644C7.73675 5.92259 8.1483 5.92259 8.40215 6.17644L11.35 9.12425V2.57883C11.35 2.21985 11.641 1.92883 12 1.92883ZM12 12.6565C12.1724 12.6565 12.3377 12.725 12.4596 12.8469L16.5171 16.9043C16.7709 17.1582 16.7709 17.5697 16.5171 17.8236C16.2632 18.0774 15.8517 18.0774 15.5978 17.8236L12.65 14.8757V21.4212C12.65 21.7801 12.359 22.0712 12 22.0712C11.641 22.0712 11.35 21.7801 11.35 21.4212V14.8757L8.40217 17.8236C8.14833 18.0774 7.73678 18.0774 7.48294 17.8236C7.2291 17.5697 7.2291 17.1582 7.48294 16.9043L11.5404 12.8469C11.6623 12.725 11.8276 12.6565 12 12.6565Z", fill: "currentColor" }) });
Collapse224.displayName = "Collapse224";
const Memo$2B = reactExports.memo(Collapse224);
const Branch24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 15.65C4.70213 15.65 3.65 16.7021 3.65 18C3.65 19.2979 4.70213 20.35 6 20.35C7.29787 20.35 8.35 19.2979 8.35 18C8.35 16.7021 7.29787 15.65 6 15.65ZM2.35 18C2.35 15.9842 3.98416 14.35 6 14.35C8.01584 14.35 9.65 15.9842 9.65 18C9.65 20.0158 8.01584 21.65 6 21.65C3.98416 21.65 2.35 20.0158 2.35 18Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18 8.35001C18.359 8.35001 18.65 8.64102 18.65 9.00001C18.65 11.5593 17.6333 14.0139 15.8236 15.8236C14.0139 17.6333 11.5593 18.65 9 18.65C8.64101 18.65 8.35 18.359 8.35 18C8.35 17.641 8.64101 17.35 9 17.35C11.2146 17.35 13.3384 16.4703 14.9043 14.9043C16.4703 13.3384 17.35 11.2146 17.35 9.00001C17.35 8.64102 17.641 8.35001 18 8.35001Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18 3.65001C16.7021 3.65001 15.65 4.70214 15.65 6.00001C15.65 7.29788 16.7021 8.35001 18 8.35001C19.2979 8.35001 20.35 7.29788 20.35 6.00001C20.35 4.70214 19.2979 3.65001 18 3.65001ZM14.35 6.00001C14.35 3.98417 15.9842 2.35001 18 2.35001C20.0158 2.35001 21.65 3.98417 21.65 6.00001C21.65 8.01585 20.0158 9.65001 18 9.65001C15.9842 9.65001 14.35 8.01585 14.35 6.00001Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 2.35001C6.35898 2.35001 6.65 2.64102 6.65 3.00001V15C6.65 15.359 6.35898 15.65 6 15.65C5.64101 15.65 5.35 15.359 5.35 15V3.00001C5.35 2.64102 5.64101 2.35001 6 2.35001Z", fill: "currentColor" })] });
Branch24.displayName = "Branch24";
const Memo$2A = reactExports.memo(Branch24);
const InfoFilled16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("g", { clipPath: "url(#clip0_1049_4224)", children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16 8C16 12.4183 12.4183 16 8 16C3.58172 16 0 12.4183 0 8C0 3.58172 3.58172 0 8 0C12.4183 0 16 3.58172 16 8ZM8 2.375C8.51777 2.375 8.9375 2.79473 8.9375 3.3125C8.9375 3.83027 8.51777 4.25 8 4.25C7.48223 4.25 7.0625 3.83027 7.0625 3.3125C7.0625 2.79473 7.48223 2.375 8 2.375ZM10.5 12.375C10.5 12.7616 10.1866 13.075 9.8 13.075H6.2C5.8134 13.075 5.5 12.7616 5.5 12.375C5.5 11.9884 5.8134 11.675 6.2 11.675H7.3V7.45H6.825C6.4384 7.45 6.125 7.1366 6.125 6.75C6.125 6.3634 6.4384 6.05 6.825 6.05H7.70625C8.25854 6.05 8.70625 6.49772 8.70625 7.05V11.675H9.8C10.1866 11.675 10.5 11.9884 10.5 12.375Z", fill: "currentColor" }) }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "clip0_1049_4224", children: jsxRuntimeExports.jsx("rect", { width: 16, height: 16, fill: "white" }) }) })] });
InfoFilled16.displayName = "InfoFilled16";
const Memo$2z = reactExports.memo(InfoFilled16);
const Calendar24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.00001 4.65001C4.25442 4.65001 3.65001 5.25442 3.65001 6.00001V20C3.65001 20.7456 4.25442 21.35 5.00001 21.35H19C19.7456 21.35 20.35 20.7456 20.35 20V6.00001C20.35 5.25442 19.7456 4.65001 19 4.65001H5.00001ZM2.35001 6.00001C2.35001 4.53645 3.53645 3.35001 5.00001 3.35001H19C20.4636 3.35001 21.65 4.53645 21.65 6.00001V20C21.65 21.4636 20.4636 22.65 19 22.65H5.00001C3.53645 22.65 2.35001 21.4636 2.35001 20V6.00001Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.00001 1.35001C8.35899 1.35001 8.65001 1.64102 8.65001 2.00001V6.00001C8.65001 6.35899 8.35899 6.65001 8.00001 6.65001C7.64102 6.65001 7.35001 6.35899 7.35001 6.00001V2.00001C7.35001 1.64102 7.64102 1.35001 8.00001 1.35001ZM16 1.35001C16.359 1.35001 16.65 1.64102 16.65 2.00001V6.00001C16.65 6.35899 16.359 6.65001 16 6.65001C15.641 6.65001 15.35 6.35899 15.35 6.00001V2.00001C15.35 1.64102 15.641 1.35001 16 1.35001ZM2.35001 10C2.35001 9.64102 2.64102 9.35001 3.00001 9.35001H21C21.359 9.35001 21.65 9.64102 21.65 10C21.65 10.359 21.359 10.65 21 10.65H3.00001C2.64102 10.65 2.35001 10.359 2.35001 10Z", fill: "currentColor" })] });
Calendar24.displayName = "Calendar24";
const Memo$2y = reactExports.memo(Calendar24);
const Filters24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.35 7.00001C2.35 6.64102 2.64101 6.35001 3 6.35001H10C10.359 6.35001 10.65 6.64102 10.65 7.00001C10.65 7.35899 10.359 7.65001 10 7.65001H3C2.64101 7.65001 2.35 7.35899 2.35 7.00001ZM18 6.35001L21 6.35001C21.359 6.35001 21.65 6.64102 21.65 7.00001C21.65 7.35899 21.359 7.65001 21 7.65001L18 7.65001C17.641 7.65001 17.35 7.35899 17.35 7.00001C17.35 6.64102 17.641 6.35001 18 6.35001ZM2.35 17C2.35 16.641 2.64101 16.35 3 16.35H6C6.35898 16.35 6.65 16.641 6.65 17C6.65 17.359 6.35898 17.65 6 17.65H3C2.64101 17.65 2.35 17.359 2.35 17ZM13.35 17C13.35 16.641 13.641 16.35 14 16.35H21C21.359 16.35 21.65 16.641 21.65 17C21.65 17.359 21.359 17.65 21 17.65H14C13.641 17.65 13.35 17.359 13.35 17Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.5 15.15C9.52172 15.15 10.35 15.9783 10.35 17C10.35 18.0217 9.52172 18.85 8.5 18.85C7.47827 18.85 6.65 18.0217 6.65 17C6.65 15.9783 7.47827 15.15 8.5 15.15ZM11.65 17C11.65 15.2603 10.2397 13.85 8.5 13.85C6.7603 13.85 5.35 15.2603 5.35 17C5.35 18.7397 6.7603 20.15 8.5 20.15C10.2397 20.15 11.65 18.7397 11.65 17Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.5 5.15001C14.4783 5.15001 13.65 5.97828 13.65 7.00001C13.65 8.02173 14.4783 8.85001 15.5 8.85001C16.5217 8.85001 17.35 8.02173 17.35 7.00001C17.35 5.97828 16.5217 5.15001 15.5 5.15001ZM12.35 7.00001C12.35 5.26031 13.7603 3.85001 15.5 3.85001C17.2397 3.85001 18.65 5.26031 18.65 7.00001C18.65 8.7397 17.2397 10.15 15.5 10.15C13.7603 10.15 12.35 8.7397 12.35 7.00001Z", fill: "currentColor" })] });
Filters24.displayName = "Filters24";
const Memo$2x = reactExports.memo(Filters24);
const Alarm24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.6999 2.58808C11.0968 2.36464 11.5446 2.24725 12 2.24725C12.4555 2.24725 12.9032 2.36464 13.3001 2.58808C13.697 2.81152 14.0296 3.13348 14.2658 3.52289L14.2676 3.52598L22.743 17.6749C22.9744 18.0756 23.0967 18.53 23.098 18.9927C23.0993 19.4554 22.9794 19.9104 22.7503 20.3124C22.5212 20.7144 22.1908 21.0494 21.792 21.2841C21.3932 21.5187 20.9399 21.6449 20.4772 21.65L20.47 21.65L3.52288 21.65C3.06019 21.6449 2.6069 21.5187 2.2081 21.2841C1.80929 21.0494 1.47889 20.7144 1.24975 20.3124C1.02061 19.9104 0.900723 19.4554 0.902018 18.9927C0.903314 18.53 1.02575 18.0757 1.25713 17.675L1.26234 17.6659L9.73241 3.52598L9.73428 3.52289C9.97049 3.13348 10.3031 2.81152 10.6999 2.58808ZM12 3.54725C11.768 3.54725 11.5399 3.60705 11.3377 3.72088C11.136 3.83445 10.9669 3.99798 10.8466 4.19575C10.8463 4.1962 10.8461 4.19665 10.8458 4.19711L2.38058 18.3291C2.26422 18.5322 2.20267 18.7622 2.20201 18.9963C2.20135 19.2321 2.26243 19.4638 2.37916 19.6686C2.49589 19.8734 2.66421 20.0441 2.86737 20.1636C3.06964 20.2827 3.29941 20.3469 3.53403 20.35H20.466C20.7006 20.3469 20.9304 20.2827 21.1327 20.1636C21.3358 20.0441 21.5042 19.8734 21.6209 19.6686C21.7376 19.4638 21.7987 19.2321 21.798 18.9963C21.7974 18.7622 21.7358 18.5323 21.6195 18.3291L13.1543 4.19711C13.154 4.19665 13.1537 4.1962 13.1535 4.19575C13.0332 3.99798 12.8641 3.83445 12.6623 3.72088C12.4602 3.60705 12.232 3.54725 12 3.54725ZM12 8.35C12.359 8.35 12.65 8.64101 12.65 9V13C12.65 13.359 12.359 13.65 12 13.65C11.641 13.65 11.35 13.359 11.35 13V9C11.35 8.64101 11.641 8.35 12 8.35ZM11.35 17C11.35 16.641 11.641 16.35 12 16.35H12.01C12.369 16.35 12.66 16.641 12.66 17C12.66 17.359 12.369 17.65 12.01 17.65H12C11.641 17.65 11.35 17.359 11.35 17Z", fill: "currentColor" }) });
Alarm24.displayName = "Alarm24";
const Memo$2w = reactExports.memo(Alarm24);
const InfoAlarm16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0.205221 12.6799L6.69066 1.74455C6.82716 1.51726 7.01936 1.32935 7.2487 1.19893C7.47805 1.06851 7.7368 1 8 1C8.2632 1 8.52195 1.06851 8.7513 1.19893C8.98064 1.32935 9.17284 1.51726 9.30934 1.74455L15.7948 12.6799C15.9285 12.9138 15.9992 13.179 16 13.449C16.0007 13.7191 15.9315 13.9847 15.799 14.2193C15.6666 14.4539 15.4757 14.6495 15.2452 14.7864C15.0148 14.9234 14.7528 14.997 14.4854 15H1.51456C1.24718 14.997 0.985227 14.9234 0.754766 14.7864C0.524306 14.6495 0.333369 14.4539 0.200953 14.2193C0.0685372 13.9847 -0.000742706 13.7191 6.00468e-06 13.449C0.000754715 13.179 0.0715059 12.9138 0.205221 12.6799ZM8.80001 6C8.80001 5.55817 8.44184 5.2 8.00001 5.2C7.55818 5.2 7.20001 5.55817 7.20001 6V9C7.20001 9.44182 7.55818 9.8 8.00001 9.8C8.44184 9.8 8.80001 9.44182 8.80001 9V6ZM8.00001 11.5333C7.55818 11.5333 7.20001 11.8915 7.20001 12.3333C7.20001 12.7752 7.55818 13.1333 8.00001 13.1333H8.00668C8.44851 13.1333 8.80668 12.7752 8.80668 12.3333C8.80668 11.8915 8.44851 11.5333 8.00668 11.5333H8.00001Z", fill: "currentColor" }) });
InfoAlarm16.displayName = "InfoAlarm16";
const Memo$2v = reactExports.memo(InfoAlarm16);
const Calendar16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.33333 3.16667C2.8731 3.16667 2.5 3.53977 2.5 4.00001V13.3333C2.5 13.7936 2.8731 14.1667 3.33333 14.1667H12.6667C13.1269 14.1667 13.5 13.7936 13.5 13.3333V4.00001C13.5 3.53977 13.1269 3.16667 12.6667 3.16667H3.33333ZM1.5 4.00001C1.5 2.98748 2.32081 2.16667 3.33333 2.16667H12.6667C13.6792 2.16667 14.5 2.98748 14.5 4.00001V13.3333C14.5 14.3459 13.6792 15.1667 12.6667 15.1667H3.33333C2.32081 15.1667 1.5 14.3459 1.5 13.3333V4.00001Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.5 6.66667C1.5 6.39053 1.72386 6.16667 2 6.16667H14C14.2761 6.16667 14.5 6.39053 14.5 6.66667C14.5 6.94281 14.2761 7.16667 14 7.16667H2C1.72386 7.16667 1.5 6.94281 1.5 6.66667Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.6667 0.833328C10.9428 0.833328 11.1667 1.05719 11.1667 1.33333V3.99999C11.1667 4.27614 10.9428 4.49999 10.6667 4.49999C10.3905 4.49999 10.1667 4.27614 10.1667 3.99999V1.33333C10.1667 1.05719 10.3905 0.833328 10.6667 0.833328Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.33333 0.833328C5.60947 0.833328 5.83333 1.05719 5.83333 1.33333V3.99999C5.83333 4.27614 5.60947 4.49999 5.33333 4.49999C5.05719 4.49999 4.83333 4.27614 4.83333 3.99999V1.33333C4.83333 1.05719 5.05719 0.833328 5.33333 0.833328Z", fill: "currentColor" })] });
Calendar16.displayName = "Calendar16";
const Memo$2u = reactExports.memo(Calendar16);
const FilterOff16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.65 11.5C15.65 11.141 15.359 10.85 15 10.85L10 10.85C9.64102 10.85 9.35001 11.141 9.35001 11.5C9.35001 11.859 9.64102 12.15 10 12.15H15C15.359 12.15 15.65 11.859 15.65 11.5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0.350006 4.50001C0.350006 4.85899 0.641021 5.15001 1.00001 5.15001H6.00001C6.35899 5.15001 6.65001 4.85899 6.65001 4.50001C6.65001 4.14102 6.35899 3.85001 6.00001 3.85001H1.00001C0.641021 3.85001 0.350006 4.14102 0.350006 4.50001Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.23025 11.5C3.23025 11.859 2.93924 12.15 2.58025 12.15H1.00001C0.641021 12.15 0.350006 11.859 0.350006 11.5C0.350006 11.141 0.641021 10.85 1.00001 10.85H2.58025C2.93924 10.85 3.23025 11.141 3.23025 11.5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.00001 10.15C5.74559 10.15 6.35001 10.7544 6.35001 11.5C6.35001 12.2456 5.74559 12.85 5.00001 12.85C4.25442 12.85 3.65001 12.2456 3.65001 11.5C3.65001 10.7544 4.25442 10.15 5.00001 10.15ZM7.65001 11.5C7.65001 10.0365 6.46356 8.85001 5.00001 8.85001C3.53645 8.85001 2.35001 10.0365 2.35001 11.5C2.35001 12.9636 3.53645 14.15 5.00001 14.15C6.46356 14.15 7.65001 12.9636 7.65001 11.5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.35 4.50001C12.35 4.14102 12.641 3.85001 13 3.85001L15 3.85001C15.359 3.85001 15.65 4.14102 15.65 4.50001C15.65 4.85899 15.359 5.15001 15 5.15001L13 5.15001C12.641 5.15001 12.35 4.85899 12.35 4.50001Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11 3.15001C10.2544 3.15001 9.65001 3.75442 9.65001 4.50001C9.65001 5.24559 10.2544 5.85001 11 5.85001C11.7456 5.85001 12.35 5.24559 12.35 4.50001C12.35 3.75442 11.7456 3.15001 11 3.15001ZM8.35001 4.50001C8.35001 3.03645 9.53645 1.85001 11 1.85001C12.4636 1.85001 13.65 3.03645 13.65 4.50001C13.65 5.96356 12.4636 7.15001 11 7.15001C9.53645 7.15001 8.35001 5.96356 8.35001 4.50001Z", fill: "currentColor" })] });
FilterOff16.displayName = "FilterOff16";
const Memo$2t = reactExports.memo(FilterOff16);
const FilterOn16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.65 11.5C15.65 11.141 15.359 10.85 15 10.85H10C9.64101 10.85 9.35 11.141 9.35 11.5C9.35 11.859 9.64101 12.15 10 12.15H15C15.359 12.15 15.65 11.859 15.65 11.5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0.349997 4.5C0.349997 4.14102 0.641012 3.85 0.999997 3.85H4C4.35898 3.85 4.65 4.14102 4.65 4.5C4.65 4.85898 4.35898 5.15 4 5.15H0.999997C0.641012 5.15 0.349997 4.85898 0.349997 4.5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.99999 8.85001C6.46355 8.85001 7.64999 10.0365 7.64999 11.5C7.64999 12.9636 6.46355 14.15 4.99999 14.15C3.7607 14.15 2.7201 13.2993 2.43029 12.15H0.999991C0.641006 12.15 0.349991 11.859 0.349991 11.5C0.349991 11.141 0.641006 10.85 0.999991 10.85H2.43029C2.7201 9.70071 3.7607 8.85001 4.99999 8.85001ZM6.34999 11.5C6.34999 10.7544 5.74558 10.15 4.99999 10.15C4.25441 10.15 3.64999 10.7544 3.64999 11.5C3.64999 12.2456 4.25441 12.85 4.99999 12.85C5.74558 12.85 6.34999 12.2456 6.34999 11.5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.5 9C13.9853 9 16 6.98528 16 4.5C16 2.01472 13.9853 0 11.5 0C9.01472 0 7 2.01472 7 4.5C7 6.98528 9.01472 9 11.5 9ZM14.4596 3.95963C14.7135 3.70578 14.7135 3.29423 14.4596 3.04039C14.2058 2.78655 13.7942 2.78655 13.5404 3.04039L11 5.58077L9.95962 4.54039C9.70578 4.28655 9.29422 4.28655 9.04038 4.54039C8.78654 4.79423 8.78654 5.20578 9.04038 5.45963L10.5404 6.95963C10.7942 7.21347 11.2058 7.21347 11.4596 6.95963L14.4596 3.95963Z", fill: "currentColor" })] });
FilterOn16.displayName = "FilterOn16";
const Memo$2s = reactExports.memo(FilterOn16);
const Locate16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_4764_28837)", children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 12C10.2091 12 12 10.2091 12 8C12 5.79086 10.2091 4 8 4C5.79086 4 4 5.79086 4 8C4 10.2091 5.79086 12 8 12ZM8 13C10.7614 13 13 10.7614 13 8C13 5.23858 10.7614 3 8 3C5.23858 3 3 5.23858 3 8C3 10.7614 5.23858 13 8 13Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 7C8.55228 7 9 7.44772 9 8C9 8.55228 8.55228 9 8 9C7.44772 9 7 8.55228 7 8C7 7.44772 7.44772 7 8 7ZM8 6C9.10457 6 10 6.89543 10 8C10 9.10457 9.10457 10 8 10C6.89543 10 6 9.10457 6 8C6 6.89543 6.89543 6 8 6Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 0.5C8.27614 0.5 8.5 0.723858 8.5 1V3.1738C8.5 3.44994 8.27614 3.6738 8 3.6738C7.72386 3.6738 7.5 3.44994 7.5 3.1738V1C7.5 0.723858 7.72386 0.5 8 0.5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.5 8C15.5 8.27614 15.2761 8.5 15 8.5H13C12.7239 8.5 12.5 8.27614 12.5 8C12.5 7.72386 12.7239 7.5 13 7.5H15C15.2761 7.5 15.5 7.72386 15.5 8Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 12.5C8.27614 12.5 8.5 12.7239 8.5 13V15C8.5 15.2761 8.27614 15.5 8 15.5C7.72386 15.5 7.5 15.2761 7.5 15V13C7.5 12.7239 7.72386 12.5 8 12.5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.5 8C3.5 8.27614 3.27614 8.5 3 8.5H1C0.723858 8.5 0.5 8.27614 0.5 8C0.5 7.72386 0.723858 7.5 1 7.5H3C3.27614 7.5 3.5 7.72386 3.5 8Z", fill: "currentColor" })] }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "clip0_4764_28837", children: jsxRuntimeExports.jsx("rect", { width: 16, height: 16, fill: "white" }) }) })] });
Locate16.displayName = "Locate16";
const Memo$2r = reactExports.memo(Locate16);
const CornerUpRight16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.64645 3.31312C9.84171 3.11786 10.1583 3.11786 10.3536 3.31312L13.6869 6.64645C13.8821 6.84171 13.8821 7.1583 13.6869 7.35356L10.3536 10.6869C10.1583 10.8822 9.84171 10.8822 9.64645 10.6869C9.45118 10.4916 9.45118 10.175 9.64645 9.97978L12.6262 7L9.64645 4.02023C9.45118 3.82496 9.45118 3.50838 9.64645 3.31312Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.33333 7.5C4.75869 7.5 4.20759 7.72827 3.80127 8.1346C3.39494 8.54093 3.16666 9.09203 3.16666 9.66667V12.3333C3.16666 12.6095 2.94281 12.8333 2.66666 12.8333C2.39052 12.8333 2.16666 12.6095 2.16666 12.3333V9.66667C2.16666 8.82681 2.50029 8.02136 3.09416 7.4275C3.68802 6.83363 4.49348 6.5 5.33333 6.5H13.3333C13.6095 6.5 13.8333 6.72386 13.8333 7C13.8333 7.27614 13.6095 7.5 13.3333 7.5H5.33333Z", fill: "currentColor" })] });
CornerUpRight16.displayName = "CornerUpRight16";
const Memo$2q = reactExports.memo(CornerUpRight16);
const SetArea16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.5 2.5C3.23478 2.5 2.98043 2.60536 2.79289 2.79289C2.60536 2.98043 2.5 3.23478 2.5 3.5V5.75C2.5 6.02614 2.27614 6.25 2 6.25C1.72386 6.25 1.5 6.02614 1.5 5.75V3.5C1.5 2.96957 1.71071 2.46086 2.08579 2.08579C2.46086 1.71071 2.96957 1.5 3.5 1.5H5.75C6.02614 1.5 6.25 1.72386 6.25 2C6.25 2.27614 6.02614 2.5 5.75 2.5H3.5ZM9.75 2C9.75 1.72386 9.97386 1.5 10.25 1.5H12.5C13.0304 1.5 13.5391 1.71071 13.9142 2.08579C14.2893 2.46086 14.5 2.96957 14.5 3.5V5.75C14.5 6.02614 14.2761 6.25 14 6.25C13.7239 6.25 13.5 6.02614 13.5 5.75V3.5C13.5 3.23478 13.3946 2.98043 13.2071 2.79289C13.0196 2.60536 12.7652 2.5 12.5 2.5H10.25C9.97386 2.5 9.75 2.27614 9.75 2ZM2 9.75C2.27614 9.75 2.5 9.97386 2.5 10.25V12.5C2.5 12.7652 2.60536 13.0196 2.79289 13.2071C2.98043 13.3946 3.23478 13.5 3.5 13.5H5.75C6.02614 13.5 6.25 13.7239 6.25 14C6.25 14.2761 6.02614 14.5 5.75 14.5H3.5C2.96957 14.5 2.46086 14.2893 2.08579 13.9142C1.71071 13.5391 1.5 13.0304 1.5 12.5V10.25C1.5 9.97386 1.72386 9.75 2 9.75ZM14 9.75C14.2761 9.75 14.5 9.97386 14.5 10.25V12.5C14.5 13.0304 14.2893 13.5391 13.9142 13.9142C13.5391 14.2893 13.0304 14.5 12.5 14.5H10.25C9.97386 14.5 9.75 14.2761 9.75 14C9.75 13.7239 9.97386 13.5 10.25 13.5H12.5C12.7652 13.5 13.0196 13.3946 13.2071 13.2071C13.3946 13.0196 13.5 12.7652 13.5 12.5V10.25C13.5 9.97386 13.7239 9.75 14 9.75Z", fill: "currentColor" }) });
SetArea16.displayName = "SetArea16";
const Memo$2p = reactExports.memo(SetArea16);
const Update16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.21968 3.67655C8.50552 3.4661 7.75089 3.44341 7.02592 3.61053C6.30092 3.77765 5.62837 4.12936 5.07132 4.63377C4.51421 5.13823 4.09077 5.77906 3.84141 6.49695C3.75081 6.75781 3.46589 6.89582 3.20504 6.80521C2.94418 6.71461 2.80617 6.42969 2.89677 6.16884C3.20069 5.29385 3.71757 4.51055 4.4001 3.89251C5.08269 3.27442 5.90868 2.84184 6.8013 2.63608C7.69396 2.43031 8.62331 2.4583 9.50235 2.71734C10.3788 2.97561 11.176 3.45494 11.8204 4.10985L13.5 5.71777V4C13.5 3.72386 13.7239 3.5 14 3.5C14.2761 3.5 14.5 3.72386 14.5 4V6.88778C14.5 6.88837 14.5 6.88896 14.5 6.88955V7C14.5 7.27614 14.2761 7.5 14 7.5H11C10.7239 7.5 10.5 7.27614 10.5 7C10.5 6.72386 10.7239 6.5 11 6.5H12.871L11.1233 4.82692L11.1122 4.8159C10.5851 4.27866 9.93389 3.88702 9.21968 3.67655ZM1.5 9C1.5 8.72386 1.72386 8.5 2 8.5H5C5.27614 8.5 5.5 8.72386 5.5 9C5.5 9.27614 5.27614 9.5 5 9.5H3.12897L4.87667 11.1731L4.88783 11.1841C5.41489 11.7213 6.06611 12.113 6.78032 12.3234C7.49448 12.5339 8.24911 12.5566 8.97408 12.3895C9.69908 12.2223 10.3716 11.8706 10.9287 11.3662C11.4858 10.8618 11.9092 10.2209 12.1586 9.50305C12.2492 9.24219 12.5341 9.10418 12.795 9.19479C13.0558 9.28539 13.1938 9.57031 13.1032 9.83116C12.7993 10.7061 12.2824 11.4895 11.5999 12.1075C10.9173 12.7256 10.0913 13.1582 9.1987 13.3639C8.30605 13.5697 7.3767 13.5417 6.49765 13.2827C5.62121 13.0244 4.82403 12.5451 4.17963 11.8902L2.5 10.2822V12C2.5 12.2761 2.27614 12.5 2 12.5C1.72386 12.5 1.5 12.2761 1.5 12V9.1122C1.5 9.11162 1.5 9.11105 1.5 9.11047V9Z", fill: "currentColor" }) });
Update16.displayName = "Update16";
const Memo$2o = reactExports.memo(Update16);
const CornerUpLeft16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.35355 3.31312C6.54881 3.50838 6.54881 3.82496 6.35355 4.02023L3.37377 7L6.35355 9.97978C6.54881 10.175 6.54881 10.4916 6.35355 10.6869C6.15829 10.8822 5.84171 10.8822 5.64644 10.6869L2.31311 7.35356C2.11785 7.1583 2.11785 6.84171 2.31311 6.64645L5.64644 3.31312C5.84171 3.11786 6.15829 3.11786 6.35355 3.31312Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.16666 7C2.16666 6.72386 2.39052 6.5 2.66666 6.5H10.6667C11.5065 6.5 12.312 6.83363 12.9058 7.4275C13.4997 8.02136 13.8333 8.82681 13.8333 9.66667V12.3333C13.8333 12.6095 13.6095 12.8333 13.3333 12.8333C13.0572 12.8333 12.8333 12.6095 12.8333 12.3333V9.66667C12.8333 9.09203 12.6051 8.54093 12.1987 8.1346C11.7924 7.72827 11.2413 7.5 10.6667 7.5H2.66666C2.39052 7.5 2.16666 7.27614 2.16666 7Z", fill: "currentColor" })] });
CornerUpLeft16.displayName = "CornerUpLeft16";
const Memo$2n = reactExports.memo(CornerUpLeft16);
const Plus24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3.35001C12.359 3.35001 12.65 3.64102 12.65 4.00001V11.35L19.9999 11.35C20.3589 11.35 20.6499 11.641 20.6499 12C20.6499 12.359 20.3589 12.65 19.9999 12.65L12.65 12.65V20C12.65 20.359 12.359 20.65 12 20.65C11.641 20.65 11.35 20.359 11.35 20V12.65L3.99991 12.65C3.64093 12.65 3.34991 12.359 3.34991 12C3.34991 11.641 3.64093 11.35 3.99991 11.35L11.35 11.35L11.35 4.00001C11.35 3.64102 11.641 3.35001 12 3.35001Z", fill: "currentColor" }) });
Plus24.displayName = "Plus24";
const Memo$2m = reactExports.memo(Plus24);
const Plus16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 2.16667C8.27614 2.16667 8.5 2.39053 8.5 2.66667L8.5 7.5L13.3332 7.5C13.6093 7.5 13.8332 7.72386 13.8332 8C13.8332 8.27614 13.6093 8.5 13.3332 8.5L8.5 8.5L8.5 13.3333C8.5 13.6095 8.27614 13.8333 8 13.8333C7.72386 13.8333 7.5 13.6095 7.5 13.3333L7.5 8.5L2.6665 8.5C2.39036 8.5 2.1665 8.27614 2.1665 8C2.1665 7.72386 2.39036 7.5 2.6665 7.5L7.5 7.5L7.5 2.66667C7.5 2.39053 7.72386 2.16667 8 2.16667Z", fill: "currentColor" }) });
Plus16.displayName = "Plus16";
const Memo$2l = reactExports.memo(Plus16);
const BookOpen24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.35001 4.00001C2.35001 3.64102 2.64102 3.35001 3.00001 3.35001H8.40001C9.52459 3.35001 10.6047 3.79115 11.4023 4.57894C11.6309 4.80471 11.831 5.05367 12 5.32028C12.1691 5.05367 12.3691 4.80471 12.5977 4.57894C13.3953 3.79115 14.4754 3.35001 15.6 3.35001H21C21.359 3.35001 21.65 3.64102 21.65 4.00001V17.3333C21.65 17.6923 21.359 17.9833 21 17.9833H14.7C14.1537 17.9833 13.6314 18.1977 13.2476 18.5769C12.864 18.9557 12.65 19.4678 12.65 20C12.65 20.359 12.359 20.65 12 20.65C11.641 20.65 11.35 20.359 11.35 20C11.35 19.4678 11.136 18.9557 10.7524 18.5769C10.3686 18.1977 9.84629 17.9833 9.30001 17.9833H3.00001C2.64102 17.9833 2.35001 17.6923 2.35001 17.3333V4.00001ZM11.35 17.3768C10.7656 16.9292 10.0451 16.6833 9.30001 16.6833H3.65001V4.65001H8.40001C9.18498 4.65001 9.9362 4.95806 10.4888 5.50387C11.0412 6.04941 11.35 6.78758 11.35 7.55556V17.3768ZM12.65 17.3768C13.2344 16.9292 13.9549 16.6833 14.7 16.6833H20.35V4.65001H15.6C14.815 4.65001 14.0638 4.95806 13.5112 5.50387C12.9588 6.04941 12.65 6.78758 12.65 7.55556V17.3768Z", fill: "currentColor" }) });
BookOpen24.displayName = "BookOpen24";
const Memo$2k = reactExports.memo(BookOpen24);
const Download24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3.492C12.359 3.492 12.65 3.78302 12.65 4.142V12.9463L15.5559 10.0404C15.8098 9.78658 16.2213 9.78658 16.4752 10.0404C16.729 10.2943 16.729 10.7058 16.4751 10.9597L12.4597 14.9751C12.2058 15.229 11.7943 15.229 11.5404 14.9751L7.52495 10.9597C7.27111 10.7058 7.27111 10.2943 7.52495 10.0404C7.77879 9.78658 8.19035 9.78658 8.44419 10.0404L11.35 12.9463V4.142C11.35 3.78302 11.641 3.492 12 3.492ZM3.98616 13.4203C4.34514 13.4203 4.63616 13.7113 4.63616 14.0703V18.858C4.63616 19.0513 4.79286 19.208 4.98616 19.208H19.0139C19.2072 19.208 19.3639 19.0513 19.3639 18.858V14.0703C19.3639 13.7113 19.6549 13.4203 20.0139 13.4203C20.3729 13.4203 20.6639 13.7113 20.6639 14.0703V18.858C20.6639 19.7693 19.9251 20.508 19.0139 20.508H4.98616C4.07489 20.508 3.33616 19.7693 3.33616 18.858V14.0703C3.33616 13.7113 3.62717 13.4203 3.98616 13.4203Z", fill: "currentColor" }) });
Download24.displayName = "Download24";
const Memo$2j = reactExports.memo(Download24);
const Download16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.49997 2.76132C8.49997 2.48518 8.27612 2.26132 7.99997 2.26132C7.72383 2.26132 7.49997 2.48518 7.49997 2.76132V8.46989L5.67655 6.64646C5.48129 6.45119 5.16471 6.45119 4.96945 6.64646C4.77418 6.84172 4.77418 7.1583 4.96944 7.35356L7.64642 10.0305C7.84168 10.2258 8.15826 10.2258 8.35353 10.0306L11.0305 7.35356C11.2258 7.1583 11.2258 6.84172 11.0305 6.64646C10.8353 6.45119 10.5187 6.45119 10.3234 6.64646L8.49997 8.46989V2.76132ZM3.15723 9.38017C3.15723 9.10403 2.93337 8.88017 2.65723 8.88017C2.38108 8.88017 2.15723 9.10403 2.15723 9.38017V12.2387C2.15723 13.0671 2.8288 13.7387 3.65723 13.7387H12.3424C13.1708 13.7387 13.8424 13.0671 13.8424 12.2387V9.38017C13.8424 9.10403 13.6185 8.88017 13.3424 8.88017C13.0662 8.88017 12.8424 9.10403 12.8424 9.38017V12.2387C12.8424 12.5148 12.6185 12.7387 12.3424 12.7387H3.65723C3.38108 12.7387 3.15723 12.5148 3.15723 12.2387V9.38017Z", fill: "currentColor" }) });
Download16.displayName = "Download16";
const Memo$2i = reactExports.memo(Download16);
const Upload16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.49997 9.677C8.49997 9.95314 8.27612 10.177 7.99997 10.177C7.72383 10.177 7.49997 9.95314 7.49997 9.677V3.96843L5.67655 5.79186C5.48129 5.98712 5.16471 5.98712 4.96945 5.79186C4.77418 5.5966 4.77418 5.28002 4.96944 5.08476L7.64642 2.40777C7.84168 2.21251 8.15826 2.21251 8.35353 2.40777L11.0305 5.08475C11.2258 5.28002 11.2258 5.5966 11.0305 5.79186C10.8353 5.98712 10.5187 5.98712 10.3234 5.79186L8.49997 3.96843V9.677ZM3.15723 9.38017C3.15723 9.10403 2.93337 8.88017 2.65723 8.88017C2.38108 8.88017 2.15723 9.10403 2.15723 9.38017V12.2387C2.15723 13.0671 2.8288 13.7387 3.65723 13.7387H12.3424C13.1708 13.7387 13.8424 13.0671 13.8424 12.2387V9.38017C13.8424 9.10403 13.6185 8.88017 13.3424 8.88017C13.0662 8.88017 12.8424 9.10403 12.8424 9.38017V12.2387C12.8424 12.5148 12.6185 12.7387 12.3424 12.7387H3.65723C3.38108 12.7387 3.15723 12.5148 3.15723 12.2387V9.38017Z", fill: "currentColor" }) });
Upload16.displayName = "Upload16";
const Memo$2h = reactExports.memo(Upload16);
const PointOutline24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.1472 4.65001C9.11118 4.65001 6.65 7.11119 6.65 10.1472C6.65 12.4236 7.97949 14.6899 9.44336 16.442C10.1656 17.3064 10.8982 18.019 11.4673 18.5125C11.7443 18.7526 11.9774 18.9364 12.1472 19.0586C12.317 18.9364 12.5502 18.7526 12.8271 18.5125C13.3962 18.019 14.1289 17.3064 14.8511 16.442C16.3149 14.6899 17.6444 12.4236 17.6444 10.1472C17.6444 7.11119 15.1832 4.65001 12.1472 4.65001ZM5.35 10.1472C5.35 6.39322 8.39321 3.35001 12.1472 3.35001C15.9012 3.35001 18.9444 6.39322 18.9444 10.1472C18.9444 12.888 17.3724 15.4518 15.8487 17.2755C15.0771 18.199 14.2945 18.9608 13.6787 19.4947C13.3713 19.7613 13.1 19.9757 12.8878 20.1272C12.7828 20.2021 12.6836 20.2679 12.5964 20.3179C12.5536 20.3424 12.5029 20.3695 12.4489 20.3924L12.4472 20.3931C12.4141 20.4072 12.2958 20.4575 12.1472 20.4575C11.9987 20.4575 11.8803 20.4072 11.8472 20.3931L11.8455 20.3924C11.7916 20.3695 11.7408 20.3424 11.698 20.3179C11.6108 20.2679 11.5116 20.2021 11.4067 20.1272C11.1944 19.9757 10.9232 19.7613 10.6157 19.4947C9.99994 18.9608 9.2173 18.199 8.44573 17.2755C6.92203 15.4518 5.35 12.888 5.35 10.1472Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M13.6472 9.90375C13.6472 10.7322 12.9756 11.4038 12.1472 11.4038C11.3188 11.4038 10.6472 10.7322 10.6472 9.90375C10.6472 9.07533 11.3188 8.40375 12.1472 8.40375C12.9756 8.40375 13.6472 9.07533 13.6472 9.90375Z", fill: "currentColor" })] });
PointOutline24.displayName = "PointOutline24";
const Memo$2g = reactExports.memo(PointOutline24);
const PointOutline16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.09814 3.16666C6.11094 3.16666 4.5 4.7776 4.5 6.7648C4.5 8.25857 5.37389 9.7542 6.34673 10.9186C6.82567 11.4918 7.31155 11.9644 7.68856 12.2913C7.85152 12.4326 7.99107 12.544 8.09814 12.6232C8.20521 12.544 8.34476 12.4326 8.50772 12.2913C8.88474 11.9644 9.37061 11.4918 9.84955 10.9186C10.8224 9.7542 11.6963 8.25857 11.6963 6.7648C11.6963 4.7776 10.0853 3.16666 8.09814 3.16666ZM3.5 6.7648C3.5 4.22532 5.55866 2.16666 8.09814 2.16666C10.6376 2.16666 12.6963 4.22532 12.6963 6.7648C12.6963 8.61583 11.6358 10.3403 10.617 11.5598C10.1 12.1785 9.57572 12.6888 9.16282 13.0468C8.9567 13.2255 8.77421 13.3699 8.63057 13.4724C8.55967 13.523 8.49154 13.5682 8.4308 13.6031C8.40102 13.6202 8.36464 13.6396 8.32532 13.6563L8.32382 13.6569C8.29999 13.6671 8.21087 13.705 8.09814 13.705C7.98541 13.705 7.89629 13.6671 7.87247 13.6569L7.87096 13.6563C7.83165 13.6396 7.79527 13.6202 7.76549 13.6031C7.70474 13.5682 7.63662 13.523 7.56571 13.4724C7.42207 13.3699 7.23958 13.2255 7.03346 13.0468C6.62056 12.6888 6.09624 12.1785 5.57933 11.5598C4.56046 10.3403 3.5 8.61583 3.5 6.7648Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M9.09814 6.60249C9.09814 7.15477 8.65043 7.60249 8.09814 7.60249C7.54586 7.60249 7.09814 7.15477 7.09814 6.60249C7.09814 6.0502 7.54586 5.60249 8.09814 5.60249C8.65043 5.60249 9.09814 6.0502 9.09814 6.60249Z", fill: "currentColor" })] });
PointOutline16.displayName = "PointOutline16";
const Memo$2f = reactExports.memo(PointOutline16);
const PointFilled24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 22C12.4479 22 20 16.1255 20 9.77761C20 5.48216 16.4183 2 12 2C7.58172 2 4 5.48216 4 9.77761C4 16.1255 11.5521 22 12 22ZM12 12C13.1046 12 14 11.1046 14 10C14 8.89543 13.1046 8 12 8C10.8954 8 10 8.89543 10 10C10 11.1046 10.8954 12 12 12Z", fill: "currentColor" }) });
PointFilled24.displayName = "PointFilled24";
const Memo$2e = reactExports.memo(PointFilled24);
const StartLoc = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("circle", { cx: 12, cy: 12, r: 8, fill: "currentColor", stroke: "white", strokeWidth: 1.3, strokeLinecap: "square", strokeLinejoin: "bevel" }) });
StartLoc.displayName = "StartLoc";
const Memo$2d = reactExports.memo(StartLoc);
const Circle = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("circle", { cx: 12, cy: 12, r: 6, stroke: "currentColor", strokeWidth: 2, strokeLinecap: "square", strokeLinejoin: "bevel" }) });
Circle.displayName = "Circle";
const Memo$2c = reactExports.memo(Circle);
const PointFilled16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 14.6667C8.2986 14.6667 13.3333 10.7503 13.3333 6.5184C13.3333 3.65477 10.9455 1.33333 8 1.33333C5.05449 1.33333 2.66667 3.65477 2.66667 6.5184C2.66667 10.7503 7.70141 14.6667 8 14.6667ZM9.33334 6.66666C9.33334 7.40304 8.73638 7.99999 8 7.99999C7.26363 7.99999 6.66667 7.40304 6.66667 6.66666C6.66667 5.93028 7.26363 5.33333 8 5.33333C8.73638 5.33333 9.33334 5.93028 9.33334 6.66666Z", fill: "currentColor" }) });
PointFilled16.displayName = "PointFilled16";
const Memo$2b = reactExports.memo(PointFilled16);
const Line24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17.1326 6.8674C17.3864 7.12124 17.3864 7.5328 17.1326 7.78664L7.78664 17.1326C7.5328 17.3864 7.12124 17.3864 6.8674 17.1326C6.61356 16.8788 6.61356 16.4672 6.8674 16.2134L16.2134 6.8674C16.4672 6.61356 16.8788 6.61356 17.1326 6.8674Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.3 17.3V18.7H6.7V17.3H5.3ZM5 16C4.44772 16 4 16.4477 4 17V19C4 19.5523 4.44772 20 5 20H7C7.55228 20 8 19.5523 8 19V17C8 16.4477 7.55228 16 7 16H5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17.3 5.3V6.7H18.7V5.3H17.3ZM17 4C16.4477 4 16 4.44772 16 5V7C16 7.55228 16.4477 8 17 8H19C19.5523 8 20 7.55228 20 7V5C20 4.44772 19.5523 4 19 4H17Z", fill: "currentColor" })] });
Line24.displayName = "Line24";
const Memo$2a = reactExports.memo(Line24);
const Area24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.35 5.35H16.65V6.65H7.35V5.35ZM6.65 7.35V16.65H5.35V7.35H6.65ZM18.65 7.35V16.65H17.35V7.35H18.65ZM7.35 17.35H16.65V18.65H7.35V17.35Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.3 17.3V18.7H6.7V17.3H5.3ZM5.3 5.3V6.7H6.7V5.3H5.3ZM17.3 5.3V6.7H18.7V5.3H17.3ZM17.3 17.3V18.7H18.7V17.3H17.3ZM5 4C4.44772 4 4 4.44772 4 5V7C4 7.55228 4.44772 8 5 8H7C7.55228 8 8 7.55228 8 7V5C8 4.44772 7.55228 4 7 4H5ZM5 16C4.44772 16 4 16.4477 4 17V19C4 19.5523 4.44772 20 5 20H7C7.55228 20 8 19.5523 8 19V17C8 16.4477 7.55228 16 7 16H5ZM16 5C16 4.44772 16.4477 4 17 4H19C19.5523 4 20 4.44772 20 5V7C20 7.55228 19.5523 8 19 8H17C16.4477 8 16 7.55228 16 7V5ZM17 16C16.4477 16 16 16.4477 16 17V19C16 19.5523 16.4477 20 17 20H19C19.5523 20 20 19.5523 20 19V17C20 16.4477 19.5523 16 19 16H17Z", fill: "currentColor" })] });
Area24.displayName = "Area24";
const Memo$29 = reactExports.memo(Area24);
const EditLine24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.2076 2.54039C14.4615 2.28655 14.873 2.28655 15.1269 2.54039L20.0766 7.49013C20.1985 7.61203 20.267 7.77736 20.267 7.94975C20.267 8.12214 20.1985 8.28747 20.0766 8.40937L10.8842 17.6018C10.7623 17.7237 10.597 17.7921 10.4246 17.7921H5.47487C5.11589 17.7921 4.82487 17.5011 4.82487 17.1421V12.1924C4.82487 12.02 4.89336 11.8547 5.01526 11.7328L14.2076 2.54039ZM12.4045 6.18199L16.435 10.2125L18.6978 7.94975L14.6673 3.91925L12.4045 6.18199ZM15.5158 11.1317L11.4853 7.10123L6.12488 12.4616V16.4921H10.1554L15.5158 11.1317ZM3.84999 20.0586C3.84999 19.6997 4.14101 19.4086 4.49999 19.4086H21.8086C22.1676 19.4086 22.4586 19.6997 22.4586 20.0586C22.4586 20.4176 22.1676 20.7086 21.8086 20.7086H4.49999C4.14101 20.7086 3.84999 20.4176 3.84999 20.0586Z", fill: "currentColor" }) });
EditLine24.displayName = "EditLine24";
const Memo$28 = reactExports.memo(EditLine24);
const Poly24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.85472 1.69311C3.06244 1.56808 3.32248 1.56904 3.52926 1.69561L13.9276 8.06001L20.6736 6.61443C20.8884 6.56841 21.1119 6.63398 21.2678 6.78876C21.4237 6.94354 21.4908 7.16658 21.4463 7.3817L18.4463 21.8817C18.4091 22.0614 18.2977 22.2171 18.1395 22.3102C17.9813 22.4033 17.7911 22.4252 17.6159 22.3704L9.76865 19.9181L4.42609 20.8895C4.24339 20.9227 4.05522 20.8762 3.90903 20.7617C3.76284 20.6472 3.67259 20.4757 3.66106 20.2904L2.54119 2.29037C2.52614 2.04839 2.647 1.81815 2.85472 1.69311ZM3.91627 3.45665L4.91314 19.4797L9.69353 18.6105C9.79694 18.5917 9.90337 18.5982 10.0037 18.6296L17.3187 20.9155L19.9713 8.09444L13.946 9.38558C13.783 9.42052 13.6127 9.39146 13.4705 9.30441L3.91627 3.45665Z", fill: "currentColor" }) });
Poly24.displayName = "Poly24";
const Memo$27 = reactExports.memo(Poly24);
const Bi24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.35001 4.00001C3.35001 3.64102 3.64102 3.35001 4.00001 3.35001H10C10.359 3.35001 10.65 3.64102 10.65 4.00001V10C10.65 10.359 10.359 10.65 10 10.65H4.00001C3.64102 10.65 3.35001 10.359 3.35001 10V4.00001ZM4.65001 4.65001V9.35001H9.35001V4.65001H4.65001ZM13.35 4.00001C13.35 3.64102 13.641 3.35001 14 3.35001H20C20.359 3.35001 20.65 3.64102 20.65 4.00001V10C20.65 10.359 20.359 10.65 20 10.65H14C13.641 10.65 13.35 10.359 13.35 10V4.00001ZM14.65 4.65001V9.35001H19.35V4.65001H14.65ZM3.35001 14C3.35001 13.641 3.64102 13.35 4.00001 13.35H10C10.359 13.35 10.65 13.641 10.65 14V20C10.65 20.359 10.359 20.65 10 20.65H4.00001C3.64102 20.65 3.35001 20.359 3.35001 20V14ZM4.65001 14.65V19.35H9.35001V14.65H4.65001ZM13.35 14C13.35 13.641 13.641 13.35 14 13.35H20C20.359 13.35 20.65 13.641 20.65 14V20C20.65 20.359 20.359 20.65 20 20.65H14C13.641 20.65 13.35 20.359 13.35 20V14ZM14.65 14.65V19.35H19.35V14.65H14.65Z", fill: "currentColor" }) });
Bi24.displayName = "Bi24";
const Memo$26 = reactExports.memo(Bi24);
const SelectArea24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.2901 0.760469C11.6368 0.853381 11.8426 1.2098 11.7497 1.55655L10.8394 4.95392C10.7465 5.30067 10.3901 5.50645 10.0433 5.41354C9.69656 5.32063 9.49078 4.96421 9.58369 4.61745L10.494 1.22009C10.5869 0.873335 10.9433 0.667557 11.2901 0.760469ZM5.90388 1.46957C6.21477 1.29008 6.6123 1.39659 6.7918 1.70748L8.5504 4.75348C8.72989 5.06437 8.62337 5.4619 8.31248 5.6414C8.00159 5.82089 7.60406 5.71437 7.42457 5.40348L5.66596 2.35748C5.48647 2.04659 5.59299 1.64906 5.90388 1.46957ZM15.6001 4.06768C15.7796 4.37857 15.6731 4.7761 15.3622 4.95559L12.3162 6.7142C12.0053 6.89369 11.6078 6.78717 11.4283 6.47628C11.2488 6.16539 11.3553 5.76786 11.6662 5.58837L14.7122 3.82976C15.0231 3.65027 15.4206 3.75679 15.6001 4.06768ZM2.59651 5.77965C2.68943 5.4329 3.04584 5.22712 3.3926 5.32003L6.78996 6.23035C7.13672 6.32327 7.3425 6.67968 7.24958 7.02644C7.15667 7.37319 6.80025 7.57897 6.4535 7.48606L3.05613 6.57574C2.70938 6.48282 2.5036 6.1264 2.59651 5.77965ZM9.72242 8.04472C9.95232 7.91198 10.2398 7.93239 10.4487 8.09628L19.7572 15.4008C19.9621 15.5616 20.0512 15.8292 19.9837 16.0807C19.9161 16.3323 19.7049 16.5192 19.4471 16.5558L14.9999 17.1855L12.2309 20.722C12.0703 20.9271 11.8028 21.0165 11.5512 20.9492C11.2996 20.882 11.1124 20.671 11.0756 20.4131L9.40394 8.69946C9.36643 8.43666 9.49252 8.17745 9.72242 8.04472ZM10.9196 10.1183L12.1472 18.7202L14.1377 16.178C14.2413 16.0457 14.392 15.9586 14.5584 15.9351L17.7553 15.4824L10.9196 10.1183ZM7.47746 8.7573C7.65696 9.06819 7.55044 9.46572 7.23955 9.64521L4.19355 11.4038C3.88266 11.5833 3.48513 11.4768 3.30563 11.1659C3.12614 10.855 3.23266 10.4575 3.54355 10.278L6.58955 8.51938C6.90044 8.33989 7.29797 8.44641 7.47746 8.7573Z", fill: "currentColor" }) });
SelectArea24.displayName = "SelectArea24";
const Memo$25 = reactExports.memo(SelectArea24);
const Ruler24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.63636 3.35001C7.80875 3.35001 7.97408 3.41849 8.09598 3.54039L20.4596 15.904C20.7135 16.1579 20.7135 16.5694 20.4596 16.8233L16.8233 20.4596C16.5694 20.7135 16.1579 20.7135 15.904 20.4596L3.54038 8.09599C3.41848 7.97409 3.35 7.80876 3.35 7.63637C3.35 7.46398 3.41848 7.29865 3.54038 7.17675L7.17674 3.54039C7.29864 3.41849 7.46397 3.35001 7.63636 3.35001ZM4.91924 7.63637L6.68543 9.40256L8.13517 8.02828C8.3957 7.78131 8.80711 7.7923 9.05408 8.05283C9.30105 8.31336 9.29006 8.72477 9.02953 8.97174L7.605 10.3221L9.89392 12.611L11.3568 11.2243C11.6173 10.9773 12.0287 10.9883 12.2757 11.2489C12.5227 11.5094 12.5117 11.9208 12.2511 12.1678L10.8135 13.5306L13.1854 15.9026L14.6352 14.5283C14.8957 14.2813 15.3071 14.2923 15.5541 14.5528C15.8011 14.8134 15.7901 15.2248 15.5295 15.4717L14.105 16.8221L16.3636 19.0808L19.0808 16.3636L7.63636 4.91924L4.91924 7.63637Z", fill: "currentColor" }) });
Ruler24.displayName = "Ruler24";
const Memo$24 = reactExports.memo(Ruler24);
const Close24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.54039 5.54039C5.79423 5.28655 6.20578 5.28655 6.45963 5.54039L12 11.0808L17.5404 5.54039C17.7942 5.28655 18.2058 5.28655 18.4596 5.54039C18.7135 5.79423 18.7135 6.20578 18.4596 6.45963L12.9192 12L18.4596 17.5404C18.7135 17.7942 18.7135 18.2058 18.4596 18.4596C18.2058 18.7135 17.7942 18.7135 17.5404 18.4596L12 12.9192L6.45963 18.4596C6.20578 18.7135 5.79423 18.7135 5.54039 18.4596C5.28655 18.2058 5.28655 17.7942 5.54039 17.5404L11.0808 12L5.54039 6.45963C5.28655 6.20578 5.28655 5.79423 5.54039 5.54039Z", fill: "currentColor" }) });
Close24.displayName = "Close24";
const Memo$23 = reactExports.memo(Close24);
const Close16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.64645 2.64645C2.84171 2.45118 3.15829 2.45118 3.35355 2.64645L13.3536 12.6464C13.5488 12.8417 13.5488 13.1583 13.3536 13.3536C13.1583 13.5488 12.8417 13.5488 12.6464 13.3536L2.64645 3.35355C2.45118 3.15829 2.45118 2.84171 2.64645 2.64645Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.3536 2.64645C13.1583 2.45118 12.8417 2.45118 12.6464 2.64645L2.64645 12.6464C2.45118 12.8417 2.45118 13.1583 2.64645 13.3536C2.84171 13.5488 3.15829 13.5488 3.35355 13.3536L13.3536 3.35355C13.5488 3.15829 13.5488 2.84171 13.3536 2.64645Z", fill: "currentColor" })] });
Close16.displayName = "Close16";
const Memo$22 = reactExports.memo(Close16);
const ChevronDown24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.54039 8.54039C5.79423 8.28655 6.20578 8.28655 6.45963 8.54039L12 14.0808L17.5404 8.54039C17.7942 8.28655 18.2058 8.28655 18.4596 8.54039C18.7135 8.79423 18.7135 9.20578 18.4596 9.45963L12.4596 15.4596C12.2058 15.7135 11.7942 15.7135 11.5404 15.4596L5.54039 9.45963C5.28655 9.20578 5.28655 8.79423 5.54039 8.54039Z", fill: "currentColor" }) });
ChevronDown24.displayName = "ChevronDown24";
const Memo$21 = reactExports.memo(ChevronDown24);
const ChevronDown16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.64645 5.64645C2.84171 5.45118 3.15829 5.45118 3.35355 5.64645L8 10.2929L12.6464 5.64645C12.8417 5.45118 13.1583 5.45118 13.3536 5.64645C13.5488 5.84171 13.5488 6.15829 13.3536 6.35355L8.35355 11.3536C8.15829 11.5488 7.84171 11.5488 7.64645 11.3536L2.64645 6.35355C2.45118 6.15829 2.45118 5.84171 2.64645 5.64645Z", fill: "currentColor" }) });
ChevronDown16.displayName = "ChevronDown16";
const Memo$20 = reactExports.memo(ChevronDown16);
const ChevronUp24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.54039 15.4596C5.79423 15.7135 6.20578 15.7135 6.45963 15.4596L12 9.91923L17.5404 15.4596C17.7942 15.7135 18.2058 15.7135 18.4596 15.4596C18.7135 15.2058 18.7135 14.7942 18.4596 14.5404L12.4596 8.54037C12.2058 8.28653 11.7942 8.28653 11.5404 8.54037L5.54039 14.5404C5.28655 14.7942 5.28655 15.2058 5.54039 15.4596Z", fill: "currentColor" }) });
ChevronUp24.displayName = "ChevronUp24";
const Memo$1$ = reactExports.memo(ChevronUp24);
const ChevronUp16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.64645 11.3536C2.84171 11.5488 3.15829 11.5488 3.35355 11.3536L8 6.70711L12.6464 11.3536C12.8417 11.5488 13.1583 11.5488 13.3536 11.3536C13.5488 11.1583 13.5488 10.8417 13.3536 10.6464L8.35355 5.64645C8.15829 5.45118 7.84171 5.45118 7.64645 5.64645L2.64645 10.6464C2.45118 10.8417 2.45118 11.1583 2.64645 11.3536Z", fill: "currentColor" }) });
ChevronUp16.displayName = "ChevronUp16";
const Memo$1_ = reactExports.memo(ChevronUp16);
const ChevronLeft24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.4596 5.54039C15.7135 5.79423 15.7135 6.20578 15.4596 6.45963L9.91924 12L15.4596 17.5404C15.7135 17.7942 15.7135 18.2058 15.4596 18.4596C15.2058 18.7135 14.7942 18.7135 14.5404 18.4596L8.54038 12.4596C8.28654 12.2058 8.28654 11.7942 8.54038 11.5404L14.5404 5.54039C14.7942 5.28655 15.2058 5.28655 15.4596 5.54039Z", fill: "currentColor" }) });
ChevronLeft24.displayName = "ChevronLeft24";
const Memo$1Z = reactExports.memo(ChevronLeft24);
const ChevronLeft16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.3536 3.64645C10.5488 3.84171 10.5488 4.15829 10.3536 4.35355L6.70711 8L10.3536 11.6464C10.5488 11.8417 10.5488 12.1583 10.3536 12.3536C10.1583 12.5488 9.84171 12.5488 9.64645 12.3536L5.64645 8.35355C5.45118 8.15829 5.45118 7.84171 5.64645 7.64645L9.64645 3.64645C9.84171 3.45118 10.1583 3.45118 10.3536 3.64645Z", fill: "currentColor" }) });
ChevronLeft16.displayName = "ChevronLeft16";
const Memo$1Y = reactExports.memo(ChevronLeft16);
const ChevronRight24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.54038 5.54039C8.79422 5.28655 9.20578 5.28655 9.45962 5.54039L15.4596 11.5404C15.7135 11.7942 15.7135 12.2058 15.4596 12.4596L9.45962 18.4596C9.20578 18.7135 8.79422 18.7135 8.54038 18.4596C8.28654 18.2058 8.28654 17.7942 8.54038 17.5404L14.0808 12L8.54038 6.45963C8.28654 6.20578 8.28654 5.79423 8.54038 5.54039Z", fill: "currentColor" }) });
ChevronRight24.displayName = "ChevronRight24";
const Memo$1X = reactExports.memo(ChevronRight24);
const ChevronRight16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.64645 3.64645C5.84171 3.45118 6.15829 3.45118 6.35355 3.64645L10.3536 7.64645C10.5488 7.84171 10.5488 8.15829 10.3536 8.35355L6.35355 12.3536C6.15829 12.5488 5.84171 12.5488 5.64645 12.3536C5.45118 12.1583 5.45118 11.8417 5.64645 11.6464L9.29289 8L5.64645 4.35355C5.45119 4.15829 5.45119 3.84171 5.64645 3.64645Z", fill: "currentColor" }) });
ChevronRight16.displayName = "ChevronRight16";
const Memo$1W = reactExports.memo(ChevronRight16);
const TriangleDown16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { d: "M3 5L8 11L13 5", fill: "currentColor" }) });
TriangleDown16.displayName = "TriangleDown16";
const Memo$1V = reactExports.memo(TriangleDown16);
const TriangleUp16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { d: "M13 11L8 5L3 11", fill: "currentColor" }) });
TriangleUp16.displayName = "TriangleUp16";
const Memo$1U = reactExports.memo(TriangleUp16);
const ArrowLeft16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.0203 4.47009C7.82504 4.27483 7.50846 4.27483 7.31319 4.47009L4.13683 7.64646C4.04306 7.74022 3.99038 7.8674 3.99038 8.00001C3.99038 8.13262 4.04306 8.2598 4.13683 8.35356L7.31319 11.5299C7.50846 11.7252 7.82504 11.7252 8.0203 11.5299C8.21556 11.3347 8.21556 11.0181 8.0203 10.8228L5.69749 8.50001L11.5096 8.50002C11.7858 8.50002 12.0096 8.27616 12.0096 8.00002C12.0096 7.72388 11.7858 7.50002 11.5096 7.50002L5.69749 7.50001L8.0203 5.1772C8.21556 4.98194 8.21556 4.66535 8.0203 4.47009Z", fill: "currentColor" }) });
ArrowLeft16.displayName = "ArrowLeft16";
const Memo$1T = reactExports.memo(ArrowLeft16);
const ArrowRight16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.97956 4.47009C8.17482 4.27483 8.4914 4.27483 8.68666 4.47009L11.863 7.64646C12.0583 7.84172 12.0583 8.1583 11.863 8.35356L8.68666 11.5299C8.4914 11.7252 8.17482 11.7252 7.97956 11.5299C7.7843 11.3347 7.7843 11.0181 7.97956 10.8228L10.3024 8.50001L4.49023 8.50002C4.21409 8.50002 3.99023 8.27616 3.99023 8.00002C3.99023 7.72388 4.21409 7.50002 4.49023 7.50002L10.3024 7.50001L7.97956 5.1772C7.7843 4.98194 7.7843 4.66536 7.97956 4.47009Z", fill: "currentColor" }) });
ArrowRight16.displayName = "ArrowRight16";
const Memo$1S = reactExports.memo(ArrowRight16);
const DollarCircle16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.99792 8.00001C2.99792 5.23743 5.23743 2.99792 8.00001 2.99792C10.7626 2.99792 13.0021 5.23743 13.0021 8.00001C13.0021 10.7626 10.7626 13.0021 8.00001 13.0021C5.23743 13.0021 2.99792 10.7626 2.99792 8.00001ZM8.00001 1.99792C4.68515 1.99792 1.99792 4.68515 1.99792 8.00001C1.99792 11.3149 4.68515 14.0021 8.00001 14.0021C11.3149 14.0021 14.0021 11.3149 14.0021 8.00001C14.0021 4.68515 11.3149 1.99792 8.00001 1.99792ZM8.50001 4.69875C8.50001 4.42261 8.27615 4.19875 8.00001 4.19875C7.72386 4.19875 7.50001 4.42261 7.50001 4.69875V5.29917H7.4498C6.56591 5.29917 5.84938 6.0157 5.84938 6.89959C5.84938 7.78347 6.56591 8.50001 7.4498 8.50001H8.55021C8.88181 8.50001 9.15063 8.76882 9.15063 9.10042C9.15063 9.43202 8.88181 9.70084 8.55021 9.70084H8.0007C8.00047 9.70084 8.00024 9.70084 8.00001 9.70084C7.99977 9.70084 7.99954 9.70084 7.99931 9.70084H6.34938C6.07324 9.70084 5.84938 9.9247 5.84938 10.2008C5.84938 10.477 6.07324 10.7008 6.34938 10.7008H7.50001V11.3013C7.50001 11.5774 7.72386 11.8013 8.00001 11.8013C8.27615 11.8013 8.50001 11.5774 8.50001 11.3013V10.7008H8.55021C9.4341 10.7008 10.1506 9.98431 10.1506 9.10042C10.1506 8.21654 9.4341 7.50001 8.55021 7.50001H7.4498C7.1182 7.50001 6.84938 7.23119 6.84938 6.89959C6.84938 6.56799 7.1182 6.29917 7.4498 6.29917H9.65063C9.92677 6.29917 10.1506 6.07532 10.1506 5.79917C10.1506 5.52303 9.92677 5.29917 9.65063 5.29917H8.50001V4.69875Z", fill: "currentColor" }) });
DollarCircle16.displayName = "DollarCircle16";
const Memo$1R = reactExports.memo(DollarCircle16);
const DollarSquare16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.00001 4.19874C8.27615 4.19874 8.50001 4.4226 8.50001 4.69874V5.29916H9.65063C9.92677 5.29916 10.1506 5.52302 10.1506 5.79916C10.1506 6.0753 9.92677 6.29916 9.65063 6.29916H7.4498C7.1182 6.29916 6.84938 6.56798 6.84938 6.89958C6.84938 7.23118 7.1182 7.5 7.4498 7.5H8.55021C9.4341 7.5 10.1506 8.21653 10.1506 9.10041C10.1506 9.9843 9.4341 10.7008 8.55021 10.7008H8.50001V11.3012C8.50001 11.5774 8.27615 11.8012 8.00001 11.8012C7.72386 11.8012 7.50001 11.5774 7.50001 11.3012V10.7008H6.34938C6.07324 10.7008 5.84938 10.477 5.84938 10.2008C5.84938 9.92469 6.07324 9.70083 6.34938 9.70083H7.99931C7.99908 9.70083 7.99954 9.70083 7.99931 9.70083C7.99954 9.70083 8.00047 9.70083 8.0007 9.70083H8.55021C8.88181 9.70083 9.15063 9.43201 9.15063 9.10041C9.15063 8.76881 8.88181 8.5 8.55021 8.5H7.4498C6.56591 8.5 5.84938 7.78347 5.84938 6.89958C5.84938 6.01569 6.56591 5.29916 7.4498 5.29916H7.50001V4.69874C7.50001 4.4226 7.72386 4.19874 8.00001 4.19874Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.5 4C1.5 2.61929 2.61929 1.5 4 1.5H12C13.3807 1.5 14.5 2.61929 14.5 4V12C14.5 13.3807 13.3807 14.5 12 14.5H4C2.61929 14.5 1.5 13.3807 1.5 12V4ZM4 2.5C3.17157 2.5 2.5 3.17157 2.5 4V12C2.5 12.8284 3.17157 13.5 4 13.5H12C12.8284 13.5 13.5 12.8284 13.5 12V4C13.5 3.17157 12.8284 2.5 12 2.5H4Z", fill: "currentColor" })] });
DollarSquare16.displayName = "DollarSquare16";
const Memo$1Q = reactExports.memo(DollarSquare16);
const ArrowExternal24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.25 7.90001C6.89101 7.90001 6.6 7.60899 6.6 7.25001C6.6 6.89102 6.89101 6.60001 7.25 6.60001H16.75C17.109 6.60001 17.4 6.89102 17.4 7.25001V16.75C17.4 17.109 17.109 17.4 16.75 17.4C16.391 17.4 16.1 17.109 16.1 16.75V8.81924L7.70962 17.2096C7.45578 17.4635 7.04422 17.4635 6.79038 17.2096C6.53654 16.9558 6.53654 16.5442 6.79038 16.2904L15.1808 7.90001H7.25Z", fill: "currentColor" }) });
ArrowExternal24.displayName = "ArrowExternal24";
const Memo$1P = reactExports.memo(ArrowExternal24);
const ArrowExternal16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.83333 5.33334C4.55719 5.33334 4.33333 5.10948 4.33333 4.83334C4.33333 4.55719 4.55719 4.33334 4.83333 4.33334H11.1667L11.6667 4.83334V11.1667C11.6667 11.4428 11.4428 11.6667 11.1667 11.6667C10.8905 11.6667 10.6667 11.4428 10.6667 11.1667V6.04044L5.18688 11.5202C4.99162 11.7155 4.67504 11.7155 4.47977 11.5202C4.28451 11.325 4.28451 11.0084 4.47977 10.8131L9.95956 5.33334H4.83333Z", fill: "currentColor" }) });
ArrowExternal16.displayName = "ArrowExternal16";
const Memo$1O = reactExports.memo(ArrowExternal16);
const Trash16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.01001 2.77523C5.01001 1.9468 5.68158 1.27523 6.51001 1.27523H9.48987C10.3183 1.27523 10.9899 1.9468 10.9899 2.77523V3.76506H12.3573H12.8573H13.6021C13.8783 3.76506 14.1021 3.98892 14.1021 4.26506C14.1021 4.5412 13.8783 4.76506 13.6021 4.76506H12.8573V13.2248C12.8573 14.0532 12.1858 14.7248 11.3573 14.7248H4.64258C3.81415 14.7248 3.14258 14.0532 3.14258 13.2248V4.76506H2.39746C2.12132 4.76506 1.89746 4.5412 1.89746 4.26506C1.89746 3.98892 2.12132 3.76506 2.39746 3.76506H3.14258H3.64258H5.01001V2.77523ZM6.01001 3.76506H9.98987V2.77523C9.98987 2.49909 9.76601 2.27523 9.48987 2.27523H6.51001C6.23387 2.27523 6.01001 2.49909 6.01001 2.77523V3.76506ZM4.14258 4.76506V13.2248C4.14258 13.5009 4.36644 13.7248 4.64258 13.7248H11.3573C11.6335 13.7248 11.8573 13.5009 11.8573 13.2248V4.76506H4.14258ZM6.75513 6.87752C7.03127 6.87752 7.25513 7.10138 7.25513 7.37752V11.1124C7.25513 11.3886 7.03127 11.6124 6.75513 11.6124C6.47898 11.6124 6.25513 11.3886 6.25513 11.1124V7.37752C6.25513 7.10138 6.47898 6.87752 6.75513 6.87752ZM9.74487 7.37752C9.74487 7.10138 9.52102 6.87752 9.24487 6.87752C8.96873 6.87752 8.74487 7.10138 8.74487 7.37752V11.1124C8.74487 11.3886 8.96873 11.6124 9.24487 11.6124C9.52102 11.6124 9.74487 11.3886 9.74487 11.1124V7.37752Z", fill: "currentColor" }) });
Trash16.displayName = "Trash16";
const Memo$1N = reactExports.memo(Trash16);
const CloseFilled24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12ZM9.08462 8.16538C8.83078 7.91154 8.41922 7.91154 8.16538 8.16538C7.91154 8.41922 7.91154 8.83078 8.16538 9.08462L11.0808 12L8.16538 14.9154C7.91154 15.1692 7.91154 15.5808 8.16538 15.8346C8.41922 16.0885 8.83078 16.0885 9.08462 15.8346L12 12.9192L14.9154 15.8346C15.1692 16.0885 15.5808 16.0885 15.8346 15.8346C16.0885 15.5808 16.0885 15.1692 15.8346 14.9154L12.9192 12L15.8346 9.08462C16.0885 8.83078 16.0885 8.41922 15.8346 8.16538C15.5808 7.91154 15.1692 7.91154 14.9154 8.16538L12 11.0808L9.08462 8.16538Z", fill: "currentColor" }) });
CloseFilled24.displayName = "CloseFilled24";
const Memo$1M = reactExports.memo(CloseFilled24);
const CloseFilled16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 14C11.3137 14 14 11.3137 14 8C14 4.68629 11.3137 2 8 2C4.68629 2 2 4.68629 2 8C2 11.3137 4.68629 14 8 14ZM5.29038 5.29038C5.54422 5.03654 5.95578 5.03654 6.20962 5.29038L8 7.08076L9.79038 5.29038C10.0442 5.03654 10.4558 5.03654 10.7096 5.29038C10.9635 5.54422 10.9635 5.95578 10.7096 6.20962L8.91924 8L10.7096 9.79038C10.9635 10.0442 10.9635 10.4558 10.7096 10.7096C10.4558 10.9635 10.0442 10.9635 9.79038 10.7096L8 8.91924L6.20962 10.7096C5.95578 10.9635 5.54422 10.9635 5.29038 10.7096C5.03654 10.4558 5.03654 10.0442 5.29038 9.79038L7.08076 8L5.29038 6.20962C5.03654 5.95578 5.03654 5.54422 5.29038 5.29038Z", fill: "currentColor" }) });
CloseFilled16.displayName = "CloseFilled16";
const Memo$1L = reactExports.memo(CloseFilled16);
const InfoError16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("g", { clipPath: "url(#clip0_302_731)", children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 16C12.4183 16 16 12.4183 16 8C16 3.58172 12.4183 0 8 0C3.58172 0 0 3.58172 0 8C0 12.4183 3.58172 16 8 16ZM8.80001 4C8.80001 3.55817 8.44184 3.2 8.00001 3.2C7.55818 3.2 7.20001 3.55817 7.20001 4V8C7.20001 8.44182 7.55818 8.8 8.00001 8.8C8.44184 8.8 8.80001 8.44182 8.80001 8V4ZM8.00001 10.5333C7.55818 10.5333 7.20001 10.8915 7.20001 11.3333C7.20001 11.7752 7.55818 12.1333 8.00001 12.1333H8.00668C8.44851 12.1333 8.80668 11.7752 8.80668 11.3333C8.80668 10.8915 8.44851 10.5333 8.00668 10.5333H8.00001Z", fill: "currentColor" }) }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "clip0_302_731", children: jsxRuntimeExports.jsx("rect", { width: 16, height: 16, fill: "white" }) }) })] });
InfoError16.displayName = "InfoError16";
const Memo$1K = reactExports.memo(InfoError16);
const Error16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("g", { clipPath: "url(#clip0_9823_47436)", children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 1.83334C4.59424 1.83334 1.83333 4.59425 1.83333 8.00001C1.83333 11.4058 4.59424 14.1667 8 14.1667C11.4058 14.1667 14.1667 11.4058 14.1667 8.00001C14.1667 4.59425 11.4058 1.83334 8 1.83334ZM0.833332 8.00001C0.833332 4.04197 4.04196 0.833344 8 0.833344C11.958 0.833344 15.1667 4.04197 15.1667 8.00001C15.1667 11.9581 11.958 15.1667 8 15.1667C4.04196 15.1667 0.833332 11.9581 0.833332 8.00001ZM5.5 6.00001C5.5 5.72387 5.72386 5.50001 6 5.50001H6.00667C6.28281 5.50001 6.50667 5.72387 6.50667 6.00001C6.50667 6.27615 6.28281 6.50001 6.00667 6.50001H6C5.72386 6.50001 5.5 6.27615 5.5 6.00001ZM9.5 6.00001C9.5 5.72387 9.72386 5.50001 10 5.50001H10.0067C10.2828 5.50001 10.5067 5.72387 10.5067 6.00001C10.5067 6.27615 10.2828 6.50001 10.0067 6.50001H10C9.72386 6.50001 9.5 6.27615 9.5 6.00001ZM5.74758 9.59564C6.26113 9.22215 7.0289 8.83334 8 8.83334C8.9711 8.83334 9.73887 9.22215 10.2524 9.59564C10.5102 9.78309 10.7094 9.97049 10.8454 10.1124C10.9136 10.1836 10.9665 10.2439 11.0034 10.288C11.0219 10.31 11.0365 10.328 11.0471 10.3414L11.0599 10.3578L11.064 10.3632L11.0655 10.3652L11.0661 10.366C11.0661 10.366 11.0661 10.366 11.0661 10.3578V10.366C11.2318 10.5869 11.1876 10.901 10.9667 11.0667C10.746 11.2322 10.4331 11.1877 10.2673 10.9675L10.263 10.9621C10.2581 10.9559 10.2496 10.9452 10.2375 10.9308C10.2132 10.902 10.175 10.8581 10.1234 10.8043C10.0198 10.6962 9.86484 10.5503 9.66425 10.4044C9.26113 10.1112 8.69557 9.83334 8 9.83334C7.30443 9.83334 6.73887 10.1112 6.33575 10.4044C6.13516 10.5503 5.98022 10.6962 5.87662 10.8043C5.82503 10.8581 5.78677 10.902 5.76254 10.9308C5.75045 10.9452 5.7419 10.9559 5.73699 10.9621L5.73257 10.9677C5.56683 11.1883 5.25415 11.2323 5.03333 11.0667C4.81242 10.901 4.76765 10.5876 4.93333 10.3667V10.3578C4.93333 10.3414 4.93333 10.3667 4.93333 10.3667L4.93446 10.3652L4.93597 10.3632L4.94012 10.3578L4.95295 10.3414C4.9635 10.328 4.97807 10.31 4.99657 10.288C5.03354 10.2439 5.08643 10.1836 5.15463 10.1124C5.29062 9.97049 5.48984 9.78309 5.74758 9.59564Z", fill: "currentColor" }) }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "clip0_9823_47436", children: jsxRuntimeExports.jsx("rect", { width: 16, height: 16, fill: "white" }) }) })] });
Error16.displayName = "Error16";
const Memo$1J = reactExports.memo(Error16);
const SortDrag16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.5 5C3.5 4.72386 3.72386 4.5 4 4.5H12C12.2761 4.5 12.5 4.72386 12.5 5C12.5 5.27614 12.2761 5.5 12 5.5H4C3.72386 5.5 3.5 5.27614 3.5 5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.5 8C3.5 7.72386 3.72386 7.5 4 7.5H12C12.2761 7.5 12.5 7.72386 12.5 8C12.5 8.27614 12.2761 8.5 12 8.5H4C3.72386 8.5 3.5 8.27614 3.5 8Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.5 11C3.5 10.7239 3.72386 10.5 4 10.5H12C12.2761 10.5 12.5 10.7239 12.5 11C12.5 11.2761 12.2761 11.5 12 11.5H4C3.72386 11.5 3.5 11.2761 3.5 11Z", fill: "currentColor" })] });
SortDrag16.displayName = "SortDrag16";
const Memo$1I = reactExports.memo(SortDrag16);
const Search24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11 4.65001C7.49299 4.65001 4.65 7.493 4.65 11C4.65 14.507 7.49299 17.35 11 17.35C14.507 17.35 17.35 14.507 17.35 11C17.35 7.493 14.507 4.65001 11 4.65001ZM3.35 11C3.35 6.77503 6.77502 3.35001 11 3.35001C15.225 3.35001 18.65 6.77503 18.65 11C18.65 15.225 15.225 18.65 11 18.65C6.77502 18.65 3.35 15.225 3.35 11Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.5404 15.5404C15.7942 15.2865 16.2058 15.2865 16.4596 15.5404L20.4596 19.5404C20.7135 19.7942 20.7135 20.2058 20.4596 20.4596C20.2058 20.7135 19.7942 20.7135 19.5404 20.4596L15.5404 16.4596C15.2865 16.2058 15.2865 15.7942 15.5404 15.5404Z", fill: "currentColor" })] });
Search24.displayName = "Search24";
const Memo$1H = reactExports.memo(Search24);
const Search16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.08223 7.29471C2.08223 4.41597 4.41591 2.08228 7.29465 2.08228C10.1734 2.08228 12.5071 4.41597 12.5071 7.29471C12.5071 10.1735 10.1734 12.5071 7.29465 12.5071C4.41591 12.5071 2.08223 10.1735 2.08223 7.29471ZM7.29465 1.08228C3.86363 1.08228 1.08223 3.86368 1.08223 7.29471C1.08223 10.7257 3.86363 13.5071 7.29465 13.5071C8.83024 13.5071 10.2357 12.95 11.3199 12.0268L14.731 15.4379C14.9263 15.6332 15.2429 15.6332 15.4381 15.4379C15.6334 15.2427 15.6334 14.9261 15.4381 14.7308L12.027 11.3197C12.95 10.2355 13.5071 8.83017 13.5071 7.29471C13.5071 3.86368 10.7257 1.08228 7.29465 1.08228Z", fill: "currentColor" }) });
Search16.displayName = "Search16";
const Memo$1G = reactExports.memo(Search16);
const Intercom = (props) => jsxRuntimeExports.jsxs("svg", { width: 108, height: 108, viewBox: "0 0 108 108", fill: "none", ...props, children: [jsxRuntimeExports.jsxs("g", { filter: "url(#filter0_ddddd_130_814)", children: [jsxRuntimeExports.jsx("circle", { cx: 54, cy: 30, r: 22, fill: "url(#paint0_linear_130_814)" }), jsxRuntimeExports.jsx("path", { d: "M64.2666 40.9992C64.2666 41.3517 63.913 41.5942 63.5849 41.4653C62.455 41.0212 60.1184 40.104 58.1007 39.3179C58.0428 39.2954 57.9817 39.284 57.9196 39.284H46.2538C44.8627 39.284 43.7333 38.0857 43.7333 36.6095V20.9389C43.7333 19.4642 44.8627 18.2667 46.2538 18.2667H61.7455C63.1373 18.2667 64.2659 19.4635 64.2659 20.9397V34.4359L64.2666 40.9992ZM61.2314 32.9465C61.1765 32.876 61.1075 32.8177 61.0289 32.7753C60.9502 32.7328 60.8637 32.7071 60.7746 32.6999C60.6855 32.6927 60.5959 32.704 60.5114 32.7332C60.427 32.7624 60.3495 32.8088 60.2839 32.8695C60.2619 32.8886 58.0729 34.8356 53.9993 34.8356C49.9762 34.8356 47.7535 32.9025 47.7139 32.8673C47.6482 32.8069 47.5708 32.7608 47.4864 32.7319C47.402 32.703 47.3126 32.6918 47.2237 32.6992C47.1348 32.7066 47.0484 32.7323 46.9699 32.7747C46.8915 32.8172 46.8227 32.8754 46.7679 32.9458C46.6505 33.0923 46.5931 33.2778 46.6073 33.465C46.6197 33.6512 46.7032 33.8255 46.8405 33.9519C46.9446 34.0458 49.4343 36.2619 53.9993 36.2619C58.565 36.2619 61.0547 34.0458 61.1588 33.9519C61.2958 33.8254 61.3791 33.6511 61.3913 33.465C61.4055 33.2782 61.3483 33.0929 61.2314 32.9465Z", fill: "white" })] }), jsxRuntimeExports.jsxs("defs", { children: [jsxRuntimeExports.jsxs("filter", { id: "filter0_ddddd_130_814", x: 0, y: 0, width: 108, height: 108, filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB", children: [jsxRuntimeExports.jsx("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), jsxRuntimeExports.jsx("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }), jsxRuntimeExports.jsx("feOffset", {}), jsxRuntimeExports.jsx("feGaussianBlur", { stdDeviation: 0.5 }), jsxRuntimeExports.jsx("feColorMatrix", { type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.04 0" }), jsxRuntimeExports.jsx("feBlend", { mode: "normal", in2: "BackgroundImageFix", result: "effect1_dropShadow_130_814" }), jsxRuntimeExports.jsx("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }), jsxRuntimeExports.jsx("feOffset", { dy: 4 }), jsxRuntimeExports.jsx("feGaussianBlur", { stdDeviation: 4 }), jsxRuntimeExports.jsx("feColorMatrix", { type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.04 0" }), jsxRuntimeExports.jsx("feBlend", { mode: "normal", in2: "effect1_dropShadow_130_814", result: "effect2_dropShadow_130_814" }), jsxRuntimeExports.jsx("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }), jsxRuntimeExports.jsx("feOffset", { dy: 16 }), jsxRuntimeExports.jsx("feGaussianBlur", { stdDeviation: 12 }), jsxRuntimeExports.jsx("feColorMatrix", { type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.04 0" }), jsxRuntimeExports.jsx("feBlend", { mode: "normal", in2: "effect2_dropShadow_130_814", result: "effect3_dropShadow_130_814" }), jsxRuntimeExports.jsx("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }), jsxRuntimeExports.jsx("feOffset", { dy: 24 }), jsxRuntimeExports.jsx("feGaussianBlur", { stdDeviation: 16 }), jsxRuntimeExports.jsx("feColorMatrix", { type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.04 0" }), jsxRuntimeExports.jsx("feBlend", { mode: "normal", in2: "effect3_dropShadow_130_814", result: "effect4_dropShadow_130_814" }), jsxRuntimeExports.jsx("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }), jsxRuntimeExports.jsx("feOffset", { dy: 4 }), jsxRuntimeExports.jsx("feGaussianBlur", { stdDeviation: 2 }), jsxRuntimeExports.jsx("feColorMatrix", { type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.1 0" }), jsxRuntimeExports.jsx("feBlend", { mode: "normal", in2: "effect4_dropShadow_130_814", result: "effect5_dropShadow_130_814" }), jsxRuntimeExports.jsx("feBlend", { mode: "normal", in: "SourceGraphic", in2: "effect5_dropShadow_130_814", result: "shape" })] }), jsxRuntimeExports.jsxs("linearGradient", { id: "paint0_linear_130_814", x1: 32, y1: 30, x2: 76, y2: 30, gradientUnits: "userSpaceOnUse", children: [jsxRuntimeExports.jsx("stop", { stopColor: "#26ABFF" }), jsxRuntimeExports.jsx("stop", { offset: 1, stopColor: "#00CCFF" })] })] })] });
Intercom.displayName = "Intercom";
const Memo$1F = reactExports.memo(Intercom);
const Delete24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.51083 3.57198C7.63426 3.43092 7.81257 3.35001 8.00001 3.35001H21C21.7028 3.35001 22.3769 3.6292 22.8738 4.12617C23.3708 4.62314 23.65 5.29718 23.65 6.00001V18C23.65 18.7028 23.3708 19.3769 22.8738 19.8738C22.3769 20.3708 21.7028 20.65 21 20.65H8.00001C7.81257 20.65 7.63426 20.5691 7.51083 20.428L0.510831 12.428C0.296398 12.183 0.296398 11.817 0.510831 11.572L7.51083 3.57198ZM8.29496 4.65001L1.86371 12L8.29496 19.35H21C21.358 19.35 21.7014 19.2078 21.9546 18.9546C22.2078 18.7014 22.35 18.358 22.35 18V6.00001C22.35 5.64196 22.2078 5.29859 21.9546 5.04541C21.7014 4.79224 21.358 4.65001 21 4.65001H8.29496ZM11.5404 8.54039C11.7942 8.28655 12.2058 8.28655 12.4596 8.54039L15 11.0808L17.5404 8.54039C17.7942 8.28655 18.2058 8.28655 18.4596 8.54039C18.7135 8.79423 18.7135 9.20578 18.4596 9.45963L15.9192 12L18.4596 14.5404C18.7135 14.7942 18.7135 15.2058 18.4596 15.4596C18.2058 15.7135 17.7942 15.7135 17.5404 15.4596L15 12.9192L12.4596 15.4596C12.2058 15.7135 11.7942 15.7135 11.5404 15.4596C11.2865 15.2058 11.2865 14.7942 11.5404 14.5404L14.0808 12L11.5404 9.45963C11.2865 9.20578 11.2865 8.79423 11.5404 8.54039Z", fill: "currentColor" }) });
Delete24.displayName = "Delete24";
const Memo$1E = reactExports.memo(Delete24);
const Delete16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.95704 2.33741C5.05199 2.2289 5.18915 2.16666 5.33333 2.16666H14C14.4862 2.16666 14.9525 2.35982 15.2964 2.70363C15.6402 3.04745 15.8333 3.51377 15.8333 4V12C15.8333 12.4862 15.6402 12.9525 15.2964 13.2964C14.9525 13.6402 14.4862 13.8333 14 13.8333H5.33333C5.18915 13.8333 5.05199 13.7711 4.95704 13.6626L0.290378 8.32925C0.12543 8.14074 0.12543 7.85926 0.290378 7.67074L4.95704 2.33741ZM5.56022 3.16666L1.33105 8L5.56022 12.8333H14C14.221 12.8333 14.433 12.7455 14.5893 12.5893C14.7455 12.433 14.8333 12.221 14.8333 12V4C14.8333 3.77898 14.7455 3.56702 14.5893 3.41074C14.433 3.25446 14.221 3.16666 14 3.16666H5.56022Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.7071 6L8 10.7071L7.29289 10L12 5.29289L12.7071 6Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 5.29289L12.7071 10L12 10.7071L7.29289 6L8 5.29289Z", fill: "currentColor" })] });
Delete16.displayName = "Delete16";
const Memo$1D = reactExports.memo(Delete16);
const EyeOff24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_705_816)", children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.9985 4.65C11.3419 4.64846 10.6874 4.72326 10.0481 4.8729C9.69861 4.95472 9.34892 4.73769 9.26711 4.38815C9.18529 4.03861 9.40232 3.68893 9.75185 3.60711C10.489 3.43457 11.2437 3.34829 12.0007 3.35001C15.7601 3.35029 18.6697 5.49733 20.5992 7.55544C21.5699 8.59089 22.3121 9.62386 22.8117 10.3974C23.0618 10.7847 23.2522 11.1087 23.381 11.3376C23.4454 11.4521 23.4944 11.5429 23.5279 11.6061C23.5446 11.6378 23.5575 11.6625 23.5664 11.6799L23.5768 11.7003L23.5798 11.7063L23.5808 11.7082C23.5808 11.7082 23.5814 11.7093 23 12L22.4268 11.6936C22.3723 11.7954 22.3169 11.8967 22.2605 11.9974C22.2564 11.99 22.2522 11.9825 22.2479 11.9749C22.1306 11.7663 21.9538 11.4653 21.7196 11.1026C21.2504 10.3762 20.5551 9.40912 19.6508 8.44457C17.8304 6.50282 15.2403 4.65001 12 4.65001L11.9985 4.65ZM22.2605 11.9974C21.7104 12.9803 21.0682 13.9092 20.3426 14.7715C20.1115 15.0462 20.1468 15.4562 20.4215 15.6874C20.6962 15.9185 21.1062 15.8832 21.3374 15.6085C22.1955 14.5886 22.9449 13.4819 23.5732 12.3064C23.6726 12.1205 23.6757 11.8979 23.5814 11.7093L23 12C22.4186 12.2907 22.4188 12.291 22.4188 12.291L22.4173 12.2881L22.4102 12.2743C22.4036 12.2613 22.3931 12.2411 22.3788 12.2142C22.3524 12.1642 22.3129 12.0909 22.2605 11.9974ZM5.66551 5.5434C5.9243 5.34579 6.28938 5.37014 6.51962 5.60039L10.3371 9.41789C10.3386 9.41935 10.3401 9.42082 10.3415 9.4223L14.5777 13.6585C14.5792 13.6599 14.5807 13.6614 14.5821 13.6629L18.3996 17.4804C18.5322 17.613 18.6011 17.7964 18.5885 17.9836C18.576 18.1707 18.4832 18.3433 18.334 18.4569C16.5143 19.8441 14.2985 20.6125 12.0106 20.6499L12 20.6501C8.24032 20.6501 5.33041 18.5028 3.4008 16.4446C2.43007 15.4091 1.6879 14.3762 1.18835 13.6026C0.938167 13.2153 0.747771 12.8913 0.619021 12.6624C0.554622 12.5479 0.505572 12.4571 0.472109 12.3939C0.455375 12.3622 0.442532 12.3375 0.433609 12.3202L0.423166 12.2997L0.420155 12.2937L0.419203 12.2919C0.419203 12.2919 0.418621 12.2907 0.999999 12L0.418621 12.2907C0.324168 12.1018 0.327385 11.8788 0.427247 11.6927C1.71496 9.2929 3.50099 7.19626 5.66551 5.5434ZM1.73979 12.0032C1.74381 12.0104 1.7479 12.0177 1.75207 12.0251C1.86941 12.2337 2.04621 12.5347 2.2804 12.8974C2.74959 13.6239 3.44493 14.5909 4.3492 15.5554C6.16859 17.4961 8.75685 19.348 11.9947 19.35C13.753 19.3203 15.4628 18.7991 16.9334 17.8526L14.0925 15.0117C13.8808 15.168 13.6522 15.3012 13.4107 15.4089C12.963 15.6084 12.4796 15.7156 11.9896 15.7243C11.4995 15.7329 11.0127 15.6428 10.5582 15.4592C10.1037 15.2756 9.69082 15.0024 9.34423 14.6558C8.99763 14.3092 8.72439 13.8963 8.54082 13.4418C8.35724 12.9873 8.26709 12.5005 8.27573 12.0104C8.28438 11.5204 8.39165 11.037 8.59115 10.5893C8.69877 10.3478 8.83205 10.1192 8.98829 9.90753L6.00896 6.9282C4.28107 8.33706 2.83267 10.0585 1.73979 12.0032ZM9.92384 10.8431C9.86952 10.9314 9.82098 11.0233 9.77861 11.1184C9.65016 11.4067 9.5811 11.7178 9.57553 12.0334C9.56996 12.3489 9.62801 12.6623 9.7462 12.955C9.86439 13.2476 10.0403 13.5134 10.2635 13.7365C10.4866 13.9597 10.7524 14.1356 11.045 14.2538C11.3377 14.372 11.6511 14.43 11.9666 14.4245C12.2822 14.4189 12.5933 14.3498 12.8816 14.2214C12.9767 14.179 13.0687 14.1305 13.1569 14.0762L9.92384 10.8431Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0.540379 0.540387C0.79422 0.286546 1.20578 0.286546 1.45962 0.540387L23.4596 22.5404C23.7135 22.7942 23.7135 23.2058 23.4596 23.4596C23.2058 23.7135 22.7942 23.7135 22.5404 23.4596L0.540379 1.45963C0.286538 1.20578 0.286538 0.794227 0.540379 0.540387Z", fill: "currentColor" })] }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "clip0_705_816", children: jsxRuntimeExports.jsx("rect", { width: 24, height: 24, fill: "white" }) }) })] });
EyeOff24.displayName = "EyeOff24";
const Memo$1C = reactExports.memo(EyeOff24);
const EyeOff16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_1049_4206)", children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.99882 3.16666C7.56629 3.16564 7.13511 3.21492 6.71396 3.3135C6.44508 3.37644 6.17609 3.20949 6.11316 2.94061C6.05022 2.67174 6.21717 2.40275 6.48604 2.33982C6.98248 2.22361 7.49074 2.16551 8.00059 2.16666C10.5334 2.16688 12.4895 3.61332 13.7814 4.99135C14.432 5.68529 14.9292 6.37731 15.2638 6.8954C15.4314 7.15492 15.559 7.37206 15.6454 7.52569C15.6886 7.60254 15.7216 7.6636 15.7442 7.70624C15.7555 7.72756 15.7641 7.74428 15.7702 7.75608L15.7773 7.77005L15.7794 7.77418L15.7801 7.77553C15.7802 7.77572 15.7805 7.77638 15.3333 7.99999L14.8924 7.76429C14.8504 7.84279 14.8076 7.92079 14.7639 7.99828C14.6863 7.86113 14.5725 7.66832 14.4237 7.43792C14.1125 6.956 13.6513 6.31469 13.0519 5.6753C11.8439 4.38677 10.1336 3.16666 8 3.16666L7.99882 3.16666ZM14.7639 7.99828C14.4032 8.63785 13.9837 9.24263 13.5108 9.80474C13.333 10.016 13.3601 10.3314 13.5714 10.5092C13.7827 10.687 14.0981 10.6599 14.2759 10.4486C14.851 9.76511 15.3532 9.02346 15.7743 8.2357C15.8507 8.09267 15.8526 7.92059 15.7801 7.77553L15.3333 7.99999C14.8861 8.2236 14.8862 8.22373 14.8862 8.22384L14.8854 8.22221L14.8809 8.21331C14.8778 8.20738 14.8735 8.19904 14.8679 8.1884C14.8656 8.18398 14.8631 8.17916 14.8603 8.17395C14.8415 8.13846 14.8126 8.08494 14.7738 8.01596C14.7706 8.01017 14.7673 8.00428 14.7639 7.99828ZM3.73655 3.6426C3.93562 3.49059 4.21644 3.50933 4.39355 3.68644L6.93825 6.23114C6.93942 6.23229 6.94058 6.23345 6.94174 6.23462L9.76537 9.05826C9.76654 9.05941 9.7677 9.06057 9.76885 9.06173L12.3136 11.6064C12.4156 11.7085 12.4685 11.8496 12.4589 11.9935C12.4492 12.1374 12.3778 12.2702 12.2631 12.3576C11.0386 13.291 9.54762 13.8081 8.00817 13.8333L8 13.8334C5.46691 13.8334 3.51057 12.3868 2.21856 11.0086C1.568 10.3147 1.07082 9.62267 0.73623 9.10459C0.568623 8.84507 0.440995 8.62792 0.354577 8.47429C0.311349 8.39744 0.278376 8.33638 0.255815 8.29375C0.244533 8.27243 0.235849 8.2557 0.229784 8.24391L0.222649 8.22994L0.220558 8.2258L0.219882 8.22446C0.219785 8.22426 0.219453 8.2236 0.666667 7.99999L0.219882 8.22446C0.147227 8.07914 0.149272 7.90673 0.226089 7.76358C1.08906 6.15535 2.28598 4.75028 3.73655 3.6426ZM1.23638 8.00216C1.31394 8.13928 1.42763 8.33192 1.57627 8.56206C1.88751 9.04398 2.34867 9.68529 2.9481 10.3247C4.15532 11.6124 5.86424 12.8318 7.99592 12.8333C9.12774 12.8141 10.229 12.4861 11.1829 11.89L9.38794 10.095C9.25618 10.1877 9.11545 10.2676 8.9676 10.3335C8.66093 10.4701 8.32989 10.5436 7.99421 10.5495C7.65854 10.5554 7.32511 10.4937 7.01381 10.3679C6.70252 10.2422 6.41974 10.055 6.18234 9.81765C5.94495 9.58025 5.7578 9.29747 5.63206 8.98618C5.50633 8.67488 5.44458 8.34145 5.4505 8.00578C5.45642 7.6701 5.5299 7.33906 5.66654 7.03239C5.73241 6.88454 5.81233 6.74381 5.90496 6.61206L4.00153 4.70863C2.88624 5.62752 1.9488 6.74381 1.23638 8.00216ZM6.63018 7.33728C6.61219 7.37062 6.59543 7.40468 6.57997 7.43939C6.49798 7.62339 6.4539 7.82201 6.45034 8.02342C6.44679 8.22482 6.48384 8.42488 6.55928 8.61166C6.63472 8.79844 6.74701 8.9681 6.88945 9.11054C7.03189 9.25298 7.20156 9.36527 7.38833 9.44071C7.57511 9.51615 7.77517 9.5532 7.97657 9.54965C8.17798 9.54609 8.3766 9.50201 8.5606 9.42003C8.59531 9.40456 8.62937 9.3878 8.66271 9.36981L6.63018 7.33728Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0.313113 0.313103C0.508375 0.117841 0.824958 0.117841 1.02022 0.313103L15.6869 14.9798C15.8821 15.175 15.8821 15.4916 15.6869 15.6869C15.4916 15.8821 15.175 15.8821 14.9798 15.6869L0.313113 1.02021C0.117851 0.824948 0.117851 0.508365 0.313113 0.313103Z", fill: "currentColor" })] }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "clip0_1049_4206", children: jsxRuntimeExports.jsx("rect", { width: 16, height: 16, fill: "white" }) }) })] });
EyeOff16.displayName = "EyeOff16";
const Memo$1B = reactExports.memo(EyeOff16);
const Eye24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.738 12C1.74259 12.0082 1.74728 12.0166 1.75207 12.0251C1.86941 12.2337 2.04621 12.5347 2.2804 12.8974C2.74959 13.6239 3.44493 14.5909 4.3492 15.5554C6.16959 17.4972 8.75968 19.35 12 19.35C15.2403 19.35 17.8304 17.4972 19.6508 15.5554C20.5551 14.5909 21.2504 13.6239 21.7196 12.8974C21.9538 12.5347 22.1306 12.2337 22.2479 12.0251C22.2527 12.0166 22.2574 12.0082 22.262 12C22.2574 11.9918 22.2527 11.9834 22.2479 11.9749C22.1306 11.7663 21.9538 11.4653 21.7196 11.1026C21.2504 10.3762 20.5551 9.40912 19.6508 8.44457C17.8304 6.50282 15.2403 4.65001 12 4.65001C8.75968 4.65001 6.16959 6.50282 4.3492 8.44457C3.44493 9.40912 2.74959 10.3762 2.2804 11.1026C2.04621 11.4653 1.86941 11.7663 1.75207 11.9749C1.74728 11.9834 1.74259 11.9918 1.738 12ZM23 12C23.5814 11.7093 23.5813 11.7091 23.5811 11.7088L23.5798 11.7063L23.5768 11.7003L23.5664 11.6799C23.5575 11.6625 23.5446 11.6378 23.5279 11.6061C23.4944 11.5429 23.4454 11.4521 23.381 11.3376C23.2522 11.1087 23.0618 10.7847 22.8116 10.3974C22.3121 9.62386 21.5699 8.59089 20.5992 7.55544C18.6696 5.49719 15.7597 3.35001 12 3.35001C8.24032 3.35001 5.33041 5.49719 3.4008 7.55544C2.43007 8.59089 1.6879 9.62386 1.18835 10.3974C0.938167 10.7847 0.747771 11.1087 0.619021 11.3376C0.554622 11.4521 0.505572 11.5429 0.472109 11.6061C0.455375 11.6378 0.442532 11.6625 0.433609 11.6799L0.423166 11.7003L0.420155 11.7063L0.419203 11.7082C0.419073 11.7084 0.418621 11.7093 0.999998 12L0.418621 11.7093C0.327124 11.8923 0.327124 12.1077 0.418621 12.2907L0.999998 12C0.418621 12.2907 0.418491 12.2904 0.418621 12.2907L0.420155 12.2938L0.423166 12.2997L0.433609 12.3202C0.442532 12.3375 0.455375 12.3622 0.472109 12.3939C0.505572 12.4571 0.554622 12.5479 0.619021 12.6624C0.747771 12.8913 0.938167 13.2153 1.18835 13.6026C1.6879 14.3762 2.43007 15.4091 3.4008 16.4446C5.33041 18.5028 8.24032 20.65 12 20.65C15.7597 20.65 18.6696 18.5028 20.5992 16.4446C21.5699 15.4091 22.3121 14.3762 22.8116 13.6026C23.0618 13.2153 23.2522 12.8913 23.381 12.6624C23.4454 12.5479 23.4944 12.4571 23.5279 12.3939C23.5446 12.3622 23.5575 12.3375 23.5664 12.3202L23.5768 12.2997L23.5798 12.2938L23.5808 12.2919C23.5809 12.2916 23.5814 12.2907 23 12ZM23 12L23.5814 12.2907C23.6729 12.1077 23.6726 11.8918 23.5811 11.7088L23 12ZM12 9.65001C10.7021 9.65001 9.65 10.7021 9.65 12C9.65 13.2979 10.7021 14.35 12 14.35C13.2979 14.35 14.35 13.2979 14.35 12C14.35 10.7021 13.2979 9.65001 12 9.65001ZM8.35 12C8.35 9.98417 9.98416 8.35001 12 8.35001C14.0158 8.35001 15.65 9.98417 15.65 12C15.65 14.0158 14.0158 15.65 12 15.65C9.98416 15.65 8.35 14.0158 8.35 12Z", fill: "currentColor" }) });
Eye24.displayName = "Eye24";
const Memo$1A = reactExports.memo(Eye24);
const Eye16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.23515 7.99999C1.31274 8.13725 1.42685 8.3307 1.57627 8.56206C1.88751 9.04398 2.34867 9.68529 2.9481 10.3247C4.15609 11.6132 5.86642 12.8333 8 12.8333C10.1336 12.8333 11.8439 11.6132 13.0519 10.3247C13.6513 9.68529 14.1125 9.04398 14.4237 8.56206C14.5731 8.3307 14.6873 8.13724 14.7648 7.99999C14.6873 7.86273 14.5731 7.66928 14.4237 7.43792C14.1125 6.956 13.6513 6.31469 13.0519 5.67529C11.8439 4.38677 10.1336 3.16666 8 3.16666C5.86642 3.16666 4.15609 4.38677 2.9481 5.67529C2.34867 6.31469 1.88751 6.956 1.57627 7.43792C1.42685 7.66928 1.31274 7.86273 1.23515 7.99999ZM15.3333 7.99999C15.7805 7.77638 15.7805 7.77621 15.7804 7.77602L15.7794 7.77418L15.7773 7.77004L15.7702 7.75608C15.7641 7.74428 15.7555 7.72755 15.7442 7.70623C15.7216 7.6636 15.6887 7.60254 15.6454 7.52569C15.559 7.37206 15.4314 7.15491 15.2638 6.89539C14.9292 6.37731 14.432 5.68529 13.7814 4.99135C12.4894 3.61321 10.5331 2.16666 8 2.16666C5.46691 2.16666 3.51057 3.61321 2.21857 4.99135C1.568 5.68529 1.07082 6.37731 0.736231 6.89539C0.568624 7.15491 0.440996 7.37206 0.354578 7.52569C0.31135 7.60254 0.278377 7.6636 0.255816 7.70623C0.244534 7.72755 0.23585 7.74428 0.229784 7.75608L0.22265 7.77004L0.220559 7.77418L0.219883 7.77553C0.219786 7.77572 0.219454 7.77638 0.666667 7.99999L0.219883 7.77553C0.149501 7.91629 0.149072 8.08283 0.219454 8.2236L0.666667 7.99999C0.219454 8.2236 0.219357 8.2234 0.219454 8.2236L0.220559 8.2258L0.22265 8.22994L0.229784 8.2439C0.23585 8.2557 0.244534 8.27242 0.255816 8.29374C0.278377 8.33638 0.31135 8.39744 0.354578 8.47429C0.440996 8.62792 0.568624 8.84506 0.736231 9.10459C1.07082 9.62267 1.568 10.3147 2.21857 11.0086C3.51057 12.3868 5.46691 13.8333 8 13.8333C10.5331 13.8333 12.4894 12.3868 13.7814 11.0086C14.432 10.3147 14.9292 9.62267 15.2638 9.10459C15.4314 8.84506 15.559 8.62792 15.6454 8.47429C15.6887 8.39744 15.7216 8.33638 15.7442 8.29374C15.7555 8.27242 15.7641 8.2557 15.7702 8.2439L15.7773 8.22994L15.7794 8.2258L15.7801 8.22445C15.7802 8.22426 15.7805 8.2236 15.3333 7.99999ZM15.3333 7.99999L15.7801 8.22445C15.8505 8.08369 15.8507 7.91678 15.7804 7.77602L15.3333 7.99999Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 6.49999C7.17157 6.49999 6.5 7.17157 6.5 7.99999C6.5 8.82842 7.17157 9.49999 8 9.49999C8.82843 9.49999 9.5 8.82842 9.5 7.99999C9.5 7.17157 8.82843 6.49999 8 6.49999ZM5.5 7.99999C5.5 6.61928 6.61929 5.49999 8 5.49999C9.38071 5.49999 10.5 6.61928 10.5 7.99999C10.5 9.3807 9.38071 10.5 8 10.5C6.61929 10.5 5.5 9.3807 5.5 7.99999Z", fill: "currentColor" })] });
Eye16.displayName = "Eye16";
const Memo$1z = reactExports.memo(Eye16);
const Chat24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18.2222 4.65001C18.5213 4.65001 18.8082 4.76883 19.0197 4.98032C19.2312 5.19182 19.35 5.47868 19.35 5.77778V18.4308L16.9041 15.9848C16.7822 15.8629 16.6168 15.7945 16.4444 15.7945H5.77778C5.47867 15.7945 5.19182 15.6756 4.98032 15.4641C4.76882 15.2526 4.65 14.9658 4.65 14.6667V5.77778C4.65 5.47868 4.76882 5.19182 4.98032 4.98032C5.19182 4.76883 5.47867 4.65001 5.77778 4.65001H18.2222ZM19.9389 4.06109C19.4836 3.60579 18.8661 3.35001 18.2222 3.35001H5.77778C5.13389 3.35001 4.51637 3.60579 4.06108 4.06109C3.60578 4.51638 3.35 5.1339 3.35 5.77778V14.6667C3.35 15.3106 3.60578 15.9281 4.06108 16.3834C4.51637 16.8387 5.13389 17.0944 5.77778 17.0944H16.1752L19.5404 20.4596C19.7263 20.6455 20.0059 20.7011 20.2487 20.6005C20.4916 20.4999 20.65 20.2629 20.65 20V5.77778C20.65 5.1339 20.3942 4.51638 19.9389 4.06109Z", fill: "currentColor" }) });
Chat24.displayName = "Chat24";
const Memo$1y = reactExports.memo(Chat24);
const Chat16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.1481 3.16666C12.3299 3.16666 12.5041 3.23885 12.6326 3.36735C12.7611 3.49585 12.8333 3.67013 12.8333 3.85185V12.1262L11.3165 10.6094C11.2227 10.5156 11.0956 10.463 10.963 10.463H3.85185C3.67013 10.463 3.49585 10.3908 3.36735 10.2623C3.23885 10.1338 3.16666 9.9595 3.16666 9.77777V3.85185C3.16666 3.67013 3.23885 3.49585 3.36735 3.36735C3.49585 3.23885 3.67013 3.16666 3.85185 3.16666H12.1481ZM13.3397 2.66024C13.0237 2.34421 12.5951 2.16666 12.1481 2.16666H3.85185C3.40491 2.16666 2.97628 2.34421 2.66024 2.66024C2.34421 2.97628 2.16666 3.40491 2.16666 3.85185V9.77777C2.16666 10.2247 2.34421 10.6533 2.66024 10.9694C2.97628 11.2854 3.40491 11.463 3.85185 11.463H10.7559L12.9798 13.6869C13.1228 13.8299 13.3378 13.8727 13.5247 13.7953C13.7115 13.7179 13.8333 13.5356 13.8333 13.3333V3.85185C13.8333 3.40491 13.6558 2.97628 13.3397 2.66024Z", fill: "currentColor" }) });
Chat16.displayName = "Chat16";
const Memo$1x = reactExports.memo(Chat16);
const Reports24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.12617 2.12617C4.62314 1.6292 5.29718 1.35001 6 1.35001H14C14.1724 1.35001 14.3377 1.41849 14.4596 1.54039L20.4596 7.54039C20.5815 7.66229 20.65 7.82762 20.65 8.00001V20C20.65 20.7028 20.3708 21.3769 19.8738 21.8738C19.3769 22.3708 18.7028 22.65 18 22.65H6C5.29718 22.65 4.62314 22.3708 4.12617 21.8738C3.6292 21.3769 3.35 20.7028 3.35 20V4.00001C3.35 3.29718 3.6292 2.62314 4.12617 2.12617ZM6 2.65001C5.64196 2.65001 5.29858 2.79224 5.04541 3.04541C4.79223 3.29859 4.65 3.64196 4.65 4.00001V20C4.65 20.358 4.79223 20.7014 5.04541 20.9546C5.29858 21.2078 5.64196 21.35 6 21.35H18C18.358 21.35 18.7014 21.2078 18.9546 20.9546C19.2078 20.7014 19.35 20.358 19.35 20V8.26925L13.7308 2.65001H6Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.35 9.00001C7.35 8.64102 7.64102 8.35001 8 8.35001H10C10.359 8.35001 10.65 8.64102 10.65 9.00001C10.65 9.35899 10.359 9.65001 10 9.65001H8C7.64102 9.65001 7.35 9.35899 7.35 9.00001ZM7.35 13C7.35 12.641 7.64102 12.35 8 12.35H16C16.359 12.35 16.65 12.641 16.65 13C16.65 13.359 16.359 13.65 16 13.65H8C7.64102 13.65 7.35 13.359 7.35 13ZM7.35 17C7.35 16.641 7.64102 16.35 8 16.35H16C16.359 16.35 16.65 16.641 16.65 17C16.65 17.359 16.359 17.65 16 17.65H8C7.64102 17.65 7.35 17.359 7.35 17Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14 1.35001C14.359 1.35001 14.65 1.64102 14.65 2.00001V7.35001H20C20.359 7.35001 20.65 7.64102 20.65 8.00001C20.65 8.35899 20.359 8.65001 20 8.65001H14C13.641 8.65001 13.35 8.35899 13.35 8.00001V2.00001C13.35 1.64102 13.641 1.35001 14 1.35001Z", fill: "currentColor" })] });
Reports24.displayName = "Reports24";
const Memo$1w = reactExports.memo(Reports24);
const Reports16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.70364 1.37031C3.04746 1.02649 3.51377 0.833336 4 0.833336H9.33334C9.46595 0.833336 9.59312 0.886014 9.68689 0.979783L13.6869 4.97978C13.7807 5.07355 13.8333 5.20073 13.8333 5.33334V13.3333C13.8333 13.8196 13.6402 14.2859 13.2964 14.6297C12.9525 14.9735 12.4862 15.1667 12 15.1667H4C3.51377 15.1667 3.04746 14.9735 2.70364 14.6297C2.35983 14.2859 2.16667 13.8196 2.16667 13.3333V2.66667C2.16667 2.18044 2.35983 1.71412 2.70364 1.37031ZM4 1.83334C3.77899 1.83334 3.56703 1.92113 3.41075 2.07741C3.25447 2.23369 3.16667 2.44566 3.16667 2.66667V13.3333C3.16667 13.5543 3.25447 13.7663 3.41075 13.9226C3.56703 14.0789 3.77899 14.1667 4 14.1667H12C12.221 14.1667 12.433 14.0789 12.5893 13.9226C12.7455 13.7663 12.8333 13.5543 12.8333 13.3333V5.54044L9.12623 1.83334H4Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.83333 11.3333C4.83333 11.0572 5.05719 10.8333 5.33333 10.8333H10.6667C10.9428 10.8333 11.1667 11.0572 11.1667 11.3333C11.1667 11.6095 10.9428 11.8333 10.6667 11.8333H5.33333C5.05719 11.8333 4.83333 11.6095 4.83333 11.3333Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.83333 8.66667C4.83333 8.39053 5.05719 8.16667 5.33333 8.16667H10.6667C10.9428 8.16667 11.1667 8.39053 11.1667 8.66667C11.1667 8.94281 10.9428 9.16667 10.6667 9.16667H5.33333C5.05719 9.16667 4.83333 8.94281 4.83333 8.66667Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.83333 6C4.83333 5.72386 5.05719 5.5 5.33333 5.5H6.66666C6.9428 5.5 7.16666 5.72386 7.16666 6C7.16666 6.27614 6.9428 6.5 6.66666 6.5H5.33333C5.05719 6.5 4.83333 6.27614 4.83333 6Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.33334 0.833336C9.60948 0.833336 9.83333 1.05719 9.83333 1.33334V4.83334H13.3333C13.6095 4.83334 13.8333 5.05719 13.8333 5.33334C13.8333 5.60948 13.6095 5.83334 13.3333 5.83334H9.33333C9.05719 5.83334 8.83333 5.60948 8.83333 5.33334V1.33334C8.83333 1.05719 9.05719 0.833336 9.33334 0.833336Z", fill: "currentColor" })] });
Reports16.displayName = "Reports16";
const Memo$1v = reactExports.memo(Reports16);
const Finish24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M20.4488 6.52983C20.7085 6.7777 20.7181 7.18914 20.4702 7.44882L10.9247 17.4488C10.8021 17.5773 10.6322 17.65 10.4545 17.65C10.2769 17.65 10.107 17.5773 9.98436 17.4488L5.52982 12.7821C5.28195 12.5225 5.29152 12.111 5.55119 11.8632C5.81086 11.6153 6.22231 11.6249 6.47018 11.8845L10.4545 16.0586L19.5298 6.5512C19.7777 6.29152 20.1891 6.28196 20.4488 6.52983Z", fill: "currentColor" }) });
Finish24.displayName = "Finish24";
const Memo$1u = reactExports.memo(Finish24);
const Finish16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.6786 4.30499C13.8783 4.49566 13.8857 4.81216 13.695 5.01191L7.33138 11.6786C7.23703 11.7774 7.10634 11.8333 6.9697 11.8333C6.83306 11.8333 6.70237 11.7774 6.60802 11.6786L3.63832 8.56747C3.44765 8.36772 3.45501 8.05122 3.65476 7.86055C3.85451 7.66988 4.17101 7.67724 4.36168 7.87699L6.9697 10.6092L12.9717 4.32143C13.1623 4.12169 13.4788 4.11433 13.6786 4.30499Z", fill: "currentColor" }) });
Finish16.displayName = "Finish16";
const Memo$1t = reactExports.memo(Finish16);
const FinishFilled16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("g", { clipPath: "url(#clip0_1558_24081)", children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16 8C16 12.4183 12.4183 16 8 16C3.58172 16 0 12.4183 0 8C0 3.58172 3.58172 0 8 0C12.4183 0 16 3.58172 16 8ZM12.9717 5.94721C13.2187 5.68669 13.2077 5.27528 12.9472 5.0283C12.6867 4.78132 12.2753 4.79229 12.0283 5.0528L6.9681 10.3903L4.47019 7.77342C4.22232 7.51375 3.81087 7.50418 3.5512 7.75205C3.29152 7.99992 3.28196 8.41137 3.52983 8.67104L6.49952 11.7821C6.62244 11.9109 6.79279 11.9836 6.97081 11.9833C7.14883 11.983 7.31893 11.9097 7.44141 11.7805L12.9717 5.94721Z", fill: "currentColor" }) }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "clip0_1558_24081", children: jsxRuntimeExports.jsx("rect", { width: 16, height: 16, rx: 8, fill: "white" }) }) })] });
FinishFilled16.displayName = "FinishFilled16";
const Memo$1s = reactExports.memo(FinishFilled16);
const Edit24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.0224 3.02239C14.2762 2.76855 14.6878 2.76855 14.9416 3.02239L20.9779 9.05863C21.2317 9.31247 21.2317 9.72403 20.9779 9.97787L11.0486 19.9072C10.9267 20.0291 10.7614 20.0976 10.589 20.0976L4.55275 20.0976C4.19376 20.0976 3.90275 19.8066 3.90275 19.4476L3.90274 13.4114C3.90275 13.239 3.97122 13.0737 4.09312 12.9518L14.0224 3.02239ZM14.482 4.40125L11.5208 7.36245L16.6378 12.4794L19.599 9.51825L14.482 4.40125ZM15.7186 13.3987L10.6016 8.28169L5.20274 13.6806V18.7976H10.3197L15.7186 13.3987Z", fill: "currentColor" }) });
Edit24.displayName = "Edit24";
const Memo$1r = reactExports.memo(Edit24);
const Edit16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("g", { clipPath: "url(#clip0_1049_4202)", children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.48808 1.45422C9.68334 1.25896 9.99992 1.25896 10.1952 1.45422L14.5459 5.80497C14.7412 6.00023 14.7412 6.31682 14.5459 6.51208L7.38921 13.6689C7.29544 13.7627 7.16826 13.8153 7.03565 13.8153L2.6849 13.8153C2.40876 13.8153 2.1849 13.5915 2.1849 13.3153L2.1849 8.96459C2.1849 8.83198 2.23758 8.70481 2.33134 8.61104L9.48808 1.45422ZM9.84163 2.51488L7.75183 4.60469L11.3955 8.24833L13.4853 6.15852L9.84163 2.51488ZM10.6884 8.95544L7.04473 5.3118L3.1849 9.17169L3.1849 12.8153L6.82854 12.8153L10.6884 8.95544Z", fill: "currentColor" }) }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "clip0_1049_4202", children: jsxRuntimeExports.jsx("rect", { width: 16, height: 16, fill: "white" }) }) })] });
Edit16.displayName = "Edit16";
const Memo$1q = reactExports.memo(Edit16);
const Prefs24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 2.65001C11.6902 2.65001 11.393 2.77308 11.174 2.99216C10.9549 3.21124 10.8318 3.50837 10.8318 3.81819V3.97273L10.8318 3.97533C10.8301 4.39462 10.7059 4.80428 10.4744 5.15387C10.2429 5.50346 9.91418 5.77773 9.52878 5.9429C9.466 5.96981 9.39947 5.98661 9.33169 5.99278C8.97398 6.12338 8.58712 6.15691 8.21077 6.08867C7.78807 6.01203 7.39803 5.81052 7.09093 5.51012L7.08581 5.50511L7.03129 5.45053C6.9228 5.34192 6.7937 5.2555 6.65189 5.19671C6.51007 5.13793 6.35806 5.10767 6.20455 5.10767C6.05103 5.10767 5.89902 5.13793 5.7572 5.19671C5.61539 5.2555 5.48655 5.34167 5.37806 5.45028C5.26944 5.55877 5.18277 5.68812 5.12398 5.82994C5.06519 5.97175 5.03493 6.12376 5.03493 6.27728C5.03493 6.4308 5.06519 6.58281 5.12398 6.72462C5.18277 6.86644 5.26893 6.99528 5.37755 7.10377L5.43742 7.16364C5.73781 7.47074 5.9393 7.86081 6.01594 8.2835C6.09136 8.69946 6.04246 9.12827 5.87559 9.51635C5.72535 9.91311 5.46101 10.2567 5.11568 10.5037C4.76478 10.7547 4.34649 10.8943 3.9152 10.9044L3.9 10.9046H3.81818C3.50836 10.9046 3.21123 11.0276 2.99215 11.2467C2.77308 11.4658 2.65 11.7629 2.65 12.0727C2.65 12.3826 2.77308 12.6797 2.99215 12.8988C3.21123 13.1178 3.50836 13.2409 3.81818 13.2409H3.97532C4.39462 13.2426 4.80428 13.3668 5.15387 13.5984C5.50249 13.8292 5.77621 14.1567 5.94153 14.5408C6.11385 14.9329 6.1651 15.3677 6.08867 15.7892C6.01202 16.2119 5.81051 16.602 5.51012 16.9091L5.5051 16.9142L5.45052 16.9687C5.34191 17.0772 5.2555 17.2063 5.19671 17.3481C5.13792 17.4899 5.10766 17.6419 5.10766 17.7955C5.10766 17.949 5.13792 18.101 5.19671 18.2428C5.2555 18.3846 5.34166 18.5135 5.45027 18.622C5.55876 18.7306 5.68811 18.8172 5.82993 18.876C5.97174 18.9348 6.12375 18.9651 6.27727 18.9651C6.43079 18.9651 6.5828 18.9348 6.72462 18.876C6.86643 18.8172 6.99527 18.7311 7.10376 18.6225L7.16363 18.5626C7.47073 18.2622 7.8608 18.0607 8.2835 17.9841C8.69945 17.9086 9.12825 17.9575 9.51633 18.1244C9.9131 18.2746 10.2567 18.539 10.5037 18.8843C10.7547 19.2352 10.8943 19.6535 10.9044 20.0848L10.9045 20.1V20.1818C10.9045 20.4916 11.0276 20.7888 11.2467 21.0079C11.4658 21.2269 11.7629 21.35 12.0727 21.35C12.3825 21.35 12.6797 21.2269 12.8988 21.0079C13.1178 20.7888 13.2409 20.4916 13.2409 20.1818V20.0273L13.2409 20.0247C13.2426 19.6054 13.3668 19.1957 13.5983 18.8461C13.8292 18.4975 14.1568 18.2238 14.5408 18.0584C14.933 17.8862 15.3677 17.8349 15.7892 17.9113C16.2119 17.988 16.602 18.1895 16.9091 18.4899L16.9142 18.4949L16.9687 18.5495C17.0772 18.6581 17.2063 18.7445 17.3481 18.8033C17.4899 18.8621 17.6419 18.8923 17.7955 18.8923C17.949 18.8923 18.101 18.8621 18.2428 18.8033C18.3846 18.7445 18.5135 18.6583 18.6219 18.5497C18.7306 18.4412 18.8172 18.3119 18.876 18.1701C18.9348 18.0283 18.9651 17.8763 18.9651 17.7227C18.9651 17.5692 18.9348 17.4172 18.876 17.2754C18.8172 17.1336 18.7311 17.0047 18.6225 16.8962L18.5626 16.8364C18.2622 16.5293 18.0607 16.1392 17.9841 15.7165C17.9076 15.295 17.9589 14.8603 18.1312 14.4681C18.2965 14.0841 18.5702 13.7565 18.9189 13.5256C19.2685 13.2941 19.6781 13.1699 20.0974 13.1682L20.1 13.1682L20.1818 13.1682C20.4916 13.1682 20.7888 13.0451 21.0078 12.826C21.2269 12.607 21.35 12.3098 21.35 12C21.35 11.6902 21.2269 11.3931 21.0078 11.174C20.7888 10.9549 20.4916 10.8318 20.1818 10.8318H20.0273L20.0247 10.8318C19.6054 10.8301 19.1957 10.7059 18.8461 10.4744C18.4965 10.2429 18.2223 9.91419 18.0571 9.52879C18.0302 9.466 18.0134 9.39949 18.0072 9.3317C17.8766 8.97399 17.8431 8.58713 17.9113 8.21078C17.988 7.78808 18.1895 7.39804 18.4899 7.09094L18.4949 7.08582L18.5495 7.0313C18.6581 6.92281 18.7445 6.79371 18.8033 6.6519C18.8621 6.51008 18.8923 6.35807 18.8923 6.20455C18.8923 6.05103 18.8621 5.89902 18.8033 5.75721C18.7445 5.61539 18.6583 5.48656 18.5497 5.37806C18.4412 5.26945 18.3119 5.18277 18.1701 5.12399C18.0283 5.0652 17.8762 5.03494 17.7227 5.03494C17.5692 5.03494 17.4172 5.0652 17.2754 5.12399C17.1336 5.18277 17.0047 5.26894 16.8962 5.37755L16.8364 5.43742C16.5293 5.73782 16.1392 5.9393 15.7165 6.01595C15.295 6.09238 14.8602 6.04113 14.468 5.86881C14.084 5.70349 13.7565 5.42977 13.5256 5.08114C13.2941 4.73155 13.1699 4.3219 13.1682 3.9026L13.1682 3.90001V3.81819C13.1682 3.50837 13.0451 3.21124 12.826 2.99216C12.607 2.77308 12.3098 2.65001 12 2.65001ZM10.2547 2.07292C10.7176 1.61005 11.3454 1.35001 12 1.35001C12.6546 1.35001 13.2824 1.61005 13.7453 2.07292C14.2081 2.53579 14.4682 3.16358 14.4682 3.81819V3.89845C14.469 4.06386 14.5181 4.22543 14.6095 4.36335C14.701 4.50156 14.831 4.60999 14.9833 4.67529L14.9897 4.67804C15.1451 4.74661 15.3175 4.7671 15.4846 4.7368C15.6507 4.70669 15.804 4.6278 15.9251 4.51023L15.9765 4.45882C16.2057 4.22934 16.4779 4.04729 16.7776 3.92308C17.0772 3.79887 17.3984 3.73494 17.7227 3.73494C18.0471 3.73494 18.3683 3.79887 18.6679 3.92308C18.9674 4.04725 19.2395 4.22921 19.4687 4.45857C19.6981 4.68774 19.88 4.95986 20.0042 5.25939C20.1284 5.55902 20.1923 5.8802 20.1923 6.20455C20.1923 6.52891 20.1284 6.85008 20.0042 7.14972C19.88 7.44935 19.6979 7.72156 19.4685 7.95079L19.4171 8.00218C19.2995 8.12325 19.2206 8.2766 19.1905 8.44271C19.1602 8.60982 19.1806 8.78218 19.2492 8.93756C19.2733 8.99214 19.2897 9.04964 19.2981 9.10843C19.3635 9.22128 19.4544 9.31797 19.5639 9.39052C19.7018 9.48184 19.8634 9.53094 20.0287 9.53182H20.1818C20.8364 9.53182 21.4642 9.79186 21.9271 10.2547C22.39 10.7176 22.65 11.3454 22.65 12C22.65 12.6546 22.39 13.2824 21.9271 13.7453C21.4642 14.2081 20.8364 14.4682 20.1818 14.4682H20.1016C19.9361 14.469 19.7746 14.5182 19.6367 14.6095C19.4984 14.701 19.39 14.831 19.3247 14.9833L19.322 14.9897C19.2534 15.1451 19.2329 15.3175 19.2632 15.4846C19.2933 15.6507 19.3722 15.804 19.4898 15.9251L19.5412 15.9765C19.7707 16.2057 19.9527 16.4779 20.0769 16.7776C20.2011 17.0772 20.2651 17.3984 20.2651 17.7227C20.2651 18.0471 20.2011 18.3683 20.0769 18.6679C19.9528 18.9674 19.7708 19.2395 19.5414 19.4687C19.3123 19.6981 19.0401 19.88 18.7406 20.0042C18.441 20.1284 18.1198 20.1923 17.7955 20.1923C17.4711 20.1923 17.1499 20.1284 16.8503 20.0042C16.5507 19.88 16.2784 19.6979 16.0492 19.4685L15.9978 19.4171C15.8767 19.2995 15.7234 19.2206 15.5573 19.1905C15.3902 19.1602 15.2178 19.1806 15.0624 19.2492L15.0561 19.252C14.9037 19.3173 14.7737 19.4257 14.6822 19.5639C14.5909 19.7019 14.5418 19.8634 14.5409 20.0288V20.1818C14.5409 20.8364 14.2809 21.4642 13.818 21.9271C13.3551 22.39 12.7273 22.65 12.0727 22.65C11.4181 22.65 10.7903 22.39 10.3275 21.9271C9.86459 21.4642 9.60455 20.8364 9.60455 20.1818V20.1087C9.59932 19.9405 9.54427 19.7776 9.44632 19.6406C9.3471 19.5019 9.20844 19.3962 9.04836 19.3373C9.03551 19.3326 9.02281 19.3275 9.01028 19.3219C8.8549 19.2534 8.68255 19.2329 8.51543 19.2632C8.34934 19.2933 8.19599 19.3722 8.07492 19.4898L8.02351 19.5412C7.79428 19.7707 7.52207 19.9527 7.22244 20.0769C6.92281 20.2011 6.60163 20.2651 6.27727 20.2651C5.95292 20.2651 5.63174 20.2011 5.33211 20.0769C5.03259 19.9528 4.76046 19.7708 4.53129 19.5414C4.30193 19.3123 4.11997 19.0401 3.9958 18.7406C3.87159 18.441 3.80766 18.1198 3.80766 17.7955C3.80766 17.4711 3.87159 17.1499 3.9958 16.8503C4.12001 16.5507 4.30206 16.2785 4.53155 16.0492L4.58295 15.9978C4.70052 15.8767 4.77941 15.7234 4.80952 15.5573C4.83982 15.3902 4.81937 15.2178 4.75079 15.0625L4.74798 15.0561C4.68268 14.9037 4.57428 14.7738 4.43607 14.6822C4.29815 14.5909 4.13658 14.5418 3.97117 14.5409H3.81818C3.16358 14.5409 2.53579 14.2809 2.07291 13.818C1.61004 13.3551 1.35 12.7273 1.35 12.0727C1.35 11.4181 1.61004 10.7903 2.07291 10.3275C2.53579 9.86459 3.16358 9.60455 3.81818 9.60455H3.89133C4.05953 9.59932 4.22245 9.54428 4.35941 9.44633C4.49814 9.3471 4.60381 9.20844 4.66268 9.04837C4.66741 9.03551 4.67254 9.02281 4.67807 9.01029C4.74664 8.85491 4.7671 8.68255 4.7368 8.51544C4.70668 8.34934 4.62779 8.19599 4.51022 8.07492L4.45882 8.02352C4.22934 7.79429 4.04728 7.52208 3.92308 7.22245C3.79887 6.92281 3.73493 6.60164 3.73493 6.27728C3.73493 5.95292 3.79887 5.63175 3.92308 5.33211C4.04724 5.03259 4.2292 4.76047 4.45856 4.5313C4.68774 4.30193 4.95986 4.11997 5.25938 3.99581C5.55901 3.8716 5.88019 3.80767 6.20455 3.80767C6.5289 3.80767 6.85008 3.8716 7.14971 3.99581C7.44934 4.12002 7.72156 4.30207 7.95078 4.53155L8.00219 4.58295C8.12326 4.70052 8.2766 4.77941 8.4427 4.80953C8.60982 4.83983 8.78218 4.81937 8.93755 4.7508C8.99214 4.72671 9.04965 4.71031 9.10844 4.70194C9.22129 4.63646 9.31797 4.54562 9.39051 4.43608C9.48184 4.29818 9.53094 4.13665 9.53182 3.97127V3.81819C9.53182 3.16358 9.79186 2.53579 10.2547 2.07292ZM12 9.65001C10.7021 9.65001 9.65 10.7021 9.65 12C9.65 13.2979 10.7021 14.35 12 14.35C13.2979 14.35 14.35 13.2979 14.35 12C14.35 10.7021 13.2979 9.65001 12 9.65001ZM8.35 12C8.35 9.98417 9.98416 8.35001 12 8.35001C14.0158 8.35001 15.65 9.98417 15.65 12C15.65 14.0158 14.0158 15.65 12 15.65C9.98416 15.65 8.35 14.0158 8.35 12Z", fill: "currentColor" }) });
Prefs24.displayName = "Prefs24";
const Memo$1p = reactExports.memo(Prefs24);
const Prefs16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("g", { clipPath: "url(#clip0_1049_4211)", children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.4158 10.4004C12.3801 10.2037 12.4042 10.001 12.4848 9.81818C12.5617 9.63892 12.6892 9.48605 12.8518 9.37836C13.0144 9.27068 13.205 9.21289 13.4 9.21212H13.4545C13.776 9.21212 14.0843 9.08441 14.3116 8.85709C14.539 8.62978 14.6667 8.32147 14.6667 8C14.6667 7.67852 14.539 7.37021 14.3116 7.1429C14.0843 6.91558 13.776 6.78787 13.4545 6.78787H13.3515C13.1565 6.7871 12.966 6.72931 12.8034 6.62163C12.6408 6.51394 12.5132 6.36107 12.4364 6.18181V6.13333C12.3557 5.95053 12.3316 5.74776 12.3673 5.55115C12.4029 5.35455 12.4966 5.17313 12.6364 5.0303L12.6727 4.99393C12.7854 4.88136 12.8748 4.74768 12.9358 4.60053C12.9968 4.45338 13.0282 4.29565 13.0282 4.13636C13.0282 3.97707 12.9968 3.81934 12.9358 3.67219C12.8748 3.52504 12.7854 3.39136 12.6727 3.27878C12.5602 3.16608 12.4265 3.07668 12.2793 3.01568C12.1322 2.95468 11.9744 2.92328 11.8152 2.92328C11.6559 2.92328 11.4981 2.95468 11.351 3.01568C11.2038 3.07668 11.0701 3.16608 10.9576 3.27878L10.9212 3.31515C10.7784 3.45487 10.597 3.54859 10.4004 3.58424C10.2038 3.61989 10.001 3.59582 9.81818 3.51515C9.63893 3.43832 9.48605 3.31076 9.37837 3.14816C9.27069 2.98556 9.2129 2.79502 9.21212 2.59999V2.54545C9.21212 2.22397 9.08441 1.91567 8.8571 1.68835C8.62978 1.46103 8.32147 1.33333 8 1.33333C7.67852 1.33333 7.37022 1.46103 7.1429 1.68835C6.91558 1.91567 6.78788 2.22397 6.78788 2.54545V2.64848C6.7871 2.8435 6.72931 3.03404 6.62163 3.19664C6.51395 3.35924 6.36107 3.48681 6.18182 3.56363H6.13333C5.95053 3.64431 5.74776 3.66837 5.55116 3.63273C5.35455 3.59708 5.17314 3.50335 5.0303 3.36363L4.99394 3.32727C4.88136 3.21457 4.74768 3.12516 4.60053 3.06416C4.45338 3.00317 4.29565 2.97177 4.13636 2.97177C3.97707 2.97177 3.81934 3.00317 3.67219 3.06416C3.52504 3.12516 3.39136 3.21457 3.27879 3.32727C3.16609 3.43984 3.07668 3.57352 3.01568 3.72067C2.95468 3.86782 2.92329 4.02555 2.92329 4.18484C2.92329 4.34414 2.95468 4.50186 3.01568 4.64901C3.07668 4.79616 3.16609 4.92985 3.27879 5.04242L3.31515 5.07878C3.45487 5.22162 3.5486 5.40304 3.58424 5.59964C3.61989 5.79624 3.59583 5.99902 3.51515 6.18181C3.44589 6.37014 3.32157 6.53327 3.15836 6.65C2.99515 6.76673 2.8006 6.83167 2.6 6.83636H2.54545C2.22398 6.83636 1.91567 6.96406 1.68835 7.19138C1.46104 7.4187 1.33333 7.72701 1.33333 8.04848C1.33333 8.36995 1.46104 8.67826 1.68835 8.90558C1.91567 9.1329 2.22398 9.2606 2.54545 9.2606H2.64848C2.84351 9.26138 3.03404 9.31917 3.19664 9.42685C3.35924 9.53453 3.48681 9.68741 3.56364 9.86666C3.64431 10.0495 3.66838 10.2522 3.63273 10.4488C3.59708 10.6454 3.50335 10.8269 3.36364 10.9697L3.32727 11.0061C3.21457 11.1186 3.12517 11.2523 3.06417 11.3995C3.00317 11.5466 2.97177 11.7043 2.97177 11.8636C2.97177 12.0229 3.00317 12.1807 3.06417 12.3278C3.12517 12.475 3.21457 12.6086 3.32727 12.7212C3.43984 12.8339 3.57353 12.9233 3.72068 12.9843C3.86783 13.0453 4.02556 13.0767 4.18485 13.0767C4.34414 13.0767 4.50187 13.0453 4.64902 12.9843C4.79617 12.9233 4.92985 12.8339 5.04242 12.7212L5.07879 12.6848C5.22162 12.5451 5.40304 12.4514 5.59964 12.4158C5.79625 12.3801 5.99902 12.4042 6.18182 12.4848C6.37014 12.5541 6.53327 12.6784 6.65001 12.8416C6.76674 13.0048 6.83167 13.1994 6.83636 13.4V13.4545C6.83636 13.776 6.96407 14.0843 7.19138 14.3116C7.4187 14.539 7.72701 14.6667 8.04848 14.6667C8.36996 14.6667 8.67827 14.539 8.90558 14.3116C9.1329 14.0843 9.2606 13.776 9.2606 13.4545V13.3515C9.26138 13.1565 9.31917 12.966 9.42685 12.8033C9.53453 12.6407 9.68741 12.5132 9.86667 12.4364C10.0495 12.3557 10.2522 12.3316 10.4488 12.3673C10.6454 12.4029 10.8269 12.4966 10.9697 12.6364L11.0061 12.6727C11.1186 12.7854 11.2523 12.8748 11.3995 12.9358C11.5466 12.9968 11.7043 13.0282 11.8636 13.0282C12.0229 13.0282 12.1807 12.9968 12.3278 12.9358C12.475 12.8748 12.6086 12.7854 12.7212 12.6727C12.8339 12.5601 12.9233 12.4265 12.9843 12.2793C13.0453 12.1322 13.0767 11.9744 13.0767 11.8151C13.0767 11.6559 13.0453 11.4981 12.9843 11.351C12.9233 11.2038 12.8339 11.0701 12.7212 10.9576L12.6848 10.9212C12.5451 10.7784 12.4514 10.597 12.4158 10.4004ZM10 8C10 9.10457 9.10457 10 8 10C6.89543 10 6 9.10457 6 8C6 6.89543 6.89543 6 8 6C9.10457 6 10 6.89543 10 8Z", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" }) }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "clip0_1049_4211", children: jsxRuntimeExports.jsx("rect", { width: 16, height: 16, fill: "white" }) }) })] });
Prefs16.displayName = "Prefs16";
const Memo$1o = reactExports.memo(Prefs16);
const More24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M12 13C12.5523 13 13 12.5523 13 12C13 11.4477 12.5523 11 12 11C11.4477 11 11 11.4477 11 12C11 12.5523 11.4477 13 12 13Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M5 13C5.55228 13 6 12.5523 6 12C6 11.4477 5.55228 11 5 11C4.44772 11 4 11.4477 4 12C4 12.5523 4.44772 13 5 13Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M19 13C19.5523 13 20 12.5523 20 12C20 11.4477 19.5523 11 19 11C18.4477 11 18 11.4477 18 12C18 12.5523 18.4477 13 19 13Z", fill: "currentColor" })] });
More24.displayName = "More24";
const Memo$1n = reactExports.memo(More24);
const More16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M13 7C13.5523 7 14 7.44772 14 8C14 8.55228 13.5523 9 13 9C12.4477 9 12 8.55228 12 8C12 7.44772 12.4477 7 13 7Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M8 7C8.55228 7 9 7.44772 9 8C9 8.55228 8.55228 9 8 9C7.44772 9 7 8.55228 7 8C7 7.44772 7.44772 7 8 7Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M3 7C3.55228 7 4 7.44772 4 8C4 8.55228 3.55228 9 3 9C2.44772 9 2 8.55228 2 8C2 7.44772 2.44772 7 3 7Z", fill: "currentColor" })] });
More16.displayName = "More16";
const Memo$1m = reactExports.memo(More16);
const Link16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.44729 10.5C4.43799 10.4994 4.42864 10.499 4.41927 10.4987C3.07625 10.4564 2 9.35371 2 8C2 6.64629 3.07625 5.54357 4.41927 5.50127C4.42864 5.50097 4.43798 5.50055 4.44729 5.5H4.5H6.5C6.77614 5.5 7 5.27614 7 5C7 4.72386 6.77614 4.5 6.5 4.5H5.38779H4.5H4.38868C4.38819 4.5 4.38779 4.5004 4.38779 4.5009C4.38779 4.50138 4.3874 4.50178 4.38692 4.50179C2.50626 4.56149 1 6.10484 1 8C1 9.89516 2.50626 11.4385 4.38692 11.4982C4.3874 11.4982 4.38779 11.4986 4.38779 11.4991C4.38779 11.4996 4.38819 11.5 4.38868 11.5H4.5H5.38779H6.5C6.77614 11.5 7 11.2761 7 11C7 10.7239 6.77614 10.5 6.5 10.5H4.5H4.44729ZM11.5 10.5H9.5C9.22386 10.5 9 10.7239 9 11C9 11.2761 9.22386 11.5 9.5 11.5H10.6122H11.5H11.6113C11.6118 11.5 11.6122 11.4996 11.6122 11.4991C11.6122 11.4986 11.6126 11.4982 11.6131 11.4982C13.4937 11.4385 15 9.89516 15 8C15 6.10484 13.4937 4.56149 11.6131 4.50179C11.6126 4.50178 11.6122 4.50138 11.6122 4.5009C11.6122 4.5004 11.6118 4.5 11.6113 4.5H11.5H10.6122H9.5C9.22386 4.5 9 4.72386 9 5C9 5.27614 9.22386 5.5 9.5 5.5H11.5H11.5527C11.562 5.50055 11.5714 5.50097 11.5807 5.50127C12.9237 5.54357 14 6.64629 14 8C14 9.35371 12.9237 10.4564 11.5807 10.4987C11.5714 10.499 11.562 10.4994 11.5527 10.5H11.5ZM11 8C11 7.72386 10.7761 7.5 10.5 7.5H5.5C5.22386 7.5 5 7.72386 5 8C5 8.27614 5.22386 8.5 5.5 8.5H10.5C10.7761 8.5 11 8.27614 11 8Z", fill: "currentColor" }) });
Link16.displayName = "Link16";
const Memo$1l = reactExports.memo(Link16);
const History16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 3C6.20275 3 4.62612 3.94834 3.74466 5.37319H5C5.27614 5.37319 5.5 5.59704 5.5 5.87319C5.5 6.14933 5.27614 6.37319 5 6.37319H2V3.5C2 3.22386 2.22386 3 2.5 3C2.77614 3 3 3.22386 3 3.5V4.68239C4.07457 3.06609 5.91237 2 8 2C11.3137 2 14 4.68629 14 8C14 11.3137 11.3137 14 8 14C5.66763 14 3.64699 12.6691 2.6545 10.7276C2.52881 10.4817 2.62624 10.1805 2.87212 10.0548C3.118 9.92911 3.41922 10.0265 3.54491 10.2724C4.37314 11.8926 6.05767 13 8 13C10.7614 13 13 10.7614 13 8C13 5.23858 10.7614 3 8 3ZM8 5C8.27614 5 8.5 5.22386 8.5 5.5V7.79289L10.3536 9.64645C10.5488 9.84171 10.5488 10.1583 10.3536 10.3536C10.1583 10.5488 9.84171 10.5488 9.64645 10.3536L7.5 8.20711V5.5C7.5 5.22386 7.72386 5 8 5Z", fill: "currentColor" }) });
History16.displayName = "History16";
const Memo$1k = reactExports.memo(History16);
const Community24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 2.65001C6.83614 2.65001 2.65 6.83614 2.65 12C2.65 17.1639 6.83614 21.35 12 21.35C17.1639 21.35 21.35 17.1639 21.35 12C21.35 6.83614 17.1639 2.65001 12 2.65001ZM1.35 12C1.35 6.11817 6.11817 1.35001 12 1.35001C17.8818 1.35001 22.65 6.11817 22.65 12C22.65 17.8818 17.8818 22.65 12 22.65C6.11817 22.65 1.35 17.8818 1.35 12Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 8.65001C10.1498 8.65001 8.65 10.1499 8.65 12C8.65 13.8502 10.1498 15.35 12 15.35C13.8502 15.35 15.35 13.8502 15.35 12C15.35 10.1499 13.8502 8.65001 12 8.65001ZM7.35 12C7.35 9.43188 9.43187 7.35001 12 7.35001C14.5681 7.35001 16.65 9.43188 16.65 12C16.65 14.5681 14.5681 16.65 12 16.65C9.43187 16.65 7.35 14.5681 7.35 12Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.47038 4.47039C4.72422 4.21655 5.13578 4.21655 5.38962 4.47039L9.62962 8.71039C9.88346 8.96423 9.88346 9.37578 9.62962 9.62963C9.37578 9.88347 8.96422 9.88347 8.71038 9.62963L4.47038 5.38963C4.21654 5.13578 4.21654 4.72423 4.47038 4.47039ZM19.5296 4.47039C19.7835 4.72423 19.7835 5.13578 19.5296 5.38963L18.8203 6.09898L15.2896 9.62963C15.0358 9.88347 14.6242 9.88347 14.3704 9.62963C14.1165 9.37578 14.1165 8.96423 14.3704 8.71039L18.6104 4.47039C18.8642 4.21655 19.2758 4.21655 19.5296 4.47039ZM9.62962 14.3704C9.88346 14.6242 9.88346 15.0358 9.62962 15.2896L5.38962 19.5296C5.13578 19.7835 4.72422 19.7835 4.47038 19.5296C4.21654 19.2758 4.21654 18.8642 4.47038 18.6104L8.71038 14.3704C8.96422 14.1165 9.37578 14.1165 9.62962 14.3704ZM14.3704 14.3704C14.6242 14.1165 15.0358 14.1165 15.2896 14.3704L19.5296 18.6104C19.7835 18.8642 19.7835 19.2758 19.5296 19.5296C19.2758 19.7835 18.8642 19.7835 18.6104 19.5296L14.3704 15.2896C14.1165 15.0358 14.1165 14.6242 14.3704 14.3704Z", fill: "currentColor" })] });
Community24.displayName = "Community24";
const Memo$1j = reactExports.memo(Community24);
const Users24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.3703 2.96878C15.4594 2.62101 15.8135 2.41128 16.1612 2.50032C17.1615 2.75642 18.048 3.33813 18.6811 4.15375C19.3142 4.96938 19.6578 5.97251 19.6578 7.00501C19.6578 8.0375 19.3142 9.04064 18.6811 9.85626C18.048 10.6719 17.1615 11.2536 16.1612 11.5097C15.8135 11.5987 15.4594 11.389 15.3703 11.0412C15.2813 10.6935 15.491 10.3394 15.8388 10.2503C16.5594 10.0658 17.1981 9.64673 17.6542 9.05913C18.1103 8.47154 18.3578 7.74885 18.3578 7.00501C18.3578 6.26116 18.1103 5.53848 17.6542 4.95088C17.1981 4.36328 16.5594 3.9442 15.8388 3.75969C15.491 3.67065 15.2813 3.31655 15.3703 2.96878ZM1.71195 15.712C2.584 14.8399 3.76674 14.35 5 14.35H13C14.2333 14.35 15.416 14.8399 16.288 15.712C17.1601 16.584 17.65 17.7668 17.65 19V21C17.65 21.359 17.359 21.65 17 21.65C16.641 21.65 16.35 21.359 16.35 21V19C16.35 18.1115 15.9971 17.2594 15.3688 16.6312C14.7406 16.003 13.8885 15.65 13 15.65H5C4.11152 15.65 3.25944 16.003 2.63119 16.6312C2.00294 17.2594 1.65 18.1115 1.65 19V21C1.65 21.359 1.35898 21.65 0.999998 21.65C0.641013 21.65 0.349998 21.359 0.349998 21V19C0.349998 17.7668 0.839908 16.584 1.71195 15.712ZM19.3706 14.9675C19.4604 14.6199 19.8149 14.4109 20.1625 14.5006C21.1601 14.7582 22.0439 15.3398 22.6751 16.1541C23.3063 16.9684 23.6492 17.9692 23.65 18.9995V21C23.65 21.359 23.359 21.65 23 21.65C22.641 21.65 22.35 21.359 22.35 21V19.0005C22.3494 18.2582 22.1024 17.5372 21.6476 16.9506C21.1929 16.3639 20.5562 15.9449 19.8375 15.7594C19.4899 15.6696 19.2809 15.3151 19.3706 14.9675Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9 3.65001C7.14984 3.65001 5.65 5.14985 5.65 7.00001C5.65 8.85016 7.14984 10.35 9 10.35C10.8502 10.35 12.35 8.85016 12.35 7.00001C12.35 5.14985 10.8502 3.65001 9 3.65001ZM4.35 7.00001C4.35 4.43188 6.43187 2.35001 9 2.35001C11.5681 2.35001 13.65 4.43188 13.65 7.00001C13.65 9.56813 11.5681 11.65 9 11.65C6.43187 11.65 4.35 9.56813 4.35 7.00001Z", fill: "currentColor" })] });
Users24.displayName = "Users24";
const Memo$1i = reactExports.memo(Users24);
const People16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.9603 9.61389C12.0294 9.34652 12.3021 9.18573 12.5695 9.25477C13.1535 9.40556 13.6709 9.74603 14.0404 10.2227C14.4099 10.6994 14.6107 11.2854 14.6111 11.8885V13C14.6111 13.2761 14.3873 13.5 14.1111 13.5C13.835 13.5 13.6111 13.2761 13.6111 13V11.8893C13.6108 11.5077 13.4838 11.1369 13.25 10.8354C13.0163 10.5338 12.6889 10.3184 12.3195 10.223C12.0521 10.154 11.8913 9.88127 11.9603 9.61389Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.18618 9.96398C2.6967 9.45346 3.38911 9.16666 4.11108 9.16666H8.55553C9.27751 9.16666 9.96992 9.45346 10.4804 9.96398C10.9909 10.4745 11.2778 11.1669 11.2778 11.8889V13C11.2778 13.2761 11.0539 13.5 10.7778 13.5C10.5016 13.5 10.2778 13.2761 10.2778 13V11.8889C10.2778 11.4321 10.0963 10.9941 9.77332 10.6711C9.45034 10.3481 9.01229 10.1667 8.55553 10.1667H4.11108C3.65432 10.1667 3.21627 10.3481 2.89329 10.6711C2.57031 10.9941 2.38886 11.4321 2.38886 11.8889V13C2.38886 13.2761 2.165 13.5 1.88886 13.5C1.61272 13.5 1.38886 13.2761 1.38886 13V11.8889C1.38886 11.1669 1.67567 10.4745 2.18618 9.96398Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.73774 2.94818C9.80623 2.68067 10.0786 2.51934 10.3461 2.58783C10.9317 2.73776 11.4507 3.07831 11.8213 3.55579C12.192 4.03327 12.3931 4.62053 12.3931 5.22498C12.3931 5.82943 12.192 6.41669 11.8213 6.89417C11.4507 7.37166 10.9317 7.71221 10.3461 7.86213C10.0786 7.93063 9.80623 7.76929 9.73774 7.50178C9.66924 7.23427 9.83058 6.96188 10.0981 6.89338C10.4685 6.79853 10.7969 6.58308 11.0314 6.281C11.2659 5.97892 11.3931 5.60739 11.3931 5.22498C11.3931 4.84258 11.2659 4.47105 11.0314 4.16896C10.7969 3.86688 10.4685 3.65143 10.0981 3.55658C9.83058 3.48809 9.66924 3.2157 9.73774 2.94818Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.33331 3.5C5.38216 3.5 4.61109 4.27107 4.61109 5.22222C4.61109 6.17338 5.38216 6.94444 6.33331 6.94444C7.28447 6.94444 8.05554 6.17338 8.05554 5.22222C8.05554 4.27107 7.28447 3.5 6.33331 3.5ZM3.61109 5.22222C3.61109 3.71878 4.82987 2.5 6.33331 2.5C7.83676 2.5 9.05554 3.71878 9.05554 5.22222C9.05554 6.72566 7.83676 7.94444 6.33331 7.94444C4.82987 7.94444 3.61109 6.72566 3.61109 5.22222Z", fill: "currentColor" })] });
People16.displayName = "People16";
const Memo$1h = reactExports.memo(People16);
const Area16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.83334 3.49999H11.1667V4.49999H4.83334V3.49999ZM4.50001 4.83332V11.1667H3.50001V4.83332H4.50001ZM12.5 4.83332V11.1667H11.5V4.83332H12.5ZM4.83334 11.5H11.1667V12.5H4.83334V11.5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.66667 11.6667V12.3333H4.33334V11.6667H3.66667ZM3.16667 10.6667C2.89053 10.6667 2.66667 10.8905 2.66667 11.1667V12.8333C2.66667 13.1095 2.89053 13.3333 3.16667 13.3333H4.83334C5.10948 13.3333 5.33334 13.1095 5.33334 12.8333V11.1667C5.33334 10.8905 5.10948 10.6667 4.83334 10.6667H3.16667Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.66667 3.66666V4.33332H4.33334V3.66666H3.66667ZM3.16667 2.66666C2.89053 2.66666 2.66667 2.89051 2.66667 3.16666V4.83332C2.66667 5.10947 2.89053 5.33332 3.16667 5.33332H4.83334C5.10948 5.33332 5.33334 5.10947 5.33334 4.83332V3.16666C5.33334 2.89051 5.10948 2.66666 4.83334 2.66666H3.16667Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.6667 3.66666V4.33332H12.3333V3.66666H11.6667ZM11.1667 2.66666C10.8905 2.66666 10.6667 2.89051 10.6667 3.16666V4.83332C10.6667 5.10947 10.8905 5.33332 11.1667 5.33332H12.8333C13.1095 5.33332 13.3333 5.10947 13.3333 4.83332V3.16666C13.3333 2.89051 13.1095 2.66666 12.8333 2.66666H11.1667Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.6667 11.6667V12.3333H12.3333V11.6667H11.6667ZM11.1667 10.6667C10.8905 10.6667 10.6667 10.8905 10.6667 11.1667V12.8333C10.6667 13.1095 10.8905 13.3333 11.1667 13.3333H12.8333C13.1095 13.3333 13.3333 13.1095 13.3333 12.8333V11.1667C13.3333 10.8905 13.1095 10.6667 12.8333 10.6667H11.1667Z", fill: "currentColor" })] });
Area16.displayName = "Area16";
const Memo$1g = reactExports.memo(Area16);
const Map16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.7152 2.08904C1.84999 1.99563 2.02201 1.97426 2.17556 2.03184L6 3.466L9.82444 2.03184C9.93763 1.98939 10.0624 1.98939 10.1756 2.03184L14.1756 3.53184C14.3707 3.60502 14.5 3.79158 14.5 4V13.5C14.5 13.664 14.4196 13.8176 14.2848 13.911C14.15 14.0044 13.978 14.0257 13.8244 13.9682L10 12.534L6.17556 13.9682C6.06237 14.0106 5.93763 14.0106 5.82444 13.9682L1.82444 12.4682C1.62929 12.395 1.5 12.2084 1.5 12V2.5C1.5 2.33601 1.58042 2.18245 1.7152 2.08904ZM10.5 11.6535L13.5 12.7785V4.3465L10.5 3.2215V11.6535ZM9.5 3.2215V11.6535L6.5 12.7785V4.3465L9.5 3.2215ZM5.5 4.3465L2.5 3.2215V11.6535L5.5 12.7785V4.3465Z", fill: "currentColor" }) });
Map16.displayName = "Map16";
const Memo$1f = reactExports.memo(Map16);
const Map24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.62977 3.21574C2.80499 3.09431 3.02862 3.06653 3.22824 3.14138L9.00001 5.30579L14.7718 3.14138C14.9189 3.0862 15.0811 3.0862 15.2282 3.14138L21.2282 5.39138C21.4819 5.48652 21.65 5.72905 21.65 5.99999V20.25C21.65 20.4632 21.5455 20.6628 21.3702 20.7842C21.195 20.9057 20.9714 20.9335 20.7718 20.8586L15 18.6942L9.22824 20.8586C9.08109 20.9138 8.91893 20.9138 8.77178 20.8586L2.77178 18.6086C2.51808 18.5135 2.35001 18.2709 2.35001 18V3.74999C2.35001 3.53681 2.45455 3.33717 2.62977 3.21574ZM15.65 17.5495L20.35 19.312V6.45044L15.65 4.68794V17.5495ZM14.35 4.68794V17.5495L9.65001 19.312V6.45044L14.35 4.68794ZM8.35001 6.45044L3.65001 4.68794V17.5495L8.35001 19.312V6.45044Z", fill: "currentColor" }) });
Map24.displayName = "Map24";
const Memo$1e = reactExports.memo(Map24);
const List24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.35 6.00001C2.35 5.64102 2.64101 5.35001 3 5.35001H3.01C3.36898 5.35001 3.66 5.64102 3.66 6.00001C3.66 6.35899 3.36898 6.65001 3.01 6.65001H3C2.64101 6.65001 2.35 6.35899 2.35 6.00001ZM7.35 6.00001C7.35 5.64102 7.64101 5.35001 8 5.35001H21C21.359 5.35001 21.65 5.64102 21.65 6.00001C21.65 6.35899 21.359 6.65001 21 6.65001H8C7.64101 6.65001 7.35 6.35899 7.35 6.00001ZM2.35 12C2.35 11.641 2.64101 11.35 3 11.35H3.01C3.36898 11.35 3.66 11.641 3.66 12C3.66 12.359 3.36898 12.65 3.01 12.65H3C2.64101 12.65 2.35 12.359 2.35 12ZM7.35 12C7.35 11.641 7.64101 11.35 8 11.35H21C21.359 11.35 21.65 11.641 21.65 12C21.65 12.359 21.359 12.65 21 12.65H8C7.64101 12.65 7.35 12.359 7.35 12ZM2.35 18C2.35 17.641 2.64101 17.35 3 17.35H3.01C3.36898 17.35 3.66 17.641 3.66 18C3.66 18.359 3.36898 18.65 3.01 18.65H3C2.64101 18.65 2.35 18.359 2.35 18ZM7.35 18C7.35 17.641 7.64101 17.35 8 17.35H21C21.359 17.35 21.65 17.641 21.65 18C21.65 18.359 21.359 18.65 21 18.65H8C7.64101 18.65 7.35 18.359 7.35 18Z", fill: "currentColor" }) });
List24.displayName = "List24";
const Memo$1d = reactExports.memo(List24);
const Share24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18 2.65001C16.7021 2.65001 15.65 3.70214 15.65 5.00001C15.65 5.41394 15.757 5.80288 15.9449 6.14067C15.9542 6.15413 15.963 6.16804 15.9714 6.18239C15.9797 6.19662 15.9874 6.21104 15.9945 6.22562C16.4076 6.90003 17.1512 7.35001 18 7.35001C19.2979 7.35001 20.35 6.29788 20.35 5.00001C20.35 3.70214 19.2979 2.65001 18 2.65001ZM15.2247 7.37076C15.8941 8.15372 16.8891 8.65001 18 8.65001C20.0158 8.65001 21.65 7.01585 21.65 5.00001C21.65 2.98417 20.0158 1.35001 18 1.35001C15.9842 1.35001 14.35 2.98417 14.35 5.00001C14.35 5.43842 14.4273 5.85878 14.569 6.24821L8.77535 9.62926C8.1059 8.8463 7.11091 8.35001 6.00001 8.35001C3.98417 8.35001 2.35001 9.98417 2.35001 12C2.35001 14.0158 3.98417 15.65 6.00001 15.65C7.11105 15.65 8.10614 15.1536 8.7756 14.3705L14.5706 17.7474C14.4279 18.138 14.35 18.5599 14.35 19C14.35 21.0158 15.9842 22.65 18 22.65C20.0158 22.65 21.65 21.0158 21.65 19C21.65 16.9842 20.0158 15.35 18 15.35C16.8908 15.35 15.8972 15.8448 15.2277 16.6257L9.43114 13.2478C9.57276 12.8585 9.65001 12.4383 9.65001 12C9.65001 11.5616 9.57271 11.1412 9.431 10.7518L15.2247 7.37076ZM8.00549 10.7744C8.0126 10.789 8.0203 10.8034 8.02861 10.8176C8.03698 10.832 8.04583 10.8459 8.0551 10.8593C8.24298 11.1971 8.35001 11.5861 8.35001 12C8.35001 12.4139 8.24299 12.8029 8.05511 13.1407C8.04575 13.1542 8.03684 13.1683 8.0284 13.1827C8.02017 13.1969 8.01254 13.2112 8.00549 13.2256C7.59246 13.9 6.84878 14.35 6.00001 14.35C4.70214 14.35 3.65001 13.2979 3.65001 12C3.65001 10.7021 4.70214 9.65001 6.00001 9.65001C6.84878 9.65001 7.59245 10.1 8.00549 10.7744ZM15.9198 17.9058C15.9424 17.8785 15.9632 17.8489 15.9816 17.8173C15.9995 17.7866 16.0145 17.7551 16.0269 17.723C16.4457 17.0772 17.173 16.65 18 16.65C19.2979 16.65 20.35 17.7021 20.35 19C20.35 20.2979 19.2979 21.35 18 21.35C16.7021 21.35 15.65 20.2979 15.65 19C15.65 18.6049 15.7475 18.2326 15.9198 17.9058Z", fill: "currentColor" }) });
Share24.displayName = "Share24";
const Memo$1c = reactExports.memo(Share24);
const Image24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 3.65001C4.25441 3.65001 3.65 4.25442 3.65 5.00001V19C3.65 19.7456 4.25441 20.35 5 20.35H19C19.7456 20.35 20.35 19.7456 20.35 19V5.00001C20.35 4.25442 19.7456 3.65001 19 3.65001H5ZM2.35 5.00001C2.35 3.53645 3.53644 2.35001 5 2.35001H19C20.4636 2.35001 21.65 3.53645 21.65 5.00001V19C21.65 20.4636 20.4636 21.65 19 21.65H5C3.53644 21.65 2.35 20.4636 2.35 19V5.00001Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.5404 9.54039C15.7942 9.28655 16.2058 9.28655 16.4596 9.54039L21.4596 14.5404C21.7135 14.7942 21.7135 15.2058 21.4596 15.4596C21.2058 15.7135 20.7942 15.7135 20.5404 15.4596L16 10.9192L5.45962 21.4596C5.20578 21.7135 4.79422 21.7135 4.54038 21.4596C4.28654 21.2058 4.28654 20.7942 4.54038 20.5404L15.5404 9.54039Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.5 7.65001C8.03056 7.65001 7.65 8.03056 7.65 8.50001C7.65 8.96945 8.03056 9.35001 8.5 9.35001C8.96944 9.35001 9.35 8.96945 9.35 8.50001C9.35 8.03056 8.96944 7.65001 8.5 7.65001ZM6.35 8.50001C6.35 7.31259 7.31259 6.35001 8.5 6.35001C9.68741 6.35001 10.65 7.31259 10.65 8.50001C10.65 9.68742 9.68741 10.65 8.5 10.65C7.31259 10.65 6.35 9.68742 6.35 8.50001Z", fill: "currentColor" })] });
Image24.displayName = "Image24";
const Memo$1b = reactExports.memo(Image24);
const Image16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.33333 2.5C2.8731 2.5 2.5 2.8731 2.5 3.33333V12.6667C2.5 13.1269 2.8731 13.5 3.33333 13.5H12.6667C13.1269 13.5 13.5 13.1269 13.5 12.6667V3.33333C13.5 2.8731 13.1269 2.5 12.6667 2.5H3.33333ZM1.5 3.33333C1.5 2.32081 2.32081 1.5 3.33333 1.5H12.6667C13.6792 1.5 14.5 2.32081 14.5 3.33333V12.6667C14.5 13.6792 13.6792 14.5 12.6667 14.5H3.33333C2.32081 14.5 1.5 13.6792 1.5 12.6667V3.33333Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.3131 6.31311C10.5084 6.11785 10.825 6.11785 11.0202 6.31311L14.3536 9.64645C14.5488 9.84171 14.5488 10.1583 14.3536 10.3536C14.1583 10.5488 13.8417 10.5488 13.6464 10.3536L10.6667 7.37377L3.68689 14.3536C3.49163 14.5488 3.17504 14.5488 2.97978 14.3536C2.78452 14.1583 2.78452 13.8417 2.97978 13.6464L10.3131 6.31311Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.66666 5.16667C5.39052 5.16667 5.16666 5.39052 5.16666 5.66667C5.16666 5.94281 5.39052 6.16667 5.66666 6.16667C5.94281 6.16667 6.16666 5.94281 6.16666 5.66667C6.16666 5.39052 5.94281 5.16667 5.66666 5.16667ZM4.16666 5.66667C4.16666 4.83824 4.83824 4.16667 5.66666 4.16667C6.49509 4.16667 7.16666 4.83824 7.16666 5.66667C7.16666 6.49509 6.49509 7.16667 5.66666 7.16667C4.83824 7.16667 4.16666 6.49509 4.16666 5.66667Z", fill: "currentColor" })] });
Image16.displayName = "Image16";
const Memo$1a = reactExports.memo(Image16);
const Globe24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 2.65001C6.83614 2.65001 2.65 6.83614 2.65 12C2.65 17.1639 6.83614 21.35 12 21.35C17.1639 21.35 21.35 17.1639 21.35 12C21.35 6.83614 17.1639 2.65001 12 2.65001ZM1.35 12C1.35 6.11817 6.11817 1.35001 12 1.35001C17.8818 1.35001 22.65 6.11817 22.65 12C22.65 17.8818 17.8818 22.65 12 22.65C6.11817 22.65 1.35 17.8818 1.35 12Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 1.35001C12.1826 1.35001 12.3568 1.42681 12.4799 1.56163C14.944 4.25925 16.4029 7.71589 16.6239 11.35H22C22.359 11.35 22.65 11.641 22.65 12C22.65 12.359 22.359 12.65 22 12.65H16.6239C16.4029 16.2841 14.944 19.7408 12.4799 22.4384C12.3568 22.5732 12.1826 22.65 12 22.65C11.8174 22.65 11.6432 22.5732 11.5201 22.4384C9.056 19.7408 7.59714 16.2841 7.37611 12.65H2C1.64101 12.65 1.35 12.359 1.35 12C1.35 11.641 1.64101 11.35 2 11.35H7.37611C7.59714 7.71589 9.056 4.25925 11.5201 1.56163C11.6432 1.42681 11.8174 1.35001 12 1.35001ZM8.67873 12.65C8.88182 15.716 10.0442 18.6407 12 21.0091C13.9558 18.6407 15.1182 15.716 15.3213 12.65H8.67873ZM15.3213 11.35H8.67873C8.88182 8.28401 10.0442 5.35934 12 2.99088C13.9558 5.35934 15.1182 8.28401 15.3213 11.35Z", fill: "currentColor" })] });
Globe24.displayName = "Globe24";
const Memo$19 = reactExports.memo(Globe24);
const RouteDirection24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M8.06667 4.5C8.06667 5.88071 6.93246 7 5.53333 7C4.13421 7 3 5.88071 3 4.5C3 3.11929 4.13421 2 5.53333 2C6.93246 2 8.06667 3.11929 8.06667 4.5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M20.7333 19.5C20.7333 20.8807 19.5991 22 18.2 22C16.8009 22 15.6667 20.8807 15.6667 19.5C15.6667 18.1193 16.8009 17 18.2 17C19.5991 17 20.7333 18.1193 20.7333 19.5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.35 4.50001C9.35 4.14102 9.64102 3.85001 10 3.85001H13.2308C14.5512 3.85001 15.7929 4.18802 16.7188 4.93039C17.6635 5.68784 18.2167 6.81779 18.2167 8.25001C18.2167 9.68222 17.6635 10.8122 16.7188 11.5696C15.7929 12.312 14.5512 12.65 13.2308 12.65L8.70038 12.65L8.7 12L8.70003 11.35L13.2308 11.35C14.3463 11.35 15.2725 11.063 15.9056 10.5554C16.5199 10.0628 16.9167 9.31779 16.9167 8.25001C16.9167 7.18222 16.5199 6.43718 15.9056 5.94462C15.2725 5.43699 14.3463 5.15001 13.2308 5.15001H10C9.64102 5.15001 9.35 4.85899 9.35 4.50001ZM11.9051 18.85H8.7C7.53068 18.85 6.57986 18.5606 5.9361 18.0523C5.3128 17.5602 4.91667 16.8172 4.91667 15.75C4.91667 14.6828 5.3128 13.9398 5.9361 13.4477C6.57986 12.9395 7.53106 12.65 8.70038 12.65L8.7 12L8.70003 11.35C7.33602 11.35 6.07015 11.6856 5.13057 12.4273C4.17054 13.1852 3.61667 14.3172 3.61667 15.75C3.61667 17.1828 4.17054 18.3148 5.13057 19.0727C6.07015 19.8145 7.33599 20.15 8.7 20.15H11.9051L10.1226 21.8923C9.86586 22.1432 9.86117 22.5548 10.1121 22.8115C10.363 23.0682 10.7746 23.0729 11.0313 22.822L13.9543 19.9648C14.0795 19.8425 14.15 19.675 14.15 19.5C14.15 19.325 14.0795 19.1575 13.9543 19.0352L11.0313 16.178C10.7746 15.9271 10.363 15.9318 10.1121 16.1885C9.86117 16.4452 9.86586 16.8568 10.1226 17.1077L11.9051 18.85Z", fill: "currentColor" })] });
RouteDirection24.displayName = "RouteDirection24";
const Memo$18 = reactExports.memo(RouteDirection24);
const Route24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M8.72222 5.74999C8.72222 6.90058 7.77705 7.83332 6.61111 7.83332C5.44518 7.83332 4.5 6.90058 4.5 5.74999C4.5 4.5994 5.44518 3.66666 6.61111 3.66666C7.77705 3.66666 8.72222 4.5994 8.72222 5.74999Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M19.2778 18.25C19.2778 19.4006 18.3326 20.3333 17.1667 20.3333C16.0007 20.3333 15.0556 19.4006 15.0556 18.25C15.0556 17.0994 16.0007 16.1667 17.1667 16.1667C18.3326 16.1667 19.2778 17.0994 19.2778 18.25Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.0939 6.40001V5.10001H13.0256C14.143 5.10001 15.2041 5.38594 16.0001 6.02414C16.8148 6.67742 17.2889 7.65112 17.2889 8.87501C17.2889 10.0989 16.8148 11.0726 16.0001 11.7259C15.2041 12.3641 14.143 12.65 13.0256 12.65L9.25007 12.65L9.24999 12L9.25002 11.35L13.0256 11.35C13.9382 11.35 14.6837 11.1151 15.1869 10.7116C15.6713 10.3233 15.9889 9.73446 15.9889 8.87501C15.9889 8.01556 15.6713 7.42676 15.1869 7.03837C14.6837 6.63491 13.9382 6.40001 13.0256 6.40001H7.0939ZM6.20833 12.2711C7.01597 11.6335 8.09712 11.35 9.25002 11.35L9.24999 12L9.25007 12.65C8.29186 12.65 7.52568 12.8874 7.01387 13.2914C6.52251 13.6793 6.20555 14.2662 6.20555 15.125C6.20555 15.9839 6.52251 16.5707 7.01387 16.9586C7.52568 17.3626 8.29178 17.6 9.24999 17.6H15.9999V18.9H9.24999C8.09709 18.9 7.01597 18.6165 6.20833 17.9789C5.38025 17.3252 4.90555 16.3495 4.90555 15.125C4.90555 13.9005 5.38025 12.9248 6.20833 12.2711Z", fill: "currentColor" })] });
Route24.displayName = "Route24";
const Memo$17 = reactExports.memo(Route24);
const LayerUrban = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M12 5.1547L17.9282 8.57735L17.9282 15.4226L12 18.8453L6.0718 15.4227L6.0718 8.57735L12 5.1547Z", fill: "white", stroke: "#FF6D00", strokeWidth: 2 }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17.1962 9.57735C17.1962 9.22008 17.0056 8.88996 16.6962 8.71132L12.5 6.28868C12.1906 6.11004 11.8094 6.11004 11.5 6.28868L7.30385 8.71132C6.99445 8.88996 6.80385 9.22008 6.80385 9.57735V14.4226C6.80385 14.7799 6.99445 15.11 7.30385 15.2887L11.5 17.7113C11.8094 17.89 12.1906 17.89 12.5 17.7113L16.6962 15.2887C17.0056 15.11 17.1962 14.7799 17.1962 14.4226V9.57735ZM14.9417 10.879C14.9417 10.5217 14.7511 10.1916 14.4417 10.0129L12.5 8.8919C12.1906 8.71327 11.8094 8.71327 11.5 8.8919L9.55831 10.0129C9.24891 10.1916 9.05831 10.5217 9.05831 10.879V13.121C9.05831 13.4783 9.24891 13.8084 9.55831 13.9871L11.5 15.1081C11.8094 15.2867 12.1906 15.2867 12.5 15.1081L14.4417 13.9871C14.7511 13.8084 14.9417 13.4783 14.9417 13.121V10.879Z", fill: "#FFD4B5" })] });
LayerUrban.displayName = "LayerUrban";
const Memo$16 = reactExports.memo(LayerUrban);
const LayerPeriphery = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M12 5.1547L17.9282 8.57735L17.9282 15.4226L12 18.8453L6.0718 15.4227L6.0718 8.57735L12 5.1547Z", fill: "white", stroke: "#24D225", strokeWidth: 2 }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17.1962 9.57735C17.1962 9.22008 17.0056 8.88996 16.6962 8.71132L12.5 6.28868C12.1906 6.11004 11.8094 6.11004 11.5 6.28868L7.30385 8.71132C6.99445 8.88996 6.80385 9.22008 6.80385 9.57735V14.4226C6.80385 14.7799 6.99445 15.11 7.30385 15.2887L11.5 17.7113C11.8094 17.89 12.1906 17.89 12.5 17.7113L16.6962 15.2887C17.0056 15.11 17.1962 14.7799 17.1962 14.4226V9.57735ZM14.9417 10.879C14.9417 10.5217 14.7511 10.1916 14.4417 10.0129L12.5 8.8919C12.1906 8.71327 11.8094 8.71327 11.5 8.8919L9.55831 10.0129C9.24891 10.1916 9.05831 10.5217 9.05831 10.879V13.121C9.05831 13.4783 9.24891 13.8084 9.55831 13.9871L11.5 15.1081C11.8094 15.2867 12.1906 15.2867 12.5 15.1081L14.4417 13.9871C14.7511 13.8084 14.9417 13.4783 14.9417 13.121V10.879Z", fill: "#9DF09E" })] });
LayerPeriphery.displayName = "LayerPeriphery";
const Memo$15 = reactExports.memo(LayerPeriphery);
const LayerLegend = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("rect", { x: 2, y: 2, width: 12, height: 12, rx: 6, fill: "currentColor" }) });
LayerLegend.displayName = "LayerLegend";
const Memo$14 = reactExports.memo(LayerLegend);
const LayerLegendSmall = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("rect", { x: 4, y: 4, width: 8, height: 8, rx: 4, fill: "currentColor" }) });
LayerLegendSmall.displayName = "LayerLegendSmall";
const Memo$13 = reactExports.memo(LayerLegendSmall);
const User24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3.65001C7.38843 3.65001 3.65001 7.38843 3.65001 12C3.65001 13.7427 4.18386 15.3607 5.09694 16.6993C5.98766 14.8398 7.60752 13.3958 9.58672 12.7384C8.82837 12.0696 8.35001 11.0907 8.35001 10C8.35001 7.98417 9.98417 6.35001 12 6.35001C14.0158 6.35001 15.65 7.98417 15.65 10C15.65 11.0907 15.1716 12.0696 14.4133 12.7384C16.3925 13.3958 18.0124 14.8398 18.9031 16.6993C19.8162 15.3607 20.35 13.7427 20.35 12C20.35 7.38843 16.6116 3.65001 12 3.65001ZM17.9719 17.836C17.0869 15.3939 14.7463 13.65 12 13.65C9.25369 13.65 6.91313 15.3939 6.02809 17.836C7.54417 19.3872 9.65965 20.35 12 20.35C14.3404 20.35 16.4558 19.3872 17.9719 17.836ZM2.35001 12C2.35001 6.67046 6.67046 2.35001 12 2.35001C17.3296 2.35001 21.65 6.67046 21.65 12C21.65 17.3296 17.3296 21.65 12 21.65C6.67046 21.65 2.35001 17.3296 2.35001 12ZM12 7.65001C10.7021 7.65001 9.65001 8.70214 9.65001 10C9.65001 11.2979 10.7021 12.35 12 12.35C13.2979 12.35 14.35 11.2979 14.35 10C14.35 8.70214 13.2979 7.65001 12 7.65001Z", fill: "currentColor" }) });
User24.displayName = "User24";
const Memo$12 = reactExports.memo(User24);
const InfoOutline16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.00002 2.66669C5.0545 2.66669 2.66669 5.0545 2.66669 8.00002C2.66669 10.9455 5.0545 13.3334 8.00002 13.3334C10.9455 13.3334 13.3334 10.9455 13.3334 8.00002C13.3334 5.0545 10.9455 2.66669 8.00002 2.66669ZM1.66669 8.00002C1.66669 4.50222 4.50222 1.66669 8.00002 1.66669C11.4978 1.66669 14.3334 4.50222 14.3334 8.00002C14.3334 11.4978 11.4978 14.3334 8.00002 14.3334C4.50222 14.3334 1.66669 11.4978 1.66669 8.00002Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 6.87481C8.27614 6.87481 8.5 7.09867 8.5 7.37481V11C8.5 11.2761 8.27614 11.5 8 11.5C7.72386 11.5 7.5 11.2761 7.5 11V7.37481C7.5 7.09867 7.72386 6.87481 8 6.87481Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 4.5C8.27614 4.5 8.5 4.72386 8.5 5V5.01C8.5 5.28614 8.27614 5.51 8 5.51C7.72386 5.51 7.5 5.28614 7.5 5.01V5C7.5 4.72386 7.72386 4.5 8 4.5Z", fill: "currentColor" })] });
InfoOutline16.displayName = "InfoOutline16";
const Memo$11 = reactExports.memo(InfoOutline16);
const Record16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.00002 1.66669C4.50222 1.66669 1.66669 4.50222 1.66669 8.00002C1.66669 11.4978 4.50222 14.3334 8.00002 14.3334C11.4978 14.3334 14.3334 11.4978 14.3334 8.00002C14.3334 4.50222 11.4978 1.66669 8.00002 1.66669ZM2.66669 8.00002C2.66669 5.0545 5.0545 2.66669 8.00002 2.66669C10.9455 2.66669 13.3334 5.0545 13.3334 8.00002C13.3334 10.9455 10.9455 13.3334 8.00002 13.3334C5.0545 13.3334 2.66669 10.9455 2.66669 8.00002Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M11 8C11 9.65685 9.65685 11 8 11C6.34315 11 5 9.65685 5 8C5 6.34315 6.34315 5 8 5C9.65685 5 11 6.34315 11 8Z", fill: "currentColor" })] });
Record16.displayName = "Record16";
const Memo$10 = reactExports.memo(Record16);
const InfoErrorOutline16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.00002 13.3334C10.9455 13.3334 13.3334 10.9455 13.3334 8.00002C13.3334 5.0545 10.9455 2.66669 8.00002 2.66669C5.0545 2.66669 2.66669 5.0545 2.66669 8.00002C2.66669 10.9455 5.0545 13.3334 8.00002 13.3334ZM14.3334 8.00002C14.3334 11.4978 11.4978 14.3334 8.00002 14.3334C4.50222 14.3334 1.66669 11.4978 1.66669 8.00002C1.66669 4.50222 4.50222 1.66669 8.00002 1.66669C11.4978 1.66669 14.3334 4.50222 14.3334 8.00002Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.00004 9.12523C7.7239 9.12523 7.50004 8.90137 7.50004 8.62523V5.00004C7.50004 4.7239 7.7239 4.50004 8.00004 4.50004C8.27618 4.50004 8.50004 4.7239 8.50004 5.00004V8.62523C8.50004 8.90137 8.27618 9.12523 8.00004 9.12523Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.00004 11.5C7.7239 11.5 7.50004 11.2762 7.50004 11V10.99C7.50004 10.7139 7.7239 10.49 8.00004 10.49C8.27618 10.49 8.50004 10.7139 8.50004 10.99V11C8.50004 11.2762 8.27618 11.5 8.00004 11.5Z", fill: "currentColor" })] });
InfoErrorOutline16.displayName = "InfoErrorOutline16";
const Memo$$ = reactExports.memo(InfoErrorOutline16);
const Update24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.0914 4.94056C12.8672 4.59424 11.573 4.55683 10.3298 4.83193C9.08668 5.10703 7.93643 5.68535 6.98596 6.51158C6.03558 7.33774 5.31606 8.38464 4.89305 9.55378C4.77091 9.89135 4.39824 10.066 4.06068 9.94385C3.72311 9.82172 3.54846 9.44905 3.6706 9.11148C4.16971 7.73202 5.01741 6.5003 6.13308 5.53046C7.24868 4.56069 8.596 3.88416 10.0489 3.56264C11.5018 3.24113 13.0142 3.28479 14.4453 3.68966C15.87 4.0927 17.1691 4.84099 18.2221 5.86657L21.35 8.57676V5C21.35 4.64101 21.641 4.35 22 4.35C22.359 4.35 22.65 4.64101 22.65 5V10C22.65 10.359 22.359 10.65 22 10.65H17C16.641 10.65 16.35 10.359 16.35 10C16.35 9.64101 16.641 9.35 17 9.35H20.2572L17.3562 6.83643C17.3463 6.82783 17.3366 6.81894 17.3272 6.80976C16.4286 5.93043 15.3156 5.28687 14.0914 4.94056ZM1.35001 14C1.35001 13.641 1.64102 13.35 2.00001 13.35H7.00001C7.35899 13.35 7.65001 13.641 7.65001 14C7.65001 14.359 7.35899 14.65 7.00001 14.65H3.74281L6.64383 17.1636C6.65375 17.1722 6.66341 17.1811 6.67279 17.1902C7.57142 18.0696 8.68444 18.7131 9.90859 19.0594C11.1328 19.4058 12.4271 19.4432 13.6702 19.1681C14.9133 18.893 16.0636 18.3146 17.0141 17.4884C17.9644 16.6623 18.684 15.6154 19.107 14.4462C19.2291 14.1086 19.6018 13.934 19.9393 14.0561C20.2769 14.1783 20.4515 14.5509 20.3294 14.8885C19.8303 16.268 18.9826 17.4997 17.8669 18.4695C16.7513 19.4393 15.404 20.1158 13.9511 20.4374C12.4982 20.7589 10.9859 20.7152 9.55471 20.3103C8.13001 19.9073 6.83086 19.159 5.77795 18.1334L2.65001 15.4232V19C2.65001 19.359 2.35899 19.65 2.00001 19.65C1.64102 19.65 1.35001 19.359 1.35001 19V14Z", fill: "currentColor" }) });
Update24.displayName = "Update24";
const Memo$_ = reactExports.memo(Update24);
const Play24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 2.65C6.83614 2.65 2.65001 6.83614 2.65001 12C2.65001 17.1639 6.83614 21.35 12 21.35C17.1639 21.35 21.35 17.1639 21.35 12C21.35 6.83614 17.1639 2.65 12 2.65ZM1.35001 12C1.35001 6.11817 6.11817 1.35 12 1.35C17.8818 1.35 22.65 6.11817 22.65 12C22.65 17.8818 17.8818 22.65 12 22.65C6.11817 22.65 1.35001 17.8818 1.35001 12Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.6933 7.42691C9.90465 7.3138 10.1611 7.32619 10.3606 7.45917L16.3606 11.4592C16.5414 11.5797 16.65 11.7827 16.65 12C16.65 12.2173 16.5414 12.4203 16.3606 12.5408L10.3606 16.5408C10.1611 16.6738 9.90465 16.6862 9.6933 16.5731C9.48195 16.46 9.35001 16.2397 9.35001 16V8C9.35001 7.76028 9.48195 7.54002 9.6933 7.42691ZM10.65 9.21453V14.7855L14.8282 12L10.65 9.21453Z", fill: "currentColor" })] });
Play24.displayName = "Play24";
const Memo$Z = reactExports.memo(Play24);
const PlayActive24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12ZM10.3606 7.45917C10.1611 7.3262 9.90464 7.3138 9.69329 7.42691C9.48194 7.54002 9.35 7.76028 9.35 8V16C9.35 16.2397 9.48194 16.46 9.69329 16.5731C9.90464 16.6862 10.1611 16.6738 10.3606 16.5408L16.3606 12.5408C16.5414 12.4203 16.65 12.2173 16.65 12C16.65 11.7827 16.5414 11.5797 16.3606 11.4592L10.3606 7.45917ZM14.8282 12L10.65 14.7855V9.21454L14.8282 12Z", fill: "currentColor" }) });
PlayActive24.displayName = "PlayActive24";
const Memo$Y = reactExports.memo(PlayActive24);
const StepBackward24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7 5.35C7.35898 5.35 7.65 5.64101 7.65 6V18C7.65 18.359 7.35898 18.65 7 18.65C6.64101 18.65 6.35 18.359 6.35 18V6C6.35 5.64101 6.64101 5.35 7 5.35ZM16.5404 5.54038C16.7942 5.28654 17.2058 5.28654 17.4596 5.54038C17.7135 5.79422 17.7135 6.20578 17.4596 6.45962L11.9192 12L17.4596 17.5404C17.7135 17.7942 17.7135 18.2058 17.4596 18.4596C17.2058 18.7135 16.7942 18.7135 16.5404 18.4596L10.5404 12.4596C10.4185 12.3377 10.35 12.1724 10.35 12C10.35 11.8276 10.4185 11.6623 10.5404 11.5404L16.5404 5.54038Z", fill: "currentColor" }) });
StepBackward24.displayName = "StepBackward24";
const Memo$X = reactExports.memo(StepBackward24);
const PlayTimeline24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.35 6.4798C6.35 5.2407 7.67873 4.45642 8.76381 5.0529L18.806 10.5731C19.9314 11.1917 19.9313 12.8083 18.806 13.4269L8.76381 18.9471C7.67873 19.5436 6.35 18.7593 6.35 17.5202V6.4798ZM8.13758 6.19212C7.91784 6.07133 7.65 6.23055 7.65 6.4798V17.5202C7.65 17.7695 7.91783 17.9287 8.13757 17.8079L18.1797 12.2877C18.4068 12.1629 18.4068 11.8371 18.1797 11.7123L8.13758 6.19212Z", fill: "currentColor" }) });
PlayTimeline24.displayName = "PlayTimeline24";
const Memo$W = reactExports.memo(PlayTimeline24);
const StepForward24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.54038 5.54038C6.79422 5.28654 7.20578 5.28654 7.45962 5.54038L13.4596 11.5404C13.5815 11.6623 13.65 11.8276 13.65 12C13.65 12.1724 13.5815 12.3377 13.4596 12.4596L7.45962 18.4596C7.20578 18.7135 6.79422 18.7135 6.54038 18.4596C6.28654 18.2058 6.28654 17.7942 6.54038 17.5404L12.0808 12L6.54038 6.45962C6.28654 6.20578 6.28654 5.79422 6.54038 5.54038ZM17 18.65C16.641 18.65 16.35 18.359 16.35 18V6C16.35 5.64101 16.641 5.35 17 5.35C17.359 5.35 17.65 5.64101 17.65 6V18C17.65 18.359 17.359 18.65 17 18.65Z", fill: "currentColor" }) });
StepForward24.displayName = "StepForward24";
const Memo$V = reactExports.memo(StepForward24);
const Pause24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.35 7C6.35 6.08873 7.08873 5.35 8 5.35H9C9.91127 5.35 10.65 6.08873 10.65 7V17C10.65 17.9113 9.91127 18.65 9 18.65H8C7.08873 18.65 6.35 17.9113 6.35 17V7ZM8 6.65C7.8067 6.65 7.65 6.8067 7.65 7V17C7.65 17.1933 7.8067 17.35 8 17.35H9C9.1933 17.35 9.35 17.1933 9.35 17V7C9.35 6.8067 9.1933 6.65 9 6.65H8ZM13.35 7C13.35 6.08873 14.0887 5.35 15 5.35H16C16.9113 5.35 17.65 6.08873 17.65 7V17C17.65 17.9113 16.9113 18.65 16 18.65H15C14.0887 18.65 13.35 17.9113 13.35 17V7ZM15 6.65C14.8067 6.65 14.65 6.8067 14.65 7V17C14.65 17.1933 14.8067 17.35 15 17.35H16C16.1933 17.35 16.35 17.1933 16.35 17V7C16.35 6.8067 16.1933 6.65 16 6.65H15Z", fill: "currentColor" }) });
Pause24.displayName = "Pause24";
const Memo$U = reactExports.memo(Pause24);
const ToStart24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 5.35C4.35898 5.35 4.65 5.64101 4.65 6V18C4.65 18.359 4.35898 18.65 4 18.65C3.64101 18.65 3.35 18.359 3.35 18V6C3.35 5.64101 3.64101 5.35 4 5.35ZM13.5404 5.54038C13.7942 5.28654 14.2058 5.28654 14.4596 5.54038C14.7135 5.79422 14.7135 6.20578 14.4596 6.45962L8.91924 12L14.4596 17.5404C14.7135 17.7942 14.7135 18.2058 14.4596 18.4596C14.2058 18.7135 13.7942 18.7135 13.5404 18.4596L7.54038 12.4596C7.41848 12.3377 7.35 12.1724 7.35 12C7.35 11.8276 7.41848 11.6623 7.54038 11.5404L13.5404 5.54038ZM19.5404 5.54038C19.7942 5.28654 20.2058 5.28654 20.4596 5.54038C20.7135 5.79422 20.7135 6.20578 20.4596 6.45962L14.9192 12L20.4596 17.5404C20.7135 17.7942 20.7135 18.2058 20.4596 18.4596C20.2058 18.7135 19.7942 18.7135 19.5404 18.4596L13.5404 12.4596C13.4185 12.3377 13.35 12.1724 13.35 12C13.35 11.8276 13.4185 11.6623 13.5404 11.5404L19.5404 5.54038Z", fill: "currentColor" }) });
ToStart24.displayName = "ToStart24";
const Memo$T = reactExports.memo(ToStart24);
const DoubleChevronLeft24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.4596 6.54039C11.7135 6.79423 11.7135 7.20578 11.4596 7.45963L6.91924 12L11.4596 16.5404C11.7135 16.7942 11.7135 17.2058 11.4596 17.4596C11.2058 17.7135 10.7942 17.7135 10.5404 17.4596L5.54038 12.4596C5.41848 12.3377 5.35 12.1724 5.35 12C5.35 11.8276 5.41848 11.6623 5.54038 11.5404L10.5404 6.54039C10.7942 6.28655 11.2058 6.28655 11.4596 6.54039ZM17.4596 6.54039C17.7135 6.79423 17.7135 7.20578 17.4596 7.45963L12.9192 12L17.4596 16.5404C17.7135 16.7942 17.7135 17.2058 17.4596 17.4596C17.2058 17.7135 16.7942 17.7135 16.5404 17.4596L11.5404 12.4596C11.2865 12.2058 11.2865 11.7942 11.5404 11.5404L16.5404 6.54039C16.7942 6.28655 17.2058 6.28655 17.4596 6.54039Z", fill: "currentColor" }) });
DoubleChevronLeft24.displayName = "DoubleChevronLeft24";
const Memo$S = reactExports.memo(DoubleChevronLeft24);
const DoubleChevronRight24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.54038 6.54039C5.79422 6.28655 6.20578 6.28655 6.45962 6.54039L11.4596 11.5404C11.5815 11.6623 11.65 11.8276 11.65 12C11.65 12.1724 11.5815 12.3377 11.4596 12.4596L6.45962 17.4596C6.20578 17.7135 5.79422 17.7135 5.54038 17.4596C5.28654 17.2058 5.28654 16.7942 5.54038 16.5404L10.0808 12L5.54038 7.45963C5.28654 7.20578 5.28654 6.79423 5.54038 6.54039ZM11.5404 6.54039C11.7942 6.28655 12.2058 6.28655 12.4596 6.54039L17.4596 11.5404C17.5815 11.6623 17.65 11.8276 17.65 12C17.65 12.1724 17.5815 12.3377 17.4596 12.4596L12.4596 17.4596C12.2058 17.7135 11.7942 17.7135 11.5404 17.4596C11.2865 17.2058 11.2865 16.7942 11.5404 16.5404L16.0808 12L11.5404 7.45963C11.2865 7.20578 11.2865 6.79423 11.5404 6.54039Z", fill: "currentColor" }) });
DoubleChevronRight24.displayName = "DoubleChevronRight24";
const Memo$R = reactExports.memo(DoubleChevronRight24);
const ColumnWidth16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { d: "M2.93751 3.34375C2.93751 3.01583 2.67167 2.75 2.34375 2.75C2.01583 2.75 1.75 3.01583 1.75 3.34375L1.75001 12.6562C1.75001 12.9842 2.01584 13.25 2.34376 13.25C2.67168 13.25 2.93751 12.9842 2.93751 12.6562V3.34375ZM14.25 3.34375C14.25 3.01583 13.9842 2.75 13.6563 2.75C13.3283 2.75 13.0625 3.01583 13.0625 3.34375V12.6562C13.0625 12.9842 13.3283 13.25 13.6563 13.25C13.9842 13.25 14.25 12.9842 14.25 12.6562V3.34375ZM12.2703 7.87969L10.2766 6.30625C10.2599 6.29313 10.2398 6.28497 10.2187 6.28271C10.1976 6.28045 10.1763 6.28419 10.1572 6.29348C10.1382 6.30278 10.1221 6.31726 10.1109 6.33527C10.0996 6.35328 10.0937 6.37409 10.0938 6.39531V7.4375H5.90626V6.45625C5.90626 6.3625 5.79688 6.30937 5.72344 6.36719L3.72969 7.94219C3.7162 7.95261 3.70528 7.96599 3.69776 7.98129C3.69025 7.9966 3.68634 8.01342 3.68634 8.03047C3.68634 8.04752 3.69025 8.06434 3.69776 8.07965C3.70528 8.09495 3.7162 8.10833 3.72969 8.11875L5.72188 9.69375C5.79532 9.75156 5.90469 9.7 5.90469 9.60469V8.5625H10.0922V9.54375C10.0922 9.6375 10.2016 9.69063 10.275 9.63281L12.2672 8.05781C12.3266 8.0125 12.3266 7.925 12.2703 7.87969Z", fill: "currentColor" }) });
ColumnWidth16.displayName = "ColumnWidth16";
const Memo$Q = reactExports.memo(ColumnWidth16);
const Twoxtwo16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { d: "M7.25 2.25H2.5C2.3625 2.25 2.25 2.3625 2.25 2.5V7.25C2.25 7.3875 2.3625 7.5 2.5 7.5H7.25C7.3875 7.5 7.5 7.3875 7.5 7.25V2.5C7.5 2.3625 7.3875 2.25 7.25 2.25ZM6.4375 6.4375H3.3125V3.3125H6.4375V6.4375ZM13.5 2.25H8.75C8.6125 2.25 8.5 2.3625 8.5 2.5V7.25C8.5 7.3875 8.6125 7.5 8.75 7.5H13.5C13.6375 7.5 13.75 7.3875 13.75 7.25V2.5C13.75 2.3625 13.6375 2.25 13.5 2.25ZM12.6875 6.4375H9.5625V3.3125H12.6875V6.4375ZM7.25 8.5H2.5C2.3625 8.5 2.25 8.6125 2.25 8.75V13.5C2.25 13.6375 2.3625 13.75 2.5 13.75H7.25C7.3875 13.75 7.5 13.6375 7.5 13.5V8.75C7.5 8.6125 7.3875 8.5 7.25 8.5ZM6.4375 12.6875H3.3125V9.5625H6.4375V12.6875ZM13.5 8.5H8.75C8.6125 8.5 8.5 8.6125 8.5 8.75V13.5C8.5 13.6375 8.6125 13.75 8.75 13.75H13.5C13.6375 13.75 13.75 13.6375 13.75 13.5V8.75C13.75 8.6125 13.6375 8.5 13.5 8.5ZM12.6875 12.6875H9.5625V9.5625H12.6875V12.6875Z", fill: "currentColor" }) });
Twoxtwo16.displayName = "Twoxtwo16";
const Memo$P = reactExports.memo(Twoxtwo16);
const Tags16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { d: "M7.54938 12.3487L13.4588 6.43774C13.4853 6.41118 13.4978 6.37524 13.4947 6.3393L13.0963 1.62993C13.0853 1.50805 12.99 1.41274 12.8681 1.4018L8.15875 1.00493C8.12281 1.0018 8.08531 1.0143 8.06031 1.04086L2.15094 6.95024C2.12767 6.97373 2.11462 7.00546 2.11462 7.03852C2.11462 7.07158 2.12767 7.10331 2.15094 7.1268L7.37281 12.3487C7.42125 12.3987 7.50094 12.3987 7.54938 12.3487ZM8.5275 2.16586L12.0369 2.46274L12.3338 5.97211L7.46031 10.844L3.65406 7.0393L8.5275 2.16586ZM9.4675 5.07571C9.53715 5.14535 9.61984 5.20059 9.71084 5.23828C9.80184 5.27596 9.89937 5.29535 9.99787 5.29535C10.0964 5.29534 10.1939 5.27593 10.2849 5.23823C10.3759 5.20053 10.4586 5.14528 10.5282 5.07563C10.5978 5.00598 10.6531 4.92329 10.6908 4.83229C10.7285 4.74129 10.7479 4.64376 10.7478 4.54526C10.7478 4.44677 10.7284 4.34924 10.6907 4.25824C10.653 4.16725 10.5978 4.08457 10.5281 4.01493C10.4585 3.94528 10.3758 3.89004 10.2848 3.85236C10.1938 3.81467 10.0963 3.79528 9.99776 3.79529C9.89926 3.79529 9.80173 3.8147 9.71074 3.8524C9.61974 3.8901 9.53707 3.94535 9.46742 4.015C9.39778 4.08466 9.34254 4.16734 9.30486 4.25834C9.26717 4.34934 9.24778 4.44688 9.24778 4.54537C9.24779 4.64387 9.2672 4.7414 9.3049 4.83239C9.3426 4.92339 9.39785 5.00607 9.4675 5.07571ZM13.9009 8.43461L13.2822 7.81743C13.2587 7.79416 13.227 7.78111 13.1939 7.78111C13.1608 7.78111 13.1291 7.79416 13.1056 7.81743L7.44938 13.4627L3.73687 9.75961C3.71338 9.73635 3.68166 9.7233 3.64859 9.7233C3.61553 9.7233 3.58381 9.73635 3.56031 9.75961L2.94156 10.3768C2.9183 10.4003 2.90525 10.432 2.90525 10.4651C2.90525 10.4981 2.9183 10.5299 2.94156 10.5534L6.74156 14.3471L7.36031 14.9643C7.40875 15.0127 7.48844 15.0127 7.53687 14.9643L13.9009 8.61118C13.9494 8.56274 13.9494 8.48305 13.9009 8.43461Z", fill: "currentColor" }) });
Tags16.displayName = "Tags16";
const Memo$O = reactExports.memo(Tags16);
const Upload24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3.492C12.1724 3.492 12.3378 3.56049 12.4597 3.68238L16.4751 7.69786C16.729 7.9517 16.729 8.36326 16.4751 8.6171C16.2213 8.87094 15.8098 8.87094 15.5559 8.6171L12.65 5.71124V14.5155C12.65 14.8745 12.359 15.1655 12 15.1655C11.641 15.1655 11.35 14.8745 11.35 14.5155V5.71125L8.44419 8.6171C8.19035 8.87094 7.77879 8.87094 7.52495 8.6171C7.27111 8.36326 7.27111 7.95171 7.52495 7.69787L11.5404 3.68239C11.6623 3.56049 11.8276 3.492 12 3.492ZM3.98615 13.4203C4.34514 13.4203 4.63615 13.7113 4.63615 14.0703V18.858C4.63615 19.0513 4.79285 19.208 4.98615 19.208H19.0139C19.2072 19.208 19.3639 19.0513 19.3639 18.858V14.0703C19.3639 13.7113 19.6549 13.4203 20.0139 13.4203C20.3728 13.4203 20.6639 13.7113 20.6639 14.0703V18.858C20.6639 19.7693 19.9251 20.508 19.0139 20.508H4.98615C4.07488 20.508 3.33615 19.7693 3.33615 18.858V14.0703C3.33615 13.7113 3.62717 13.4203 3.98615 13.4203Z", fill: "currentColor" }) });
Upload24.displayName = "Upload24";
const Memo$N = reactExports.memo(Upload24);
const AdvancedAnalytics24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.38382 2.91069C3.84953 2.44497 4.48118 2.18333 5.1398 2.18333H15.1936C15.366 2.18333 15.5313 2.25182 15.6532 2.37371L21.1532 7.87372C21.2751 7.99561 21.3436 8.16094 21.3436 8.33333V19.3333C21.3436 19.992 21.0819 20.6236 20.6162 21.0893C20.1505 21.555 19.5188 21.8167 18.8602 21.8167H5.1398C4.48118 21.8167 3.84953 21.555 3.38382 21.0893C2.9181 20.6236 2.65646 19.992 2.65646 19.3333V4.66667C2.65646 4.00805 2.9181 3.3764 3.38382 2.91069ZM5.1398 3.48333C4.82596 3.48333 4.52497 3.60801 4.30305 3.82992C4.08114 4.05184 3.95646 4.35283 3.95646 4.66667V19.3333C3.95646 19.6472 4.08114 19.9482 4.30305 20.1701C4.52497 20.392 4.82596 20.5167 5.1398 20.5167H18.8602C19.1741 20.5167 19.475 20.392 19.697 20.1701C19.9189 19.9482 20.0436 19.6472 20.0436 19.3333V8.60257L14.9243 3.48333H5.1398Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.37869 6.5C5.37869 6.14102 5.6697 5.85 6.02869 5.85H7.86202C8.221 5.85 8.51202 6.14102 8.51202 6.5C8.51202 6.85899 8.221 7.15 7.86202 7.15H6.02869C5.6697 7.15 5.37869 6.85899 5.37869 6.5ZM10.2803 6.5C10.2803 6.14102 10.5713 5.85 10.9303 5.85H12.7636C13.1226 5.85 13.4136 6.14102 13.4136 6.5C13.4136 6.85899 13.1226 7.15 12.7636 7.15H10.9303C10.5713 7.15 10.2803 6.85899 10.2803 6.5ZM5.37869 10.1667C5.37869 9.80768 5.6697 9.51667 6.02869 9.51667H7.86202C8.221 9.51667 8.51202 9.80768 8.51202 10.1667C8.51202 10.5257 8.221 10.8167 7.86202 10.8167H6.02869C5.6697 10.8167 5.37869 10.5257 5.37869 10.1667ZM10.2803 10.1667C10.2803 9.80768 10.5713 9.51667 10.9303 9.51667H12.7636C13.1226 9.51667 13.4136 9.80768 13.4136 10.1667C13.4136 10.5257 13.1226 10.8167 12.7636 10.8167H10.9303C10.5713 10.8167 10.2803 10.5257 10.2803 10.1667ZM5.37869 13.8333C5.37869 13.4743 5.6697 13.1833 6.02869 13.1833H7.86202C8.221 13.1833 8.51202 13.4743 8.51202 13.8333C8.51202 14.1923 8.221 14.4833 7.86202 14.4833H6.02869C5.6697 14.4833 5.37869 14.1923 5.37869 13.8333ZM10.2803 13.8333C10.2803 13.4743 10.5713 13.1833 10.9303 13.1833H12.7636C13.1226 13.1833 13.4136 13.4743 13.4136 13.8333C13.4136 14.1923 13.1226 14.4833 12.7636 14.4833H10.9303C10.5713 14.4833 10.2803 14.1923 10.2803 13.8333ZM15.182 13.8333C15.182 13.4743 15.473 13.1833 15.832 13.1833H17.6653C18.0243 13.1833 18.3153 13.4743 18.3153 13.8333C18.3153 14.1923 18.0243 14.4833 17.6653 14.4833H15.832C15.473 14.4833 15.182 14.1923 15.182 13.8333ZM5.37869 17.5C5.37869 17.141 5.6697 16.85 6.02869 16.85H7.86202C8.221 16.85 8.51202 17.141 8.51202 17.5C8.51202 17.859 8.221 18.15 7.86202 18.15H6.02869C5.6697 18.15 5.37869 17.859 5.37869 17.5ZM10.2803 17.5C10.2803 17.141 10.5713 16.85 10.9303 16.85H12.7636C13.1226 16.85 13.4136 17.141 13.4136 17.5C13.4136 17.859 13.1226 18.15 12.7636 18.15H10.9303C10.5713 18.15 10.2803 17.859 10.2803 17.5ZM15.182 17.5C15.182 17.141 15.473 16.85 15.832 16.85H17.6653C18.0243 16.85 18.3153 17.141 18.3153 17.5C18.3153 17.859 18.0243 18.15 17.6653 18.15H15.832C15.473 18.15 15.182 17.859 15.182 17.5Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.1936 2.18333C15.5525 2.18333 15.8436 2.47435 15.8436 2.83333V7.68333H20.6936C21.0525 7.68333 21.3436 7.97435 21.3436 8.33333C21.3436 8.69232 21.0525 8.98333 20.6936 8.98333H15.1936C14.8346 8.98333 14.5436 8.69232 14.5436 8.33333V2.83333C14.5436 2.47435 14.8346 2.18333 15.1936 2.18333Z", fill: "currentColor" })] });
AdvancedAnalytics24.displayName = "AdvancedAnalytics24";
const Memo$M = reactExports.memo(AdvancedAnalytics24);
const Legend24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.5176 4.5913C10.5176 4.23231 10.8086 3.9413 11.1676 3.9413H21.3786C21.7376 3.9413 22.0286 4.23231 22.0286 4.5913C22.0286 4.95028 21.7376 5.2413 21.3786 5.2413H11.1676C10.8086 5.2413 10.5176 4.95028 10.5176 4.5913ZM10.5175 11.9317C10.5175 11.5727 10.8085 11.2817 11.1675 11.2817H21.3785C21.7375 11.2817 22.0285 11.5727 22.0285 11.9317C22.0285 12.2906 21.7375 12.5817 21.3785 12.5817H11.1675C10.8085 12.5817 10.5175 12.2906 10.5175 11.9317ZM10.5176 19.4009C10.5176 19.0419 10.8086 18.7509 11.1676 18.7509H21.3786C21.7376 18.7509 22.0286 19.0419 22.0286 19.4009C22.0286 19.7599 21.7376 20.0509 21.3786 20.0509H11.1676C10.8086 20.0509 10.5176 19.7599 10.5176 19.4009Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.48068 16.9238C5.68921 16.9238 5.88508 17.0239 6.00731 17.1929L8.40767 20.5108C8.5508 20.7086 8.57097 20.97 8.45989 21.1875C8.34882 21.4049 8.12523 21.5418 7.88104 21.5418H3.0801C2.83591 21.5418 2.61232 21.4049 2.50124 21.1874C2.39016 20.97 2.41034 20.7086 2.55348 20.5108L4.95405 17.1928C5.07629 17.0239 5.27216 16.9238 5.48068 16.9238ZM4.35267 20.2418H6.60853L5.48065 18.6828L4.35267 20.2418Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.68014 6.93857C3.32115 6.93857 3.03014 6.64755 3.03014 6.28857L3.03014 2.89379C3.03014 2.5348 3.32115 2.24379 3.68014 2.24379L7.07491 2.24379C7.4339 2.24379 7.72491 2.5348 7.72491 2.89379V6.28857C7.72491 6.64755 7.4339 6.93857 7.07491 6.93857H3.68014ZM4.33014 5.63857L6.42491 5.63857L6.42491 3.54379L4.33014 3.54379L4.33014 5.63857Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.48051 10.7809C4.84517 10.7809 4.33012 11.2959 4.33012 11.9313C4.33012 12.5666 4.84517 13.0817 5.48051 13.0817C6.11586 13.0817 6.63091 12.5666 6.63091 11.9313C6.63091 11.2959 6.11586 10.7809 5.48051 10.7809ZM3.03012 11.9313C3.03012 10.5779 4.1272 9.48087 5.48051 9.48087C6.83383 9.48087 7.93091 10.5779 7.93091 11.9313C7.93091 13.2846 6.83383 14.3817 5.48051 14.3817C4.1272 14.3817 3.03012 13.2846 3.03012 11.9313Z", fill: "currentColor" })] });
Legend24.displayName = "Legend24";
const Memo$L = reactExports.memo(Legend24);
const BivariateMatrix24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.5404 1.40799C11.7942 1.15415 12.2058 1.15415 12.4596 1.40799L16.2593 5.20764C16.3812 5.32954 16.4496 5.49487 16.4496 5.66726C16.4496 5.83965 16.3812 6.00498 16.2593 6.12688L12.4596 9.92653C12.2058 10.1804 11.7942 10.1804 11.5404 9.92653L7.74072 6.12688C7.48688 5.87304 7.48688 5.46148 7.74072 5.20764L11.5404 1.40799ZM12 2.78684L9.11958 5.66726L12 8.54768L14.8804 5.66726L12 2.78684ZM5.20785 7.74072C5.46169 7.48688 5.87325 7.48688 6.12709 7.74072L9.92675 11.5404C10.1806 11.7942 10.1806 12.2058 9.92675 12.4596L6.12709 16.2593C6.00519 16.3812 5.83986 16.4497 5.66747 16.4497C5.49508 16.4497 5.32975 16.3812 5.20785 16.2593L1.4082 12.4596C1.15436 12.2058 1.15436 11.7942 1.4082 11.5404L5.20785 7.74072ZM17.8733 7.74072C18.1272 7.48688 18.5387 7.48688 18.7926 7.74072L22.5922 11.5404C22.8461 11.7942 22.8461 12.2058 22.5922 12.4596L18.7926 16.2593C18.6707 16.3812 18.5053 16.4497 18.3329 16.4497C18.1606 16.4497 17.9952 16.3812 17.8733 16.2593L14.0737 12.4596C13.8198 12.2058 13.8198 11.7942 14.0737 11.5404L17.8733 7.74072ZM2.78706 12L5.66747 14.8804L8.54789 12L5.66747 9.11958L2.78706 12ZM15.4525 12L18.3329 14.8804L21.2134 12L18.3329 9.11958L15.4525 12ZM9.11958 18.3327L12 21.2131L14.8804 18.3327L12 15.4523L9.11958 18.3327ZM11.5404 14.0735C11.7942 13.8196 12.2058 13.8196 12.4596 14.0735L16.2593 17.8731C16.3812 17.995 16.4496 18.1603 16.4496 18.3327C16.4496 18.5051 16.3812 18.6705 16.2593 18.7924L12.4596 22.592C12.2058 22.8458 11.7942 22.8458 11.5404 22.592L7.74072 18.7924C7.48688 18.5385 7.48688 18.127 7.74072 17.8731L11.5404 14.0735Z", fill: "currentColor" }) });
BivariateMatrix24.displayName = "BivariateMatrix24";
const Memo$K = reactExports.memo(BivariateMatrix24);
const Disasters24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.91853 1.53128C10.1152 1.34236 10.4088 1.29625 10.6539 1.4158C11.3546 1.75765 12.4102 2.41152 13.3498 3.28613C14.2789 4.15109 15.1719 5.30393 15.4023 6.65244C15.6217 7.93704 15.3906 9.16501 15.0314 10.161C14.9485 10.3908 14.858 10.6104 14.7633 10.8178C15.3639 10.5268 15.8848 10.1564 16.1772 9.72851C16.9068 8.66078 17.0401 7.86599 17.0401 7.71428C17.0401 7.46186 17.1862 7.23227 17.4149 7.12541C17.6435 7.01854 17.9134 7.05373 18.107 7.21565C19.3865 8.28562 21.5326 11.3976 20.2637 15.5244C19.5299 17.9106 18.4601 19.5109 17.3801 20.6031C16.3017 21.6937 15.2363 22.2535 14.5585 22.5842C14.3786 22.6719 14.1684 22.6719 13.9885 22.5842L13.9771 22.5786C13.4918 22.3419 12.7207 21.9657 12.0061 21.4587C11.2994 20.9573 10.5527 20.2628 10.2419 19.353C10.0735 18.8603 9.95939 18.419 9.88198 18.0301C9.6785 18.4215 9.55464 18.8078 9.55464 19.1428C9.55464 20.1784 9.85354 20.9978 9.97118 21.2273C10.1055 21.4895 10.0468 21.8092 9.82804 22.0065C9.6093 22.2038 9.28524 22.2293 9.03831 22.0687C8.26056 21.5628 7.11122 20.6404 6.14848 19.4882C5.19719 18.3497 4.35001 16.8933 4.35001 15.3333C4.35001 13.5041 4.89805 12.2943 5.76963 11.1823C6.1908 10.645 6.68801 10.1296 7.20997 9.59087C7.22638 9.57393 7.24283 9.55695 7.25932 9.53993C7.77319 9.0096 8.32212 8.44308 8.89847 7.76831C10.6321 5.73861 10.2022 3.23679 9.77376 2.26141C9.6641 2.01176 9.72191 1.7202 9.91853 1.53128ZM11.3941 3.37282C11.5878 4.86018 11.3797 6.86494 9.88697 8.61262C9.28364 9.31898 8.70992 9.91105 8.19935 10.438C8.1807 10.4572 8.16214 10.4764 8.14366 10.4954C7.6132 11.043 7.16475 11.5097 6.7928 11.9843C6.07812 12.8961 5.65001 13.8292 5.65001 15.3333C5.65001 16.44 6.26706 17.6027 7.14607 18.6546C7.50932 19.0894 7.90403 19.4893 8.29056 19.84C8.26781 19.6181 8.25464 19.3847 8.25464 19.1428C8.25464 18.4015 8.56484 17.6862 8.89535 17.1315C9.23171 16.5671 9.63398 16.0946 9.91496 15.8205C10.1021 15.6379 10.3804 15.5852 10.6213 15.6867C10.8622 15.7883 11.0189 16.0243 11.0189 16.2857V16.2927C11.0189 16.7358 11.0188 17.6062 11.472 18.9327C11.6493 19.4515 12.1228 19.9475 12.7583 20.3985C13.2667 20.7591 13.8181 21.0496 14.271 21.2746C14.8723 20.9651 15.659 20.4947 16.4557 19.689C17.3826 18.7517 18.3465 17.3361 19.0211 15.1423C19.8546 12.4316 18.9425 10.2572 18.0256 9.0292C17.8552 9.45548 17.6051 9.94316 17.2506 10.4619C16.7663 11.1707 15.9965 11.6688 15.2985 12.0029C14.59 12.3421 13.8781 12.5489 13.4218 12.638C13.1528 12.6904 12.8798 12.5686 12.7393 12.3333C12.5988 12.098 12.6209 11.7998 12.7947 11.5878C13.0728 11.2487 13.4999 10.5755 13.8085 9.71991C14.1163 8.86671 14.2919 7.87247 14.1209 6.87135C13.9608 5.93414 13.3082 5.0235 12.464 4.23766C12.1158 3.91349 11.748 3.6228 11.3941 3.37282Z", fill: "currentColor" }) });
Disasters24.displayName = "Disasters24";
const Memo$J = reactExports.memo(Disasters24);
const EditOsm24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.98131 7.95182C10.2352 7.69798 10.6467 7.69798 10.9006 7.95182L15.8503 12.9016C16.1041 13.1554 16.1041 13.567 15.8503 13.8208L7.70825 21.963C7.58635 22.0849 7.42102 22.1533 7.24863 22.1533H2.29888C1.9399 22.1533 1.64888 21.8623 1.64888 21.5033L1.64888 16.5536C1.64888 16.3812 1.71736 16.2159 1.83926 16.094L9.98131 7.95182ZM10.4409 9.33068L8.17819 11.5934L12.2087 15.6239L14.4714 13.3612L10.4409 9.33068ZM11.2895 16.5432L7.25896 12.5127L2.94888 16.8228L2.94888 20.8533H6.97939L11.2895 16.5432Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16.176 2.6718C15.8171 2.6718 15.526 2.38078 15.526 2.0218C15.526 1.66281 15.8171 1.3718 16.176 1.3718H22.176C22.535 1.3718 22.826 1.66281 22.826 2.0218V8.0218C22.826 8.38078 22.535 8.6718 22.176 8.6718C21.8171 8.6718 21.526 8.38078 21.526 8.0218V3.59103L16.6357 8.48142C16.3818 8.73526 15.9703 8.73526 15.7164 8.48142C15.4626 8.22757 15.4626 7.81602 15.7164 7.56218L20.6068 2.6718H16.176Z", fill: "currentColor" })] });
EditOsm24.displayName = "EditOsm24";
const Memo$I = reactExports.memo(EditOsm24);
const Layers24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.7232 3.41187C11.8985 3.32938 12.1015 3.32938 12.2768 3.41187L20.7768 7.41187C21.0046 7.51908 21.15 7.74822 21.15 8.00001C21.15 8.25179 21.0046 8.48093 20.7768 8.58814L12.2768 12.5881C12.1015 12.6706 11.8985 12.6706 11.7232 12.5881L3.22324 8.58814C2.99542 8.48093 2.85001 8.25179 2.85001 8.00001C2.85001 7.74822 2.99542 7.51908 3.22324 7.41187L11.7232 3.41187ZM5.02656 8.00001L12 11.2816L18.9735 8.00001L12 4.71838L5.02656 8.00001ZM2.91187 11.7232C3.06473 11.3984 3.45196 11.259 3.77678 11.4119L12 15.2816L20.2232 11.4119C20.5481 11.259 20.9353 11.3984 21.0881 11.7232C21.241 12.0481 21.1016 12.4353 20.7768 12.5881L12.2768 16.5881C12.1015 16.6706 11.8985 16.6706 11.7232 16.5881L3.22324 12.5881C2.89842 12.4353 2.75902 12.0481 2.91187 11.7232ZM2.91187 15.7232C3.06473 15.3984 3.45196 15.259 3.77678 15.4119L12 19.2816L20.2232 15.4119C20.5481 15.259 20.9353 15.3984 21.0881 15.7232C21.241 16.0481 21.1016 16.4353 20.7768 16.5881L12.2768 20.5881C12.1015 20.6706 11.8985 20.6706 11.7232 20.5881L3.22324 16.5881C2.89842 16.4353 2.75902 16.0481 2.91187 15.7232Z", fill: "currentColor" }) });
Layers24.displayName = "Layers24";
const Memo$H = reactExports.memo(Layers24);
const Trash24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.21842 5.17118C8.21842 4.25991 8.95715 3.52118 9.86842 3.52118H14.1315C15.0428 3.52118 15.7815 4.25991 15.7815 5.17118V6.65262H19.0461C19.4051 6.65262 19.6961 6.94364 19.6961 7.30262C19.6961 7.66161 19.4051 7.95262 19.0461 7.95262H18.1302V18.8289C18.1302 19.7401 17.3915 20.4789 16.4802 20.4789H7.51977C6.6085 20.4789 5.86977 19.7401 5.86977 18.8289V7.95262H4.95405C4.59506 7.95262 4.30405 7.66161 4.30405 7.30262C4.30405 6.94364 4.59506 6.65262 4.95405 6.65262H8.21842V5.17118ZM9.51842 6.65262H14.4815V5.17118C14.4815 4.97788 14.3248 4.82118 14.1315 4.82118H9.86842C9.67512 4.82118 9.51842 4.97788 9.51842 5.17118V6.65262ZM7.16977 7.95262V18.8289C7.16977 19.0222 7.32647 19.1789 7.51977 19.1789H16.4802C16.6735 19.1789 16.8302 19.0222 16.8302 18.8289V7.95262H7.16977ZM10.4341 10.5671C10.7931 10.5671 11.0841 10.8582 11.0841 11.2171V15.9145C11.0841 16.2735 10.7931 16.5645 10.4341 16.5645C10.0752 16.5645 9.78414 16.2735 9.78414 15.9145V11.2171C9.78414 10.8582 10.0752 10.5671 10.4341 10.5671ZM13.5657 10.5671C13.9247 10.5671 14.2157 10.8582 14.2157 11.2171V15.9145C14.2157 16.2735 13.9247 16.5645 13.5657 16.5645C13.2067 16.5645 12.9157 16.2735 12.9157 15.9145V11.2171C12.9157 10.8582 13.2067 10.5671 13.5657 10.5671Z", fill: "currentColor" }) });
Trash24.displayName = "Trash24";
const Memo$G = reactExports.memo(Trash24);
const Error24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 2.65001C6.83614 2.65001 2.65001 6.83614 2.65001 12C2.65001 17.1639 6.83614 21.35 12 21.35C17.1639 21.35 21.35 17.1639 21.35 12C21.35 6.83614 17.1639 2.65001 12 2.65001ZM1.35001 12C1.35001 6.11817 6.11817 1.35001 12 1.35001C17.8818 1.35001 22.65 6.11817 22.65 12C22.65 17.8818 17.8818 22.65 12 22.65C6.11817 22.65 1.35001 17.8818 1.35001 12ZM8.35001 9.00001C8.35001 8.64102 8.64102 8.35001 9.00001 8.35001H9.01001C9.36899 8.35001 9.66001 8.64102 9.66001 9.00001C9.66001 9.35899 9.36899 9.65001 9.01001 9.65001H9.00001C8.64102 9.65001 8.35001 9.35899 8.35001 9.00001ZM14.35 9.00001C14.35 8.64102 14.641 8.35001 15 8.35001H15.01C15.369 8.35001 15.66 8.64102 15.66 9.00001C15.66 9.35899 15.369 9.65001 15.01 9.65001H15C14.641 9.65001 14.35 9.35899 14.35 9.00001ZM8.68019 14.4743C9.43948 13.9221 10.5709 13.35 12 13.35C13.4291 13.35 14.5605 13.9221 15.3198 14.4743C15.7007 14.7513 15.9951 15.0283 16.1959 15.2378C16.2965 15.3428 16.3744 15.4316 16.4286 15.4962C16.4557 15.5285 16.4769 15.5548 16.4922 15.5741L16.5106 15.5977L16.5164 15.6053L16.5185 15.608L16.5193 15.6091C16.5195 15.6093 16.52 15.61 16 16L16.52 15.61C16.7354 15.8972 16.6772 16.3046 16.39 16.52C16.1034 16.735 15.6969 16.6774 15.4812 16.3916C15.4809 16.3912 15.4806 16.3908 15.4803 16.3904L15.4729 16.381C15.465 16.371 15.4516 16.3543 15.4328 16.3319C15.3952 16.2871 15.3363 16.2197 15.2573 16.1372C15.0986 15.9717 14.8618 15.7487 14.5552 15.5257C13.9395 15.0779 13.0709 14.65 12 14.65C10.9291 14.65 10.0605 15.0779 9.44482 15.5257C9.13821 15.7487 8.90137 15.9717 8.74274 16.1372C8.66369 16.2197 8.60484 16.2871 8.56723 16.3319C8.54844 16.3543 8.53502 16.371 8.52709 16.381L8.51946 16.3907C8.304 16.6776 7.89707 16.7353 7.61001 16.52C7.32282 16.3046 7.26462 15.8972 7.48001 15.61L8.00001 16C7.48001 15.61 7.47984 15.6102 7.48001 15.61L7.48151 15.608L7.48358 15.6053L7.48941 15.5977L7.50783 15.5741C7.5231 15.5548 7.54435 15.5285 7.57146 15.4962C7.62564 15.4316 7.70351 15.3428 7.80415 15.2378C8.00489 15.0283 8.2993 14.7513 8.68019 14.4743Z", fill: "currentColor" }) });
Error24.displayName = "Error24";
const Memo$F = reactExports.memo(Error24);
const CornerUpLeft24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.45963 3.54039C9.71347 3.79423 9.71347 4.20578 9.45963 4.45963L5.56925 8.35001H16C17.2333 8.35001 18.416 8.83992 19.2881 9.71196C20.1601 10.584 20.65 11.7667 20.65 13V20C20.65 20.359 20.359 20.65 20 20.65C19.641 20.65 19.35 20.359 19.35 20V13C19.35 12.1115 18.9971 11.2594 18.3688 10.6312C17.7406 10.003 16.8885 9.65001 16 9.65001H5.56925L9.45963 13.5404C9.71347 13.7942 9.71347 14.2058 9.45963 14.4596C9.20578 14.7135 8.79423 14.7135 8.54039 14.4596L3.54039 9.45963C3.28655 9.20578 3.28655 8.79423 3.54039 8.54039L8.54039 3.54039C8.79423 3.28655 9.20578 3.28655 9.45963 3.54039Z", fill: "currentColor" }) });
CornerUpLeft24.displayName = "CornerUpLeft24";
const Memo$E = reactExports.memo(CornerUpLeft24);
const Merge24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.00001 5.65001C5.493 5.65001 2.65001 8.493 2.65001 12C2.65001 15.507 5.493 18.35 9.00001 18.35C12.507 18.35 15.35 15.507 15.35 12C15.35 8.493 12.507 5.65001 9.00001 5.65001ZM1.35001 12C1.35001 7.77503 4.77503 4.35001 9.00001 4.35001C13.225 4.35001 16.65 7.77503 16.65 12C16.65 16.225 13.225 19.65 9.00001 19.65C4.77503 19.65 1.35001 16.225 1.35001 12Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15 5.65001C11.493 5.65001 8.65001 8.493 8.65001 12C8.65001 15.507 11.493 18.35 15 18.35C18.507 18.35 21.35 15.507 21.35 12C21.35 8.493 18.507 5.65001 15 5.65001ZM7.35001 12C7.35001 7.77503 10.775 4.35001 15 4.35001C19.225 4.35001 22.65 7.77503 22.65 12C22.65 16.225 19.225 19.65 15 19.65C10.775 19.65 7.35001 16.225 7.35001 12Z", fill: "currentColor" })] });
Merge24.displayName = "Merge24";
const Memo$D = reactExports.memo(Merge24);
const SetArea24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 4.65001C5.64196 4.65001 5.29858 4.79224 5.0454 5.04541C4.79223 5.29859 4.65 5.64196 4.65 6.00001V9.00001C4.65 9.35899 4.35898 9.65001 4 9.65001C3.64101 9.65001 3.35 9.35899 3.35 9.00001V6.00001C3.35 5.29718 3.62919 4.62314 4.12617 4.12617C4.62314 3.6292 5.29717 3.35001 6 3.35001H9C9.35898 3.35001 9.65 3.64102 9.65 4.00001C9.65 4.35899 9.35898 4.65001 9 4.65001H6ZM14.35 4.00001C14.35 3.64102 14.641 3.35001 15 3.35001H18C18.7028 3.35001 19.3769 3.6292 19.8738 4.12617C20.3708 4.62314 20.65 5.29718 20.65 6.00001V9.00001C20.65 9.35899 20.359 9.65001 20 9.65001C19.641 9.65001 19.35 9.35899 19.35 9.00001V6.00001C19.35 5.64196 19.2078 5.29859 18.9546 5.04541C18.7014 4.79224 18.358 4.65001 18 4.65001H15C14.641 4.65001 14.35 4.35899 14.35 4.00001ZM4 14.35C4.35898 14.35 4.65 14.641 4.65 15V18C4.65 18.358 4.79223 18.7014 5.0454 18.9546C5.29858 19.2078 5.64196 19.35 6 19.35H9C9.35898 19.35 9.65 19.641 9.65 20C9.65 20.359 9.35898 20.65 9 20.65H6C5.29717 20.65 4.62314 20.3708 4.12617 19.8738C3.62919 19.3769 3.35 18.7028 3.35 18V15C3.35 14.641 3.64101 14.35 4 14.35ZM20 14.35C20.359 14.35 20.65 14.641 20.65 15V18C20.65 18.7028 20.3708 19.3769 19.8738 19.8738C19.3769 20.3708 18.7028 20.65 18 20.65H15C14.641 20.65 14.35 20.359 14.35 20C14.35 19.641 14.641 19.35 15 19.35H18C18.358 19.35 18.7014 19.2078 18.9546 18.9546C19.2078 18.7014 19.35 18.358 19.35 18V15C19.35 14.641 19.641 14.35 20 14.35Z", fill: "currentColor" }) });
SetArea24.displayName = "SetArea24";
const Memo$C = reactExports.memo(SetArea24);
const Analytics24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.01396 12.6935C2.01396 7.63456 6.10498 3.54355 11.164 3.54355C11.5229 3.54355 11.814 3.83456 11.814 4.19355V12.0435H19.664C20.0229 12.0435 20.314 12.3346 20.314 12.6935C20.314 17.7525 16.2229 21.8435 11.164 21.8435C6.10498 21.8435 2.01396 17.7525 2.01396 12.6935ZM10.514 4.86997C6.47799 5.19954 3.31396 8.57143 3.31396 12.6935C3.31396 17.0346 6.82295 20.5435 11.164 20.5435C15.2861 20.5435 18.658 17.3795 18.9875 13.3435H11.164C10.805 13.3435 10.514 13.0525 10.514 12.6935V4.86997Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.6675 2.14377C13.6675 1.78479 13.9585 1.49377 14.3175 1.49377C18.802 1.49377 22.4285 5.12028 22.4285 9.60473C22.4285 9.96371 22.1375 10.2547 21.7785 10.2547H14.3175C13.9585 10.2547 13.6675 9.96371 13.6675 9.60473V2.14377ZM14.9675 2.82427V8.95473H21.098C20.7917 5.70801 18.2142 3.13051 14.9675 2.82427Z", fill: "currentColor" })] });
Analytics24.displayName = "Analytics24";
const Memo$B = reactExports.memo(Analytics24);
const Layers16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.88092 10.4538C1.9985 10.2039 2.29637 10.0967 2.54623 10.2143L8 12.7807L13.4538 10.2143C13.7036 10.0967 14.0015 10.2039 14.1191 10.4538C14.2367 10.7036 14.1294 11.0015 13.8796 11.1191L8.2129 13.7857C8.07806 13.8492 7.92194 13.8492 7.7871 13.7857L2.12043 11.1191C1.87057 11.0015 1.76334 10.7036 1.88092 10.4538Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.88092 7.78711C1.9985 7.53725 2.29637 7.43002 2.54623 7.5476L8 10.1141L13.4538 7.5476C13.7036 7.43002 14.0015 7.53725 14.1191 7.78711C14.2367 8.03696 14.1294 8.33483 13.8796 8.45241L8.2129 11.1191C8.07806 11.1825 7.92194 11.1825 7.7871 11.1191L2.12043 8.45241C1.87057 8.33483 1.76334 8.03696 1.88092 7.78711Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.7871 2.21426C7.92194 2.15081 8.07806 2.15081 8.2129 2.21426L13.8796 4.88093C14.0548 4.9634 14.1667 5.13966 14.1667 5.33334C14.1667 5.52702 14.0548 5.70328 13.8796 5.78575L8.2129 8.45241C8.07806 8.51587 7.92194 8.51587 7.7871 8.45241L2.12043 5.78575C1.94519 5.70328 1.83333 5.52702 1.83333 5.33334C1.83333 5.13966 1.94519 4.9634 2.12043 4.88093L7.7871 2.21426ZM3.5076 5.33334L8 7.44741L12.4924 5.33334L8 3.21927L3.5076 5.33334Z", fill: "currentColor" })] });
Layers16.displayName = "Layers16";
const Memo$A = reactExports.memo(Layers16);
const Disasters16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.56616 0.972793C6.71741 0.827471 6.94328 0.791997 7.1318 0.883959C7.60411 1.11437 8.31348 1.55385 8.94527 2.14197C9.56908 2.72267 10.1767 3.50365 10.3339 4.42375C10.4827 5.29468 10.3258 6.12532 10.0836 6.79665C10.0502 6.88931 10.0149 6.97953 9.97831 7.06703C10.3015 6.89096 10.5707 6.68084 10.7298 6.44808C11.2109 5.74396 11.2934 5.22701 11.2934 5.14286C11.2934 4.9487 11.4058 4.77209 11.5817 4.68989C11.7576 4.60768 11.9652 4.63475 12.1141 4.75931C12.9815 5.48468 14.4288 7.58545 13.5728 10.3692C13.0806 11.9699 12.362 13.0462 11.6341 13.7823C10.9075 14.5171 10.1895 14.8943 9.73488 15.1161C9.59653 15.1835 9.4348 15.1835 9.29645 15.1161L9.2878 15.1118C8.96444 14.9541 8.44632 14.7014 7.96545 14.3602C7.49071 14.0233 6.97889 13.5501 6.76482 12.9236C6.67852 12.671 6.61337 12.4384 6.56418 12.2261C6.48252 12.4182 6.43642 12.6012 6.43642 12.7619C6.43642 13.4413 6.63297 13.9772 6.70678 14.1212C6.81012 14.3228 6.76494 14.5688 6.59667 14.7205C6.42841 14.8723 6.17913 14.8919 5.98919 14.7684C5.46601 14.4281 4.69453 13.8089 4.04782 13.0349C3.40992 12.2715 2.83333 11.2854 2.83333 10.2222C2.83333 8.98605 3.20484 8.16538 3.79394 7.41378C4.07725 7.05233 4.41122 6.70627 4.75876 6.34754C4.76959 6.33636 4.78043 6.32517 4.7913 6.31395C5.13408 5.96019 5.49876 5.58382 5.88161 5.13559C7.01495 3.80872 6.73432 2.17077 6.4548 1.53443C6.37044 1.34239 6.41491 1.11812 6.56616 0.972793ZM7.67935 2.3909C7.77725 3.37944 7.60257 4.66045 6.642 5.78506C6.23839 6.25759 5.85464 6.65362 5.5144 7.00473C5.50187 7.01767 5.48939 7.03054 5.47698 7.04335C5.12291 7.40883 4.82644 7.71752 4.581 8.03067C4.11259 8.62828 3.83333 9.23619 3.83333 10.2222C3.83333 10.9368 4.2329 11.6968 4.8152 12.3937C5.01606 12.6341 5.23155 12.8584 5.44624 13.0611C5.43989 12.9639 5.43642 12.864 5.43642 12.7619C5.43642 12.2502 5.65001 11.761 5.87296 11.3869C6.10041 11.0052 6.3723 10.6857 6.56341 10.4993C6.70736 10.3588 6.92144 10.3183 7.10676 10.3964C7.29209 10.4745 7.41258 10.656 7.41258 10.8571V10.8625C7.41257 11.1545 7.41254 11.7264 7.71111 12.6003C7.82242 12.9261 8.12407 13.2466 8.54414 13.5446C8.86781 13.7743 9.2186 13.9611 9.51341 14.1083C9.90665 13.9037 10.4117 13.5963 10.9231 13.0792C11.5332 12.4622 12.1703 11.5279 12.617 10.0753C13.1441 8.36108 12.6089 6.97413 12.033 6.15482C11.9198 6.41642 11.7642 6.70676 11.5554 7.01225C11.2229 7.49883 10.6976 7.8372 10.2278 8.0621C9.74995 8.29086 9.2699 8.43041 8.96065 8.49075C8.75373 8.53113 8.54371 8.43737 8.43562 8.25637C8.32752 8.07536 8.34458 7.846 8.47825 7.68297C8.6588 7.46279 8.93975 7.02065 9.14295 6.45733C9.34548 5.89586 9.45972 5.24501 9.34819 4.59214C9.24506 3.98843 8.82233 3.39375 8.2639 2.87392C8.07374 2.6969 7.87472 2.53498 7.67935 2.3909Z", fill: "currentColor" }) });
Disasters16.displayName = "Disasters16";
const Memo$z = reactExports.memo(Disasters16);
const AdvancedAnalytics16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.20874 1.89331C2.53172 1.57033 2.96977 1.38889 3.42653 1.38889H10.129C10.2617 1.38889 10.3888 1.44156 10.4826 1.53533L14.1493 5.202C14.243 5.29577 14.2957 5.42294 14.2957 5.55555V12.8889C14.2957 13.3456 14.1143 13.7837 13.7913 14.1067C13.4683 14.4297 13.0303 14.6111 12.5735 14.6111H3.42653C2.96977 14.6111 2.53172 14.4297 2.20874 14.1067C1.88576 13.7837 1.70431 13.3456 1.70431 12.8889V3.11111C1.70431 2.65435 1.88576 2.21629 2.20874 1.89331ZM3.42653 2.38889C3.23499 2.38889 3.05129 2.46498 2.91585 2.60042C2.7804 2.73586 2.70431 2.91956 2.70431 3.11111V12.8889C2.70431 13.0804 2.7804 13.2641 2.91585 13.3996C3.05129 13.535 3.23499 13.6111 3.42653 13.6111H12.5735C12.765 13.6111 12.9487 13.535 13.0842 13.3996C13.2196 13.2641 13.2957 13.0804 13.2957 12.8889V5.76266L9.92194 2.38889H3.42653Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.51913 9.22222C3.51913 8.94608 3.74299 8.72222 4.01913 8.72222H5.24135C5.51749 8.72222 5.74135 8.94608 5.74135 9.22222C5.74135 9.49836 5.51749 9.72222 5.24135 9.72222H4.01913C3.74299 9.72222 3.51913 9.49836 3.51913 9.22222Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.78684 9.22222C6.78684 8.94608 7.0107 8.72222 7.28684 8.72222H8.50906C8.78521 8.72222 9.00906 8.94608 9.00906 9.22222C9.00906 9.49836 8.78521 9.72222 8.50906 9.72222H7.28684C7.0107 9.72222 6.78684 9.49836 6.78684 9.22222Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.0546 9.22222C10.0546 8.94608 10.2785 8.72222 10.5546 8.72222H11.7769C12.053 8.72222 12.2769 8.94608 12.2769 9.22222C12.2769 9.49836 12.053 9.72222 11.7769 9.72222H10.5546C10.2785 9.72222 10.0546 9.49836 10.0546 9.22222Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.51913 11.6667C3.51913 11.3905 3.74299 11.1667 4.01913 11.1667H5.24135C5.51749 11.1667 5.74135 11.3905 5.74135 11.6667C5.74135 11.9428 5.51749 12.1667 5.24135 12.1667H4.01913C3.74299 12.1667 3.51913 11.9428 3.51913 11.6667Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.78684 11.6667C6.78684 11.3905 7.0107 11.1667 7.28684 11.1667H8.50906C8.78521 11.1667 9.00906 11.3905 9.00906 11.6667C9.00906 11.9428 8.78521 12.1667 8.50906 12.1667H7.28684C7.0107 12.1667 6.78684 11.9428 6.78684 11.6667Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.0546 11.6667C10.0546 11.3905 10.2785 11.1667 10.5546 11.1667H11.7769C12.053 11.1667 12.2769 11.3905 12.2769 11.6667C12.2769 11.9428 12.053 12.1667 11.7769 12.1667H10.5546C10.2785 12.1667 10.0546 11.9428 10.0546 11.6667Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.51913 6.77777C3.51913 6.50163 3.74299 6.27777 4.01913 6.27777H5.24135C5.51749 6.27777 5.74135 6.50163 5.74135 6.77777C5.74135 7.05392 5.51749 7.27777 5.24135 7.27777H4.01913C3.74299 7.27777 3.51913 7.05392 3.51913 6.77777Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.78684 6.77777C6.78684 6.50163 7.0107 6.27777 7.28684 6.27777H8.50906C8.7852 6.27777 9.00906 6.50163 9.00906 6.77777C9.00906 7.05392 8.7852 7.27777 8.50906 7.27777H7.28684C7.0107 7.27777 6.78684 7.05392 6.78684 6.77777Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.51913 4.33333C3.51913 4.05719 3.74299 3.83333 4.01913 3.83333H5.24135C5.51749 3.83333 5.74135 4.05719 5.74135 4.33333C5.74135 4.60947 5.51749 4.83333 5.24135 4.83333H4.01913C3.74299 4.83333 3.51913 4.60947 3.51913 4.33333Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.78684 4.33333C6.78684 4.05719 7.0107 3.83333 7.28684 3.83333H8.50906C8.7852 3.83333 9.00906 4.05719 9.00906 4.33333C9.00906 4.60947 8.7852 4.83333 8.50906 4.83333H7.28684C7.0107 4.83333 6.78684 4.60947 6.78684 4.33333Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.129 1.38889C10.4052 1.38889 10.629 1.61274 10.629 1.88889V5.05555H13.7957C14.0719 5.05555 14.2957 5.27941 14.2957 5.55555C14.2957 5.8317 14.0719 6.05555 13.7957 6.05555H10.129C9.8529 6.05555 9.62904 5.83169 9.62904 5.55555V1.88889C9.62904 1.61274 9.8529 1.38889 10.129 1.38889Z", fill: "currentColor" })] });
AdvancedAnalytics16.displayName = "AdvancedAnalytics16";
const Memo$y = reactExports.memo(AdvancedAnalytics16);
const Legend16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.94504 12.9339C6.94504 12.6578 7.1689 12.4339 7.44504 12.4339H14.2524C14.5285 12.4339 14.7524 12.6578 14.7524 12.9339C14.7524 13.21 14.5285 13.4339 14.2524 13.4339H7.44504C7.1689 13.4339 6.94504 13.21 6.94504 12.9339Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.94502 7.95443C6.94502 7.67829 7.16888 7.45443 7.44502 7.45443H14.2524C14.5285 7.45443 14.7524 7.67829 14.7524 7.95443C14.7524 8.23058 14.5285 8.45443 14.2524 8.45443H7.44502C7.16888 8.45443 6.94502 8.23058 6.94502 7.95443Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.94504 3.06086C6.94504 2.78472 7.1689 2.56086 7.44504 2.56086H14.2524C14.5285 2.56086 14.7524 2.78472 14.7524 3.06086C14.7524 3.337 14.5285 3.56086 14.2524 3.56086H7.44504C7.1689 3.56086 6.94504 3.337 6.94504 3.06086Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.65379 11.2159C3.8142 11.2159 3.96486 11.2929 4.05889 11.4228L5.65913 13.6348C5.76923 13.787 5.78475 13.988 5.6993 14.1553C5.61386 14.3226 5.44187 14.4278 5.25403 14.4278H2.0534C1.86556 14.4278 1.69357 14.3226 1.60813 14.1553C1.52268 13.988 1.5382 13.7869 1.64831 13.6348L3.24869 11.4228C3.34272 11.2928 3.49339 11.2159 3.65379 11.2159ZM3.03231 13.4278H4.27518L3.65377 12.5689L3.03231 13.4278Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.45343 4.69237C2.17728 4.69237 1.95343 4.46851 1.95343 4.19237L1.95343 1.92918C1.95343 1.65304 2.17728 1.42918 2.45343 1.42918L4.71661 1.42918C4.99275 1.42918 5.21661 1.65304 5.21661 1.92918L5.21661 4.19237C5.21661 4.46851 4.99275 4.69237 4.71661 4.69237H2.45343ZM2.95343 3.69237H4.21661L4.21661 2.42918L2.95343 2.42918V3.69237Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.65368 7.2539C3.26693 7.2539 2.95342 7.56742 2.95342 7.95416C2.95342 8.34091 3.26693 8.65443 3.65368 8.65443C4.04042 8.65443 4.35394 8.34091 4.35394 7.95416C4.35394 7.56742 4.04042 7.2539 3.65368 7.2539ZM1.95342 7.95416C1.95342 7.01513 2.71465 6.2539 3.65368 6.2539C4.59271 6.2539 5.35394 7.01513 5.35394 7.95416C5.35394 8.89319 4.59271 9.65443 3.65368 9.65443C2.71465 9.65443 1.95342 8.89319 1.95342 7.95416Z", fill: "currentColor" })] });
Legend16.displayName = "Legend16";
const Memo$x = reactExports.memo(Legend16);
const BivariateMatrix16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.33531 8.35355C9.14005 8.15829 9.14005 7.84171 9.33531 7.64645L11.8684 5.11334C12.0637 4.91808 12.3803 4.91808 12.5755 5.11334L15.1086 7.64645C15.3039 7.84171 15.3039 8.15829 15.1086 8.35355L12.5755 10.8867C12.3803 11.0819 12.0637 11.0819 11.8684 10.8867L9.33531 8.35355ZM10.396 8L12.222 9.826L14.048 8L12.222 6.174L10.396 8Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.11334 12.5754C4.91808 12.3801 4.91808 12.0635 5.11334 11.8683L7.64645 9.33517C7.84171 9.1399 8.15829 9.1399 8.35355 9.33517L10.8867 11.8683C11.0819 12.0635 11.0819 12.3801 10.8867 12.5754L8.35355 15.1085C8.15829 15.3037 7.84171 15.3037 7.64645 15.1085L5.11334 12.5754ZM6.174 12.2218L8 14.0478L9.826 12.2218L8 10.3958L6.174 12.2218Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.11334 4.13173C4.91808 3.93647 4.91808 3.61988 5.11334 3.42462L7.64645 0.891518C7.84171 0.696256 8.15829 0.696256 8.35355 0.891518L10.8867 3.42462C11.0819 3.61988 11.0819 3.93647 10.8867 4.13173L8.35355 6.66483C8.15829 6.86009 7.84171 6.86009 7.64645 6.66483L5.11334 4.13173ZM6.174 3.77817L8 5.60417L9.826 3.77817L8 1.95218L6.174 3.77817Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0.891663 8.35355C0.696401 8.15829 0.696401 7.84171 0.891663 7.64645L3.42477 5.11334C3.62003 4.91808 3.93661 4.91808 4.13187 5.11334L6.66498 7.64645C6.86024 7.84171 6.86024 8.15829 6.66498 8.35355L4.13187 10.8867C3.93661 11.0819 3.62003 11.0819 3.42477 10.8867L0.891663 8.35355ZM1.95232 8L3.77832 9.826L5.60432 8L3.77832 6.174L1.95232 8Z", fill: "currentColor" })] });
BivariateMatrix16.displayName = "BivariateMatrix16";
const Memo$w = reactExports.memo(BivariateMatrix16);
const Analytics16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.27597 8.46237C1.27597 5.05289 4.03316 2.2957 7.44264 2.2957C7.71878 2.2957 7.94264 2.51956 7.94264 2.7957V7.96237H13.1093C13.3854 7.96237 13.6093 8.18622 13.6093 8.46237C13.6093 11.8718 10.8521 14.629 7.44264 14.629C4.03316 14.629 1.27597 11.8718 1.27597 8.46237ZM6.94264 3.31949C4.32078 3.57032 2.27597 5.77387 2.27597 8.46237C2.27597 11.3196 4.58545 13.629 7.44264 13.629C10.1311 13.629 12.3347 11.5842 12.5855 8.96237H7.44264C7.16649 8.96237 6.94264 8.73851 6.94264 8.46237V3.31949Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.045 1.42918C9.045 1.15304 9.26886 0.929184 9.545 0.929184C12.5715 0.929184 15.019 3.3767 15.019 6.40315C15.019 6.6793 14.7951 6.90315 14.519 6.90315H9.545C9.26886 6.90315 9.045 6.6793 9.045 6.40315V1.42918ZM10.045 1.9567V5.90315H13.9915C13.7617 3.82918 12.119 2.18648 10.045 1.9567Z", fill: "currentColor" })] });
Analytics16.displayName = "Analytics16";
const Memo$v = reactExports.memo(Analytics16);
const DoubleChevronUp24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.5 5.85C11.6724 5.85 11.8377 5.91848 11.9596 6.04038L16.9596 11.0404C17.2135 11.2942 17.2135 11.7058 16.9596 11.9596C16.7058 12.2135 16.2942 12.2135 16.0404 11.9596L11.5 7.41924L6.95962 11.9596C6.70578 12.2135 6.29422 12.2135 6.04038 11.9596C5.78654 11.7058 5.78654 11.2942 6.04038 11.0404L11.0404 6.04038C11.1623 5.91848 11.3276 5.85 11.5 5.85ZM6.04038 17.0404L11.0404 12.0404C11.2942 11.7865 11.7058 11.7865 11.9596 12.0404L16.9596 17.0404C17.2135 17.2942 17.2135 17.7058 16.9596 17.9596C16.7058 18.2135 16.2942 18.2135 16.0404 17.9596L11.5 13.4192L6.95962 17.9596C6.70578 18.2135 6.29422 18.2135 6.04038 17.9596C5.78654 17.7058 5.78654 17.2942 6.04038 17.0404Z", fill: "currentColor" }) });
DoubleChevronUp24.displayName = "DoubleChevronUp24";
const Memo$u = reactExports.memo(DoubleChevronUp24);
const DoubleChevronDown24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.04038 6.04038C6.29422 5.78654 6.70578 5.78654 6.95962 6.04038L11.5 10.5808L16.0404 6.04038C16.2942 5.78654 16.7058 5.78654 16.9596 6.04038C17.2135 6.29422 17.2135 6.70578 16.9596 6.95962L11.9596 11.9596C11.8377 12.0815 11.6724 12.15 11.5 12.15C11.3276 12.15 11.1623 12.0815 11.0404 11.9596L6.04038 6.95962C5.78654 6.70578 5.78654 6.29422 6.04038 6.04038ZM6.04038 12.0404C6.29422 11.7865 6.70578 11.7865 6.95962 12.0404L11.5 16.5808L16.0404 12.0404C16.2942 11.7865 16.7058 11.7865 16.9596 12.0404C17.2135 12.2942 17.2135 12.7058 16.9596 12.9596L11.9596 17.9596C11.7058 18.2135 11.2942 18.2135 11.0404 17.9596L6.04038 12.9596C5.78654 12.7058 5.78654 12.2942 6.04038 12.0404Z", fill: "currentColor" }) });
DoubleChevronDown24.displayName = "DoubleChevronDown24";
const Memo$t = reactExports.memo(DoubleChevronDown24);
const History24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.7412 7.86976H7.09091C7.4499 7.86976 7.74091 8.16077 7.74091 8.51976C7.74091 8.87874 7.4499 9.16976 7.09091 9.16976H3C2.64102 9.16976 2.35 8.87874 2.35 8.51976V4.63636C2.35 4.27738 2.64102 3.98636 3 3.98636C3.35899 3.98636 3.65 4.27738 3.65 4.63636V7.15975C5.32022 4.28456 8.43359 2.35 12 2.35C17.3295 2.35 21.65 6.67045 21.65 12C21.65 17.3295 17.3295 21.65 12 21.65C8.249 21.65 4.99901 19.5097 3.40257 16.3868C3.23918 16.0671 3.36583 15.6755 3.68548 15.5121C4.00512 15.3487 4.3967 15.4754 4.5601 15.795C5.94301 18.5003 8.75605 20.35 12 20.35C16.6116 20.35 20.35 16.6116 20.35 12C20.35 7.38842 16.6116 3.65 12 3.65C8.89174 3.65 6.17896 5.34846 4.7412 7.86976ZM12 7.25909C12.359 7.25909 12.65 7.5501 12.65 7.90909V11.7308L15.7324 14.8131C15.9862 15.0669 15.9862 15.4785 15.7324 15.7323C15.4785 15.9862 15.067 15.9862 14.8131 15.7323L11.5404 12.4596C11.4185 12.3377 11.35 12.1724 11.35 12V7.90909C11.35 7.5501 11.641 7.25909 12 7.25909Z", fill: "currentColor" }) });
History24.displayName = "History24";
const Memo$s = reactExports.memo(History24);
const Video24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 6.65C3.25441 6.65 2.65 7.25441 2.65 8V16C2.65 16.7456 3.25441 17.35 4 17.35H14C14.7456 17.35 15.35 16.7456 15.35 16V8C15.35 7.25441 14.7456 6.65 14 6.65H4ZM1.35 8C1.35 6.53644 2.53644 5.35 4 5.35H14C15.4636 5.35 16.65 6.53644 16.65 8V10.6122L21.5839 6.50065C21.7776 6.33919 22.0473 6.30439 22.2757 6.41137C22.5041 6.51834 22.65 6.74779 22.65 7V17C22.65 17.2522 22.5041 17.4817 22.2757 17.5886C22.0473 17.6956 21.7776 17.6608 21.5839 17.4993L16.65 13.3878V16C16.65 17.4636 15.4636 18.65 14 18.65H4C2.53644 18.65 1.35 17.4636 1.35 16V8ZM17.0153 12L21.35 15.6122V8.38778L17.0153 12Z", fill: "currentColor" }) });
Video24.displayName = "Video24";
const Memo$r = reactExports.memo(Video24);
const TimelinePoint24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { d: "M18 9C18 13.1682 14.3081 18.181 12.7163 20.1486C12.3421 20.6111 11.6579 20.6111 11.2837 20.1486C9.69194 18.181 6 13.1682 6 9C6 5.68629 8.68629 3 12 3C15.3137 3 18 5.68629 18 9Z", fill: "currentColor" }) });
TimelinePoint24.displayName = "TimelinePoint24";
const Memo$q = reactExports.memo(TimelinePoint24);
const TimelinePoints24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.7163 20.1486C14.3081 18.181 18 13.1682 18 9C18 5.68629 15.3137 3 12 3C8.68629 3 6 5.68629 6 9C6 13.1682 9.69194 18.181 11.2837 20.1486C11.6579 20.6111 12.3421 20.6111 12.7163 20.1486ZM8 9C8 8.44772 8.44772 8 9 8C9.55228 8 10 8.44772 10 9C10 9.55228 9.55228 10 9 10C8.44772 10 8 9.55228 8 9ZM11 9C11 8.44772 11.4477 8 12 8C12.5523 8 13 8.44772 13 9C13 9.55228 12.5523 10 12 10C11.4477 10 11 9.55228 11 9ZM15 8C14.4477 8 14 8.44772 14 9C14 9.55228 14.4477 10 15 10C15.5523 10 16 9.55228 16 9C16 8.44772 15.5523 8 15 8Z", fill: "currentColor" }) });
TimelinePoints24.displayName = "TimelinePoints24";
const Memo$p = reactExports.memo(TimelinePoints24);
const Ninja24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23 12C23 18.0723 18.078 23 12 23C5.92202 23 1 18.0723 1 12C1 5.92771 5.92202 1 12 1C18.078 1 23 5.92771 23 12ZM12 22C17.5254 22 22 17.5203 22 12C22 6.47967 17.5254 2 12 2C6.47463 2 2 6.47967 2 12C2 17.5203 6.47463 22 12 22Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.0455 8.03394C8.07302 8.03394 4.69296 9.6045 3.43677 11.7975C4.69296 13.9904 8.07302 15.561 12.0455 15.561C16.0181 15.561 19.3981 13.9904 20.6543 11.7975C19.3981 9.6045 16.0181 8.03394 12.0455 8.03394ZM17.3348 10.6499L12.8579 12.9116C13.3369 13.417 14.0416 13.7363 14.8272 13.7363C16.2705 13.7363 17.4404 12.6588 17.4404 11.3296C17.4404 11.0935 17.4035 10.8654 17.3348 10.6499ZM6.5893 10.6499L11.0662 12.9116C10.5871 13.417 9.88248 13.7363 9.09684 13.7363C7.65361 13.7363 6.48364 12.6588 6.48364 11.3296C6.48364 11.0935 6.52054 10.8654 6.5893 10.6499Z", fill: "currentColor" })] });
Ninja24.displayName = "Ninja24";
const Memo$o = reactExports.memo(Ninja24);
const Kontur24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M14.2361 7.31354L10.5888 11.3033C10.5626 11.3325 10.5282 11.353 10.4901 11.362C10.452 11.3711 10.4121 11.3682 10.3757 11.3539C10.3392 11.3395 10.308 11.3144 10.2861 11.2818C10.2643 11.2491 10.2528 11.2106 10.2533 11.1713V7.55703C10.2533 7.41309 10.1964 7.27505 10.0952 7.17327C9.99393 7.07149 9.85663 7.01431 9.71347 7.01431H8.87605C8.73288 7.01431 8.59558 7.07149 8.49435 7.17327C8.39312 7.27505 8.33625 7.41309 8.33625 7.55703V16.4665C8.33508 16.5383 8.3482 16.6097 8.37485 16.6764C8.40149 16.7431 8.44111 16.8038 8.49139 16.8549C8.54167 16.906 8.6016 16.9465 8.66765 16.974C8.7337 17.0015 8.80456 17.0154 8.87605 17.015H9.71055C9.7813 17.0154 9.85143 17.0017 9.9169 16.9748C9.98237 16.9478 10.0419 16.9081 10.0921 16.858C10.1422 16.8078 10.182 16.7482 10.2092 16.6825C10.2364 16.6168 10.2503 16.5464 10.2503 16.4753V14.5127C10.2747 14.3738 10.3263 14.2412 10.4021 14.1225C10.5056 14.0095 10.6316 13.9197 10.7718 13.8589C10.9121 13.7981 11.0636 13.7677 11.2163 13.7697C11.3691 13.7716 11.5197 13.8058 11.6584 13.8702C11.7971 13.9345 11.9208 14.0275 12.0215 14.143L14.2332 16.6865C14.3204 16.7884 14.4282 16.8704 14.5495 16.9271C14.6708 16.9838 14.8027 17.0137 14.9364 17.015H16.0481C16.1223 17.0187 16.1958 17 16.2594 16.9614C16.323 16.9228 16.3737 16.866 16.405 16.7983C16.4363 16.7306 16.4468 16.6551 16.4352 16.5813C16.4236 16.5076 16.3904 16.439 16.3399 16.3843L12.5467 12.2215C12.4941 12.1668 12.4647 12.0937 12.4647 12.0176C12.4647 11.9415 12.4941 11.8684 12.5467 11.8137L16.3399 7.64797C16.3904 7.59329 16.4236 7.52469 16.4352 7.45094C16.4468 7.37719 16.4363 7.30164 16.405 7.23394C16.3737 7.16624 16.323 7.10946 16.2594 7.07086C16.1958 7.03226 16.1223 7.0136 16.0481 7.01724H14.9218C14.7934 7.01639 14.6661 7.04228 14.5481 7.09327C14.4301 7.14426 14.3239 7.21926 14.2361 7.31354Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M1.58147 16.6073V1.73964C1.58147 1.69996 1.59714 1.6619 1.62505 1.63385C1.65296 1.60579 1.69081 1.59003 1.73027 1.59003H16.2115C16.2605 1.59003 16.3091 1.58031 16.3544 1.56144C16.3997 1.54257 16.4409 1.51491 16.4756 1.48004C16.5103 1.44517 16.5378 1.40378 16.5565 1.35822C16.5753 1.31266 16.585 1.26383 16.585 1.21452V0.375504C16.585 0.275914 16.5456 0.180403 16.4756 0.109983C16.4055 0.0395619 16.3105 0 16.2115 0H0.373483C0.274429 0 0.179432 0.0395619 0.109391 0.109983C0.0393489 0.180403 0 0.275914 0 0.375504V16.6073C0 16.7068 0.0393489 16.8024 0.109391 16.8728C0.179432 16.9432 0.274429 16.9828 0.373483 16.9828H1.20798C1.3068 16.982 1.40135 16.9422 1.47123 16.8719C1.54111 16.8017 1.5807 16.7066 1.58147 16.6073Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M22.4214 7.39274V22.2604C22.4214 22.3 22.4058 22.3381 22.3779 22.3662C22.3499 22.3942 22.3121 22.41 22.2726 22.41H7.70973C7.61068 22.41 7.51568 22.4495 7.44564 22.52C7.3756 22.5904 7.33625 22.6859 7.33625 22.7855V23.6245C7.33625 23.7241 7.3756 23.8196 7.44564 23.89C7.51568 23.9604 7.61068 24 7.70973 24H23.6265C23.7256 24 23.8206 23.9604 23.8906 23.89C23.9606 23.8196 24 23.7241 24 23.6245V7.39274C24 7.29315 23.9606 7.19764 23.8906 7.12722C23.8206 7.0568 23.7256 7.01724 23.6265 7.01724H22.7949C22.6959 7.01724 22.6009 7.0568 22.5308 7.12722C22.4608 7.19764 22.4214 7.29315 22.4214 7.39274Z", fill: "currentColor" })] });
Kontur24.displayName = "Kontur24";
const Memo$n = reactExports.memo(Kontur24);
const Minus16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { d: "M13 8C13 7.72386 12.7761 7.5 12.5 7.5L3.49999 7.5C3.22385 7.5 2.99999 7.72386 2.99999 8C2.99999 8.27615 3.22385 8.5 3.49999 8.5H12.5C12.7761 8.5 13 8.27614 13 8Z", fill: "currentColor" }) });
Minus16.displayName = "Minus16";
const Memo$m = reactExports.memo(Minus16);
const ZoomTo16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.50007 1.00005C1.22392 1.00005 1.00005 1.22392 1.00005 1.50007V5.00025C1.00005 5.2764 1.22392 5.50027 1.50007 5.50027C1.77623 5.50027 2.0001 5.2764 2.0001 5.00025V2.20011C2.0001 2.08965 2.08965 2.0001 2.20011 2.0001H5.00025C5.2764 2.0001 5.50027 1.77623 5.50027 1.50007C5.50027 1.22392 5.2764 1.00005 5.00025 1.00005H1.50007ZM11.0005 1.00005C10.7244 1.00005 10.5005 1.22392 10.5005 1.50007C10.5005 1.77623 10.7244 2.0001 11.0005 2.0001H13.8007C13.9111 2.0001 14.0007 2.08965 14.0007 2.20011V5.00025C14.0007 5.2764 14.2246 5.50027 14.5007 5.50027C14.7769 5.50027 15.0007 5.2764 15.0007 5.00025V1.50007C15.0007 1.22392 14.7769 1.00005 14.5007 1.00005H11.0005ZM15.0007 11.0005C15.0007 10.7244 14.7769 10.5005 14.5007 10.5005C14.2246 10.5005 14.0007 10.7244 14.0007 11.0005V13.8007C14.0007 13.9111 13.9111 14.0007 13.8007 14.0007H11.0005C10.7244 14.0007 10.5005 14.2246 10.5005 14.5007C10.5005 14.7769 10.7244 15.0007 11.0005 15.0007H14.5007C14.7769 15.0007 15.0007 14.7769 15.0007 14.5007V11.0005ZM5.00025 15.0007C5.2764 15.0007 5.50027 14.7769 5.50027 14.5007C5.50027 14.2246 5.2764 14.0007 5.00025 14.0007H2.20011C2.08965 14.0007 2.0001 13.9111 2.0001 13.8007V11.0005C2.0001 10.7244 1.77623 10.5005 1.50007 10.5005C1.22392 10.5005 1.00005 10.7244 1.00005 11.0005V14.5007C1.00005 14.7769 1.22392 15.0007 1.50007 15.0007H5.00025Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.0004 12.0006C10.2096 12.0006 12.0006 10.2096 12.0006 8.0004C12.0006 5.79115 10.2096 4.0002 8.0004 4.0002C5.79115 4.0002 4.0002 5.79115 4.0002 8.0004C4.0002 10.2096 5.79115 12.0006 8.0004 12.0006ZM8.0004 13.0006C10.762 13.0006 13.0006 10.762 13.0006 8.0004C13.0006 5.23884 10.762 3.00015 8.0004 3.00015C5.23884 3.00015 3.00015 5.23884 3.00015 8.0004C3.00015 10.762 5.23884 13.0006 8.0004 13.0006Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.0004 5.00025C8.27655 5.00025 8.50042 5.22412 8.50042 5.50027L8.50042 10.5005C8.50042 10.7767 8.27655 11.0005 8.0004 11.0005C7.72424 11.0005 7.50037 10.7767 7.50037 10.5005L7.50037 5.50027C7.50037 5.22412 7.72424 5.00025 8.0004 5.00025Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.0005 8.0004C11.0005 8.27655 10.7767 8.50042 10.5005 8.50042L5.50027 8.50042C5.22412 8.50042 5.00025 8.27655 5.00025 8.0004C5.00025 7.72424 5.22412 7.50037 5.50027 7.50037L10.5005 7.50037C10.7767 7.50037 11.0005 7.72424 11.0005 8.0004Z", fill: "currentColor" })] });
ZoomTo16.displayName = "ZoomTo16";
const Memo$l = reactExports.memo(ZoomTo16);
const North16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.0607 12.4582L4.03999 12.5027C3.99526 12.5929 3.99524 12.6588 4.00567 12.7082C4.01779 12.7657 4.05166 12.8313 4.11224 12.8889C4.23127 13.0022 4.39129 13.0381 4.5618 12.9507L6.90708 11.7493C7.59238 11.3983 8.40762 11.3983 9.09292 11.7493L11.4382 12.9507C11.6087 13.0381 11.7687 13.0022 11.8878 12.8889C11.9483 12.8313 11.9822 12.7657 11.9943 12.7082C12.0048 12.6588 12.0047 12.5929 11.96 12.5027L11.9393 12.4582L8.33279 4.18746C8.26693 4.06774 8.14877 4 8 4C7.85123 4 7.73307 4.06774 7.66721 4.18745L4.0607 12.4582ZM6.76335 3.75845C7.26472 2.74718 8.73528 2.74718 9.23665 3.75845L12.8559 12.0585C13.4352 13.227 12.1572 14.4426 10.9823 13.8407L8.637 12.6394C8.23796 12.435 7.76204 12.435 7.36299 12.6394L5.01772 13.8407C3.84276 14.4426 2.56475 13.227 3.14406 12.0585L6.76335 3.75845Z", fill: "currentColor" }) });
North16.displayName = "North16";
const Memo$k = reactExports.memo(North16);
const Ruler16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.09091 2.16666C5.22352 2.16666 5.35069 2.21933 5.44446 2.3131L13.6869 10.5555C13.8821 10.7508 13.8821 11.0674 13.6869 11.2626L11.2626 13.6869C11.0674 13.8821 10.7508 13.8821 10.5555 13.6869L2.31311 5.44445C2.21934 5.35068 2.16666 5.22351 2.16666 5.0909C2.16666 4.95829 2.21934 4.83111 2.31311 4.73735L4.73735 2.3131C4.83112 2.21933 4.9583 2.16666 5.09091 2.16666ZM3.37377 5.0909L4.4582 6.17532L5.37758 5.30379C5.57799 5.11381 5.89446 5.12226 6.08444 5.32267C6.27441 5.52308 6.26596 5.83955 6.06555 6.02953L5.16555 6.88268L6.59718 8.31431L7.52532 7.43448C7.72572 7.24451 8.04219 7.25296 8.23217 7.45337C8.42215 7.65378 8.41369 7.97024 8.21329 8.16022L7.30454 9.02167L8.79153 10.5087L9.71091 9.63712C9.91132 9.44714 10.2278 9.4556 10.4178 9.65601C10.6077 9.85641 10.5993 10.1729 10.3989 10.3629L9.49889 11.216L10.9091 12.6262L12.6262 10.9091L5.09091 3.37376L3.37377 5.0909Z", fill: "currentColor" }) });
Ruler16.displayName = "Ruler16";
const Memo$j = reactExports.memo(Ruler16);
const Line16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.0404 4.66666L4.66666 12.0404L3.95956 11.3333L11.3333 3.95955L12.0404 4.66666Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.66666 11.6667V12.3333H4.33333V11.6667H3.66666ZM3.16666 10.6667C2.89052 10.6667 2.66666 10.8905 2.66666 11.1667V12.8333C2.66666 13.1095 2.89052 13.3333 3.16666 13.3333H4.83333C5.10947 13.3333 5.33333 13.1095 5.33333 12.8333V11.1667C5.33333 10.8905 5.10947 10.6667 4.83333 10.6667H3.16666Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.6667 3.66666V4.33332H12.3333V3.66666H11.6667ZM11.1667 2.66666C10.8905 2.66666 10.6667 2.89051 10.6667 3.16666V4.83332C10.6667 5.10947 10.8905 5.33332 11.1667 5.33332H12.8333C13.1095 5.33332 13.3333 5.10947 13.3333 4.83332V3.16666C13.3333 2.89051 13.1095 2.66666 12.8333 2.66666H11.1667Z", fill: "currentColor" })] });
Line16.displayName = "Line16";
const Memo$i = reactExports.memo(Line16);
const SelectArea16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.90258 0.921969C4.14172 0.783898 4.44752 0.865835 4.58559 1.10498L5.758 3.13565C5.89607 3.37479 5.81413 3.68059 5.57498 3.81866C5.33584 3.95673 5.03004 3.87479 4.89197 3.63565L3.71957 1.60498C3.58149 1.36584 3.66343 1.06004 3.90258 0.921969Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.54398 0.442576C7.81071 0.514047 7.969 0.788216 7.89753 1.05495L7.29065 3.31986C7.21918 3.58659 6.94501 3.74488 6.67828 3.67341C6.41154 3.60194 6.25325 3.32777 6.32472 3.06104L6.9316 0.79613C7.00308 0.529397 7.27724 0.371105 7.54398 0.442576Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.4578 2.67844C10.5959 2.91759 10.514 3.22339 10.2748 3.36146L8.24414 4.53386C8.005 4.67193 7.6992 4.58999 7.56113 4.35085C7.42306 4.1117 7.505 3.80591 7.74414 3.66784L9.77481 2.49543C10.014 2.35736 10.3197 2.4393 10.4578 2.67844Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.0427 5.80486C5.18077 6.044 5.09884 6.3498 4.85969 6.48787L2.82903 7.66027C2.58988 7.79834 2.28408 7.71641 2.14601 7.47726C2.00794 7.23811 2.08988 6.93232 2.32903 6.79425L4.35969 5.62184C4.59884 5.48377 4.90463 5.56571 5.0427 5.80486Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.89744 4.70154C4.82597 4.96827 4.5518 5.12656 4.28507 5.05509L2.02016 4.44821C1.75343 4.37674 1.59513 4.10257 1.66661 3.83584C1.73808 3.5691 2.01225 3.41081 2.27898 3.48228L4.54389 4.08917C4.81062 4.16064 4.96891 4.4348 4.89744 4.70154Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.44827 5.3054C6.62512 5.2033 6.84629 5.219 7.00694 5.34506L13.2126 10.2148C13.3702 10.3384 13.4388 10.5443 13.3868 10.7378C13.3349 10.9313 13.1724 11.0751 12.974 11.1032L10.0358 11.5193L8.2064 13.8558C8.08288 14.0135 7.87712 14.0823 7.68357 14.0306C7.49001 13.9788 7.34604 13.8165 7.31773 13.6182L6.20329 5.80905C6.17444 5.60689 6.27142 5.4075 6.44827 5.3054ZM8.14202 12.3159L9.37264 10.7442C9.45231 10.6424 9.56827 10.5755 9.69622 10.5574L11.6727 10.2775L7.36917 6.90045L8.14202 12.3159Z", fill: "currentColor" })] });
SelectArea16.displayName = "SelectArea16";
const Memo$h = reactExports.memo(SelectArea16);
const Poly16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.86877 1.07162C2.02855 0.975441 2.22858 0.976181 2.38765 1.07354L9.29715 5.30257L13.7684 4.34443C13.9337 4.30903 14.1056 4.35947 14.2255 4.47853C14.3454 4.59759 14.3971 4.76916 14.3628 4.93464L12.3628 14.6013C12.3342 14.7396 12.2485 14.8593 12.1268 14.9309C12.0051 15.0025 11.8588 15.0194 11.7241 14.9772L6.50822 13.3473L2.96265 13.9919C2.82212 14.0175 2.67737 13.9817 2.56492 13.8936C2.45246 13.8056 2.38305 13.6736 2.37418 13.531L1.62759 1.53105C1.61601 1.34491 1.70899 1.1678 1.86877 1.07162ZM2.68534 2.42819L3.33731 12.9074L6.45044 12.3414C6.52998 12.3269 6.61185 12.332 6.68902 12.3561L11.4954 13.8581L13.2282 5.48289L9.31131 6.32223C9.18589 6.34911 9.05493 6.32676 8.94552 6.25979L2.68534 2.42819Z", fill: "currentColor" }) });
Poly16.displayName = "Poly16";
const Memo$g = reactExports.memo(Poly16);
const EditInOsm16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.50427 5.91531L12.534 0.968197C13.0037 0.506179 13.7581 0.509301 14.224 0.975191L15.0232 1.77442C15.4946 2.24579 15.4914 3.01101 15.0161 3.47847L10.0166 8.39589L8.17342 9.13318C7.37865 9.45109 6.57562 8.69332 6.84702 7.88143L7.50427 5.91531ZM7.80203 8.2047C7.79808 8.20628 7.79408 8.20251 7.79543 8.19847L8.3766 6.45996L11.9056 2.98893L12.9876 4.07101L9.45868 7.54204L7.80203 8.2047ZM13.7006 3.36976L12.6185 2.28768L13.2352 1.68113C13.3135 1.60413 13.4392 1.60465 13.5169 1.6823L14.3161 2.48152C14.3946 2.56009 14.3941 2.68762 14.3149 2.76553L13.7006 3.36976Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.30091 3.40809C1.14736 3.35051 0.975333 3.37188 0.840546 3.46529C0.705759 3.5587 0.625343 3.71226 0.625343 3.87625V13.3763C0.625343 13.5847 0.75463 13.7712 0.949782 13.8444L4.94978 15.3444C5.06297 15.3869 5.18771 15.3869 5.30091 15.3444L9.12534 13.9103L12.9498 15.3444C13.1033 15.402 13.2754 15.3806 13.4101 15.2872C13.5449 15.1938 13.6253 15.0402 13.6253 14.8763V7.93955C13.6253 7.66341 13.4015 7.43955 13.1253 7.43955C12.8492 7.43955 12.6253 7.66341 12.6253 7.93955V14.1548L9.62534 13.0298V10.7921C9.62534 10.516 9.40149 10.2921 9.12534 10.2921C8.8492 10.2921 8.62534 10.516 8.62534 10.7921V13.0298L5.62534 14.1548V5.72346L6.342 5.45626C6.60075 5.35979 6.7323 5.07183 6.63583 4.81309C6.53936 4.55435 6.2514 4.4228 5.99266 4.51927L5.12585 4.84244L1.30091 3.40809ZM4.62534 5.72275V14.1548L1.62534 13.0298V4.59775L4.62534 5.72275Z", fill: "currentColor" })] });
EditInOsm16.displayName = "EditInOsm16";
const Memo$f = reactExports.memo(EditInOsm16);
const EditGeometry16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.00432 3.44917C1.13039 3.33724 1.30438 3.29638 1.46709 3.34048L5.77797 4.50893C6.04449 4.58117 6.20199 4.85579 6.12975 5.12232C6.05751 5.38885 5.78289 5.54634 5.51636 5.4741L1.94199 4.50528L3.26718 13.5165L10.2921 12.1656L11.3348 7.265C11.3923 6.9949 11.6578 6.82253 11.9279 6.88C12.198 6.93748 12.3704 7.20302 12.3129 7.47312L11.2011 12.698C11.1593 12.8946 11.0039 13.047 10.8065 13.085L2.94294 14.5972C2.80897 14.623 2.67029 14.5929 2.55906 14.5139C2.44782 14.4349 2.37368 14.3139 2.35384 14.179L0.841608 3.89582C0.81708 3.72902 0.878255 3.5611 1.00432 3.44917Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.61305 5.93421C6.66306 5.7846 6.74777 5.64894 6.86023 5.53832L11.7188 0.759487C12.1885 0.297469 12.9429 0.300592 13.4088 0.766481L14.208 1.56571C14.6794 2.03708 14.6763 2.8023 14.201 3.26976L9.34477 8.04627C9.25021 8.13928 9.13808 8.21255 9.01493 8.26181L7.35829 8.92447C6.56351 9.24238 5.76048 8.48461 6.03188 7.67272L6.61305 5.93421ZM6.98689 7.99599C6.98294 7.99757 6.97894 7.9938 6.9803 7.98976L7.56146 6.25125L12.42 1.47242C12.4983 1.39542 12.6241 1.39594 12.7017 1.47359L13.5009 2.27281C13.5795 2.35138 13.579 2.47891 13.4998 2.55682L8.64354 7.33333L6.98689 7.99599Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.3102 3.99999L10.9769 2.66665L11.684 1.95955L13.0173 3.29288L12.3102 3.99999Z", fill: "currentColor" })] });
EditGeometry16.displayName = "EditGeometry16";
const Memo$e = reactExports.memo(EditGeometry16);
const Tools24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.13847 20.7L20.7 5.13848V20.7H5.13847ZM4.41421 22C3.52331 22 3.07714 20.9229 3.7071 20.2929L20.2929 3.70711C20.9229 3.07714 22 3.52331 22 4.41421V21C22 21.5523 21.5523 22 21 22H4.41421Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17.1461 12.1001C17.4611 11.7852 17.9996 12.0082 17.9996 12.4537V17.4996C17.9996 17.7758 17.7758 17.9996 17.4996 17.9996H12.4537C12.0082 17.9996 11.7851 17.4611 12.1001 17.1461L17.1461 12.1001ZM14.3851 16.6996L16.6996 14.3851V16.6996H14.3851Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.4765 9.79074L10.5806 0.836119C11.1653 0.260953 12.1045 0.264836 12.6845 0.844825L14.3621 2.52242C14.9489 3.10924 14.9449 4.06186 14.3533 4.6438L5.28767 13.5606L2.04859 14.8562C1.01699 15.2689 -0.0260327 14.2854 0.32645 13.231L1.4765 9.79074ZM2.61052 10.4988L11.4922 1.76293C11.5681 1.68829 11.69 1.68879 11.7652 1.76406L13.4428 3.44166C13.519 3.51782 13.5185 3.64145 13.4417 3.71698L4.56231 12.4506L1.56578 13.6492C1.56195 13.6507 1.55807 13.6471 1.55938 13.6432L2.61052 10.4988Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.1077 6.32258L8.70269 3.91758L9.62193 2.99834L12.0269 5.40334L11.1077 6.32258Z", fill: "currentColor" })] });
Tools24.displayName = "Tools24";
const Memo$d = reactExports.memo(Tools24);
const Car24 = (props) => jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.4603 10.8253C21.0922 10.6816 20.8095 10.3783 20.6919 10.0011L19.1476 5.04641C18.4721 3.35779 16.9129 2.3 15.175 2.3H8.825C7.08749 2.3 5.5279 3.35785 4.85236 5.04641L3.30812 10.0011C3.19054 10.3783 2.90778 10.6816 2.53969 10.8253C1.82528 11.1041 1.3 11.8172 1.3 12.6773V15.682C1.3 16.1781 1.48294 16.6311 1.78994 16.9918C1.99009 17.2269 2.1 17.5256 2.1 17.8344V21.1592H4.3V18.9673C4.3 18.2494 4.88203 17.6673 5.6 17.6673H18.4C19.118 17.6673 19.7 18.2494 19.7 18.9673V21.1592H21.9V17.8344C21.9 17.5254 22.0101 17.2266 22.2104 16.9914C22.5169 16.6316 22.7 16.1788 22.7 15.682V12.6773C22.7 11.8172 22.1747 11.1041 21.4603 10.8253ZM3.6255 4.61387C4.481 2.41834 6.522 1 8.825 1H15.175C17.4785 1 19.519 2.41834 20.3745 4.61387L21.933 9.61427C23.139 10.085 24 11.2739 24 12.6773V15.682C24 16.51 23.692 17.2569 23.2 17.8344V21.8092C23.2 22.1682 22.909 22.4592 22.55 22.4592H19.05C18.691 22.4592 18.4 22.1682 18.4 21.8092V18.9673H5.6V21.8092C5.6 22.1682 5.30899 22.4592 4.95 22.4592H1.45C1.09101 22.4592 0.8 22.1682 0.8 21.8092V17.8344C0.308 17.2564 0 16.5095 0 15.682V12.6773C0 11.2739 0.861 10.085 2.067 9.61427L3.6255 4.61387Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.63097 5.96274L7.05613 8.09205H16.9439L16.369 5.96275C16.1505 5.41512 15.6992 5.1479 15.2947 5.1479H8.70526C8.30076 5.1479 7.84949 5.41512 7.63097 5.96274ZM17.6073 5.56161L18.4202 8.57264C18.5317 8.98575 18.2205 9.39205 17.7926 9.39205H6.20739C5.77949 9.39205 5.46833 8.98575 5.57985 8.57264L6.39272 5.56161C6.77097 4.52668 7.68675 3.8479 8.70526 3.8479H15.2947C16.3133 3.8479 17.229 4.52668 17.6073 5.56161Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19.2933 13.014C17.7276 13.1807 17.0028 13.9463 16.6501 14.6175H19.2933V13.014ZM19.2313 11.7137C20.011 11.6395 20.5933 12.2807 20.5933 12.9809V14.6179C20.5933 15.3365 20.0106 15.9175 19.2933 15.9175H16.5348C16.1248 15.9175 15.7501 15.726 15.5184 15.4168C15.2794 15.0979 15.1987 14.6556 15.3909 14.2339C15.8827 13.1554 16.9778 11.9282 19.2313 11.7137Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.70671 13.014C6.27241 13.1807 6.99716 13.9463 7.34989 14.6174H4.70671V13.014ZM4.76868 11.7137C3.98896 11.6395 3.40671 12.2807 3.40671 12.9809V14.6179C3.40671 15.3365 3.98935 15.9174 4.70671 15.9174H7.46522C7.87523 15.9174 8.24987 15.726 8.48159 15.4168C8.7206 15.0979 8.80133 14.6556 8.60908 14.2339C8.11733 13.1554 7.02219 11.9281 4.76868 11.7137Z", fill: "currentColor" })] });
Car24.displayName = "Car24";
const Memo$c = reactExports.memo(Car24);
const Copyright16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.00002 2.66669C5.0545 2.66669 2.66669 5.0545 2.66669 8.00002C2.66669 10.9455 5.0545 13.3334 8.00002 13.3334C10.9455 13.3334 13.3334 10.9455 13.3334 8.00002C13.3334 5.0545 10.9455 2.66669 8.00002 2.66669ZM1.66669 8.00002C1.66669 4.50222 4.50222 1.66669 8.00002 1.66669C11.4978 1.66669 14.3334 4.50222 14.3334 8.00002C14.3334 11.4978 11.4978 14.3334 8.00002 14.3334C4.50222 14.3334 1.66669 11.4978 1.66669 8.00002Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M7.84806 11.2536C7.40006 11.2536 7.00006 11.1776 6.64806 11.0256C6.29606 10.8736 6.00006 10.6576 5.76006 10.3776C5.52006 10.0896 5.33606 9.74564 5.20806 9.34564C5.08006 8.93764 5.01606 8.48564 5.01606 7.98964C5.01606 7.49364 5.08006 7.04564 5.20806 6.64564C5.33606 6.23764 5.52006 5.89364 5.76006 5.61364C6.00006 5.32564 6.29606 5.10564 6.64806 4.95364C7.00006 4.80164 7.40006 4.72564 7.84806 4.72564C8.47206 4.72564 8.98406 4.86564 9.38406 5.14564C9.65503 5.33532 9.87643 5.56721 10.0483 5.84132C10.1889 6.06557 10.0728 6.34902 9.83298 6.46094L9.70152 6.52229C9.42613 6.65081 9.10755 6.49263 8.90801 6.26341C8.8498 6.19655 8.78448 6.13596 8.71206 6.08164C8.49606 5.90564 8.20806 5.81764 7.84806 5.81764C7.36806 5.81764 7.00406 5.96964 6.75606 6.27364C6.51606 6.56964 6.39606 6.95764 6.39606 7.43764V8.55364C6.39606 9.03364 6.51606 9.42564 6.75606 9.72964C7.00406 10.0256 7.36806 10.1736 7.84806 10.1736C8.23206 10.1736 8.53606 10.0816 8.76006 9.89764C8.86302 9.81243 8.95653 9.7154 9.04059 9.60656C9.21855 9.3761 9.53166 9.25806 9.78893 9.39444L9.90903 9.45811C10.1357 9.57825 10.2395 9.85384 10.1075 10.0738C9.91601 10.393 9.67086 10.6503 9.37206 10.8456C8.95606 11.1176 8.44806 11.2536 7.84806 11.2536Z", fill: "currentColor" })] });
Copyright16.displayName = "Copyright16";
const Memo$b = reactExports.memo(Copyright16);
const Clock16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 3C5.24568 3 3 5.24568 3 8C3 10.7543 5.24568 13 8 13C10.7543 13 13 10.7543 13 8C13 5.24568 10.7543 3 8 3ZM2 8C2 4.6934 4.6934 2 8 2C11.3066 2 14 4.6934 14 8C14 11.3066 11.3066 14 8 14C4.6934 14 2 11.3066 2 8Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.9 4.4H7.9V8.04133L10.3293 10.4707L9.62223 11.1778L6.9 8.45554V4.4Z", fill: "currentColor" })] });
Clock16.displayName = "Clock16";
const Memo$a = reactExports.memo(Clock16);
const ExternalLink16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.33333 4.5C3.11232 4.5 2.90036 4.5878 2.74408 4.74408C2.5878 4.90036 2.5 5.11232 2.5 5.33333V12.6667C2.5 12.8877 2.5878 13.0996 2.74408 13.2559C2.90036 13.4122 3.11232 13.5 3.33333 13.5H10.6667C10.8877 13.5 11.0996 13.4122 11.2559 13.2559C11.4122 13.0996 11.5 12.8877 11.5 12.6667V8.66667C11.5 8.39052 11.7239 8.16667 12 8.16667C12.2761 8.16667 12.5 8.39052 12.5 8.66667V12.6667C12.5 13.1529 12.3068 13.6192 11.963 13.963C11.6192 14.3068 11.1529 14.5 10.6667 14.5H3.33333C2.8471 14.5 2.38079 14.3068 2.03697 13.963C1.69315 13.6192 1.5 13.1529 1.5 12.6667V5.33333C1.5 4.8471 1.69315 4.38079 2.03697 4.03697C2.38079 3.69315 2.8471 3.5 3.33333 3.5H7.33333C7.60948 3.5 7.83333 3.72386 7.83333 4C7.83333 4.27614 7.60948 4.5 7.33333 4.5H3.33333Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.5 2C9.5 1.72386 9.72386 1.5 10 1.5H14C14.2761 1.5 14.5 1.72386 14.5 2V6C14.5 6.27614 14.2761 6.5 14 6.5C13.7239 6.5 13.5 6.27614 13.5 6V2.5H10C9.72386 2.5 9.5 2.27614 9.5 2Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.3536 1.64645C14.5488 1.84171 14.5488 2.15829 14.3536 2.35355L7.02023 9.68689C6.82497 9.88215 6.50839 9.88215 6.31313 9.68689C6.11786 9.49162 6.11786 9.17504 6.31313 8.97978L13.6465 1.64645C13.8417 1.45118 14.1583 1.45118 14.3536 1.64645Z", fill: "currentColor" })] });
ExternalLink16.displayName = "ExternalLink16";
const Memo$9 = reactExports.memo(ExternalLink16);
const SmartCity24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.06097 6.061C9.89597 5.402 10.917 5 12 5C13.083 5 14.104 5.402 14.939 6.061L16.006 4.994C14.902 4.072 13.511 3.5 12 3.5C10.489 3.5 9.09797 4.072 7.99397 4.994L9.06097 6.061ZM17.389 3.611L18.452 2.548C16.711 0.984 14.459 0 12 0C9.54097 0 7.28897 0.984 5.54797 2.548L6.61097 3.611C8.08797 2.312 9.97297 1.5 12 1.5C14.027 1.5 15.912 2.312 17.389 3.611ZM12 6.95898C10.068 6.95898 8.5 8.52698 8.5 10.459C8.5 13.084 12 16.959 12 16.959C12 16.959 15.5 13.084 15.5 10.459C15.5 8.52598 13.932 6.95898 12 6.95898ZM12 12.008C11.172 12.008 10.5 11.336 10.5 10.508C10.5 9.67999 11.172 9.00798 12 9.00798C12.828 9.00798 13.5 9.67999 13.5 10.508C13.5 11.336 12.828 12.008 12 12.008ZM14.839 15.7609C15.058 15.4439 15.279 15.1029 15.494 14.7469L23 18.4999L12 23.9999L1 18.4999L8.505 14.7479C8.72 15.1039 8.941 15.4449 9.16 15.7619L7.35 16.6669L12.424 19.2039L14.291 18.2709L13.285 17.7679C13.461 17.5649 13.737 17.2369 14.064 16.8159L15.632 17.5999L17.074 16.8789L14.839 15.7609ZM6.008 17.3369L3.683 18.4999L8.758 21.0369L11.083 19.8739L6.008 17.3369ZM10.1 21.7079L12 22.6579L14.325 21.4949L12.425 20.5449L10.1 21.7079ZM13.767 19.8749L15.667 20.8249L17.534 19.8919L15.634 18.9419L13.767 19.8749ZM16.975 18.2709L18.875 19.2209L20.317 18.4999L18.417 17.5499L16.975 18.2709Z", fill: "currentColor" }) });
SmartCity24.displayName = "SmartCity24";
const Memo$8 = reactExports.memo(SmartCity24);
const Car16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M14.1446 6.89163C14.1899 7.03672 14.2986 7.15337 14.4402 7.20863C15.0551 7.44864 15.5 8.05823 15.5 8.78489V10.788C15.5 11.2126 15.3427 11.5974 15.0861 11.8987C15.009 11.9891 14.9667 12.1041 14.9667 12.2229V14.8061H12.7667V12.9782C12.7667 12.7021 12.5428 12.4782 12.2667 12.4782H3.73333C3.45719 12.4782 3.23333 12.7021 3.23333 12.9782V14.8061H1.03333V12.2229C1.03333 12.1042 0.991059 11.9893 0.914079 11.8989C0.657234 11.5971 0.5 11.2122 0.5 10.788V8.78489C0.5 8.05823 0.944877 7.44864 1.5598 7.20863C1.70138 7.15337 1.81013 7.03672 1.85535 6.89163L2.88901 3.57516C3.39031 2.30663 4.56571 1.5 5.88333 1.5H10.1167C11.4346 1.5 12.6097 2.3066 13.111 3.57515L14.1446 6.89163Z", stroke: "currentColor", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M4.22531 6.09469L4.73846 4.19387C4.9301 3.69115 5.36193 3.39859 5.80351 3.39859H10.1965C10.6381 3.39859 11.0699 3.69115 11.2615 4.19387L11.7747 6.09469L12.2574 5.96437L11.7747 6.09469H4.22531Z", stroke: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M11.0921 10.6378H12.7955C13.0717 10.6378 13.2955 10.4145 13.2955 10.1383V8.94804C13.2955 8.6719 13.0699 8.44401 12.7959 8.47821C11.5199 8.63748 10.9287 9.40382 10.6592 10.0578C10.5394 10.3485 10.7776 10.6378 11.0921 10.6378Z", stroke: "currentColor", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M4.90792 10.6378H3.20447C2.92833 10.6378 2.70447 10.4145 2.70447 10.1383V8.94804C2.70447 8.6719 2.93007 8.44401 3.20409 8.47821C4.48009 8.63748 5.07127 9.40382 5.3408 10.0578C5.46063 10.3485 5.2224 10.6378 4.90792 10.6378Z", stroke: "currentColor", strokeLinejoin: "round" })] });
Car16.displayName = "Car16";
const Memo$7 = reactExports.memo(Car16);
const UploadAnalysis16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.88093 9.7871C1.99851 9.53724 2.29638 9.43001 2.54624 9.54759L8.00001 12.1141L13.4538 9.54759C13.7036 9.43001 14.0015 9.53724 14.1191 9.7871C14.2367 10.037 14.1294 10.3348 13.8796 10.4524L8.2129 13.1191C8.07806 13.1825 7.92195 13.1825 7.78711 13.1191L2.12044 10.4524C1.87058 10.3348 1.76335 10.037 1.88093 9.7871Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.88093 12.4538C1.99851 12.2039 2.29638 12.0967 2.54624 12.2142L8.00001 14.7807L13.4538 12.2142C13.7036 12.0967 14.0015 12.2039 14.1191 12.4538C14.2367 12.7036 14.1294 13.0015 13.8796 13.1191L8.21291 15.7857C8.07807 15.8492 7.92195 15.8492 7.78711 15.7857L2.12044 13.1191C1.87058 13.0015 1.76335 12.7036 1.88093 12.4538Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.5102 7.58233C8.5102 7.85847 8.28634 8.08233 8.0102 8.08233C7.73405 8.08233 7.5102 7.85847 7.5102 7.58233V1.87377L5.68678 3.6972C5.49151 3.89246 5.17493 3.89246 4.97967 3.6972C4.78441 3.50193 4.78441 3.18535 4.97967 2.99009L7.65664 0.313104C7.8519 0.117841 8.16849 0.117841 8.36375 0.313102L11.0407 2.99009C11.236 3.18535 11.236 3.50193 11.0407 3.6972C10.8455 3.89246 10.5289 3.89246 10.3336 3.6972L8.5102 1.87376V7.58233Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M6.51151 5.91968V4.82504L2.12032 6.88093C1.94508 6.9634 1.83322 7.13966 1.83322 7.33334C1.83322 7.52702 1.94508 7.70328 2.12032 7.78575L7.78699 10.4524C7.92183 10.5159 8.07795 10.5159 8.21279 10.4524L13.8795 7.78575C14.0547 7.70328 14.1666 7.52702 14.1666 7.33334C14.1666 7.13966 14.0547 6.9634 13.8795 6.88093L9.5107 4.82504V5.93024L12.4923 7.33334L7.99989 9.44741L3.50749 7.33334L6.51151 5.91968Z", fill: "currentColor" })] });
UploadAnalysis16.displayName = "UploadAnalysis16";
const Memo$6 = reactExports.memo(UploadAnalysis16);
const Reference16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.5 2V5V8H12.7817L11.6385 5.98802C11.2904 5.37533 11.2904 4.62466 11.6385 4.01198L12.7817 2H5.5ZM4.5 9V12.5C4.5 12.7761 4.72386 13 5 13C5.27614 13 5.5 12.7761 5.5 12.5V9H12.7817C13.5484 9 14.0299 8.17263 13.6511 7.50599L12.508 5.49401C12.3339 5.18767 12.3339 4.81233 12.508 4.50599L13.6511 2.49401C14.0299 1.82737 13.5484 1 12.7817 1H5.5H5H4.5V1.5V2V5V8V9ZM3.6875 11.5598C3.30134 11.6302 2.94713 11.7317 2.64142 11.8596C2.32801 11.9908 2.04185 12.1598 1.82646 12.3729C1.60924 12.5879 1.4375 12.877 1.4375 13.2273C1.4375 13.5776 1.60924 13.8667 1.82646 14.0817C2.04185 14.2948 2.32801 14.4638 2.64142 14.595C3.27036 14.8583 4.10454 15.0092 5 15.0092C5.89546 15.0092 6.72964 14.8583 7.35858 14.595C7.67199 14.4638 7.95815 14.2948 8.17354 14.0817C8.39076 13.8667 8.5625 13.5776 8.5625 13.2273C8.5625 12.877 8.39076 12.5879 8.17354 12.3729C7.95815 12.1598 7.67199 11.9908 7.35858 11.8596C7.05287 11.7317 6.69866 11.6302 6.3125 11.5598V12.5795C6.56136 12.6341 6.78376 12.7031 6.97245 12.7821C7.21324 12.8829 7.37557 12.9901 7.47012 13.0837C7.56252 13.1751 7.5625 13.2233 7.5625 13.2273V13.2273V13.2274C7.5625 13.2313 7.56252 13.2795 7.47012 13.3709C7.37557 13.4645 7.21324 13.5718 6.97245 13.6726C6.49298 13.8733 5.79592 14.0092 5 14.0092C4.20408 14.0092 3.50702 13.8733 3.02755 13.6726C2.78676 13.5718 2.62443 13.4645 2.52988 13.3709C2.43748 13.2795 2.4375 13.2313 2.4375 13.2274V13.2273V13.2273C2.4375 13.2233 2.43748 13.1751 2.52988 13.0837C2.62443 12.9901 2.78676 12.8829 3.02755 12.7821C3.21624 12.7031 3.43864 12.6341 3.6875 12.5795V11.5598Z", fill: "currentColor" }) });
Reference16.displayName = "Reference16";
const Memo$5 = reactExports.memo(Reference16);
const Rubber16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.24179 8.1663L7.9081 2.5C8.68914 1.71895 9.95547 1.71895 10.7365 2.5L13 4.7635C13.7811 5.54454 13.7811 6.81087 13 7.59192L7.75056 12.8414H14V13.8414H6.02235C5.47679 13.8693 4.92198 13.6749 4.50529 13.2582L2.24179 10.9947C1.46074 10.2137 1.46074 8.94735 2.24179 8.1663ZM2.9489 8.87341C2.55837 9.26394 2.55837 9.8971 2.9489 10.2876L5.21239 12.5511C5.60292 12.9416 6.23608 12.9416 6.62661 12.5511L7.95324 11.2245L4.27553 7.54678L2.9489 8.87341ZM12.2929 6.88482L8.66034 10.5174L4.98264 6.83967L8.6152 3.20711C9.00573 2.81658 9.63889 2.81658 10.0294 3.20711L12.2929 5.4706C12.6834 5.86113 12.6834 6.49429 12.2929 6.88482Z", fill: "currentColor" }) });
Rubber16.displayName = "Rubber16";
const Memo$4 = reactExports.memo(Rubber16);
const Rubber24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.40053 13.5028L13.035 2.86833C13.9332 1.97013 15.3895 1.97013 16.2877 2.86833L21.1317 7.71234C22.0299 8.61054 22.0299 10.0668 21.1317 10.965L11.1245 20.9722L21 20.9722V22.2722H8.93542C8.89241 22.2734 8.84936 22.2734 8.80634 22.2722H8.73169V22.2689C8.19029 22.2363 7.65822 22.0132 7.24454 21.5995L2.40053 16.7555C1.50232 15.8573 1.50232 14.401 2.40053 13.5028ZM8.9134 20.9722H8.82836C8.58679 20.962 8.34822 20.8647 8.16378 20.6802L3.31977 15.8362C2.92924 15.4457 2.92924 14.8125 3.31977 14.422L6.21543 11.5264L12.4736 17.7846L9.57799 20.6802C9.39354 20.8647 9.15497 20.962 8.9134 20.9722ZM20.2124 10.0458L13.3929 16.8653L7.13467 10.6071L13.9542 3.78757C14.3447 3.39705 14.9779 3.39705 15.3684 3.78757L20.2124 8.63158C20.603 9.0221 20.603 9.65527 20.2124 10.0458Z", fill: "currentColor" }) });
Rubber24.displayName = "Rubber24";
const Memo$3 = reactExports.memo(Rubber24);
const Diamond24 = (props) => jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.76076 4.09452C5.06012 3.60243 5.59442 3.30206 6.17042 3.30206H17.8296C18.4056 3.30206 18.9399 3.60243 19.2392 4.09452L21.9716 8.5861C22.3254 9.16766 22.2857 9.90678 21.8717 10.4471L13.312 21.6196C12.6516 22.4815 11.3532 22.4817 10.6927 21.6199L2.12859 10.4473C1.71439 9.90692 1.67462 9.16763 2.02847 8.58596L4.76076 4.09452ZM6.4601 4.60206L7.69543 8.00844L10.4819 4.60206H6.4601ZM15.3215 8.85987L12 4.79936L8.67849 8.85987H15.3215ZM13.5181 4.60206L16.3046 8.00843L17.5399 4.60206H13.5181ZM18.5879 5.52526L17.3786 8.85987H20.6165L18.5879 5.52526ZM8.47564 10.1599L12 19.8782L15.5244 10.1599H8.47564ZM6.62135 8.85987L5.41205 5.52525L3.38349 8.85987H6.62135ZM7.0928 10.1599L10.2774 18.9413L3.54625 10.1599H7.0928ZM13.7193 18.9504L16.9072 10.1599H20.4541L13.7193 18.9504Z", fill: "currentColor" }) });
Diamond24.displayName = "Diamond24";
const Memo$2 = reactExports.memo(Diamond24);
const FavAdded16 = (props) => jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.5044 5.8292C14.9445 5.86715 15.1228 6.41542 14.7892 6.70497L11.5859 9.48502C11.53 9.53357 11.5055 9.60907 11.5222 9.68124L12.4799 13.8117C12.5797 14.2423 12.1128 14.5811 11.7345 14.3527L8.00001 12.0988L4.26747 14.3516C3.88881 14.5801 3.42169 14.2406 3.52217 13.8099L4.5127 9.56394L1.21441 6.70663C0.880106 6.41702 1.05881 5.86789 1.49952 5.8305L5.54113 5.48761C5.72592 5.47194 5.88685 5.35527 5.95922 5.18452L7.54 1.45479C7.71224 1.04839 8.28815 1.04824 8.46061 1.45454L10.0409 5.1775C10.1132 5.3479 10.2738 5.46439 10.4582 5.48029L14.5044 5.8292Z", fill: "currentColor" }) });
FavAdded16.displayName = "FavAdded16";
const Memo$1 = reactExports.memo(FavAdded16);
const OsmGaps16 = (props) => jsxRuntimeExports.jsxs("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", ...props, children: [jsxRuntimeExports.jsx("path", { d: "M10.1756 2.03184C10.0627 1.9895 9.93829 1.98938 9.82533 2.0315C9.70622 2.07591 9.31663 2.2219 8.82509 2.4062C8.56653 2.50315 8.43551 2.79135 8.53246 3.04992C8.62941 3.30848 8.91761 3.4395 9.17618 3.34255L9.5 3.22114V3.6875C9.5 3.96364 9.72386 4.1875 10 4.1875C10.2761 4.1875 10.5 3.96364 10.5 3.6875V3.2215L10.8244 3.34316C11.083 3.44012 11.3712 3.30912 11.4682 3.05056C11.5651 2.792 11.4341 2.5038 11.1756 2.40684L10.1756 2.03184Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.17553 4.09297C7.43408 3.99597 7.56504 3.70774 7.46804 3.4492C7.37104 3.19065 7.08281 3.0597 6.82426 3.1567L5.99995 3.46598L2.17556 2.03184C2.02201 1.97426 1.84999 1.99563 1.7152 2.08904C1.58042 2.18245 1.5 2.33601 1.5 2.5V12C1.5 12.2084 1.62929 12.395 1.82444 12.4682L5.82444 13.9682C5.93736 14.0105 6.06179 14.0106 6.17478 13.9685L10.0097 12.5377L10.8244 12.8432C11.083 12.9401 11.3712 12.8091 11.4682 12.5506C11.5651 12.292 11.4341 12.0038 11.1756 11.9068L10.5 11.6535V10.8125C10.5 10.5364 10.2761 10.3125 10 10.3125C9.72386 10.3125 9.5 10.5364 9.5 10.8125V11.6535L8.82444 11.9068C8.80136 11.9155 8.7793 11.9257 8.75832 11.9372L6.5 12.7798V4.34643L7.17553 4.09297ZM5.5 12.7785L2.5 11.6535V3.2215L5.5 4.3465V12.7785Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M13.1756 3.15684C12.917 3.05988 12.6288 3.19088 12.5318 3.44944C12.4349 3.708 12.5659 3.9962 12.8244 4.09316L13.5 4.3465V5.1875C13.5 5.46364 13.7239 5.6875 14 5.6875C14.2761 5.6875 14.5 5.46364 14.5 5.1875V4C14.5 3.79158 14.3707 3.60502 14.1756 3.53184L13.1756 3.15684Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M10.5 6.0625C10.5 5.78636 10.2761 5.5625 10 5.5625C9.72386 5.5625 9.5 5.78636 9.5 6.0625V8.4375C9.5 8.71364 9.72386 8.9375 10 8.9375C10.2761 8.9375 10.5 8.71364 10.5 8.4375V6.0625Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M14.5 7.5625C14.5 7.28636 14.2761 7.0625 14 7.0625C13.7239 7.0625 13.5 7.28636 13.5 7.5625V9.9375C13.5 10.2136 13.7239 10.4375 14 10.4375C14.2761 10.4375 14.5 10.2136 14.5 9.9375V7.5625Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M14.5 12.3125C14.5 12.0364 14.2761 11.8125 14 11.8125C13.7239 11.8125 13.5 12.0364 13.5 12.3125V12.7785L13.1756 12.6568C12.917 12.5599 12.6288 12.6909 12.5318 12.9494C12.4349 13.208 12.5659 13.4962 12.8244 13.5932L13.8244 13.9682C13.978 14.0257 14.15 14.0044 14.2848 13.911C14.4196 13.8176 14.5 13.664 14.5 13.5V12.3125Z", fill: "currentColor" })] });
OsmGaps16.displayName = "OsmGaps16";
const Memo = reactExports.memo(OsmGaps16);
const icons = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AddLayer24: Memo$2O,
  AddLayerIcon,
  AdvancedAnalytics16: Memo$y,
  AdvancedAnalytics24: Memo$M,
  Alarm24: Memo$2w,
  Analytics16: Memo$v,
  Analytics24: Memo$B,
  AnalyticsPanelIcon,
  Area16: Memo$1g,
  Area24: Memo$29,
  ArrowExternal16: Memo$1O,
  ArrowExternal24: Memo$1P,
  ArrowLeft16: Memo$1T,
  ArrowLeft24: Memo$2R,
  ArrowRight16: Memo$1S,
  ArrowRight24: Memo$2S,
  Bi24: Memo$26,
  BivariateMatrix16: Memo$w,
  BivariateMatrix24: Memo$K,
  BivariatePanelIcon,
  BookOpen24: Memo$2k,
  BoundarySelectorIcon,
  Branch24: Memo$2A,
  Calendar16: Memo$2u,
  Calendar24: Memo$2y,
  CallIcon,
  Car16: Memo$7,
  Car24: Memo$c,
  Chart24: Memo$2F,
  ChartColumn24: Memo$2E,
  Chat16: Memo$1x,
  Chat24: Memo$1y,
  ChevronDown16: Memo$20,
  ChevronDown24: Memo$21,
  ChevronLeft16: Memo$1Y,
  ChevronLeft24: Memo$1Z,
  ChevronRight16: Memo$1W,
  ChevronRight24: Memo$1X,
  ChevronUp16: Memo$1_,
  ChevronUp24: Memo$1$,
  Circle: Memo$2c,
  Clock16: Memo$a,
  Close16: Memo$22,
  Close24: Memo$23,
  CloseFilled16: Memo$1L,
  CloseFilled24: Memo$1M,
  CloseIcon,
  Collapse224: Memo$2B,
  Collapse24: Memo$2C,
  ColumnWidth16: Memo$Q,
  Community24: Memo$1j,
  Copyright16: Memo$b,
  CornerUpLeft16: Memo$2n,
  CornerUpLeft24: Memo$E,
  CornerUpRight16: Memo$2q,
  CornerUpRight24: Memo$2P,
  Database24: Memo$2Q,
  Delete16: Memo$1D,
  Delete24: Memo$1E,
  Diamond24: Memo$2,
  Disasters16: Memo$z,
  Disasters24: Memo$J,
  DisastersListIcon: DisasterListIcon,
  DollarCircle16: Memo$1R,
  DollarSquare16: Memo$1Q,
  DoubleChevronDown24: Memo$t,
  DoubleChevronLeft24: Memo$S,
  DoubleChevronRight24: Memo$R,
  DoubleChevronUp24: Memo$u,
  Download16: Memo$2i,
  Download24: Memo$2j,
  DrawLineIcon,
  DrawPointIcon,
  DrawPolygonIcon,
  DrawToolsIcon,
  Edit16: Memo$1q,
  Edit24: Memo$1r,
  EditGeometry16: Memo$e,
  EditInOsm16: Memo$f,
  EditLine24: Memo$28,
  EditOsm24: Memo$I,
  Error16: Memo$1J,
  Error24: Memo$F,
  Expand24: Memo$2D,
  ExternalLink16: Memo$9,
  Eye16: Memo$1z,
  Eye24: Memo$1A,
  EyeBallCrossedIcon,
  EyeBallIcon,
  EyeOff16: Memo$1B,
  EyeOff24: Memo$1C,
  FavAdded16: Memo$1,
  FilterOff16: Memo$2t,
  FilterOn16: Memo$2s,
  Filters24: Memo$2x,
  Finish16: Memo$1t,
  Finish24: Memo$1u,
  FinishFilled16: Memo$1s,
  FireTruckIcon,
  FlameIcon,
  Globe24: Memo$19,
  History16: Memo$1k,
  History24: Memo$s,
  HydrantIcon,
  Image16: Memo$1a,
  Image24: Memo$1b,
  Info24: Memo$2K,
  InfoAlarm16: Memo$2v,
  InfoError16: Memo$1K,
  InfoErrorOutline16: Memo$$,
  InfoFilled16: Memo$2z,
  InfoIcon,
  InfoOutline16: Memo$11,
  Intercom: Memo$1F,
  Kontur24: Memo$n,
  LayerLegend: Memo$14,
  LayerLegendSmall: Memo$13,
  LayerPeriphery: Memo$15,
  LayerUrban: Memo$16,
  Layers16: Memo$A,
  Layers24: Memo$H,
  LayersPanelIcon,
  Legend16: Memo$x,
  Legend24: Memo$L,
  LegendPanelIcon,
  Line16: Memo$i,
  Line24: Memo$2a,
  Link16: Memo$1l,
  List24: Memo$1d,
  Loader24: Memo$2I,
  Loading16: Memo$2H,
  Locate16: Memo$2r,
  Locate24: Memo$2J,
  Location24: Memo$2N,
  LocationFilled16: Memo$2L,
  LocationFilled24: Memo$2M,
  Map16: Memo$1f,
  Map24: Memo$1e,
  MarkerIcon,
  Measure24: Memo$2G,
  Merge24: Memo$D,
  Minus16: Memo$m,
  More16: Memo$1m,
  More24: Memo$1n,
  Ninja24: Memo$o,
  North16: Memo$k,
  OsmGaps16: Memo,
  Pause24: Memo$U,
  People16: Memo$1h,
  Play24: Memo$Z,
  PlayActive24: Memo$Y,
  PlayOutlineTv24: Memo$2T,
  PlayTimeline24: Memo$W,
  Plus16: Memo$2l,
  Plus24: Memo$2m,
  PointFilled16: Memo$2b,
  PointFilled24: Memo$2e,
  PointOutline16: Memo$2f,
  PointOutline24: Memo$2g,
  Poly16: Memo$g,
  Poly24: Memo$27,
  Prefs16: Memo$1o,
  Prefs24: Memo$1p,
  Record16: Memo$10,
  Reference16: Memo$5,
  Reports16: Memo$1v,
  Reports24: Memo$1w,
  Route24: Memo$17,
  RouteDirection24: Memo$18,
  Rubber16: Memo$4,
  Rubber24: Memo$3,
  Ruler16: Memo$j,
  Ruler24: Memo$24,
  Search16: Memo$1G,
  Search24: Memo$1H,
  SearchIcon,
  SelectArea16: Memo$h,
  SelectArea24: Memo$25,
  SetArea16: Memo$2p,
  SetArea24: Memo$C,
  Share24: Memo$1c,
  SmartCity24: Memo$8,
  SortDrag16: Memo$1I,
  SortIcon,
  StartLoc: Memo$2d,
  StepBackward24: Memo$X,
  StepForward24: Memo$V,
  Tags16: Memo$O,
  TimelinePoint24: Memo$q,
  TimelinePoints24: Memo$p,
  ToStart24: Memo$T,
  Tools24: Memo$d,
  Trash16: Memo$1N,
  Trash24: Memo$G,
  TrashBinIcon,
  TriangleDown16: Memo$1V,
  TriangleUp16: Memo$1U,
  TripleDotIcon,
  Twoxtwo16: Memo$P,
  Update16: Memo$2o,
  Update24: Memo$_,
  Upload16: Memo$2h,
  Upload24: Memo$N,
  UploadAnalysis16: Memo$6,
  UploadFileIcon,
  User24: Memo$12,
  Users24: Memo$1i,
  Video24: Memo$r,
  ZoomTo16: Memo$l
}, Symbol.toStringTag, { value: "Module" }));
function Text$1({ children, type, className }) {
  return reactExports.isValidElement(children) ? reactExports.cloneElement(children, { className: `k-font-${type} ${children.props.className} ${className}` }) : jsxRuntimeExports.jsx("span", { className: `k-font-${type} ${className}`, children });
}
const button = "_button_1231j_1";
const buttonDark = "_buttonDark_1231j_58";
const buttonInner = "_buttonInner_1231j_75";
const tiny = "_tiny_1231j_80";
const withContent = "_withContent_1231j_81";
const small = "_small_1231j_92";
const medium = "_medium_1231j_96";
const large = "_large_1231j_108";
const withIcon = "_withIcon_1231j_114";
const buttonContent = "_buttonContent_1231j_52";
const iconBefore = "_iconBefore_1231j_155";
const iconAfter = "_iconAfter_1231j_156";
const primary = "_primary_1231j_163";
const active = "_active_1231j_174";
const invert = "_invert_1231j_180";
const s$o = {
  button,
  buttonDark,
  buttonInner,
  tiny,
  withContent,
  small,
  medium,
  large,
  withIcon,
  buttonContent,
  iconBefore,
  iconAfter,
  primary,
  active,
  "invert-outline": "_invert-outline_1231j_180",
  invert
};
const Button = reactExports.forwardRef(({ children, className, active: active2, variant = "primary", size = "medium", dark = false, iconBefore: iconBefore2, iconAfter: iconAfter2, ...props }, ref) => {
  const hasContent = reactExports.Children.count(children) > 0;
  const hasIcon = iconBefore2 || iconAfter2;
  return jsxRuntimeExports.jsx("button", { ref, className: clsx(s$o.button, {
    [s$o.buttonDark]: dark
  }, s$o[variant], s$o[size], {
    [s$o.active]: active2,
    [s$o.withContent]: hasContent,
    [s$o.withIcon]: hasIcon
  }, className), ...props, children: jsxRuntimeExports.jsxs("div", { className: clsx(s$o.buttonInner), children: [iconBefore2 && jsxRuntimeExports.jsx("div", { className: s$o.iconBefore, children: iconBefore2 }), hasContent && jsxRuntimeExports.jsx("span", { className: s$o.buttonContent, children }), iconAfter2 && jsxRuntimeExports.jsx("div", { className: s$o.iconAfter, children: iconAfter2 })] }) });
});
Button.displayName = "Button";
var reactDomExports = requireReactDom();
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value2, end) {
  return max(start, min(value2, end));
}
function evaluate(value2, param) {
  return typeof value2 === "function" ? value2(param) : value2;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis2) {
  return axis2 === "x" ? "y" : "x";
}
function getAxisLength(axis2) {
  return axis2 === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list2 = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list2 = list2.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list2 = list2.concat(list2.map(getOppositeAlignmentPlacement));
    }
  }
  return list2;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$5 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis2 = getAlignmentAxis(placement);
    const length = getAxisLength(axis2);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis2 === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis2] - coords[axis2] - rects.floating[length];
    const startDiff = coords[axis2] - rects.reference[axis2];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis2]: coords[axis2] + alignmentOffset,
      data: {
        [axis2]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof Node || value2 instanceof getWindow(value2).Node;
}
function isElement(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof Element || value2 instanceof getWindow(value2).Element;
}
function isHTMLElement(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof HTMLElement || value2 instanceof getWindow(value2).HTMLElement;
}
function isShadowRoot(value2) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value2 instanceof ShadowRoot || value2 instanceof getWindow(value2).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value2) => css2[value2] ? css2[value2] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value2) => (css2.willChange || "").includes(value2)) || ["paint", "layout", "strict", "content"].some((value2) => (css2.contain || "").includes(value2));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result2 = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result2) ? result2.host : result2;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list2, traverseIframes) {
  var _node$ownerDocument2;
  if (list2 === void 0) {
    list2 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css2 = getComputedStyle$1(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result2 = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result2 = result2.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result2);
  return result2;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const arrow$4 = arrow$5;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$1 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i2;
  let keys;
  if (a2 && b2 && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b2.length) return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value2) {
  const dpr = getDPR(element);
  return Math.round(value2 * dpr) / dpr;
}
function useLatestRef$1(value2) {
  const ref = reactExports.useRef(value2);
  index$1(() => {
    ref.current = value2;
  });
  return ref;
}
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef$1(whileElementsMounted);
  const platformRef = useLatestRef$1(platform2);
  const openRef = useLatestRef$1(open);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$1(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$1(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1$1 = (options) => {
  function isRef(value2) {
    return {}.hasOwnProperty.call(value2, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$4({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$4({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const arrow$3 = (options, deps) => ({
  ...arrow$1$1(options),
  options: [options, deps]
});
const tooltipContainer = "_tooltipContainer_1ixj6_1";
const hoverTooltip = "_hoverTooltip_1ixj6_12";
const popup = "_popup_1ixj6_15";
const contentBody = "_contentBody_1ixj6_20";
const bodyBottom = "_bodyBottom_1ixj6_33";
const unset = "_unset_1ixj6_38";
const arrow$2 = "_arrow_1ixj6_42";
const arrowInner = "_arrowInner_1ixj6_65";
const tooltipContent$2 = "_tooltipContent_1ixj6_72";
const closeIcon = "_closeIcon_1ixj6_79";
const s$n = {
  tooltipContainer,
  hoverTooltip,
  popup,
  contentBody,
  bodyBottom,
  unset,
  arrow: arrow$2,
  "arrow-top": "_arrow-top_1ixj6_49",
  "arrow-bottom": "_arrow-bottom_1ixj6_53",
  "arrow-left": "_arrow-left_1ixj6_57",
  "arrow-right": "_arrow-right_1ixj6_61",
  arrowInner,
  tooltipContent: tooltipContent$2,
  closeIcon
};
function mapPlacement(deprecadedPlacement) {
  switch (deprecadedPlacement) {
    case "top-left":
      return "top-start";
    case "top-right":
      return "top-end";
    case "bottom-left":
      return "bottom-start";
    case "bottom-right":
      return "bottom-end";
  }
}
function calculatePlacement(deprecadedPlacement, placement, position) {
  if (deprecadedPlacement && placement)
    console.error("You should not use both placement and deprecadedPlacement props at the same time. Placement prop will be used.");
  if (placement)
    return placement;
  if (position) {
    if (typeof deprecadedPlacement === "function") {
      return mapPlacement(deprecadedPlacement(position));
    } else if (deprecadedPlacement)
      return mapPlacement(deprecadedPlacement);
  }
  return;
}
const defaultPlacement = "top";
function Tooltip({ children, position, triggerRef, transitionRef, placement: placementProp, getPlacement, classes, hoverBehavior = false, onOuterClick, onClose, open = true, offset: offsetValue = 7 }) {
  const onClickOuter = reactExports.useCallback((e) => {
    if (onOuterClick && hoverBehavior === true) {
      return;
    }
    if (onOuterClick) {
      onOuterClick(e);
      return;
    }
    onClose == null ? void 0 : onClose(e);
  }, [hoverBehavior, onOuterClick, onClose]);
  const arrowRef = reactExports.useRef(null);
  const placement = reactExports.useMemo(() => calculatePlacement(getPlacement, placementProp, position) || defaultPlacement, [getPlacement, placementProp, position]);
  const { refs, x: floatingX, y: floatingY, strategy, middlewareData: { arrow: { x: arrowX2, y: arrowY2 } = {} }, placement: finalPlacement } = useFloating$1({
    placement,
    open,
    whileElementsMounted: autoUpdate,
    middleware: [offset(offsetValue), flip(), shift({ padding: 5 }), arrow$3({ element: arrowRef })]
  });
  const positionVariables = reactExports.useMemo(() => ({
    "--tooltip-arrox-x-position": arrowX2 != null ? `${arrowX2}px` : "",
    "--tooltip-arrow-y-position": arrowY2 != null ? `${arrowY2}px` : "",
    "--tooltip-x-position": `${floatingX ?? 0}px`,
    "--tooltip-y-position": `${floatingY ?? 0}px`,
    "--tooltip-placement": strategy
  }), [arrowX2, arrowY2, floatingX, floatingY, strategy]);
  const arrowSide = reactExports.useMemo(() => {
    const side = finalPlacement.split("-")[0] || defaultPlacement;
    return `arrow-${side}`;
  }, [finalPlacement]);
  reactExports.useLayoutEffect(() => {
    if (triggerRef) {
      refs.setReference(triggerRef.current);
    } else if (position) {
      const { x: x2, y: y2 } = position;
      refs.setReference({
        getBoundingClientRect() {
          return { width: 0, height: 0, x: x2, y: y2, top: y2, left: x2, right: x2, bottom: y2 };
        }
      });
    }
  }, [position, refs, triggerRef]);
  if (position && triggerRef) {
    console.error("Both position and triggerRef are provided. Tooltip will be rendered with triggerRef");
  }
  if (!position && !triggerRef) {
    console.error("Tooltip will not be rendered because neither position nor triggerRef are provided");
    return null;
  }
  if (!open)
    return null;
  const onCloseProp = hoverBehavior ? void 0 : onClose;
  return jsxRuntimeExports.jsx("div", { ref: transitionRef, className: clsx(s$n.tooltipContainer, { [s$n.hoverTooltip]: hoverBehavior }), onClick: onClickOuter, style: positionVariables, children: jsxRuntimeExports.jsxs("div", { ref: refs.setFloating, className: s$n.tooltipContent, children: [jsxRuntimeExports.jsxs("div", { className: clsx(s$n.contentBody, clsx), children: [jsxRuntimeExports.jsxs("div", { children: [children, jsxRuntimeExports.jsx("div", { className: s$n.bodyBottom })] }), onCloseProp && jsxRuntimeExports.jsx("div", { className: s$n.closeIcon, onClick: onCloseProp, children: jsxRuntimeExports.jsx(Memo$22, {}) })] }), jsxRuntimeExports.jsx("div", { ref: arrowRef, className: clsx(s$n.arrow, s$n[arrowSide]), children: jsxRuntimeExports.jsx("div", { className: s$n.arrowInner }) })] }) });
}
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result2 = inert || lookUp && node && isInert2(node.parentNode);
  return result2;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
  return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i2 = 0; i2 < nodes.length; i2++) {
    if (nodes[i2].checked && nodes[i2].form === form) {
      return nodes[i2];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i2) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i2,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container2, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container2], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container2, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
const FOCUSABLE_ATTRIBUTE$1 = "data-floating-ui-focusable";
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  while (((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {
    var _activeElement;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function getFloatingFocusElement(floatingElement) {
  if (!floatingElement) {
    return null;
  }
  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE$1) ? floatingElement : floatingElement.querySelector("[" + FOCUSABLE_ATTRIBUTE$1 + "]") || floatingElement;
}
function isMouseLikePointerType(pointerType, strict) {
  const values = ["mouse", "pen"];
  {
    values.push("", void 0);
  }
  return values.includes(pointerType);
}
var index = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
const SafeReact$1 = {
  ...React$1
};
function useLatestRef(value2) {
  const ref = reactExports.useRef(value2);
  index(() => {
    ref.current = value2;
  });
  return ref;
}
const useInsertionEffect = SafeReact$1.useInsertionEffect;
const useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = reactExports.useRef(() => {
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return reactExports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
const getTabbableOptions = () => ({
  getShadowRoot: true,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function getTabbableIn(container2, dir) {
  const list2 = tabbable(container2, getTabbableOptions());
  const len = list2.length;
  if (len === 0) return;
  const active2 = activeElement(getDocument(container2));
  const index2 = list2.indexOf(active2);
  const nextIndex = index2 === -1 ? dir === 1 ? 0 : len - 1 : index2 + dir;
  return list2[nextIndex];
}
function getNextTabbable(referenceElement) {
  return getTabbableIn(getDocument(referenceElement).body, 1) || referenceElement;
}
function getPreviousTabbable(referenceElement) {
  return getTabbableIn(getDocument(referenceElement).body, -1) || referenceElement;
}
function isOutsideEvent(event, container2) {
  const containerElement = container2 || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}
function disableFocusInside(container2) {
  const tabbableElements = tabbable(container2, getTabbableOptions());
  tabbableElements.forEach((element) => {
    element.dataset.tabindex = element.getAttribute("tabindex") || "";
    element.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside(container2) {
  const elements = container2.querySelectorAll("[data-tabindex]");
  elements.forEach((element) => {
    const tabindex = element.dataset.tabindex;
    delete element.dataset.tabindex;
    if (tabindex) {
      element.setAttribute("tabindex", tabindex);
    } else {
      element.removeAttribute("tabindex");
    }
  });
}
function useMergeRefs(refs) {
  const cleanupRef = reactExports.useRef(void 0);
  const refEffect = reactExports.useCallback((instance2) => {
    const cleanups = refs.map((ref) => {
      if (ref == null) {
        return;
      }
      if (typeof ref === "function") {
        const refCallback = ref;
        const refCleanup = refCallback(instance2);
        return typeof refCleanup === "function" ? refCleanup : () => {
          refCallback(null);
        };
      }
      ref.current = instance2;
      return () => {
        ref.current = null;
      };
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
    };
  }, refs);
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value2) => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value2 != null) {
        cleanupRef.current = refEffect(value2);
      }
    };
  }, refs);
}
const FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
const ACTIVE_KEY = "active";
const SELECTED_KEY = "selected";
const SafeReact = {
  ...React$1
};
let serverHandoffComplete = false;
let count$1 = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count$1++
);
function useFloatingId() {
  const [id, setId] = reactExports.useState(() => serverHandoffComplete ? genId() : void 0);
  index(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  reactExports.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
const useReactId = SafeReact.useId;
const useId = useReactId || useFloatingId;
const FloatingArrow = /* @__PURE__ */ reactExports.forwardRef(function FloatingArrow2(props, ref) {
  const {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow2,
        shift: shift2
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d: d2,
    style: {
      transform,
      ...restStyle
    } = {},
    ...rest
  } = props;
  const clipPathId = useId();
  const [isRTL2, setIsRTL] = reactExports.useState(false);
  index(() => {
    if (!floating) return;
    const isRTL22 = getComputedStyle$1(floating).direction === "rtl";
    if (isRTL22) {
      setIsRTL(true);
    }
  }, [floating]);
  if (!floating) {
    return null;
  }
  const [side, alignment] = placement.split("-");
  const isVerticalSide = side === "top" || side === "bottom";
  let computedStaticOffset = staticOffset;
  if (isVerticalSide && shift2 != null && shift2.x || !isVerticalSide && shift2 != null && shift2.y) {
    computedStaticOffset = null;
  }
  const computedStrokeWidth = strokeWidth * 2;
  const halfStrokeWidth = computedStrokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const isCustomShape = !!d2;
  const yOffsetProp = computedStaticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = computedStaticOffset && alignment === "end" ? "right" : "left";
  if (computedStaticOffset && isRTL2) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowX2 = (arrow2 == null ? void 0 : arrow2.x) != null ? computedStaticOffset || arrow2.x : "";
  const arrowY2 = (arrow2 == null ? void 0 : arrow2.y) != null ? computedStaticOffset || arrow2.y : "";
  const dValue = d2 || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", {
    ...rest,
    "aria-hidden": true,
    ref,
    width: isCustomShape ? width : width + computedStrokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX2,
      [yOffsetProp]: arrowY2,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + computedStrokeWidth / 2 + "px)",
      transform: [rotation, transform].filter((t2) => !!t2).join(" "),
      ...restStyle
    },
    children: [computedStrokeWidth > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      clipPath: "url(#" + clipPathId + ")",
      fill: "none",
      stroke,
      strokeWidth: computedStrokeWidth + (d2 ? 0 : 1),
      d: dValue
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      stroke: computedStrokeWidth && !d2 ? rest.fill : "none",
      d: dValue
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", {
      id: clipPathId,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", {
        x: -halfStrokeWidth,
        y: halfStrokeWidth * (isCustomShape ? -1 : 1),
        width: width + computedStrokeWidth,
        height: width
      })
    })]
  });
});
function createEventEmitter() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((listener) => listener(data));
    },
    on(event, listener) {
      if (!map.has(event)) {
        map.set(event, /* @__PURE__ */ new Set());
      }
      map.get(event).add(listener);
    },
    off(event, listener) {
      var _map$get2;
      (_map$get2 = map.get(event)) == null || _map$get2.delete(listener);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ reactExports.createContext(null);
const FloatingTreeContext = /* @__PURE__ */ reactExports.createContext(null);
const useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = reactExports.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
const useFloatingTree = () => reactExports.useContext(FloatingTreeContext);
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function clearTimeoutIfSet(timeoutRef) {
  if (timeoutRef.current !== -1) {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = -1;
  }
}
const safePolygonIdentifier = /* @__PURE__ */ createAttribute("safe-polygon");
function getDelay(value2, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value2 === "number") {
    return value2;
  }
  if (typeof value2 === "function") {
    const result2 = value2();
    if (typeof result2 === "number") {
      return result2;
    }
    return result2 == null ? void 0 : result2[prop];
  }
  return value2 == null ? void 0 : value2[prop];
}
function getRestMs(value2) {
  if (typeof value2 === "function") {
    return value2();
  }
  return value2;
}
function useHover(context2, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements
  } = context2;
  const {
    enabled = true,
    delay = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = props;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef(handleClose);
  const delayRef = useLatestRef(delay);
  const openRef = useLatestRef(open);
  const restMsRef = useLatestRef(restMs);
  const pointerTypeRef = reactExports.useRef();
  const timeoutRef = reactExports.useRef(-1);
  const handlerRef = reactExports.useRef();
  const restTimeoutRef = reactExports.useRef(-1);
  const blockMouseMoveRef = reactExports.useRef(true);
  const performedPointerEventsMutationRef = reactExports.useRef(false);
  const unbindMouseMoveRef = reactExports.useRef(() => {
  });
  const restTimeoutPendingRef = reactExports.useRef(false);
  const isHoverOpen = reactExports.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  }, [dataRef]);
  reactExports.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        open: open2
      } = _ref;
      if (!open2) {
        clearTimeoutIfSet(timeoutRef);
        clearTimeoutIfSet(restTimeoutRef);
        blockMouseMoveRef.current = true;
        restTimeoutPendingRef.current = false;
      }
    }
    events.on("openchange", onOpenChange2);
    return () => {
      events.off("openchange", onOpenChange2);
    };
  }, [enabled, events]);
  reactExports.useEffect(() => {
    if (!enabled) return;
    if (!handleCloseRef.current) return;
    if (!open) return;
    function onLeave(event) {
      if (isHoverOpen()) {
        onOpenChange(false, event, "hover");
      }
    }
    const html = getDocument(elements.floating).documentElement;
    html.addEventListener("mouseleave", onLeave);
    return () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = reactExports.useCallback(function(event, runElseBranch, reason) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }
    if (reason === void 0) {
      reason = "hover";
    }
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeoutIfSet(timeoutRef);
      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);
    } else if (runElseBranch) {
      clearTimeoutIfSet(timeoutRef);
      onOpenChange(false, event, reason);
    }
  }, [delayRef, onOpenChange]);
  const cleanupMouseMoveHandler = useEffectEvent(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = void 0;
  });
  const clearPointerEvents = useEffectEvent(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(elements.floating).body;
      body.style.pointerEvents = "";
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  });
  const isClickLikeOpenEvent = useEffectEvent(() => {
    return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
  });
  reactExports.useEffect(() => {
    if (!enabled) return;
    function onReferenceMouseEnter(event) {
      clearTimeoutIfSet(timeoutRef);
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || getRestMs(restMsRef.current) > 0 && !getDelay(delayRef.current, "open")) {
        return;
      }
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = window.setTimeout(() => {
          if (!openRef.current) {
            onOpenChange(true, event, "hover");
          }
        }, openDelay);
      } else if (!open) {
        onOpenChange(true, event, "hover");
      }
    }
    function onReferenceMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        clearPointerEvents();
        return;
      }
      unbindMouseMoveRef.current();
      const doc = getDocument(elements.floating);
      clearTimeoutIfSet(restTimeoutRef);
      restTimeoutPendingRef.current = false;
      if (handleCloseRef.current && dataRef.current.floatingContext) {
        if (!open) {
          clearTimeoutIfSet(timeoutRef);
        }
        handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            if (!isClickLikeOpenEvent()) {
              closeWithDelay(event, true, "safe-polygon");
            }
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler);
        unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      const shouldClose = pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : true;
      if (shouldClose) {
        closeWithDelay(event);
      }
    }
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent()) return;
      if (!dataRef.current.floatingContext) return;
      handleCloseRef.current == null || handleCloseRef.current({
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents();
          cleanupMouseMoveHandler();
          if (!isClickLikeOpenEvent()) {
            closeWithDelay(event);
          }
        }
      })(event);
    }
    function onFloatingMouseEnter() {
      clearTimeoutIfSet(timeoutRef);
    }
    function onFloatingMouseLeave(event) {
      if (!isClickLikeOpenEvent()) {
        closeWithDelay(event, false);
      }
    }
    if (isElement(elements.domReference)) {
      const reference2 = elements.domReference;
      const floating = elements.floating;
      if (open) {
        reference2.addEventListener("mouseleave", onScrollMouseLeave);
      }
      if (move) {
        reference2.addEventListener("mousemove", onReferenceMouseEnter, {
          once: true
        });
      }
      reference2.addEventListener("mouseenter", onReferenceMouseEnter);
      reference2.addEventListener("mouseleave", onReferenceMouseLeave);
      if (floating) {
        floating.addEventListener("mouseleave", onScrollMouseLeave);
        floating.addEventListener("mouseenter", onFloatingMouseEnter);
        floating.addEventListener("mouseleave", onFloatingMouseLeave);
      }
      return () => {
        if (open) {
          reference2.removeEventListener("mouseleave", onScrollMouseLeave);
        }
        if (move) {
          reference2.removeEventListener("mousemove", onReferenceMouseEnter);
        }
        reference2.removeEventListener("mouseenter", onReferenceMouseEnter);
        reference2.removeEventListener("mouseleave", onReferenceMouseLeave);
        if (floating) {
          floating.removeEventListener("mouseleave", onScrollMouseLeave);
          floating.removeEventListener("mouseenter", onFloatingMouseEnter);
          floating.removeEventListener("mouseleave", onFloatingMouseLeave);
        }
      };
    }
  }, [elements, enabled, context2, mouseOnly, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent, restMsRef]);
  index(() => {
    var _handleCloseRef$curre;
    if (!enabled) return;
    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = true;
      const floatingEl = elements.floating;
      if (isElement(elements.domReference) && floatingEl) {
        var _tree$nodesRef$curren;
        const body = getDocument(elements.floating).body;
        body.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference;
        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
        if (parentFloating) {
          parentFloating.style.pointerEvents = "";
        }
        body.style.pointerEvents = "none";
        ref.style.pointerEvents = "auto";
        floatingEl.style.pointerEvents = "auto";
        return () => {
          body.style.pointerEvents = "";
          ref.style.pointerEvents = "";
          floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]);
  index(() => {
    if (!open) {
      pointerTypeRef.current = void 0;
      restTimeoutPendingRef.current = false;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
  reactExports.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
      clearTimeoutIfSet(timeoutRef);
      clearTimeoutIfSet(restTimeoutRef);
      clearPointerEvents();
    };
  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  const reference = reactExports.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          if (!blockMouseMoveRef.current && !openRef.current) {
            onOpenChange(true, nativeEvent, "hover");
          }
        }
        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
          return;
        }
        if (open || getRestMs(restMsRef.current) === 0) {
          return;
        }
        if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {
          return;
        }
        clearTimeoutIfSet(restTimeoutRef);
        if (pointerTypeRef.current === "touch") {
          handleMouseMove();
        } else {
          restTimeoutPendingRef.current = true;
          restTimeoutRef.current = window.setTimeout(handleMouseMove, getRestMs(restMsRef.current));
        }
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMsRef]);
  return reactExports.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
const HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
const FocusGuard = /* @__PURE__ */ reactExports.forwardRef(function FocusGuard2(props, ref) {
  const [role, setRole] = reactExports.useState();
  index(() => {
    if (isSafari()) {
      setRole("button");
    }
  }, []);
  const restProps = {
    ref,
    tabIndex: 0,
    // Role is only for VoiceOver
    role,
    "aria-hidden": role ? void 0 : true,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    ...props,
    ...restProps
  });
});
const PortalContext = /* @__PURE__ */ reactExports.createContext(null);
const attr = /* @__PURE__ */ createAttribute("portal");
function useFloatingPortalNode(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    id,
    root
  } = props;
  const uniqueId = useId();
  const portalContext = usePortalContext();
  const [portalNode, setPortalNode] = reactExports.useState(null);
  const portalNodeRef = reactExports.useRef(null);
  index(() => {
    return () => {
      portalNode == null || portalNode.remove();
      queueMicrotask(() => {
        portalNodeRef.current = null;
      });
    };
  }, [portalNode]);
  index(() => {
    if (!uniqueId) return;
    if (portalNodeRef.current) return;
    const existingIdRoot = id ? document.getElementById(id) : null;
    if (!existingIdRoot) return;
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    existingIdRoot.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id, uniqueId]);
  index(() => {
    if (root === null) return;
    if (!uniqueId) return;
    if (portalNodeRef.current) return;
    let container2 = root || (portalContext == null ? void 0 : portalContext.portalNode);
    if (container2 && !isElement(container2)) container2 = container2.current;
    container2 = container2 || document.body;
    let idWrapper = null;
    if (id) {
      idWrapper = document.createElement("div");
      idWrapper.id = id;
      container2.appendChild(idWrapper);
    }
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    container2 = idWrapper || container2;
    container2.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id, root, uniqueId, portalContext]);
  return portalNode;
}
function FloatingPortal(props) {
  const {
    children,
    id,
    root,
    preserveTabOrder = true
  } = props;
  const portalNode = useFloatingPortalNode({
    id,
    root
  });
  const [focusManagerState, setFocusManagerState] = reactExports.useState(null);
  const beforeOutsideRef = reactExports.useRef(null);
  const afterOutsideRef = reactExports.useRef(null);
  const beforeInsideRef = reactExports.useRef(null);
  const afterInsideRef = reactExports.useRef(null);
  const modal = focusManagerState == null ? void 0 : focusManagerState.modal;
  const open = focusManagerState == null ? void 0 : focusManagerState.open;
  const shouldRenderGuards = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!focusManagerState && // Guards are only for non-modal focus management.
    !focusManagerState.modal && // Don't render if unmount is transitioning.
    focusManagerState.open && preserveTabOrder && !!(root || portalNode)
  );
  reactExports.useEffect(() => {
    if (!portalNode || !preserveTabOrder || modal) {
      return;
    }
    function onFocus(event) {
      if (portalNode && isOutsideEvent(event)) {
        const focusing = event.type === "focusin";
        const manageFocus = focusing ? enableFocusInside : disableFocusInside;
        manageFocus(portalNode);
      }
    }
    portalNode.addEventListener("focusin", onFocus, true);
    portalNode.addEventListener("focusout", onFocus, true);
    return () => {
      portalNode.removeEventListener("focusin", onFocus, true);
      portalNode.removeEventListener("focusout", onFocus, true);
    };
  }, [portalNode, preserveTabOrder, modal]);
  reactExports.useEffect(() => {
    if (!portalNode) return;
    if (open) return;
    enableFocusInside(portalNode);
  }, [open, portalNode]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PortalContext.Provider, {
    value: reactExports.useMemo(() => ({
      preserveTabOrder,
      beforeOutsideRef,
      afterOutsideRef,
      beforeInsideRef,
      afterInsideRef,
      portalNode,
      setFocusManagerState
    }), [preserveTabOrder, portalNode]),
    children: [shouldRenderGuards && portalNode && /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGuard, {
      "data-type": "outside",
      ref: beforeOutsideRef,
      onFocus: (event) => {
        if (isOutsideEvent(event, portalNode)) {
          var _beforeInsideRef$curr;
          (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();
        } else {
          const domReference = focusManagerState ? focusManagerState.domReference : null;
          const prevTabbable = getPreviousTabbable(domReference);
          prevTabbable == null || prevTabbable.focus();
        }
      }
    }), shouldRenderGuards && portalNode && /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      "aria-owns": portalNode.id,
      style: HIDDEN_STYLES
    }), portalNode && /* @__PURE__ */ reactDomExports.createPortal(children, portalNode), shouldRenderGuards && portalNode && /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGuard, {
      "data-type": "outside",
      ref: afterOutsideRef,
      onFocus: (event) => {
        if (isOutsideEvent(event, portalNode)) {
          var _afterInsideRef$curre;
          (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();
        } else {
          const domReference = focusManagerState ? focusManagerState.domReference : null;
          const nextTabbable = getNextTabbable(domReference);
          nextTabbable == null || nextTabbable.focus();
          (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent, "focus-out"));
        }
      }
    })]
  });
}
const usePortalContext = () => reactExports.useContext(PortalContext);
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = reactExports.useRef({});
  const [events] = reactExports.useState(() => createEventEmitter());
  const nested = useFloatingParentNodeId() != null;
  const [positionReference, setPositionReference] = reactExports.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = reactExports.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = reactExports.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return reactExports.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = reactExports.useState(null);
  const [positionReference, _setPositionReference] = reactExports.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = reactExports.useRef(null);
  const tree = useFloatingTree();
  index(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating$1({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = reactExports.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      getClientRects: () => node.getClientRects(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = reactExports.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = reactExports.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = reactExports.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context2 = reactExports.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index(() => {
    rootContext.dataRef.current.floatingContext = context2;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context2;
    }
  });
  return reactExports.useMemo(() => ({
    ...position,
    context: context2,
    refs,
    elements
  }), [position, refs, elements, context2]);
}
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _2,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value2) => {
      const propsOrGetProps = value2 ? value2[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value2] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value2 === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value2);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value2;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
  const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
  const getReferenceProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return reactExports.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
const componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", false]]);
function useRole(context2, props) {
  var _elements$domReferenc, _componentRoleToAriaR;
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    elements,
    floatingId: defaultFloatingId
  } = context2;
  const {
    enabled = true,
    role = "dialog"
  } = props;
  const defaultReferenceId = useId();
  const referenceId = ((_elements$domReferenc = elements.domReference) == null ? void 0 : _elements$domReferenc.id) || defaultReferenceId;
  const floatingId = reactExports.useMemo(() => {
    var _getFloatingFocusElem;
    return ((_getFloatingFocusElem = getFloatingFocusElement(elements.floating)) == null ? void 0 : _getFloatingFocusElem.id) || defaultFloatingId;
  }, [elements.floating, defaultFloatingId]);
  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;
  const parentId = useFloatingParentNodeId();
  const isNested = parentId != null;
  const reference = reactExports.useMemo(() => {
    if (ariaRole === "tooltip" || role === "label") {
      return {
        ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open ? floatingId : void 0
      };
    }
    return {
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
      "aria-controls": open ? floatingId : void 0,
      ...ariaRole === "listbox" && {
        role: "combobox"
      },
      ...ariaRole === "menu" && {
        id: referenceId
      },
      ...ariaRole === "menu" && isNested && {
        role: "menuitem"
      },
      ...role === "select" && {
        "aria-autocomplete": "none"
      },
      ...role === "combobox" && {
        "aria-autocomplete": "list"
      }
    };
  }, [ariaRole, floatingId, isNested, open, referenceId, role]);
  const floating = reactExports.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    if (ariaRole === "tooltip" || role === "label") {
      return floatingProps;
    }
    return {
      ...floatingProps,
      ...ariaRole === "menu" && {
        "aria-labelledby": referenceId
      }
    };
  }, [ariaRole, floatingId, referenceId, role]);
  const item = reactExports.useCallback((_ref) => {
    let {
      active: active2,
      selected: selected2
    } = _ref;
    const commonProps = {
      role: "option",
      ...active2 && {
        id: floatingId + "-fui-option"
      }
    };
    switch (role) {
      case "select":
        return {
          ...commonProps,
          "aria-selected": active2 && selected2
        };
      case "combobox": {
        return {
          ...commonProps,
          "aria-selected": selected2
        };
      }
    }
    return {};
  }, [floatingId, role]);
  return reactExports.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
function createContext(rootName, defaultContext) {
  const Ctx = React.createContext(defaultContext);
  function Provider(props) {
    const { children, ...context2 } = props;
    const value2 = React.useMemo(() => context2, Object.values(context2));
    return jsxRuntimeExports.jsx(Ctx.Provider, { value: value2, children });
  }
  function useContext(childName) {
    const context2 = React.useContext(Ctx);
    if (context2) {
      return context2;
    }
    throw Error(`${childName} must be rendered inside of a ${rootName} component.`);
  }
  Ctx.displayName = `${rootName}Context`;
  Provider.displayName = `${rootName}Provider`;
  return [Provider, useContext];
}
const [TooltipProvider, useTooltipContext] = createContext("Tooltip");
const TooltipTrigger = reactExports.forwardRef(function TooltipTrigger2({ children, asChild = false, ...props }, propRef) {
  const { context: context2 } = useTooltipContext("Tooltip");
  const childrenRef = (children == null ? void 0 : children.ref) ?? null;
  const ref = useMergeRefs([context2.refs.setReference, propRef, childrenRef]);
  reactExports.useLayoutEffect(() => {
    if (propRef) {
      context2.refs.setReference(propRef == null ? void 0 : propRef.current);
    }
  }, []);
  if (propRef)
    return null;
  if (asChild && reactExports.isValidElement(children)) {
    return reactExports.cloneElement(children, context2.getReferenceProps({
      ref,
      ...props,
      ...children.props
    }));
  }
  return jsxRuntimeExports.jsx("div", { ref, ...context2.getReferenceProps(props), children });
});
const tooltipContent$1 = "_tooltipContent_1k4lm_1";
const bigger = "_bigger_1k4lm_12";
const arrow$1 = "_arrow_1k4lm_24";
const s$m = {
  tooltipContent: tooltipContent$1,
  bigger,
  "default": "_default_1k4lm_18",
  arrow: arrow$1
};
const TooltipContent = reactExports.forwardRef(function TooltipContent2(props, propRef) {
  const { context: context2, arrowRef, size } = useTooltipContext("Tooltip");
  const ref = useMergeRefs([context2.refs.setFloating, propRef]);
  const { children, ...rest } = props;
  return jsxRuntimeExports.jsx(FloatingPortal, { children: context2.open && jsxRuntimeExports.jsxs("div", { className: clsx(s$m.tooltipContent, s$m[size ?? "default"]), ref, style: {
    position: context2.strategy,
    top: context2.y ?? 0,
    left: context2.x ?? 0,
    visibility: context2.x == null ? "hidden" : "visible"
  }, ...context2.getFloatingProps(rest), children: [children, jsxRuntimeExports.jsx(FloatingArrow, { ref: arrowRef, context: context2.context, className: s$m.arrow, stroke: "transparent", strokeWidth: 2, height: 8, width: 16 })] }) });
});
const ARROW_HEIGHT = 8;
function useTooltip({ initialOpen = false, placement = "bottom", offset: offsetValue = 0, open: controlledOpen, onOpenChange: setControlledOpen } = {}, arrowRef) {
  const [uncontrolledOpen, setUncontrolledOpen] = reactExports.useState(initialOpen);
  const open = controlledOpen ?? uncontrolledOpen;
  const setOpen = setControlledOpen ?? setUncontrolledOpen;
  const data = useFloating({
    placement,
    open,
    strategy: "fixed",
    onOpenChange: setOpen,
    whileElementsMounted: autoUpdate,
    middleware: [
      offset(offsetValue + ARROW_HEIGHT),
      flip({ fallbackAxisSideDirection: "start" }),
      shift({ padding: 5 }),
      arrow$3({ element: arrowRef })
    ]
  });
  const context2 = data.context;
  const hover = useHover(context2);
  const role = useRole(context2, { role: "tooltip" });
  const interactions = useInteractions([hover, role]);
  return reactExports.useMemo(() => ({
    open,
    setOpen,
    ...interactions,
    ...data
  }), [open, setOpen, interactions, data]);
}
function SimpleTooltip({ children, content, ...options }) {
  const arrowRef = reactExports.useRef(null);
  const context2 = useTooltip(options, arrowRef);
  return jsxRuntimeExports.jsxs(TooltipProvider, { context: context2, arrowRef, size: options.size, children: [jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children }), context2.open && jsxRuntimeExports.jsx(TooltipContent, { children: content })] });
}
const legendTitle = "_legendTitle_sgaz8_1";
const grid$1 = "_grid_sgaz8_6";
const cell = "_cell_sgaz8_11";
const colorCell = "_colorCell_sgaz8_17";
const yStepsCell = "_yStepsCell_sgaz8_26";
const xStepsCell = "_xStepsCell_sgaz8_45";
const xStepsCellNoLabel = "_xStepsCellNoLabel_sgaz8_46";
const arrowX = "_arrowX_sgaz8_70";
const arrowY = "_arrowY_sgaz8_71";
const axisLabelX = "_axisLabelX_sgaz8_88";
const axisLabelY = "_axisLabelY_sgaz8_89";
const arrowHeadX = "_arrowHeadX_sgaz8_107";
const arrowHeadY = "_arrowHeadY_sgaz8_108";
const arrowHeadY_angle0 = "_arrowHeadY_angle0_sgaz8_123";
const styles$8 = {
  legendTitle,
  grid: grid$1,
  cell,
  colorCell,
  yStepsCell,
  xStepsCell,
  xStepsCellNoLabel,
  arrowX,
  arrowY,
  axisLabelX,
  axisLabelY,
  arrowHeadX,
  arrowHeadY,
  arrowHeadY_angle0
};
function createTreads() {
  const treads = {};
  return {
    increment: (treadId) => {
      if (typeof treads[treadId] === "number") {
        treads[treadId] += 1;
      } else {
        treads[treadId] = 0;
      }
      return treads[treadId];
    }
  };
}
function fillTemplate(template, data) {
  const order2 = [];
  const treads = createTreads();
  template.forEach((row2, y2) => {
    row2.split(" ").forEach((cell2, x2) => {
      const position = treads.increment(cell2);
      const dataCell = data[cell2] && data[cell2][position];
      if (dataCell) {
        order2.push({ ...dataCell, _position: { x: x2, y: y2 } });
      }
    });
  });
  return order2;
}
function safeReverse(arr) {
  return [...arr].reverse();
}
const getCellPositionStyle = (col, row2) => ({
  gridColumn: `${col + 1} / ${col + 2}`,
  gridRow: `${row2 + 1} / ${row2 + 2}`
});
const ArrowHead = ({ className, type }) => jsxRuntimeExports.jsx("div", { className, children: type === "horizontal" ? jsxRuntimeExports.jsx("svg", { width: "6", height: "12", viewBox: "0 0 6 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsxRuntimeExports.jsx("path", { d: "M6,6L0,0l0,2.4L3.6,6L0,9.6L0,12L6,6z", fill: "currentColor" }) }) : jsxRuntimeExports.jsx("svg", { width: "12", height: "6", viewBox: "0 0 12 6", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsxRuntimeExports.jsx("path", { d: "M6,0L0,6l2.4,0L6,2.4L9.6,6L12,6L6,0z", fill: "currentColor" }) }) });
function Legend({ cells: cells2, size, axis: axis2, title: title2, showAxisLabels = false, showSteps = true, showArrowHeads = true, onCellPointerOver, onCellPointerLeave, renderXAxisLabel, renderYAxisLabel }) {
  const TEMPLATE = reactExports.useMemo(() => [
    `y ${new Array(size + 1).fill(".").join(" ")}`,
    ...new Array(size).fill(`y ${new Array(size).fill("c").join(" ")} .`),
    `. ${new Array(size + 1).fill("x").join(" ")}`
  ], [size]);
  const gridCells = fillTemplate(TEMPLATE, {
    x: showSteps ? axis2.x.steps.map((step) => ({
      label: step.label || step.value.toFixed(1),
      className: styles$8.xStepsCell
    })) : axis2.x.steps.map((step) => ({
      label: "",
      className: styles$8.xStepsCellNoLabel
    })),
    y: showSteps ? safeReverse(axis2.y.steps).map((step) => ({
      label: step.label || step.value.toFixed(1),
      className: styles$8.yStepsCell
    })) : safeReverse(axis2.y.steps).map((step) => ({
      label: "",
      className: styles$8.yStepsCellNoLabel
    })),
    c: cells2.map((cell2, i2) => ({
      label: jsxRuntimeExports.jsx("span", { children: cell2.label }),
      className: clsx(styles$8.cell, styles$8.colorCell),
      style: { backgroundColor: cell2.color },
      ...onCellPointerOver && { onPointerOver: (e) => onCellPointerOver(e, cell2, i2) },
      ...onCellPointerLeave && { onPointerLeave: (e) => onCellPointerLeave(e, cell2, i2) }
    }))
  });
  const xAxisLabel = () => renderXAxisLabel ? renderXAxisLabel(axis2.x, styles$8.axisLabelX) : jsxRuntimeExports.jsx("div", { className: styles$8.axisLabelX, children: axis2.x.label });
  const yAxisLabel = () => renderYAxisLabel ? renderYAxisLabel(axis2.y, styles$8.axisLabelY) : jsxRuntimeExports.jsx("div", { className: styles$8.axisLabelY, children: axis2.y.label });
  return jsxRuntimeExports.jsxs("div", { children: [title2 && jsxRuntimeExports.jsx("div", { className: styles$8.legendTitle, children: title2 }), jsxRuntimeExports.jsxs("div", { className: styles$8.grid, style: {
    gridTemplateColumns: `repeat(${size + 2}, auto)`,
    gridTemplateRows: `repeat(${size + 2}, auto)`
  }, children: [showAxisLabels && axis2.x.label ? xAxisLabel() : null, showAxisLabels && axis2.y.label ? yAxisLabel() : null, jsxRuntimeExports.jsx("div", { className: styles$8.arrowX, children: showArrowHeads && jsxRuntimeExports.jsx(ArrowHead, { type: "horizontal", className: styles$8.arrowHeadX }) }), jsxRuntimeExports.jsx("div", { className: styles$8.arrowY, children: showArrowHeads && jsxRuntimeExports.jsx(ArrowHead, { type: "vertical", className: clsx({ [styles$8.arrowHeadY]: true, [styles$8.arrowHeadY_angle0]: !showAxisLabels }) }) }), gridCells.map((cell2) => jsxRuntimeExports.jsx("div", { style: Object.assign(getCellPositionStyle(cell2._position.x, cell2._position.y), cell2.style), className: clsx(cell2.className, styles$8.cell), onPointerOver: cell2.onPointerOver, onPointerLeave: cell2.onPointerLeave, children: cell2.label }, `${cell2._position.x}|${cell2._position.y}`))] })] });
}
function _objectWithoutPropertiesLoose(r2, e) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (e.includes(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function _extends$2() {
  return _extends$2 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e = 1; e < arguments.length; e++) {
      var t2 = arguments[e];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$2.apply(null, arguments);
}
function _setPrototypeOf(t2, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e2) {
    return t3.__proto__ = e2, t3;
  }, _setPrototypeOf(t2, e);
}
function _inheritsLoose(t2, o2) {
  t2.prototype = Object.create(o2.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o2);
}
const NAVIGATE_EVENT = "KNT_NAVIGATE_TO";
const goTo = (slug) => {
  const evt = new CustomEvent(NAVIGATE_EVENT, { detail: { payload: slug } });
  globalThis.dispatchEvent(evt);
};
const impossibleValue = Symbol(), callSafely = function(fn) {
  try {
    return fn(...[].slice.call(arguments, 1));
  } catch (err) {
    return setTimeout(() => {
      throw err;
    }), err instanceof Error ? err : err = new Error(err);
  }
};
function throwReatomError(condition, message) {
  if (condition) throw new Error(`Reatom error: ${message}`);
}
const isAtom$1 = (thing) => void 0 !== (thing == null ? void 0 : thing.__reatom), isAction$1 = (thing) => {
  var _a2;
  return true === ((_a2 = thing == null ? void 0 : thing.__reatom) == null ? void 0 : _a2.isAction);
}, isConnected$1 = (cache) => cache.subs.size + cache.listeners.size > 0;
function assertFunction(thing) {
  throwReatomError("function" != typeof thing, `invalid "${typeof thing}", function expected`);
}
const getRootCause$2 = (cause) => null === cause.cause ? cause : getRootCause$2(cause.cause), isBrowser = () => {
  var _a2;
  return !!((_a2 = globalThis.navigator) == null ? void 0 : _a2.userAgent);
};
let CTX, initiations = 0;
const createCtx = ({ callLateEffect = callSafely, callNearEffect = callSafely, restrictMultipleContexts = isBrowser() } = {}) => {
  restrictMultipleContexts && 1 == initiations++ && console.warn("Reatom: multiple contexts detected, which is irrelevant in browser, you should use only one context");
  let caches = /* @__PURE__ */ new WeakMap(), read = (proto) => caches.get(proto), logsListeners = /* @__PURE__ */ new Set(), nearEffects = [], lateEffects = [], inTr = false, trError = null, trUpdates = [], trRollbacks = [], trLogs = [], trNearEffectsStart = 0, trLateEffectsStart = 0, effectsProcessing = false, walkNearEffects = () => {
    for (let effect of nearEffects) callNearEffect(effect, ctx);
    nearEffects = [];
  }, walkLateEffects = () => {
    if (!effectsProcessing) {
      effectsProcessing = true, walkNearEffects();
      for (let effect of lateEffects) callLateEffect(effect, ctx), nearEffects.length > 0 && walkNearEffects();
      lateEffects = [], effectsProcessing = false;
    }
  }, addPatch = ({ state, proto, pubs, subs, listeners }, cause) => (proto.actual = false, trLogs.push(proto.patch = { state, proto, cause, pubs, subs, listeners }), proto.patch), enqueueComputers = (cache) => {
    for (let subProto of cache.subs) {
      let subCache = subProto.patch ?? read(subProto);
      subProto.patch && !subProto.actual || 0 === addPatch(subCache, cache).listeners.size && enqueueComputers(subCache);
    }
  }, disconnect = (proto, pubPatch) => {
    if (pubPatch.subs.delete(proto) && (trRollbacks.push(() => pubPatch.subs.add(proto)), !isConnected$1(pubPatch))) {
      null !== pubPatch.proto.disconnectHooks && nearEffects.push(...pubPatch.proto.disconnectHooks);
      for (let parentParent of pubPatch.pubs) disconnect(pubPatch.proto, parentParent);
    }
  }, connect = (proto, pubPatch) => {
    if (!pubPatch.subs.has(proto)) {
      let wasConnected = isConnected$1(pubPatch);
      if (pubPatch.subs.add(proto), trRollbacks.push(() => pubPatch.subs.delete(proto)), !wasConnected) {
        null !== pubPatch.proto.connectHooks && nearEffects.push(...pubPatch.proto.connectHooks);
        for (let parentParentPatch of pubPatch.pubs) connect(pubPatch.proto, parentParentPatch);
      }
    }
  }, actualize = (ctx2, proto, updater) => {
    let { patch, actual } = proto, updating = void 0 !== updater;
    if (!updating && actual && (0 === patch.pubs.length || isConnected$1(patch))) return patch;
    let cache = patch ?? read(proto), isInt = !cache, cause = updating ? ctx2.cause : read(__root);
    if (isInt) cache = { state: proto.initState(ctx2), proto, cause, pubs: [], subs: /* @__PURE__ */ new Set(), listeners: /* @__PURE__ */ new Set() };
    else if (null === proto.computer && !updating) return cache;
    patch && !actual || (patch = addPatch(cache, cause));
    let { state } = patch, patchCtx = { get: ctx2.get, spy: void 0, schedule: ctx2.schedule, subscribe: ctx2.subscribe, cause: patch };
    try {
      proto.computer && ((patchCtx2, patch2) => {
        let { proto: proto2, pubs } = patch2, isDepsChanged = false;
        if (0 === pubs.length || pubs.some(({ proto: proto3, state: state2 }) => !Object.is(state2, (patch2.cause = actualize(patchCtx2, proto3)).state))) {
          let newPubs = [];
          if (patchCtx2.spy = ({ __reatom: depProto }, cb) => {
            let depPatch = actualize(patchCtx2, depProto), prevDepPatch = newPubs.push(depPatch) <= pubs.length ? pubs[newPubs.length - 1] : void 0, isDepChanged = (prevDepPatch == null ? void 0 : prevDepPatch.proto) !== depPatch.proto;
            isDepsChanged || (isDepsChanged = isDepChanged);
            let state2 = depProto.isAction && !isDepChanged ? depPatch.state.slice(prevDepPatch.state.length) : depPatch.state;
            if (!cb || !isDepChanged && Object.is(state2, prevDepPatch.state)) return state2;
            if (depProto.isAction) for (const call of state2) cb(call);
            else cb(state2, isDepChanged ? void 0 : prevDepPatch == null ? void 0 : prevDepPatch.state);
          }, patch2.state = patch2.proto.computer(patchCtx2, patch2.state), patch2.pubs = newPubs, (isDepsChanged || pubs.length > newPubs.length) && isConnected$1(patch2)) {
            for (let { proto: depProto } of pubs) newPubs.every((dep) => dep.proto !== depProto) && disconnect(proto2, depProto.patch ?? read(depProto));
            for (let { proto: depProto } of newPubs) pubs.every((dep) => dep.proto !== depProto) && connect(proto2, depProto.patch ?? read(depProto));
          }
          patchCtx2.spy = () => throwReatomError(true, "async spy"), patch2 = proto2 = pubs = newPubs = null;
        }
      })(patchCtx, patch), updating && (patch.cause = ctx2.cause, updater(patchCtx, patch)), proto.actual = true;
    } catch (error2) {
      throw patch.error = error2;
    }
    if (!Object.is(state, patch.state) && (patch.subs.size > 0 && (updating || patch.listeners.size > 0) && enqueueComputers(patch), proto.updateHooks)) {
      let ctx3 = { get: patchCtx.get, spy: void 0, schedule: patchCtx.schedule, subscribe: patchCtx.subscribe, cause: patchCtx.cause };
      proto.updateHooks.forEach((hook) => trUpdates.push(() => hook(ctx3, patch)));
    }
    return patch;
  }, ctx = { get(atomOrCb) {
    if (throwReatomError(CTX && getRootCause$2(CTX.cause) !== read(__root), "cause collision"), isAtom$1(atomOrCb)) {
      let proto = atomOrCb.__reatom;
      if (inTr) return actualize(this, proto).state;
      let cache = read(proto);
      return void 0 === cache || null !== proto.computer && !isConnected$1(cache) ? this.get(() => actualize(this, proto).state) : cache.state;
    }
    if (throwReatomError(null !== trError, "tr failed"), inTr) return atomOrCb(read, actualize);
    inTr = true, trNearEffectsStart = nearEffects.length, trLateEffectsStart = lateEffects.length;
    let start = void 0 === CTX;
    start && (CTX = this);
    try {
      var result2 = atomOrCb(read, actualize);
      for (let i2 = 0; i2 < trLogs.length; i2++) {
        let { listeners, proto } = trLogs[i2];
        if (listeners.size > 0 && actualize(this, proto), trUpdates.length > 0) for (let commit of trUpdates.splice(0)) commit(this);
      }
      if (trLogs.length) for (let log of logsListeners) log(trLogs);
      for (let patch of trLogs) {
        let { proto, state } = patch;
        if (proto.isAction && (patch.state = []), patch === proto.patch) if (proto.patch = null, proto.actual = false, caches.set(proto, patch), proto.isAction) {
          if (0 === state.length) continue;
          for (let cb of patch.listeners) nearEffects.push(() => cb(state));
        } else for (let cb of patch.listeners) lateEffects.push(() => cb(read(proto).state));
      }
    } catch (e) {
      trError = e = e instanceof Error ? e : new Error(String(e));
      for (let log of logsListeners) log(trLogs, e);
      for (let cb of trRollbacks) callSafely(cb, e);
      for (let { proto } of trLogs) proto.patch = null, proto.actual = false;
      throw nearEffects.length = trNearEffectsStart, lateEffects.length = trLateEffectsStart, e;
    } finally {
      inTr = false, trError = null, trUpdates = [], trRollbacks = [], trLogs = [], trNearEffectsStart = 0, trLateEffectsStart = 0, start && (CTX = void 0);
    }
    return walkLateEffects(), result2;
  }, spy: void 0, schedule(cb, step = 1) {
    return assertFunction(cb), throwReatomError(!this, "missed context"), new Promise((res, rej) => {
      -1 === step ? inTr && trRollbacks.push(cb) : 0 === step ? inTr && trUpdates.push(() => cb(this)) : ((1 === step ? nearEffects : lateEffects).push(() => {
        try {
          let result2 = cb(this);
          return result2 instanceof Promise ? result2.then(res, rej) : res(result2), result2;
        } catch (error2) {
          throw rej(error2), error2;
        }
      }), inTr || walkLateEffects());
    });
  }, subscribe(atom2, cb = atom2) {
    if (assertFunction(cb), atom2 === cb) return logsListeners.add(cb), () => logsListeners.delete(cb);
    let { __reatom: proto } = atom2, lastState = impossibleValue, listener = (state) => Object.is(lastState, state) || cb(lastState = state), cache = read(proto);
    return void 0 !== cache && isConnected$1(cache) ? cache.listeners.add(listener) : this.get(() => {
      cache = actualize(this, proto, (patchCtx, patch) => {
      }), cache.listeners.add(listener), trRollbacks.push(() => proto.patch.listeners.delete(listener)), null !== proto.connectHooks && nearEffects.push(...proto.connectHooks);
      for (let pubPatch of cache.pubs) connect(proto, pubPatch);
    }), lastState === impossibleValue && listener((proto.patch ?? read(proto)).state), () => {
      if (cache.listeners.delete(listener) && !isConnected$1(cache)) {
        proto.disconnectHooks && nearEffects.push(...proto.disconnectHooks);
        for (let pubCache of cache.pubs) disconnect(proto, pubCache);
        inTr || (trRollbacks.length = 0, walkLateEffects());
      }
    };
  }, cause: void 0 };
  return (ctx.cause = ctx.get(() => actualize(ctx, __root))).cause = null, ctx;
};
let i = 0, __count = (name) => `${name}#${++i}`;
function pipe() {
  return [].slice.call(arguments).reduce((acc, fn) => fn(acc), this);
}
function onChange(cb) {
  var _a2;
  const hook = (ctx, patch) => cb(ctx, patch.state);
  return ((_a2 = this.__reatom).updateHooks ?? (_a2.updateHooks = /* @__PURE__ */ new Set())).add(hook), () => this.__reatom.updateHooks.delete(hook);
}
function onCall(cb) {
  return this.onChange((ctx, state) => {
    const { params, payload } = state[state.length - 1];
    cb(ctx, payload, params);
  });
}
function atom(initState, name = __count("_atom")) {
  let theAtom = (ctx, update) => ctx.get((read, actualize) => actualize(ctx, theAtom.__reatom, (patchCtx, patch) => {
    patch.state = "function" == typeof update ? update(patch.state, patchCtx) : update;
  }).state), computer = null;
  return "function" == typeof initState && (theAtom = {}, computer = initState, initState = void 0), theAtom.__reatom = { name, isAction: false, patch: null, initState: () => initState, computer, connectHooks: null, disconnectHooks: null, updateHooks: null, actual: false }, theAtom.pipe = pipe, theAtom.onChange = onChange, 0 === experimental_PLUGINS.length ? theAtom : theAtom.pipe(...experimental_PLUGINS);
}
const action = (fn, name) => {
  void 0 !== fn && "string" != typeof fn || (name = fn, fn = (ctx, v2) => v2), assertFunction(fn);
  let actionAtom = atom([], name ?? __count("_action"));
  return actionAtom.__reatom.isAction = true, actionAtom.__reatom.unstable_fn = fn, Object.assign(function() {
    var params = [].slice.call(arguments);
    let state = actionAtom(params[0], (state2, patchCtx) => (params[0] = patchCtx, [...state2, { params: params.slice(1), payload: patchCtx.cause.proto.unstable_fn(...params) }]));
    return state[state.length - 1].payload;
  }, actionAtom, { onCall });
}, experimental_PLUGINS = [], __root = atom(void 0, "root").__reatom;
function pushUnique(list2, el) {
  list2.includes(el) || list2.push(el);
}
function isString$1(thing) {
  return "string" == typeof thing;
}
function isObject$1(thing) {
  return "object" == typeof thing && null !== thing;
}
function isFunction(thing) {
  return "function" == typeof thing;
}
function isAtom(thing) {
  return isFunction(thing) && "types" in thing;
}
function isActionCreator(thing) {
  return isFunction(thing) && "type" in thing;
}
function isAction(thing) {
  return isObject$1(thing) && isString$1(thing.type) && "payload" in thing;
}
function getState(atom2, store2 = defaultStore) {
  return store2.getState(atom2);
}
const getRootCause$1 = (cause) => null === cause.cause ? cause : getRootCause$1(cause.cause), spyChange = (ctx, anAtom, handler) => {
  let isChanged = false;
  return ctx.spy(anAtom, (newState, prevState) => {
    isChanged = true, handler == null ? void 0 : handler(newState, prevState);
  }), isChanged;
};
atom(null, "initializations").__reatom.initState = () => /* @__PURE__ */ new WeakMap();
let atomsCount = 0;
function createAtom$1(dependencies, reducer, options = {}) {
  let { v3atom, id = (v3atom == null ? void 0 : v3atom.__reatom.name) ?? "atom" + ++atomsCount, store: store2 = defaultStore } = isString$1(options) ? { id: options } : options;
  const trackedTypes = [], types = [], actionCreators = {}, externalActions = {};
  throwReatomError(!isFunction(reducer) || !isString$1(id), "atom arguments"), Object.entries(dependencies).forEach(([name, dep]) => {
    if (throwReatomError(!isFunction(dep), `Invalid atom dependencies (type ${typeof dep}) at ${name}`), isAtom(dep)) dep.types.forEach((type) => pushUnique(types, type));
    else {
      let type;
      if (isActionCreator(dep)) type = (externalActions[name] = dep).type;
      else {
        type = `${name}_${id}`;
        const actionCreator = function() {
          return { payload: dep(...[].slice.call(arguments)), type, targets: [atom$1], v3action: actionCreator.v3action };
        };
        actionCreator.type = type, actionCreator.dispatch = function() {
          return store2.dispatch(actionCreator(...[].slice.call(arguments)));
        }, actionCreator.v3action = action(type), actionCreators[name] = actionCreator, "_" != name[0] && (atom$1[name] = actionCreator);
      }
      pushUnique(trackedTypes, type), pushUnique(types, type);
    }
  });
  const cacheReducer = /* @__PURE__ */ function(reducer2, dependencies2, trackedTypes2, actionCreators2, externalActions2) {
    const create2 = function(name) {
      return actionCreators2[name](...[].slice.call(arguments, 1));
    };
    return (v3ctx, state) => {
      const rootCause = getRootCause$1(v3ctx.cause);
      ctxs.has(rootCause) || ctxs.set(rootCause, /* @__PURE__ */ new WeakMap()), ctxs.get(rootCause).has(reducer2) || ctxs.get(rootCause).set(reducer2, {});
      const ctx = ctxs.get(rootCause).get(reducer2);
      return reducer2({ create: create2, get: (name) => v3ctx.spy(dependencies2[name].v3atom), getUnlistedState: (targetAtom) => v3ctx.get(targetAtom.v3atom), onAction: (name, reaction) => {
        const ac = externalActions2[name] ?? actionCreators2[name];
        throwReatomError(void 0 === ac, "Unknown action"), spyChange(v3ctx, ac.v3action, ({ payload }) => {
          reaction(payload);
        });
      }, onChange: (name, reaction) => {
        spyChange(v3ctx, dependencies2[name].v3atom, (prev, next) => reaction(prev, next));
      }, onInit: (cb) => {
        v3ctx.get((read) => read(v3ctx.cause.proto)) || cb();
      }, schedule: (effect) => v3ctx.schedule(() => effect(getRootCause$1(v3ctx.cause).v2store.dispatch, ctx, []), 2), v3ctx }, state);
    };
  }(reducer, dependencies, 0, actionCreators, externalActions);
  function atom$1(transaction) {
    return transaction.v3ctx.get(atom$1.v3atom);
  }
  return atom$1.id = id, atom$1.getState = () => store2.getState(atom$1), atom$1.subscribe = (cb) => store2.subscribe(atom$1, cb), atom$1.types = types, (atom$1.v3atom = v3atom ?? atom(cacheReducer, id)).__reatom.v2atom = atom$1, atom$1;
}
const ctxs = /* @__PURE__ */ new WeakMap();
function createStore({ callSafety = callSafely, v3ctx = createCtx({ callNearEffect: callSafety, callLateEffect: callSafety }) } = {}) {
  const store2 = { dispatch: (action2) => {
    const actions = Array.isArray(action2) ? action2 : [action2];
    throwReatomError(0 == actions.length || !actions.every(isAction), "dispatch arguments"), v3ctx.get(() => {
      actions.forEach((action3) => action3.v3action(v3ctx, action3.payload)), actions.forEach(({ targets }) => targets == null ? void 0 : targets.forEach((target) => v3ctx.get(target.v3atom)));
    });
  }, getCache: (atom2) => v3ctx.get((read) => read(atom2.v3atom.__reatom)), getState: (atom2) => v3ctx.get(atom2.v3atom), subscribe: (atom2, cb) => v3ctx.subscribe(atom2.v3atom, (state) => cb(state, [])), v3ctx };
  return getRootCause$1(v3ctx.cause).v2store = store2, store2;
}
const defaultStore = createStore();
let n = 0;
function r(r2, c2, o2 = "primitive" + ++n) {
  c2 ?? (c2 = { set: (e, t2) => t2, change: (e, t2) => t2(e) });
  let { decorators: u2, ...a2 } = isString$1(o2) ? { id: o2 } : o2;
  const l2 = createAtom$1(Object.keys(c2).reduce((e, t2) => (e[t2] = function() {
    return [].slice.call(arguments);
  }, e), {}), (e, t2 = r2) => {
    for (const n2 in c2) e.onAction(n2, (e2) => {
      t2 = c2[n2](t2, ...e2);
    });
    return t2;
  }, a2);
  return l2;
}
let c$1 = 0;
function o$1(e = false, t2 = "boolean" + ++c$1) {
  return r(e, { toggle: (e2) => !e2, setTrue: () => true, setFalse: () => false, change: (e2, t3) => t3(e2), set: (e2, t3) => t3 }, t2);
}
let f = 0;
function m$9(n2, r2, c2 = "primitive" + ++f) {
  r2 ?? (r2 = { set: (e, t2) => t2, change: (e, t2) => t2(e) });
  let { decorators: o2, ...u2 } = isString$1(c2) ? { id: c2 } : c2;
  const a2 = createAtom$1(Object.keys(r2).reduce((e, t2) => (e[t2] = function() {
    return [].slice.call(arguments);
  }, e), {}), (e, t2 = n2) => {
    for (const n3 in r2) e.onAction(n3, (e2) => {
      t2 = r2[n3](t2, ...e2);
    });
    return t2;
  }, u2);
  return a2;
}
const noop$2 = () => {
}, isObject = (thing) => "object" == typeof thing && null !== thing, isShallowEqual = (a2, b2, is = Object.is) => {
  if (Object.is(a2, b2)) return true;
  if (!isObject(a2) || !isObject(b2) || a2.__proto__ !== b2.__proto__ || a2 instanceof Error) return false;
  if (Symbol.iterator in a2) {
    let equal2 = a2 instanceof Map ? (a3, b3) => is(a3[0], b3[0]) && is(a3[1], b3[1]) : is, aIter = a2[Symbol.iterator](), bIter = b2[Symbol.iterator]();
    for (; ; ) {
      let aNext = aIter.next(), bNext = bIter.next();
      if (aNext.done || bNext.done || !equal2(aNext.value, bNext.value)) return aNext.done && bNext.done;
    }
  }
  if (a2 instanceof Date) return a2.getTime() === b2.getTime();
  if (a2 instanceof RegExp) return String(a2) === String(b2);
  for (let k2 in a2) if (k2 in b2 == 0 || !is(a2[k2], b2[k2])) return false;
  return Object.keys(a2).length === Object.keys(b2).length;
}, isDeepEqual = (a2, b2) => {
  const visited = /* @__PURE__ */ new WeakMap(), is = (a3, b3) => {
    if (isObject(a3)) {
      if (visited.has(a3)) return visited.get(a3) === b3;
      visited.set(a3, b3);
    }
    return isShallowEqual(a3, b3, is);
  };
  return isShallowEqual(a2, b2, is);
}, assign = Object.assign, merge = function() {
  return Object.assign({}, ...[].slice.call(arguments));
};
const { toString } = Object.prototype, toAbortError = (reason) => {
  if (reason instanceof Error == 0 || "AbortError" !== reason.name) {
    if (reason instanceof Error) {
      var options = { cause: reason };
      reason = reason.message;
    } else reason = isObject(reason) ? toString.call(reason) : String(reason);
    "undefined" == typeof DOMException ? (reason = new Error(reason, options)).name = "AbortError" : reason = assign(new DOMException(reason, "AbortError"), options);
  }
  return reason;
}, throwIfAborted = (controller) => {
  if (controller == null ? void 0 : controller.signal.aborted) throw toAbortError(controller.signal.reason);
}, isAbort = (thing) => thing instanceof Error && "AbortError" === thing.name, setTimeout$1 = Object.assign(function() {
  const intervalId = globalThis.setTimeout(...[].slice.call(arguments));
  return "number" == typeof intervalId ? intervalId : Object.assign(intervalId, { toJSON: () => -1 });
}, globalThis.setTimeout), MAX_SAFE_TIMEOUT = 2 ** 31 - 1;
function _catch(body, recover) {
  try {
    var result2 = body();
  } catch (e) {
    return recover(e);
  }
  return result2 && result2.then ? result2.then(void 0, recover) : result2;
}
class CauseContext extends WeakMap {
  has(cause) {
    return super.has(cause) || null !== cause.cause && this.has(cause.cause);
  }
  get(cause) {
    for (; !super.has(cause) && cause.cause; ) cause = cause.cause;
    return super.get(cause);
  }
}
const abortCauseContext = new CauseContext(), getTopController = (patch) => abortCauseContext.get(patch) ?? null, onCtxAbort = (ctx, cb) => {
  const controller = getTopController(ctx.cause);
  if (controller) {
    const handler = () => cb(toAbortError(controller.signal.reason)), cleanup = () => controller.signal.removeEventListener("abort", handler);
    if (!controller.signal.aborted) return controller.signal.addEventListener("abort", handler), cleanup;
    handler();
  }
}, CHAINS = /* @__PURE__ */ new WeakMap(), __thenReatomed = (ctx, origin, onFulfill, onReject) => {
  let chain = CHAINS.get(origin);
  if (!chain) {
    const promise = origin.then((value2) => (ctx.get((read, actualize) => chain.then.forEach((cb) => cb(value2, read, actualize))), value2), (error2) => {
      throw ctx.get((read, actualize) => chain.catch.forEach((cb) => cb(error2, read, actualize))), isAbort(error2) && promise.catch(noop$2), error2;
    });
    CHAINS.set(origin, chain = { promise, then: [], catch: [] }), CHAINS.set(promise, chain);
  }
  return onFulfill && chain.then.push(onFulfill), onReject && chain.catch.push(onReject), chain.promise;
}, withAbortableSchedule = (ctx) => {
  const { schedule } = ctx;
  return merge(ctx, { schedule(cb, step = 1) {
    const _this = this;
    if (step < 1) return schedule.call(this, cb, step);
    let resolve, reject;
    const promise = new Promise((res, rej) => {
      resolve = res, reject = rej;
    }), unabort = onCtxAbort(this, (error2) => {
      promise.catch(noop$2), reject(error2);
    });
    return schedule.call(this, function(_ctx) {
      try {
        let _temp3 = function() {
          unabort == null ? void 0 : unabort();
        };
        const _temp2 = _catch(function() {
          const controller = getTopController(_this.cause);
          return throwIfAborted(controller), Promise.resolve(cb(_ctx)).then(function(value2) {
            throwIfAborted(controller), resolve(value2);
          });
        }, function(error2) {
          reject(error2);
        });
        return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(_temp3) : _temp3());
      } catch (e) {
        return Promise.reject(e);
      }
    }, step).catch((error2) => {
      reject(error2), unabort == null ? void 0 : unabort();
    }), promise;
  } });
}, _spawn = action(function(ctx, fn, controller) {
  return abortCauseContext.set(ctx.cause, controller), fn(ctx, ...[].slice.call(arguments, 3));
}, "_spawn"), spawn = (ctx, fn, args = [], controller = new AbortController()) => _spawn(ctx, fn, controller, ...args);
const getRootCause = (cause) => null === cause.cause ? cause : getRootCause(cause.cause), isSameCtx = (ctx1, ctx2) => getRootCause(ctx1.cause) === getRootCause(ctx2.cause), addOnConnect = (anAtom, cb) => {
  var _a2;
  return ((_a2 = anAtom.__reatom).connectHooks ?? (_a2.connectHooks = /* @__PURE__ */ new Set())).add(cb);
}, addOnDisconnect = (anAtom, cb) => {
  var _a2;
  return ((_a2 = anAtom.__reatom).disconnectHooks ?? (_a2.disconnectHooks = /* @__PURE__ */ new Set())).add(cb);
}, _onConnect = action((ctx, anAtom, fn, controller) => {
  ctx.cause.cause = getRootCause(ctx.cause), abortCauseContext.set(ctx.cause, controller);
  const result2 = fn(withAbortableSchedule({ ...ctx, controller, isConnected: () => isConnected(ctx, anAtom) }));
  return result2 instanceof Promise && controller.signal.addEventListener("abort", () => result2.catch(noop$2)), result2;
}, "_onConnect"), onConnect = (anAtom, cb) => {
  const connectHook = (ctx) => {
    const controller = new AbortController(), cleanup = _onConnect(ctx, anAtom, cb, controller);
    cleanup instanceof Promise && cleanup.catch(noop$2);
    const cleanupHook = (_ctx) => {
      isSameCtx(ctx, _ctx) && disconnectHooks.delete(cleanupHook) && connectHooks.has(connectHook) && (controller.abort(toAbortError(`${anAtom.__reatom.name} disconnect`)), "function" == typeof cleanup && cleanup());
    }, disconnectHooks = addOnDisconnect(anAtom, cleanupHook);
  }, connectHooks = addOnConnect(anAtom, connectHook);
  return () => connectHooks.delete(connectHook);
}, isConnected = (ctx, { __reatom: proto }) => ctx.get((read) => {
  const cache = proto.patch ?? read(proto);
  return !!cache && cache.subs.size + cache.listeners.size > 0;
}), initializations = atom(null, "initializations");
initializations.__reatom.initState = () => /* @__PURE__ */ new WeakMap();
const withAssign = (getProps) => (target) => assign(target, getProps(target, target.__reatom.name)), reatomMap = (initState = /* @__PURE__ */ new Map(), name) => atom(initState, name).pipe(withAssign((target, name2) => {
  const getOrCreate = action((ctx, key, value2) => (actions.set(ctx, key, value2), value2), `${name2}.getOrCreate`), actions = { get: (ctx, key) => ctx.get(target).get(key), getOrCreate: (ctx, key, creator) => actions.has(ctx, key) ? actions.get(ctx, key) : getOrCreate(ctx, key, creator()), has: (ctx, key) => ctx.get(target).has(key), set: action((ctx, key, value2) => target(ctx, (prev) => {
    const valuePrev = prev.get(key);
    return Object.is(valuePrev, value2) && (void 0 !== value2 || prev.has(key)) ? prev : new Map(prev).set(key, value2);
  }), `${name2}.set`), delete: action((ctx, key) => target(ctx, (prev) => {
    if (!prev.has(key)) return prev;
    const next = new Map(prev);
    return next.delete(key), next;
  }), `${name2}.delete`), clear: action((ctx) => target(ctx, /* @__PURE__ */ new Map()), `${name2}.clear`), reset: action((ctx) => target(ctx, initState), `${name2}.reset`) };
  return actions;
}));
const handleEffect = (anAsync, params, { shouldPending = true, shouldFulfill = true, shouldReject = true, effect = anAsync.__reatom.unstable_fn } = {}) => {
  const pendingAtom = anAsync.pendingAtom, [ctx] = params;
  shouldPending && pendingAtom(ctx, (s2) => ++s2);
  const origin = ctx.schedule(() => new Promise((res, rej) => {
    throwIfAborted(ctx.controller), effect(...params).then(res, rej), ctx.controller.signal.addEventListener("abort", () => rej(toAbortError(ctx.controller.signal.reason)));
  }));
  return assign(__thenReatomed(ctx, origin, (v2) => {
    shouldFulfill && anAsync.onFulfill(ctx, v2), shouldPending && pendingAtom(ctx, (s2) => --s2);
  }, (e) => {
    shouldReject && !isAbort(e) && anAsync.onReject(ctx, e), shouldPending && pendingAtom(ctx, (s2) => --s2);
  }), { controller: ctx.controller });
}, NOOP_TIMEOUT_ID = -1, withCache = ({ ignoreAbort = true, length = 5, paramsLength, staleTime = 3e5, swr: swrOptions = true, withPersist, paramsToKey, isEqual: isEqual2 = (ctx, a2, b2) => isDeepEqual(a2, b2) } = {}) => (anAsync) => {
  if (!anAsync.cacheAtom) {
    const swr = !!swrOptions, { shouldPending = false, shouldFulfill = swr, shouldReject = false } = swrOptions;
    Infinity !== staleTime && (staleTime = Math.min(MAX_SAFE_TIMEOUT, staleTime));
    const find = paramsToKey ? (ctx, params, state = ctx.get(cacheAtom)) => {
      const key = paramsToKey(ctx, params);
      return { cached: state.get(key), key };
    } : (ctx, params, state = ctx.get(cacheAtom)) => {
      for (const [key, cached] of state) if (isEqual2(ctx, key, params)) return { cached, key };
      return { cached: void 0, key: params };
    }, findLatestWithValue = (ctx, state = ctx.get(cacheAtom)) => {
      for (const cached of state.values()) if (cached.version > 0 && (!latestCached || cached.lastUpdate > latestCached.lastUpdate)) var latestCached = cached;
      return latestCached;
    }, deleteOldest = (cache) => {
      for (const [key, cached] of cache) if (!oldestCached || oldestCached.lastUpdate > cached.lastUpdate) var oldestKey = key, oldestCached = cached;
      oldestCached && cache.delete(oldestKey);
    }, planCleanup = (ctx, key, time = staleTime) => {
      var _a2;
      const clearTimeoutId = Infinity === staleTime ? NOOP_TIMEOUT_ID : setTimeout$1(() => {
        var _a3;
        ((_a3 = cacheAtom.get(ctx, key)) == null ? void 0 : _a3.clearTimeoutId) === clearTimeoutId && cacheAtom.delete(ctx, key);
      }, time);
      return (_a2 = clearTimeoutId.unref) == null ? void 0 : _a2.call(clearTimeoutId), ctx.schedule(() => clearTimeout(clearTimeoutId), -1), clearTimeoutId;
    }, cacheAtom = anAsync.cacheAtom = reatomMap(/* @__PURE__ */ new Map(), `${anAsync.__reatom.name}._cacheAtom`).pipe(withAssign((target, name) => ({ setWithParams: action((ctx, params, value2) => {
      const { cached, key } = find(ctx, params);
      cacheAtom.set(ctx, key, { clearTimeoutId: planCleanup(ctx, key), promise: void 0, value: value2, version: cached ? cached.version + 1 : 1, controller: new AbortController(), lastUpdate: Date.now(), params });
    }), deleteWithParams: action((ctx, params) => {
      const { cached, key } = find(ctx, params);
      cached && cacheAtom.delete(ctx, key);
    }) })));
    cacheAtom.invalidate = action((ctx) => {
      const latest = findLatestWithValue(ctx);
      return cacheAtom.clear(ctx), "promiseAtom" in anAsync ? anAsync(ctx) : latest ? anAsync(ctx, ...latest.params) : null;
    }, `${cacheAtom.__reatom.name}.invalidate`), cacheAtom.options = { ignoreAbort, length, paramsLength, staleTime, swr, withPersist }, withPersist && cacheAtom.pipe(withPersist({ key: cacheAtom.__reatom.name, fromSnapshot: (ctx, snapshot, state = /* @__PURE__ */ new Map()) => {
      if (snapshot.length <= (state == null ? void 0 : state.size) && snapshot.every(([, { params, value: value2 }]) => {
        const { cached } = find(ctx, params, state);
        return !!cached && isDeepEqual(cached.value, value2);
      })) return state;
      const newState = new Map(snapshot);
      for (const [key, rec] of newState) staleTime - (Date.now() - rec.lastUpdate) <= 0 ? newState.delete(key) : rec.clearTimeoutId = planCleanup(ctx, key, staleTime - (Date.now() - rec.lastUpdate));
      for (const [key, rec] of state) if (rec.promise) {
        const { cached } = find(ctx, rec.params, newState);
        cached ? cached.promise = rec.promise : newState.set(key, rec);
      }
      return newState;
    }, time: Math.min(staleTime, MAX_SAFE_TIMEOUT), toSnapshot: (ctx, cache) => [...cache].filter(([, rec]) => !rec.promise) }));
    const swrPendingAtom = anAsync.swrPendingAtom = atom(0, `${anAsync.__reatom.name}.swrPendingAtom`), handlePromise = (ctx, key, cached, swr2) => {
      cached.clearTimeoutId = planCleanup(ctx, key);
      const isSame = () => {
        var _a2;
        return ((_a2 = cacheAtom.get(ctx, key)) == null ? void 0 : _a2.clearTimeoutId) === cached.clearTimeoutId;
      }, { unstable_fn } = anAsync.__reatom;
      let res, rej;
      return cached.promise = new Promise(function() {
        return [res, rej] = [].slice.call(arguments);
      }), function() {
        try {
          let _temp2 = function() {
            return cached.promise;
          };
          var a2;
          a2 = [].slice.call(arguments);
          const _temp = function(body, recover) {
            try {
              var result2 = Promise.resolve(ignoreAbort ? spawn(a2[0], function(ctx2) {
                return unstable_fn({ ...ctx2, controller: getTopController(ctx2.cause) }, ...[].slice.call(arguments, 1));
              }, a2.slice(1)) : unstable_fn(...a2)).then(function(value2) {
                res(value2), ctx.get(() => {
                  isSame() && cacheAtom.set(ctx, key, { ...cached, promise: void 0, value: value2, version: cached.version + 1 }), swr2 && swrPendingAtom(ctx, (s2) => s2 - 1);
                });
              });
            } catch (e) {
              return recover(e);
            }
            return result2 && result2.then ? result2.then(void 0, recover) : result2;
          }(0, function(error2) {
            rej(error2), ctx.get(() => {
              isSame() && (cached.version > 0 ? cacheAtom.set(ctx, key, { ...cached, promise: void 0 }) : cacheAtom.delete(ctx, key)), swr2 && swrPendingAtom(ctx, (s2) => s2 - 1);
            });
          });
          return Promise.resolve(_temp && _temp.then ? _temp.then(_temp2) : _temp2());
        } catch (e) {
          return Promise.reject(e);
        }
      };
    };
    if (anAsync._handleCache = action(function() {
      var params = [].slice.call(arguments);
      const [ctx] = params, controller = getTopController(ctx.cause.cause);
      abortCauseContext.set(ctx.cause, ctx.controller = controller);
      const paramsKey = params.slice(1, 1 + (paramsLength ?? params.length));
      let { cached = { clearTimeoutId: NOOP_TIMEOUT_ID, promise: void 0, value: void 0, version: 0, controller, lastUpdate: -1, params: [] }, key } = find(ctx, paramsKey);
      const prevController = cached.controller;
      cached = { ...cached, lastUpdate: Date.now(), params: paramsKey, controller };
      const cache = cacheAtom.set(ctx, key, cached);
      return cache.size > length && deleteOldest(cache), 0 === cached.version && !cached.promise || cached.promise && prevController.signal.aborted ? handleEffect(anAsync, params, { effect: handlePromise(ctx, key, cached, false) }) : (cached.version > 0 && anAsync.onFulfill(ctx, cached.value), cached.promise || !swr ? handleEffect(anAsync, params, { effect: function() {
        try {
          return Promise.resolve(cached.promise ?? cached.value);
        } catch (e) {
          return Promise.reject(e);
        }
      }, shouldPending: false, shouldFulfill, shouldReject }) : (swr && swrPendingAtom(ctx, (s2) => s2 + 1), handleEffect(anAsync, params, { effect: handlePromise(ctx, key, cached, swr), shouldPending, shouldFulfill, shouldReject })));
    }, `${anAsync.__reatom.name}._handleCache`), "dataAtom" in anAsync) {
      const { initState } = anAsync.dataAtom.__reatom;
      anAsync.dataAtom.__reatom.initState = (ctx) => {
        const cached = findLatestWithValue(ctx), iniState = initState(ctx);
        return cached ? anAsync.dataAtom.mapFulfill ? anAsync.dataAtom.mapFulfill(ctx, cached.value, iniState) : cached.value : iniState;
      };
    }
    withPersist && "dataAtom" in anAsync && onConnect(anAsync.dataAtom, (ctx) => ctx.subscribe(cacheAtom, () => {
    }));
  }
  return anAsync;
}, resolved = /* @__PURE__ */ new WeakSet(), reatomResource = (asyncComputed, name = __count("asyncAtom")) => {
  const promises = new CauseContext(), theAsync = reatomAsync((ctx) => {
    const promise = promises.get(ctx.cause);
    return throwReatomError(!promise, "reaction manual call"), promise;
  }, name), promiseAtom = atom((_ctx, state) => {
    if (state && !_ctx.cause.pubs.length) return state;
    const params = [], ctx = merge(_ctx, { spy(anAtom, cb) {
      throwReatomError(cb, "spy reactions are unsupported in ResourceAtom");
      const value2 = _ctx.spy(anAtom);
      return params.push(value2), value2;
    } }), controller = new AbortController(), unabort = onCtxAbort(ctx, (error2) => {
      isConnected(ctx, theReaction) || controller.abort(error2);
    });
    unabort && controller.signal.addEventListener("abort", unabort), abortCauseContext.set(ctx.cause, ctx.controller = controller);
    const computedPromise = asyncComputed(withAbortableSchedule(ctx));
    computedPromise.catch(noop$2), promises.set(ctx.cause, computedPromise);
    const pendingBefore = ctx.get(theAsync.pendingAtom), fulfillCallsBefore = ctx.get(theAsync.onFulfill);
    let promise = theAsync(ctx, ...params);
    promise.controller.signal.addEventListener("abort", () => {
      var _a2;
      ((_a2 = theReaction.cacheAtom) == null ? void 0 : _a2.options.ignoreAbort) || controller.abort(promise.controller.signal.reason);
    });
    const cached = pendingBefore === ctx.get(theAsync.pendingAtom), fulfillCalls = ctx.get(theAsync.onFulfill);
    return cached && controller.abort(toAbortError("cached")), cached && fulfillCallsBefore !== fulfillCalls && (promise = Object.assign(Promise.resolve(fulfillCalls[fulfillCalls.length - 1].payload), { controller })), __thenReatomed(ctx, promise, () => resolved.add(promise), () => resolved.add(promise)).catch(noop$2), state == null ? void 0 : state.controller.abort(toAbortError("concurrent")), promise;
  }, `${name}._promiseAtom`);
  onConnect(theAsync, (ctx) => ctx.subscribe(promiseAtom, noop$2)), onConnect(promiseAtom, (ctx) => () => {
    ctx.get((read) => {
      var _a2;
      const state = (_a2 = read(promiseAtom.__reatom)) == null ? void 0 : _a2.state;
      state == null ? void 0 : state.controller.abort(ctx.controller.signal.reason), resolved.has(state) || reset(ctx, promiseAtom.__reatom, ctx.controller.signal.reason);
    });
  });
  const theReaction = Object.assign((ctx) => ctx.get((read, actualize) => {
    var _a2;
    reset(ctx, promiseAtom.__reatom, toAbortError("force")), actualize(ctx, promiseAtom.__reatom, noop$2);
    const state = ctx.get(theAsync), payload = (_a2 = state[state.length - 1]) == null ? void 0 : _a2.payload;
    return throwReatomError(!payload, "unexpectedly failed invalidation. Please, report the issue"), payload;
  }), theAsync, { promiseAtom, init: (ctx) => ctx.subscribe(promiseAtom, noop$2), reset: action((ctx) => {
    reset(ctx, promiseAtom.__reatom, toAbortError("reset"));
  }, `${name}.reset`) });
  return Object.defineProperty(theAsync, "_handleCache", { get: () => theReaction._handleCache }), theReaction;
}, reset = (ctx, proto, reason) => ctx.get((read, actualize) => {
  if (read(proto)) {
    const { computer } = proto;
    proto.computer = null;
    try {
      actualize(ctx, proto, (patchCtx, patch) => {
        var _a2;
        (_a2 = patch.state) == null ? void 0 : _a2.controller.abort(reason), patch.pubs = [], patch.state = void 0;
      });
    } finally {
      proto.computer = computer;
    }
  }
}), reatomAsync = (effect, options = {}) => {
  const { name = __count("async"), onEffect: onEffectHook, onFulfill: onFulfillHook, onReject: onRejectHook, onSettle: onSettleHook } = "string" == typeof options ? { name: options } : options, pendingAtom = atom(0, `${name}.pendingAtom`), theAsync = Object.assign(function() {
    var params = [].slice.call(arguments);
    return params[0].get((read, actualize) => {
      const { state } = actualize(params[0], theAsync.__reatom, (ctx, patch) => {
        abortCauseContext.set(ctx.cause, ctx.controller = new AbortController());
        const unabort = onCtxAbort(params[0], (error2) => {
          payload == null ? void 0 : payload.catch(noop$2), ctx.controller.abort(error2);
        });
        unabort && ctx.controller.signal.addEventListener("abort", unabort), params[0] = withAbortableSchedule(ctx);
        var payload = theAsync._handleCache ? theAsync._handleCache(...params) : handleEffect(theAsync, params);
        __thenReatomed(ctx, payload, void 0, () => {
          onReject.__reatom.updateHooks.size > 1 && payload.catch(noop$2);
        }), patch.state = [...patch.state, { params: params.slice(1), payload }];
      });
      return state[state.length - 1].payload;
    });
  }, action(effect, name)), onFulfill = action(`${name}.onFulfill`), onReject = action(`${name}.onReject`), onSettle = action(`${name}._onSettle`);
  return onFulfill.onCall((ctx) => onSettle(ctx)), onReject.onCall((ctx) => onSettle(ctx)), onEffectHook && theAsync.onCall((ctx, promise, params) => onEffectHook(ctx, params, promise)), onFulfillHook && onFulfill.onCall(onFulfillHook), onRejectHook && onReject.onCall(onRejectHook), onSettleHook && onSettle.onCall(onSettleHook), onConnect(pendingAtom, (ctx) => ctx.subscribe(theAsync, noop$2)), assign(theAsync, { onFulfill, onReject, onSettle, pendingAtom });
};
reatomAsync.from = (effect, options = {}) => (effect.name.length > 2 && ("object" == typeof options ? options.name ?? (options.name = effect.name) : options ?? (options = effect.name)), reatomAsync(function(ctx) {
  return effect(...[].slice.call(arguments, 1));
}, options));
const withDataAtom = (initState, mapFulfill) => (anAsync) => {
  if (!anAsync.dataAtom) {
    const dataAtom = anAsync.dataAtom = Object.assign(atom(initState, `${anAsync.__reatom.name}.dataAtom`), { reset: action((ctx) => {
      dataAtom(ctx, initState);
    }, `${anAsync.__reatom.name}.dataAtom.reset`), mapFulfill });
    dataAtom.__reatom.computer = (ctx, state) => (ctx.spy(anAsync.onFulfill, ({ payload }) => {
      state = payload;
    }), state), anAsync.onFulfill.onCall((ctx) => {
      ctx.get(dataAtom);
    }), onConnect(dataAtom, (ctx) => ctx.subscribe(anAsync, noop$2));
  }
  return anAsync;
};
const getCause = (patch, log = "") => log.length > 1e4 ? `${log} ...` : null !== patch.cause && patch.cause.proto !== __root ? getCause(patch.cause, log + " <-- " + (patch.cause.proto.name ?? "unnamed")) : log || "root", getTimeStampDefault = () => {
  let ms = (/* @__PURE__ */ new Date()).getMilliseconds();
  return ms = ms.toString().padStart(3, "0"), `${(/* @__PURE__ */ new Date()).toLocaleTimeString()} ${ms}ms`;
};
let timesPrecision = 10 ** 15;
const createLogBatched = ({ debounce = 500, getTimeStamp = getTimeStampDefault, limit = 5e3, log = console.log, domain = "", shouldGroup = false, shouldLogGraph = false } = {}) => {
  domain && (domain = `(${domain}) `);
  let queue = [], isBatching = false, batchingStart = Date.now();
  return (msg) => {
    0 !== Object.keys(msg.changes).length && (isBatching || (isBatching = true, batchingStart = Date.now()), setTimeout((length) => {
      if (isBatching = queue.length !== length && Date.now() - batchingStart < limit, isBatching) return;
      const isFewTransactions = queue.length > 0;
      console.groupCollapsed(`Reatom ${domain}${length} transaction${length > 1 ? "s" : ""}`), shouldLogGraph && ((logsSet) => {
        const visited = /* @__PURE__ */ new Set(), checkCause = (patch) => {
          !patch.cause || patch.cause.proto === __root || patch.cause.proto.name.startsWith("_") && patch.cause.proto.name.includes("._") || logsSet.has(patch.cause) || visited.has(patch.cause) || (checkCause(patch.cause), visited.add(patch.cause));
        };
        for (const patch of logsSet) checkCause(patch);
        const logs = [...logsSet], maxDistance = logs.reduce((acc, patch, i2) => Math.max(acc, i2 - ((patch.cause && logs.indexOf(patch.cause)) ?? i2)), 0), shiftRatio = 20 * maxDistance, x2 = Math.floor(maxDistance / logs.length * shiftRatio) + 20;
        let y2 = 30, body = "", width = x2;
        for (const patch of logs) {
          const { isAction: isAction2, name } = patch.proto, color = isAction2 ? name.endsWith(".onFulfill") ? "#E6DC73" : "#ffff80" : "#151134";
          body += `<circle cx="${x2}" cy="${y2}" r="10" fill="${color}" />`, body += `<text x="${x2 + 15}" y="${y2 + 5}" font-size="10" fill="gray">${name}</text>`, y2 += 30, width = Math.max(width, x2 + 10 * name.length);
        }
        logs.forEach(({ cause }, idx) => {
          if (!cause || cause.proto === __root || 0 === idx) return;
          const causeIdx = logs.indexOf(cause);
          if (causeIdx < 0) return;
          const causeY = 30 * causeIdx + 30, shiftX = Math.floor(x2 - (idx - causeIdx) / logs.length * shiftRatio - 10), shiftY = Math.floor(30 * (causeIdx + (idx - causeIdx) / 2)) + 30, idxY = 30 * idx + 30, lineX = Math.floor(x2 - 10);
          body += `<polyline points="${lineX},${causeY} ${shiftX},${shiftY} ${lineX},${idxY}" stroke="gray" fill="none" />`;
        });
        const dataUrl = `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${y2}" style="font-family: monospace;">${body}</svg>`)}`;
        console.log("%c                         ", `font-size:${y2}px; background: url(${dataUrl}) no-repeat; font-family: monospace;`);
      })(new Set(queue.flatMap(({ changes }) => Object.values(changes)).sort((a2, b2) => a2.time - b2.time).map(({ patch }) => patch)));
      for (const { changes, time, error: error2 } of queue) {
        console.log(`%c ${time}`, `padding-left: calc(50% - ${time.length / 2}em); font-size: 0.7rem;`), error2 && console.error(error2);
        let inGroup = false;
        Object.entries(changes).forEach(([k2, change], i2, arr) => {
          var _a2;
          const isAction2 = "payload" in change, style2 = (isAction2 ? "background: #ffff80; color: #151134;" : "background: #151134; color: white;") + "font-weight: 400; padding: 0.15em;  padding-right: 1ch;", name = k2.replace(/(\d)*\./, ""), head = name.replace(/\..*/, ""), nextK = (_a2 = arr[i2 + 1]) == null ? void 0 : _a2[0], nextName = nextK == null ? void 0 : nextK.replace(/(\d)*\./, ""), isGroup = nextName == null ? void 0 : nextName.startsWith(head);
          shouldGroup && !inGroup && isGroup && isFewTransactions && (inGroup = true, console.groupCollapsed(`%c ${head}`, style2));
          const data = isAction2 ? change.payload : change.newState;
          console.groupCollapsed(`%c ${name}`, style2), console.log(change), console.groupEnd(), isAction2 && !isShallowEqual(change.params, [data]) && log(...change.params), log(data), shouldGroup && !isGroup && inGroup && (inGroup = false, console.groupEnd());
        });
      }
      console.log("\n\n", "transactions:", queue), console.groupEnd(), queue = [];
    }, debounce, queue.push(Object.assign(msg, { time: getTimeStamp() }))));
  };
}, connectLogger = (ctx, { devtools = false, historyLength = 10, domain = "", log = createLogBatched({ domain }), showCause = true, skip = () => false, skipUnnamed = true } = {}) => {
  const history = /* @__PURE__ */ new WeakMap();
  let read;
  ctx.get((r2) => read = r2);
  const ctxUnsubscribe = ctx.subscribe((logs, error2) => {
    let i2 = -1;
    try {
      const states = /* @__PURE__ */ new WeakMap(), changes = {};
      for (; ++i2 < logs.length; ) {
        const patch = logs[i2], { cause, proto, state } = patch, { isAction: isAction2 } = proto;
        let { name } = proto;
        if (skip(patch)) continue;
        if (!name || name.startsWith("_") || /\._/.test(name)) {
          if (skipUnnamed) continue;
          name ?? (name = "unnamed");
        }
        const oldCache = read(proto), oldState = states.has(proto) ? states.get(proto) : oldCache == null ? void 0 : oldCache.state;
        if (states.set(proto, state), Object.is(state, oldState) || isAction2 && 0 === state.length) continue;
        let atomHistory = history.get(proto) ?? [];
        if (historyLength && (atomHistory = atomHistory.slice(0, historyLength - 1), atomHistory.unshift(isAction2 ? { ...patch, state: [...state] } : patch), history.set(proto, atomHistory)), !(oldCache || "root" !== cause.proto.name || isAction2 && 0 !== state.length)) continue;
        const changeMsg = changes[`${i2 + 1}.${name}`] = { patch, history: atomHistory, time: (globalThis.performance ?? Date).now() + 1 / timesPrecision-- };
        if (isAction2) {
          const call = state.at(-1);
          changeMsg.params = call.params, changeMsg.payload = call.payload;
        } else changeMsg.newState = state, changeMsg.oldState = oldState;
        changeMsg.patch = patch, showCause && (changeMsg.cause = getCause(patch));
      }
      log({ error: error2, changes, logs, ctx });
    } catch (error3) {
      console.error("Reatom/logger error with", logs[i2]), console.log(error3);
    }
  });
  return () => {
    ctxUnsubscribe();
  };
};
const AppFeature = {
  REFERENCE_AREA: "reference_area"
};
class ConfigRepository {
  constructor() {
    __privateAdd(this, _config);
    /* -- Intercom staff -- */
    __privateAdd(this, _readSessionIntercomSetting, (key) => sessionStorage.getItem(`kontur.intercom.${key}`));
    __privateAdd(this, _setIntercomSetting, (k2, v2) => {
      const key = `kontur.intercom.${k2}`;
      v2 ? sessionStorage.setItem(key, v2) : sessionStorage.removeItem(key);
    });
  }
  set({
    baseUrl,
    initialUrl,
    initialUrlData,
    stageConfig,
    appConfig,
    baseMapUrl,
    initialUser,
    defaultLayers,
    activeLayers
  }) {
    __privateSet(this, _config, {
      baseUrl,
      initialUrl,
      initialUrlData,
      ...stageConfig,
      ...appConfig,
      mapBaseStyle: baseMapUrl,
      features: Object.keys(appConfig.features).length > 0 ? appConfig.features : stageConfig.featuresByDefault,
      initialUser,
      defaultLayers,
      activeLayers
    });
  }
  get() {
    return __privateGet(this, _config);
  }
  getIntercomSettings() {
    return {
      intercomAppId: __privateGet(this, _config).intercomAppId,
      intercomSelector: __privateGet(this, _config).intercomSelector,
      name: __privateGet(this, _readSessionIntercomSetting).call(this, "name"),
      email: __privateGet(this, _readSessionIntercomSetting).call(this, "email"),
      phone: __privateGet(this, _readSessionIntercomSetting).call(this, "phone")
    };
  }
  updateIntercomSettings(settings) {
    Object.entries(settings).forEach(([k2, v2]) => __privateGet(this, _setIntercomSetting).call(this, k2, v2));
  }
}
_config = new WeakMap();
_readSessionIntercomSetting = new WeakMap();
_setIntercomSetting = new WeakMap();
const configRepo = new ConfigRepository();
const METRICS_EVENT = "METRICS";
function dispatchMetricsEvent(name, payload) {
  if (!globalThis.CustomEvent) return;
  const evt = new CustomEvent(METRICS_EVENT, {
    detail: {
      name,
      payload
    }
  });
  globalThis.dispatchEvent(evt);
}
class FallbackStorage {
  constructor() {
    __publicField(this, "storage", /* @__PURE__ */ new Map());
  }
  setItem(key, value2) {
    this.storage.set(key, value2);
  }
  getItem(key) {
    return this.storage.get(key);
  }
  removeItem(key) {
    this.storage.delete(key);
  }
  clear() {
    this.storage.clear();
  }
  get length() {
    return this.storage.size;
  }
  key(index2) {
    return this.storage.keys()[index2] ?? null;
  }
}
class StableStorage {
  constructor(type) {
    __publicField(this, "storage");
    if (this.storageAvailable(type)) {
      this.storage = globalThis[type];
    } else {
      this.storage = new FallbackStorage();
    }
  }
  storageAvailable(type) {
    try {
      const storage = globalThis[type];
      const x2 = "__storage_test__";
      storage.setItem(x2, x2);
      storage.removeItem(x2);
      return true;
    } catch (e) {
    }
  }
  setItem(key, value2) {
    return this.storage.setItem(key, value2);
  }
  getItem(key) {
    return this.storage.getItem(key);
  }
  get length() {
    return this.storage.length;
  }
  clear() {
    return this.storage.clear();
  }
  key(index2) {
    return this.storage.key(index2);
  }
  removeItem(key) {
    return this.storage.removeItem(key);
  }
}
new StableStorage("sessionStorage");
const localStorage$1 = new StableStorage("localStorage");
const KONTUR_DEBUG = !!localStorage$1.getItem("KONTUR_DEBUG");
!!localStorage$1.getItem("KONTUR_METRICS_DEBUG");
const KONTUR_WARN = !!localStorage$1.getItem("KONTUR_WARN");
const KONTUR_TRACE_TYPE = localStorage$1.getItem("KONTUR_TRACE_TYPE");
const KONTUR_TRACE_PATCH = !!localStorage$1.getItem("KONTUR_TRACE_PATCH");
const store = createStore({});
if (KONTUR_TRACE_PATCH) {
  connectLogger(store.v3ctx, {
    historyLength: 10,
    showCause: KONTUR_TRACE_PATCH,
    skipUnnamed: true,
    domain: "Kontur"
  });
}
store.v3ctx.subscribe((patches) => {
  patches == null ? void 0 : patches.forEach((patch) => {
    var _a2;
    const atomName = (_a2 = patch.proto) == null ? void 0 : _a2.name;
    if (atomName) {
      dispatchMetricsEvent(atomName, patch == null ? void 0 : patch.state);
      KONTUR_WARN && console.warn(atomName, patch);
      if (KONTUR_TRACE_TYPE) {
        if (atomName.includes(KONTUR_TRACE_TYPE)) {
          console.trace("TRACE:", atomName, patch);
        }
      }
    }
  });
});
const addStoreInOptions = (options) => ({
  store,
  ...typeof options === "string" ? { id: options } : options
});
const createAtom = (deps, reducer, options) => createAtom$1(deps, reducer, addStoreInOptions(options));
const createBooleanAtom = (initState, options) => o$1(initState, addStoreInOptions(options));
let count = 0;
function createSetAtom(initState = /* @__PURE__ */ new Set(), options = `set${++count}`) {
  return m$9(
    initState,
    {
      set: (state, el) => {
        if (state.has(el)) return state;
        return new Set(state).add(el);
      },
      delete: (state, el) => {
        const newState = state = new Set(state);
        if (!newState.delete(el)) return state;
        return newState;
      },
      clear: () => /* @__PURE__ */ new Set(),
      change: (state, cb) => cb(new Set(state))
    },
    addStoreInOptions(options)
  );
}
function createMapAtom(initState = /* @__PURE__ */ new Map(), options = `map${++count}`) {
  return m$9(
    initState,
    {
      set: (state, key, el) => {
        if (state.get(key) === el) return state;
        return new Map(state).set(key, el);
      },
      delete: (state, key) => {
        const newState = state = new Map(state);
        if (!newState.delete(key)) return state;
        return newState;
      },
      clear: () => /* @__PURE__ */ new Map(),
      change: (state, cb) => cb(new Map(state))
    },
    addStoreInOptions(options)
  );
}
const JSON_MIME = "application/json";
const CONTENT_TYPE_HEADER = "Content-Type";
const FETCH_ERROR = Symbol();
const CATCHER_FALLBACK = Symbol();
function extractContentType(headers = {}) {
  var _a2;
  const normalizedHeaders = headers instanceof Array ? Object.fromEntries(headers) : headers;
  return (_a2 = Object.entries(normalizedHeaders).find(([k2]) => k2.toLowerCase() === CONTENT_TYPE_HEADER.toLowerCase())) === null || _a2 === void 0 ? void 0 : _a2[1];
}
function isLikelyJsonMime(value2) {
  return /^application\/.*json.*/.test(value2);
}
const mix = function(one, two, mergeArrays = false) {
  return Object.entries(two).reduce((acc, [key, newValue]) => {
    const value2 = one[key];
    if (Array.isArray(value2) && Array.isArray(newValue)) {
      acc[key] = mergeArrays ? [...value2, ...newValue] : newValue;
    } else if (typeof value2 === "object" && typeof newValue === "object") {
      acc[key] = mix(value2, newValue, mergeArrays);
    } else {
      acc[key] = newValue;
    }
    return acc;
  }, { ...one });
};
const config$2 = {
  // Default options
  options: {},
  // Error type
  errorType: "text",
  // Polyfills
  polyfills: {
    // fetch: null,
    // FormData: null,
    // URL: null,
    // URLSearchParams: null,
    // performance: null,
    // PerformanceObserver: null,
    // AbortController: null,
  },
  polyfill(p2, doThrow = true, instance2 = false, ...args) {
    const res = this.polyfills[p2] || (typeof self !== "undefined" ? self[p2] : null) || (typeof global !== "undefined" ? global[p2] : null);
    if (doThrow && !res)
      throw new Error(p2 + " is not defined");
    return instance2 && res ? new res(...args) : res;
  }
};
function setOptions(options, replace = false) {
  config$2.options = replace ? options : mix(config$2.options, options);
}
function setPolyfills(polyfills, replace = false) {
  config$2.polyfills = replace ? polyfills : mix(config$2.polyfills, polyfills);
}
function setErrorType(errorType) {
  config$2.errorType = errorType;
}
const middlewareHelper = (middlewares) => (fetchFunction) => {
  return middlewares.reduceRight((acc, curr) => curr(acc), fetchFunction) || fetchFunction;
};
class WretchError extends Error {
}
const resolver = (wretch) => {
  const sharedState = /* @__PURE__ */ Object.create(null);
  wretch = wretch._addons.reduce((w2, addon) => addon.beforeRequest && addon.beforeRequest(w2, wretch._options, sharedState) || w2, wretch);
  const { _url: url2, _options: opts, _config: config2, _catchers, _resolvers: resolvers, _middlewares: middlewares, _addons: addons } = wretch;
  const catchers = new Map(_catchers);
  const finalOptions = mix(config2.options, opts);
  let finalUrl = url2;
  const _fetchReq = middlewareHelper(middlewares)((url3, options) => {
    finalUrl = url3;
    return config2.polyfill("fetch")(url3, options);
  })(url2, finalOptions);
  const referenceError = new Error();
  const throwingPromise = _fetchReq.catch((error2) => {
    throw { [FETCH_ERROR]: error2 };
  }).then((response) => {
    var _a2;
    if (!response.ok) {
      const err = new WretchError();
      err["cause"] = referenceError;
      err.stack = err.stack + "\nCAUSE: " + referenceError.stack;
      err.response = response;
      err.status = response.status;
      err.url = finalUrl;
      if (response.type === "opaque") {
        throw err;
      }
      const jsonErrorType = config2.errorType === "json" || ((_a2 = response.headers.get("Content-Type")) === null || _a2 === void 0 ? void 0 : _a2.split(";")[0]) === "application/json";
      const bodyPromise = !config2.errorType ? Promise.resolve(response.body) : jsonErrorType ? response.text() : response[config2.errorType]();
      return bodyPromise.then((body) => {
        err.message = typeof body === "string" ? body : response.statusText;
        if (body) {
          if (jsonErrorType && typeof body === "string") {
            err.text = body;
            err.json = JSON.parse(body);
          } else {
            err[config2.errorType] = body;
          }
        }
        throw err;
      });
    }
    return response;
  });
  const catchersWrapper = (promise) => {
    return promise.catch((err) => {
      const fetchErrorFlag = Object.prototype.hasOwnProperty.call(err, FETCH_ERROR);
      const error2 = fetchErrorFlag ? err[FETCH_ERROR] : err;
      const catcher = (error2 === null || error2 === void 0 ? void 0 : error2.status) && catchers.get(error2.status) || catchers.get(error2 === null || error2 === void 0 ? void 0 : error2.name) || fetchErrorFlag && catchers.has(FETCH_ERROR) && catchers.get(FETCH_ERROR);
      if (catcher)
        return catcher(error2, wretch);
      const catcherFallback = catchers.get(CATCHER_FALLBACK);
      if (catcherFallback)
        return catcherFallback(error2, wretch);
      throw error2;
    });
  };
  const bodyParser = (funName) => (cb) => funName ? (
    // If a callback is provided, then callback with the body result otherwise return the parsed body itself.
    catchersWrapper(throwingPromise.then((_2) => _2 && _2[funName]()).then((_2) => cb ? cb(_2) : _2))
  ) : (
    // No body parsing method - return the response
    catchersWrapper(throwingPromise.then((_2) => cb ? cb(_2) : _2))
  );
  const responseChain = {
    _wretchReq: wretch,
    _fetchReq,
    _sharedState: sharedState,
    res: bodyParser(null),
    json: bodyParser("json"),
    blob: bodyParser("blob"),
    formData: bodyParser("formData"),
    arrayBuffer: bodyParser("arrayBuffer"),
    text: bodyParser("text"),
    error(errorId, cb) {
      catchers.set(errorId, cb);
      return this;
    },
    badRequest(cb) {
      return this.error(400, cb);
    },
    unauthorized(cb) {
      return this.error(401, cb);
    },
    forbidden(cb) {
      return this.error(403, cb);
    },
    notFound(cb) {
      return this.error(404, cb);
    },
    timeout(cb) {
      return this.error(408, cb);
    },
    internalError(cb) {
      return this.error(500, cb);
    },
    fetchError(cb) {
      return this.error(FETCH_ERROR, cb);
    }
  };
  const enhancedResponseChain = addons.reduce((chain, addon) => ({
    ...chain,
    ...typeof addon.resolver === "function" ? addon.resolver(chain) : addon.resolver
  }), responseChain);
  return resolvers.reduce((chain, r2) => r2(chain, wretch), enhancedResponseChain);
};
const core = {
  _url: "",
  _options: {},
  _config: config$2,
  _catchers: /* @__PURE__ */ new Map(),
  _resolvers: [],
  _deferred: [],
  _middlewares: [],
  _addons: [],
  addon(addon) {
    return { ...this, _addons: [...this._addons, addon], ...addon.wretch };
  },
  errorType(errorType) {
    return {
      ...this,
      _config: {
        ...this._config,
        errorType
      }
    };
  },
  polyfills(polyfills, replace = false) {
    return {
      ...this,
      _config: {
        ...this._config,
        polyfills: replace ? polyfills : mix(this._config.polyfills, polyfills)
      }
    };
  },
  url(_url, replace = false) {
    if (replace)
      return { ...this, _url };
    const split = this._url.split("?");
    return {
      ...this,
      _url: split.length > 1 ? split[0] + _url + "?" + split[1] : this._url + _url
    };
  },
  options(options, replace = false) {
    return { ...this, _options: replace ? options : mix(this._options, options) };
  },
  headers(headerValues) {
    const headers = !headerValues ? {} : Array.isArray(headerValues) ? Object.fromEntries(headerValues) : "entries" in headerValues ? Object.fromEntries(headerValues.entries()) : headerValues;
    return { ...this, _options: mix(this._options, { headers }) };
  },
  accept(headerValue) {
    return this.headers({ Accept: headerValue });
  },
  content(headerValue) {
    return this.headers({ [CONTENT_TYPE_HEADER]: headerValue });
  },
  auth(headerValue) {
    return this.headers({ Authorization: headerValue });
  },
  catcher(errorId, catcher) {
    const newMap = new Map(this._catchers);
    newMap.set(errorId, catcher);
    return { ...this, _catchers: newMap };
  },
  catcherFallback(catcher) {
    return this.catcher(CATCHER_FALLBACK, catcher);
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  resolve(resolver2, clear = false) {
    return { ...this, _resolvers: clear ? [resolver2] : [...this._resolvers, resolver2] };
  },
  defer(callback, clear = false) {
    return {
      ...this,
      _deferred: clear ? [callback] : [...this._deferred, callback]
    };
  },
  middlewares(middlewares, clear = false) {
    return {
      ...this,
      _middlewares: clear ? middlewares : [...this._middlewares, ...middlewares]
    };
  },
  fetch(method = this._options.method, url2 = "", body = null) {
    let base = this.url(url2).options({ method });
    const contentType = extractContentType(base._options.headers);
    const formDataClass = this._config.polyfill("FormData", false);
    const jsonify = typeof body === "object" && !(formDataClass && body instanceof formDataClass) && (!base._options.headers || !contentType || isLikelyJsonMime(contentType));
    base = !body ? base : jsonify ? base.json(body, contentType) : base.body(body);
    return resolver(base._deferred.reduce((acc, curr) => curr(acc, acc._url, acc._options), base));
  },
  get(url2 = "") {
    return this.fetch("GET", url2);
  },
  delete(url2 = "") {
    return this.fetch("DELETE", url2);
  },
  put(body, url2 = "") {
    return this.fetch("PUT", url2, body);
  },
  post(body, url2 = "") {
    return this.fetch("POST", url2, body);
  },
  patch(body, url2 = "") {
    return this.fetch("PATCH", url2, body);
  },
  head(url2 = "") {
    return this.fetch("HEAD", url2);
  },
  opts(url2 = "") {
    return this.fetch("OPTIONS", url2);
  },
  body(contents) {
    return { ...this, _options: { ...this._options, body: contents } };
  },
  json(jsObject, contentType) {
    const currentContentType = extractContentType(this._options.headers);
    return this.content(contentType || isLikelyJsonMime(currentContentType) && currentContentType || JSON_MIME).body(JSON.stringify(jsObject));
  }
};
function factory(_url = "", _options = {}) {
  return { ...core, _url, _options };
}
factory["default"] = factory;
factory.options = setOptions;
factory.errorType = setErrorType;
factory.polyfills = setPolyfills;
factory.WretchError = WretchError;
function stringify(value2) {
  return typeof value2 !== "undefined" ? value2 : "";
}
const appendQueryParams = (url2, qp, replace, omitUndefinedOrNullValues, config2) => {
  let queryString2;
  if (typeof qp === "string") {
    queryString2 = qp;
  } else {
    const usp = config2.polyfill("URLSearchParams", true, true);
    for (const key in qp) {
      const value2 = qp[key];
      if (omitUndefinedOrNullValues && (value2 === null || value2 === void 0))
        continue;
      if (qp[key] instanceof Array) {
        for (const val of value2)
          usp.append(key, stringify(val));
      } else {
        usp.append(key, stringify(value2));
      }
    }
    queryString2 = usp.toString();
  }
  const split = url2.split("?");
  if (!queryString2)
    return replace ? split[0] : url2;
  if (replace || split.length < 2)
    return split[0] + "?" + queryString2;
  return url2 + "&" + queryString2;
};
const queryString = {
  wretch: {
    query(qp, replace = false, omitUndefinedOrNullValues = false) {
      return { ...this, _url: appendQueryParams(this._url, qp, replace, omitUndefinedOrNullValues, this._config) };
    }
  }
};
const AUTH_REQUIREMENT = {
  MUST: "must",
  OPTIONAL: "optional",
  NEVER: "never"
};
const wait = (sec = 1, opt = {}) => new Promise(
  (res, rej) => setTimeout(
    (opt == null ? void 0 : opt.failWithMessage) ? () => rej({ message: opt.failWithMessage }) : res,
    sec * 1e3
  )
);
class ApiClientError extends Error {
  constructor(message, problem, status = 0) {
    super(message);
    __publicField(this, "problem");
    __publicField(this, "status", 0);
    this.problem = problem;
    this.status = status;
    Object.setPrototypeOf(this, ApiClientError.prototype);
  }
}
function isApiError(error2) {
  return error2 instanceof ApiClientError;
}
function getApiErrorKind(error2) {
  return isApiError(error2) ? error2.problem.kind : null;
}
const ABORT_ERROR_MESSAGE = "Abort error";
const isAbortError = (e) => {
  if (!e) return false;
  if (typeof e === "string") {
    return e === ABORT_ERROR_MESSAGE;
  }
  if (isApiError(e)) {
    return e.problem.kind === "canceled";
  } else if (e instanceof DOMException) {
    return e.name === "AbortError";
  }
  return false;
};
async function abortable(abortController, promise) {
  return new Promise((res, rej) => {
    if (abortController.signal.aborted) {
      rej(new DOMException("Aborted", "AbortError"));
    }
    const onAbort = () => {
      abortController.signal.removeEventListener("abort", onAbort);
      rej(new DOMException("Aborted", "AbortError"));
    };
    abortController.signal.addEventListener("abort", onAbort);
    promise.then(res).catch(rej).finally(() => abortController.signal.removeEventListener("abort", onAbort));
  });
}
function parseApiError(errorObj) {
  var _a2;
  if (errorObj == null ? void 0 : errorObj.json) {
    const errorData = errorObj == null ? void 0 : errorObj.json;
    if (errorData == null ? void 0 : errorData.message) return errorData.message;
    if (errorData == null ? void 0 : errorData.error_description) return errorData.error_description;
    if (errorData !== null) {
      if (Array.isArray(errorData)) {
        return errorData.map(
          (errorMsg) => errorMsg.name && errorMsg.message ? `${errorMsg.name}: ${errorMsg.message}` : errorMsg
        ).join("<br/>");
      }
      if (errorData == null ? void 0 : errorData.error) return errorData["error"];
      if ((errorData == null ? void 0 : errorData.errors) && Array.isArray(errorData["errors"])) {
        return errorData["errors"].reduce((acc, errorObj2) => {
          if (errorObj2 == null ? void 0 : errorObj2.message) {
            acc.push(errorObj2["message"]);
          }
          return acc;
        }, []).join("<br/>");
      }
    }
    return String(errorData);
  }
  let res = ((_a2 = errorObj == null ? void 0 : errorObj.response) == null ? void 0 : _a2.statusText) ?? (errorObj == null ? void 0 : errorObj.message) ?? (errorObj == null ? void 0 : errorObj.text);
  if (res == null ? void 0 : res.startsWith("<html>")) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(res, "text/html");
    const title2 = doc.querySelector("title");
    res = title2 == null ? void 0 : title2.innerText;
  }
  return res ?? "Unknown Error";
}
function createApiError(err) {
  var _a2, _b;
  let errorMessage = "";
  let problem = { kind: "unknown", temporary: true };
  let status = 0;
  if (err instanceof ApiClientError) {
    return err;
  }
  if (KONTUR_DEBUG) {
    console.error("Raw error:", err);
  }
  if (err instanceof DOMException && err.name === "AbortError" || err instanceof factory.WretchError && err.name === "AbortError" || err instanceof factory.WretchError && err.cause instanceof DOMException && err.cause.name === "AbortError" || err instanceof factory.WretchError && err.message === "The operation was aborted" || err instanceof Error && err.name === "AbortError") {
    problem = { kind: "canceled" };
  } else if (err instanceof factory.WretchError) {
    status = err.status;
    if (status === 400) {
      problem = { kind: "bad-request" };
    } else if (status === 401) {
      problem = { kind: "unauthorized", data: (_a2 = err.json) == null ? void 0 : _a2.error };
      if ((_b = err.json) == null ? void 0 : _b.message) {
        errorMessage = err.json.message;
      }
    } else if (status === 403) {
      problem = { kind: "forbidden" };
    } else if (status === 404) {
      problem = { kind: "not-found" };
    } else if (status === 408 || status === 504) {
      errorMessage = "Server not available, please try later";
      problem = { kind: "timeout", temporary: true };
    } else if (status >= 500) {
      problem = { kind: "server", data: (err == null ? void 0 : err.json) ?? (err == null ? void 0 : err.text) };
    }
  } else {
    problem = { kind: "client-unknown" };
  }
  if (!errorMessage) {
    errorMessage = parseApiError(err);
  }
  return new ApiClientError(errorMessage || "Unknown error", problem, status);
}
const ApiMethodTypes = {
  GET: "get",
  POST: "post",
  PUT: "put",
  PATCH: "patch",
  DELETE: "delete"
};
async function autoParseBody(res) {
  if (res.status === 204) {
    res.data = null;
    return res;
  }
  if (res.ok) {
    const contentType = res.headers.get("content-type") ?? "";
    if (contentType.includes("application/json")) {
      res.data = await res.json();
    } else {
      res.data = await res.text();
    }
  }
  return res;
}
class ApiClient {
  constructor({ on } = {}) {
    __publicField(this, "AUTH_REQUIREMENT", AUTH_REQUIREMENT);
    __publicField(this, "listeners", {
      error: /* @__PURE__ */ new Set(),
      poolUpdate: /* @__PURE__ */ new Set(),
      idle: /* @__PURE__ */ new Set()
    });
    __publicField(this, "baseURL");
    __publicField(this, "requestPool", /* @__PURE__ */ new Map());
    __publicField(this, "authService");
    if (on) {
      Object.entries(on).forEach(
        ([event, cb]) => {
          if (cb) this.on(event, cb);
        }
      );
    }
  }
  on(event, cb) {
    this.listeners[event].add(cb);
    return () => {
      this.listeners[event].delete(cb);
    };
  }
  _emit(type, payload) {
    this.listeners[type].forEach((l2) => l2(payload));
  }
  init(cfg) {
    let baseURL = cfg.baseUrl ?? "";
    this.baseURL = baseURL;
  }
  updateRequestPool(requestId, status) {
    if (status === null) {
      this.requestPool.delete(requestId);
    } else {
      this.requestPool.set(requestId, status);
    }
    this._emit("poolUpdate", new Map(this.requestPool));
    this._emit("idle", this.requestPool.size === 0);
  }
  /**
   * Makes an HTTP request with configurable authentication behavior
   * @template T - The expected response type
   * @param {ApiMethod} method - HTTP method to use
   * @param {string} path - Request URL or path
   * @param {unknown} [requestParams] - Query parameters or body data
   * @param {CustomRequestConfig} [requestConfig] - Additional request configuration
   * @param {AuthRequirement} [requestConfig.authRequirement] - Authentication requirement level:
   *   - MUST: Request will fail if user is not authenticated
   *   - OPTIONAL (default): Will attempt to use auth if available, but proceed without if not possible
   *   - NEVER: Explicitly prevents authentication
   * @returns {Promise<T | null>} The response data
   * @throws {ApiClientError} On request failure or auth requirement not met
   */
  async call(method, path2, requestParams, requestConfig = {}) {
    var _a2;
    const RequestsWithBody = ["post", "put", "patch"];
    const requestId = Math.random().toString(36).substring(7);
    this.updateRequestPool(requestId, "pending");
    const { origin, pathname, search: search2 } = path2.startsWith("http") ? new URL(path2) : {
      origin: this.baseURL,
      pathname: path2,
      search: ""
    };
    let req = factory(origin, { mode: "cors" }).addon(queryString).url(pathname + search2);
    if (requestConfig.signal) {
      req = req.options({ signal: requestConfig.signal });
    }
    if (requestConfig.headers) {
      req = req.headers(requestConfig.headers);
    }
    let isAuthenticatedRequest = false;
    const authRequirement = requestConfig.authRequirement ?? AUTH_REQUIREMENT.OPTIONAL;
    if (authRequirement !== AUTH_REQUIREMENT.NEVER) {
      try {
        const requireAuth = authRequirement === AUTH_REQUIREMENT.MUST;
        const token = await this.authService.getAccessToken(requireAuth);
        if (token) {
          isAuthenticatedRequest = true;
          req = req.auth(`Bearer ${token}`);
        }
      } catch (error2) {
        if (authRequirement === AUTH_REQUIREMENT.OPTIONAL) {
          console.warn("Authentication failed but proceeding with request:", error2);
        } else {
          throw error2;
        }
      }
    }
    if (requestParams) {
      req = RequestsWithBody.includes(method) ? req.json(requestParams) : req.query(requestParams);
    }
    try {
      const response = await req[method]().res(autoParseBody);
      this.updateRequestPool(requestId, null);
      return response.data;
    } catch (err) {
      this.updateRequestPool(requestId, null);
      const apiError = createApiError(err);
      if (getApiErrorKind(apiError) === "canceled") {
        throw apiError;
      }
      if (isAuthenticatedRequest && getApiErrorKind(apiError) === "unauthorized") {
        try {
          const token = await this.authService.getAccessToken();
          if (!token) {
            throw apiError;
          }
        } catch (error2) {
          throw apiError;
        }
        throw apiError;
      }
      const defaultRetryConfig = {
        attempts: 0,
        delayMs: 1e3,
        onErrorKinds: ["timeout"]
      };
      const retryConfig = {
        ...defaultRetryConfig,
        ...requestConfig.retry,
        onErrorKinds: ((_a2 = requestConfig.retry) == null ? void 0 : _a2.onErrorKinds) ?? defaultRetryConfig.onErrorKinds
      };
      if (retryConfig.attempts > 0) {
        const shouldRetry = retryConfig.onErrorKinds.includes(
          getApiErrorKind(apiError)
        );
        if (shouldRetry) {
          if (retryConfig.delayMs) {
            await wait(retryConfig.delayMs / 1e3);
          }
          return this.call(method, path2, requestParams, {
            ...requestConfig,
            retry: {
              ...retryConfig,
              attempts: retryConfig.attempts - 1
            }
          });
        }
      }
      const errorsConfig = requestConfig.errorsConfig;
      if (errorsConfig && errorsConfig.messages) {
        if (typeof errorsConfig.messages !== "string") {
          if (apiError.status in errorsConfig.messages) {
            apiError.message = errorsConfig.messages[apiError.status];
          }
        } else {
          apiError.message = errorsConfig.messages;
        }
      }
      if ((errorsConfig == null ? void 0 : errorsConfig.hideErrors) !== true) {
        this._emit("error", apiError);
      }
      throw apiError;
    }
  }
  // method shortcuts
  async get(path2, requestParams, requestConfig) {
    return this.call(ApiMethodTypes.GET, path2, requestParams, requestConfig);
  }
  async post(path2, requestParams, requestConfig) {
    return this.call(ApiMethodTypes.POST, path2, requestParams, requestConfig);
  }
  async put(path2, requestParams, requestConfig) {
    return this.call(ApiMethodTypes.PUT, path2, requestParams, requestConfig);
  }
  async patch(path2, requestParams, requestConfig) {
    return this.call(ApiMethodTypes.PATCH, path2, requestParams, requestConfig);
  }
  async delete(path2, requestConfig) {
    return this.call(ApiMethodTypes.DELETE, path2, void 0, requestConfig);
  }
}
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let nanoid = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
};
const currentNotificationAtom = createAtom(
  {
    showNotification: (type, message, lifetimeSec) => ({ type, message, lifetimeSec }),
    removeNotification: (id) => id
  },
  ({ onAction, schedule, create: create2 }, state = []) => {
    onAction("showNotification", ({ type, message, lifetimeSec }) => {
      const id = nanoid(4);
      const onClose = () => currentNotificationAtom.removeNotification.dispatch(id);
      state = [...state, { id, type, message, lifetimeSec, onClose }];
      schedule((dispatch) => {
        setTimeout(onClose, lifetimeSec * 1e3);
      });
    });
    onAction(
      "removeNotification",
      (idToDelete) => state = state.filter(({ id }) => id !== idToDelete)
    );
    return [...state];
  },
  "[Shared state] currentNotificationAtom"
);
const _NotificationService = class _NotificationService {
  constructor() {
    __publicField(this, "defaultLifetimeSec", 10);
  }
  static getInstance() {
    if (!_NotificationService.instance) {
      throw new Error("You have to initialize api client first!");
    } else {
      return _NotificationService.instance;
    }
  }
  static init() {
    _NotificationService.instance = new _NotificationService();
  }
  error(message, lifetimeSec) {
    currentNotificationAtom.showNotification.dispatch(
      "error",
      message,
      lifetimeSec || this.defaultLifetimeSec
    );
  }
  warning(message, lifetimeSec) {
    currentNotificationAtom.showNotification.dispatch(
      "warning",
      message,
      lifetimeSec || this.defaultLifetimeSec
    );
  }
  info(message, lifetimeSec) {
    currentNotificationAtom.showNotification.dispatch(
      "info",
      message,
      lifetimeSec || this.defaultLifetimeSec
    );
  }
  success(message, lifetimeSec) {
    currentNotificationAtom.showNotification.dispatch(
      "success",
      message,
      lifetimeSec || this.defaultLifetimeSec
    );
  }
};
__publicField(_NotificationService, "instance");
let NotificationService = _NotificationService;
NotificationService.init();
const notificationServiceInstance = NotificationService.getInstance();
const apiClient = new ApiClient({
  on: {
    error: (error2) => {
      switch (error2.problem.kind) {
        default:
          notificationServiceInstance.error({
            title: "Error",
            description: error2.message
          });
      }
    },
    idle: () => dispatchMetricsEvent("apiClient_isIdle")
  }
});
new ApiClient({
  on: {
    error: (error2) => {
      switch (error2.problem.kind) {
        default:
          notificationServiceInstance.error({
            title: "Error",
            description: error2.message
          });
      }
    },
    idle: () => dispatchMetricsEvent("reportsClient_isIdle")
  }
});
async function getCurrentUserSubscription() {
  return await apiClient.get(
    "/users/current_user/billing_subscription",
    { appId: configRepo.get().id },
    { authRequirement: apiClient.AUTH_REQUIREMENT.MUST }
  );
}
reatomResource(async () => {
  return await getCurrentUserSubscription();
}, "currentUserSubscriptionResource").pipe(withDataAtom(), withCache());
createBooleanAtom(false, "intercomVisibleAtom");
function openIntercomChat() {
  if (globalThis.Intercom && globalThis.intercomSettings) {
    globalThis.Intercom("showMessages");
  } else {
    console.warn("Intercom is not available");
  }
}
function isExternalLink(href) {
  const externalProtocols = ["http://", "https://", "mailto:", "ftp://", "tel:"];
  return externalProtocols.some((protocol) => href.startsWith(protocol));
}
function isInnerAnchorLink(href) {
  return href.startsWith("#");
}
const MEDIA_PARAMS_SEPARATOR = "::";
const MEDIA_PARAMS_DELIMITER = ",";
function parseMediaParams(url2) {
  const parts = url2.split(MEDIA_PARAMS_SEPARATOR);
  if (parts.length !== 2) return { originalUrl: url2, params: null };
  const [width, height, fullscreen] = parts[1].split(MEDIA_PARAMS_DELIMITER);
  return {
    originalUrl: parts[0],
    params: {
      ...width && { width: parseInt(width) },
      ...height && { height: parseInt(height) },
      ...fullscreen !== void 0 && { allowFullscreen: fullscreen === "1" }
    }
  };
}
const YOUTUBE_DOMAINS = ["youtube.com", "youtu.be"];
const isYoutubeUrl = (url2) => {
  try {
    const parsedUrl = new URL(url2);
    return YOUTUBE_DOMAINS.some((domain) => parsedUrl.hostname.endsWith(domain));
  } catch {
    return false;
  }
};
function getYoutubeEmbedUrl(url2) {
  try {
    const parsedUrl = new URL(url2);
    let videoId = null;
    if (parsedUrl.hostname.includes("youtu.be")) {
      videoId = parsedUrl.pathname.slice(1);
    } else {
      if (parsedUrl.pathname.includes("shorts")) {
        videoId = parsedUrl.pathname.split("/shorts/")[1];
      } else if (parsedUrl.pathname.includes("embed")) {
        videoId = parsedUrl.pathname.split("/embed/")[1];
      } else {
        videoId = parsedUrl.searchParams.get("v");
      }
    }
    return videoId ? `https://www.youtube.com/embed/${videoId}` : url2;
  } catch {
    return url2;
  }
}
const appProtocolHandlers = {
  intercom: () => openIntercomChat()
  // Add more handlers here:
  // someCommand: (url) => { /* handle someCommand */ },
};
function handleAppProtocol(url2) {
  const handler = appProtocolHandlers[url2.hostname];
  if (handler) {
    handler(url2);
    return true;
  }
  console.warn(`Unknown app protocol handler: ${url2.hostname}`);
  return false;
}
function MarkdownLink({
  children,
  href,
  title: title2
}) {
  const handleClick = reactExports.useCallback(
    (e) => {
      if (isInnerAnchorLink(href)) {
        return;
      }
      try {
        const url2 = new URL(href);
        if (url2.protocol === "app:") {
          handleAppProtocol(url2);
          e.preventDefault();
          return;
        }
      } catch {
      }
      goTo(href);
      e.preventDefault();
    },
    [href]
  );
  if (isExternalLink(href)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("a", { title: title2, href, target: "_blank", rel: "noreferrer", className: "external", children });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("a", { title: title2, href, onClick: handleClick, className: "internal", children });
}
function buildAssetUrl(asset) {
  return `${configRepo.get().apiGateway}/apps/${configRepo.get().id}/assets/${asset}`;
}
function MarkdownMedia({
  title: title2,
  alt,
  src
}) {
  const { originalUrl, params } = parseMediaParams(src);
  if (isYoutubeUrl(originalUrl)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "iframe",
      {
        src: getYoutubeEmbedUrl(originalUrl),
        width: (params == null ? void 0 : params.width) || 560,
        height: (params == null ? void 0 : params.height) || 315,
        title: title2 || alt || "YouTube video player",
        frameBorder: "0",
        allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
        allowFullScreen: (params == null ? void 0 : params.allowFullscreen) ?? true,
        referrerPolicy: "strict-origin-when-cross-origin"
      }
    );
  }
  let realSrc = originalUrl;
  if (!isExternalLink(originalUrl)) {
    realSrc = buildAssetUrl(originalUrl);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: realSrc,
      alt,
      title: title2,
      ...(params == null ? void 0 : params.width) && { width: params.width },
      ...(params == null ? void 0 : params.height) && { height: params.height }
    }
  );
}
function wrapContentInSection(content, idPrefix, classPrefix) {
  const result2 = [];
  const stack2 = [];
  let keyCounter = 0;
  const parentCounters = /* @__PURE__ */ new Map();
  const wrapAndPushContent = (level) => {
    while (stack2.length > 0 && stack2[stack2.length - 1].level >= level) {
      const { level: stackLevel, content: content2, id } = stack2.pop();
      if (content2.length > 0) {
        const wrappedContent = React.createElement(
          "div",
          {
            className: `${classPrefix}-${id}`,
            key: `div-h${stackLevel}-${++keyCounter}`
          },
          content2
        );
        if (stack2.length > 0) {
          stack2[stack2.length - 1].content.push(wrappedContent);
        } else {
          result2.push(wrappedContent);
        }
      }
    }
  };
  const processElement = (element) => {
    const headingMatch = element.type.toString().match(/^h([1-6])$/);
    if (headingMatch) {
      const level = Number.parseInt(headingMatch[1]);
      wrapAndPushContent(level);
      const parentId = stack2.length > 0 ? stack2[stack2.length - 1].id : "";
      const currentCount = (parentCounters.get(parentId) || 0) + 1;
      parentCounters.set(parentId, currentCount);
      const fullId = parentId ? `${parentId}-${currentCount}` : `${idPrefix}-${currentCount}`;
      const clonedElement = React.cloneElement(element, {
        key: `heading-${++keyCounter}`,
        id: fullId
      });
      if (stack2.length > 0 && level > stack2[stack2.length - 1].level) {
        stack2[stack2.length - 1].content.push(clonedElement);
      } else {
        result2.push(clonedElement);
      }
      stack2.push({ level, content: [], id: fullId });
    } else {
      const clonedElement = React.cloneElement(element, {
        key: `content-${++keyCounter}`
      });
      if (stack2.length > 0) {
        stack2[stack2.length - 1].content.push(clonedElement);
      } else {
        result2.push(clonedElement);
      }
    }
  };
  React.Children.forEach(content, (element) => {
    if (React.isValidElement(element)) {
      processElement(element);
    }
  });
  wrapAndPushContent(0);
  return result2;
}
function splitIntoSections(compiled) {
  const sections = [];
  let currentSection = [];
  React.Children.forEach(compiled, (element) => {
    if (React.isValidElement(element) && element.type === "hr") {
      if (currentSection.length > 0) {
        sections.push(currentSection);
        currentSection = [];
      }
    } else {
      currentSection.push(element);
    }
  });
  if (currentSection.length > 0) {
    sections.push(currentSection);
  }
  return sections;
}
function structureMarkdownContent(compiled, idPrefix = "hdr", classPrefix = "wrap") {
  const sections = splitIntoSections(compiled);
  return sections.map(
    (section, index2) => React.createElement(
      "section",
      { key: `section-${index2}` },
      wrapContentInSection(section, idPrefix, classPrefix)
    )
  );
}
const markdownOptions = {
  overrides: {
    a: MarkdownLink,
    img: MarkdownMedia,
    h1: { props: { id: void 0 } },
    h2: { props: { id: void 0 } },
    h3: { props: { id: void 0 } },
    h4: { props: { id: void 0 } },
    h5: { props: { id: void 0 } },
    h6: { props: { id: void 0 } }
  },
  wrapper: null
};
function MarkdownContent({ content }) {
  const compiled = Xe(content, markdownOptions);
  return structureMarkdownContent(compiled);
}
var fastDeepEqual;
var hasRequiredFastDeepEqual;
function requireFastDeepEqual() {
  if (hasRequiredFastDeepEqual) return fastDeepEqual;
  hasRequiredFastDeepEqual = 1;
  var isArray = Array.isArray;
  var keyList = Object.keys;
  var hasProp = Object.prototype.hasOwnProperty;
  fastDeepEqual = function equal2(a2, b2) {
    if (a2 === b2) return true;
    if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
      var arrA = isArray(a2), arrB = isArray(b2), i2, length, key;
      if (arrA && arrB) {
        length = a2.length;
        if (length != b2.length) return false;
        for (i2 = length; i2-- !== 0; )
          if (!equal2(a2[i2], b2[i2])) return false;
        return true;
      }
      if (arrA != arrB) return false;
      var dateA = a2 instanceof Date, dateB = b2 instanceof Date;
      if (dateA != dateB) return false;
      if (dateA && dateB) return a2.getTime() == b2.getTime();
      var regexpA = a2 instanceof RegExp, regexpB = b2 instanceof RegExp;
      if (regexpA != regexpB) return false;
      if (regexpA && regexpB) return a2.toString() == b2.toString();
      var keys = keyList(a2);
      length = keys.length;
      if (length !== keyList(b2).length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!hasProp.call(b2, keys[i2])) return false;
      for (i2 = length; i2-- !== 0; ) {
        key = keys[i2];
        if (!equal2(a2[key], b2[key])) return false;
      }
      return true;
    }
    return a2 !== a2 && b2 !== b2;
  };
  return fastDeepEqual;
}
var build;
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1;
  var __values = build && build.__values || function(o2) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
    if (m2) return m2.call(o2);
    if (o2 && typeof o2.length === "number") return {
      next: function() {
        if (o2 && i2 >= o2.length) o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = build && build.__read || function(o2, n2) {
    var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m2) return o2;
    var i2 = m2.call(o2), r2, ar = [], e;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = build && build.__spreadArray || function(to2, from, pack) {
    if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
    return to2.concat(ar || Array.prototype.slice.call(from));
  };
  var deepEqual2 = requireFastDeepEqual();
  var promiseCaches = [];
  var usePromise2 = function(promise, inputs, lifespan) {
    var e_1, _a2;
    if (lifespan === void 0) {
      lifespan = 0;
    }
    try {
      for (var promiseCaches_1 = __values(promiseCaches), promiseCaches_1_1 = promiseCaches_1.next(); !promiseCaches_1_1.done; promiseCaches_1_1 = promiseCaches_1.next()) {
        var promiseCache_1 = promiseCaches_1_1.value;
        if (deepEqual2(inputs, promiseCache_1.inputs)) {
          if (Object.prototype.hasOwnProperty.call(promiseCache_1, "error")) {
            throw promiseCache_1.error;
          } else if (Object.prototype.hasOwnProperty.call(promiseCache_1, "response")) {
            return promiseCache_1.response;
          }
          throw promiseCache_1.promise;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (promiseCaches_1_1 && !promiseCaches_1_1.done && (_a2 = promiseCaches_1.return)) _a2.call(promiseCaches_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    var promiseCache = {
      promise: promise.apply(void 0, __spreadArray([], __read(inputs), false)).then(function(response) {
        promiseCache.response = response;
      }).catch(function(e) {
        promiseCache.error = e;
      }).then(function() {
        if (lifespan > 0) {
          setTimeout(function() {
            var index2 = promiseCaches.indexOf(promiseCache);
            if (index2 !== -1) {
              promiseCaches.splice(index2, 1);
            }
          }, lifespan);
        }
      }),
      inputs
    };
    promiseCaches.push(promiseCache);
    throw promiseCache.promise;
  };
  build = usePromise2;
  return build;
}
var buildExports = requireBuild();
const usePromise = /* @__PURE__ */ getDefaultExportFromCjs(buildExports);
const article = "_article_b9f5o_1";
const s$l = {
  article
};
function Article({
  children,
  className = "",
  id = ""
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("article", { className: `${s$l.article} ${className}`, id, children });
}
const isString = (obj) => typeof obj === "string";
const defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
const makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
const copy = (a2, s2, t2) => {
  a2.forEach((m2) => {
    if (s2[m2]) t2[m2] = s2[m2];
  });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
const canNotTraverseDeeper = (object) => !object || isString(object);
const getLastOfPath = (object, path2, Empty) => {
  const stack2 = !isString(path2) ? path2 : path2.split(".");
  let stackIndex = 0;
  while (stackIndex < stack2.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack2[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack2[stackIndex])
  };
};
const setPath = (object, path2, newValue) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path2, Object);
  if (obj !== void 0 || path2.length === 1) {
    obj[k2] = newValue;
    return;
  }
  let e = path2[path2.length - 1];
  let p2 = path2.slice(0, path2.length - 1);
  let last2 = getLastOfPath(object, p2, Object);
  while (last2.obj === void 0 && p2.length) {
    e = `${p2[p2.length - 1]}.${e}`;
    p2 = p2.slice(0, p2.length - 1);
    last2 = getLastOfPath(object, p2, Object);
    if (last2 && last2.obj && typeof last2.obj[`${last2.k}.${e}`] !== "undefined") {
      last2.obj = void 0;
    }
  }
  last2.obj[`${last2.k}.${e}`] = newValue;
};
const pushPath = (object, path2, newValue, concat2) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path2, Object);
  obj[k2] = obj[k2] || [];
  obj[k2].push(newValue);
};
const getPath = (object, path2) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path2);
  if (!obj) return void 0;
  return obj[k2];
};
const getPathWithDefaults = (data, defaultData, key) => {
  const value2 = getPath(data, key);
  if (value2 !== void 0) {
    return value2;
  }
  return getPath(defaultData, key);
};
const deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
const regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const escape = (data) => {
  if (isString(data)) {
    return data.replace(/[&<>"'\/]/g, (s2) => _entityMap[s2]);
  }
  return data;
};
class RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
}
const chars = [" ", ",", "?", "!", ";"];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c2) => nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0);
  if (possibleChars.length === 0) return true;
  const r2 = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c2) => c2 === "?" ? "\\?" : c2).join("|")})`);
  let matched = !r2.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r2.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
const deepFind = function(obj, path2) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return void 0;
  if (obj[path2]) return obj[path2];
  const tokens = path2.split(keySeparator);
  let current = obj;
  for (let i2 = 0; i2 < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j2 = i2; j2 < tokens.length; ++j2) {
      if (j2 !== i2) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j2];
      next = current[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j2 < tokens.length - 1) {
          continue;
        }
        i2 += j2 - i2 + 1;
        break;
      }
    }
    current = next;
  }
  return current;
};
const getCleanedCode = (code) => code && code.replace("_", "-");
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    if (console && console[type]) console[type].apply(console, args);
  }
};
class Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
}
var baseLogger = new Logger();
class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach((_ref) => {
        let [observer, numTimesAdded] = _ref;
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
}
class ResourceStore extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index2 = this.options.ns.indexOf(ns);
    if (index2 > -1) {
      this.options.ns.splice(index2, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path2;
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
    } else {
      path2 = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path2.push(...key);
        } else if (isString(key) && keySeparator) {
          path2.push(...key.split(keySeparator));
        } else {
          path2.push(key);
        }
      }
    }
    const result2 = getPath(this.data, path2);
    if (!result2 && !ns && !key && lng.indexOf(".") > -1) {
      lng = path2[0];
      ns = path2[1];
      key = path2.slice(2).join(".");
    }
    if (result2 || !ignoreJSONStructure || !isString(key)) return result2;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value2) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path2 = [lng, ns];
    if (key) path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      value2 = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path2, value2);
    if (!options.silent) this.emit("added", lng, ns, key, value2);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m2 in resources) {
      if (isString(resources[m2]) || Array.isArray(resources[m2])) this.addResource(lng, ns, m2, resources[m2], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path2 = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path2) || {};
    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path2, pack);
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1") return {
      ...{},
      ...this.getResource(lng, ns)
    };
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n2 = data && Object.keys(data) || [];
    return !!n2.find((v2) => data[v2] && Object.keys(data[v2]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value2, key, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor]) value2 = this.processors[processor].process(value2, key, options, translator);
    });
    return value2;
  }
};
const checkedLoadedFor = {};
class Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved2 = this.resolve(key, options);
    return resolved2 && resolved2.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m2 = key.match(this.interpolator.nestingRegexp);
      if (m2 && m2.length > 0) {
        return {
          key,
          namespaces: isString(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object") options = {
      ...options
    };
    if (!options) options = {};
    if (keys === void 0 || keys === null) return "";
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved2 = this.resolve(keys, options);
    let res = resolved2 && resolved2.res;
    const resUsedKey = resolved2 && resolved2.usedKey || key;
    const resExactUsedKey = resolved2 && resolved2.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = !isString(res) && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(res))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved2.res = r2;
          resolved2.usedParams = this.getUsedParamsDetails(options);
          return resolved2;
        }
        return r2;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(res);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m2 in res) {
          if (Object.prototype.hasOwnProperty.call(res, m2)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m2}`;
            copy2[m2] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy2[m2] === deepKey) copy2[m2] = res[m2];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && !isString(options.count);
      const hasDefaultValue = Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i2 = 0; i2 < fallbackLngs.length; i2++) {
            lngs.push(fallbackLngs[i2]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l2, k2, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l2, namespace, k2, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language2) => {
              const suffixes = this.pluralResolver.getSuffixes(language2, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language2], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved2, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved2.res = res;
      resolved2.usedParams = this.getUsedParamsDetails(options);
      return resolved2;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved2, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved2.usedLng, resolved2.usedNS, resolved2.usedKey, {
        resolved: resolved2
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init({
        ...options,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...options.interpolation
          }
        }
      });
      const skipOnVariables = isString(res) && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && !isString(options.replace) ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved2.usedLng, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved2 && resolved2.res) options.lng = this.language || resolved2.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastKey && lastKey[0] === args[0] && !options.context) {
          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return _this.translate(...args, key);
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved2,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString(keys)) keys = [keys];
    keys.forEach((k2) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k2, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && !isString(options.count);
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (isString(options.context) || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
}
const capitalize$1 = (string) => string.charAt(0).toUpperCase() + string.slice(1);
class LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p2 = code.split("-");
    if (p2.length === 2) return null;
    p2.pop();
    if (p2[p2.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p2.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p2 = code.split("-");
    return this.formatLanguageCode(p2[0]);
  }
  formatLanguageCode(code) {
    if (isString(code) && code.indexOf("-") > -1) {
      if (typeof Intl !== "undefined" && typeof Intl.getCanonicalLocales !== "undefined") {
        try {
          let formattedCode = Intl.getCanonicalLocales(code)[0];
          if (formattedCode && this.options.lowerCaseLng) {
            formattedCode = formattedCode.toLowerCase();
          }
          if (formattedCode) return formattedCode;
        } catch (e) {
        }
      }
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p2 = code.split("-");
      if (this.options.lowerCaseLng) {
        p2 = p2.map((part) => part.toLowerCase());
      } else if (p2.length === 2) {
        p2[0] = p2[0].toLowerCase();
        p2[1] = p2[1].toUpperCase();
        if (specialCases.indexOf(p2[1].toLowerCase()) > -1) p2[1] = capitalize$1(p2[1].toLowerCase());
      } else if (p2.length === 3) {
        p2[0] = p2[0].toLowerCase();
        if (p2[1].length === 2) p2[1] = p2[1].toUpperCase();
        if (p2[0] !== "sgn" && p2[2].length === 2) p2[2] = p2[2].toUpperCase();
        if (specialCases.indexOf(p2[1].toLowerCase()) > -1) p2[1] = capitalize$1(p2[1].toLowerCase());
        if (specialCases.indexOf(p2[2].toLowerCase()) > -1) p2[2] = capitalize$1(p2[2].toLowerCase());
      }
      return p2.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c2) => {
      if (!c2) return;
      if (this.isSupportedCode(c2)) {
        codes.push(c2);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c2}`);
      }
    };
    if (isString(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
}
let sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
let _rulesPluralsTypes = {
  1: (n2) => Number(n2 > 1),
  2: (n2) => Number(n2 != 1),
  3: (n2) => 0,
  4: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  5: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5),
  6: (n2) => Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2),
  7: (n2) => Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  8: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3),
  9: (n2) => Number(n2 >= 2),
  10: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4),
  11: (n2) => Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3),
  12: (n2) => Number(n2 % 10 != 1 || n2 % 100 == 11),
  13: (n2) => Number(n2 !== 0),
  14: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3),
  15: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  16: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2),
  17: (n2) => Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1),
  18: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2),
  19: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3),
  20: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2),
  21: (n2) => Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0),
  22: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3)
};
const nonIntlVersions = ["v1", "v2", "v3"];
const intlVersions = ["v4"];
const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const createRules = () => {
  const rules = {};
  sets.forEach((set) => {
    set.lngs.forEach((l2) => {
      rules[l2] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
};
class PluralResolver {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
      const type = options.ordinal ? "ordinal" : "cardinal";
      const cacheKey = JSON.stringify({
        cleanedCode,
        type
      });
      if (cacheKey in this.pluralRulesCache) {
        return this.pluralRulesCache[cacheKey];
      }
      let rule;
      try {
        rule = new Intl.PluralRules(cleanedCode, {
          type
        });
      } catch (err) {
        if (!code.match(/-|_/)) return;
        const lngPart = this.languageUtils.getLanguagePartFromCode(code);
        rule = this.getRule(lngPart, options);
      }
      this.pluralRulesCache[cacheKey] = rule;
      return rule;
    }
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }
    return rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (!rule) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    return rule.numbers.map((number) => this.getSuffix(code, number, options));
  }
  getSuffix(code, count2) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      if (this.shouldUseIntlApi()) {
        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count2)}`;
      }
      return this.getSuffixRetroCompatible(rule, count2);
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return "";
  }
  getSuffixRetroCompatible(rule, count2) {
    const idx = rule.noAbs ? rule.plurals(count2) : rule.plurals(Math.abs(count2));
    let suffix = rule.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = "plural";
      } else if (suffix === 1) {
        suffix = "";
      }
    }
    const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
    if (this.options.compatibilityJSON === "v1") {
      if (suffix === 1) return "";
      if (typeof suffix === "number") return `_plural_${suffix.toString()}`;
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
}
const deepFindWithDefaults = function(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path2 = getPathWithDefaults(data, defaultData, key);
  if (!path2 && ignoreJSONStructure && isString(key)) {
    path2 = deepFind(data, key, keySeparator);
    if (path2 === void 0) path2 = deepFind(defaultData, key, keySeparator);
  }
  return path2;
};
const regexSafe = (val) => val.replace(/\$/g, "$$$$");
class Interpolator {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value2) => value2);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp && existingRegExp.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value2;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path2 = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path2, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path2;
      }
      const p2 = key.split(this.formatSeparator);
      const k2 = p2.shift().trim();
      const f2 = p2.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k2, this.options.keySeparator, this.options.ignoreJSONStructure), f2, lng, {
        ...options,
        ...data,
        interpolationkey: k2
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value2 = handleFormat(matchedVar);
        if (value2 === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value2 = isString(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value2 = "";
          } else if (skipOnVariables) {
            value2 = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value2 = "";
          }
        } else if (!isString(value2) && !this.useRawValueToEscape) {
          value2 = makeString(value2);
        }
        const safeValue = todo.safeValue(value2);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value2.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match;
    let value2;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c2 = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c2[1]}`;
      key = c2[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r2 = match[1].split(this.formatSeparator).map((elem) => elem.trim());
        match[1] = r2.shift();
        formatters = r2;
        doReduce = true;
      }
      value2 = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value2 && match[0] === str && !isString(value2)) return value2;
      if (!isString(value2)) value2 = makeString(value2);
      if (!value2) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value2 = "";
      }
      if (doReduce) {
        value2 = formatters.reduce((v2, f2) => this.format(v2, f2, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value2.trim());
      }
      str = str.replace(match[0], value2);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}
const parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    const optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
const createCachedFormatter = (fn) => {
  const cache = {};
  return (val, lng, options) => {
    let optForCache = options;
    if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options.interpolationkey]: void 0
      };
    }
    const key = lng + JSON.stringify(optForCache);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
};
class Formatter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = options.interpolation.formatSeparator || ",";
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value2, format, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f2) => f2.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f2) => f2.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result2 = formats.reduce((mem, f2) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f2);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l2, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error2) {
          this.logger.warn(error2);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value2);
    return result2;
  }
}
const removePending = (q2, name) => {
  if (q2.pending[name] !== void 0) {
    delete q2.pending[name];
    q2.pendingCount--;
  }
};
class Connector extends EventEmitter {
  constructor(backend, store2, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store2;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0) ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0) pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0) pending[name] = true;
          if (toLoad[name] === void 0) toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s2 = name.split("|");
    const lng = s2[0];
    const ns = s2[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    if (err && data) this.state[name] = 0;
    const loaded = {};
    this.queue.forEach((q2) => {
      pushPath(q2.loaded, [lng], ns);
      removePending(q2, name);
      if (err) q2.errors.push(err);
      if (q2.pendingCount === 0 && !q2.done) {
        Object.keys(q2.loaded).forEach((l2) => {
          if (!loaded[l2]) loaded[l2] = {};
          const loadedKeys = q2.loaded[l2];
          if (loadedKeys.length) {
            loadedKeys.forEach((n2) => {
              if (loaded[l2][n2] === void 0) loaded[l2][n2] = true;
            });
          }
        });
        q2.done = true;
        if (q2.errors.length) {
          q2.callback(q2.errors);
        } else {
          q2.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q2) => !q2.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait: wait2,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver2 = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait2 * 2, callback);
        }, wait2);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r2 = fc(lng, ns);
        if (r2 && typeof r2.then === "function") {
          r2.then((data) => resolver2(null, data)).catch(resolver2);
        } else {
          resolver2(null, r2);
        }
      } catch (err) {
        resolver2(err);
      }
      return;
    }
    return fc(lng, ns, resolver2);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s2 = name.split("|");
    const lng = s2[0];
    const ns = s2[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend && this.backend.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r2;
          if (fc.length === 5) {
            r2 = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r2 = fc(languages, namespace, key, fallbackValue);
          }
          if (r2 && typeof r2.then === "function") {
            r2.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r2);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
}
const get = () => ({
  debug: false,
  initImmediate: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString(args[1])) ret.defaultValue = args[1];
    if (isString(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value2) => value2,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  }
});
const transformOptions = (options) => {
  if (isString(options.ns)) options.ns = [options.ns];
  if (isString(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
};
const noop$1 = () => {
};
const bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
class I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (isString(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation
      };
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s2 = this.services;
      s2.logger = baseLogger;
      s2.resourceStore = this.store;
      s2.languageUtils = lu;
      s2.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s2.formatter = createClassOnDemand(formatter);
        s2.formatter.init(s2, this.options);
        this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
      }
      s2.interpolator = new Interpolator(this.options);
      s2.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
      s2.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s2.languageDetector.init) s2.languageDetector.init(s2, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s2.i18nFormat.init) s2.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m2) => {
        if (m2.init) m2.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop$1;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred2 = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred2.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred2;
  }
  loadResources(language2) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1;
    let usedCallback = callback;
    const usedLng = isString(language2) ? language2 : this.language;
    if (typeof language2 === "function") usedCallback = language2;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l2) => {
          if (l2 === "cimode") return;
          if (toLoad.indexOf(l2) < 0) toLoad.push(l2);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l2) => append(l2));
      } else {
        append(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l2) => append(l2));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred2 = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop$1;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred2.resolve();
      callback(err);
    });
    return deferred2;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l2) {
    if (!l2 || !this.languages) return;
    if (["cimode", "dev"].indexOf(l2) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred2 = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l2) => {
      this.language = l2;
      this.languages = this.services.languageUtils.toResolveHierarchy(l2);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l2);
    };
    const done = (err, l2) => {
      if (l2) {
        setLngProps(l2);
        this.translator.changeLanguage(l2);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l2);
        this.logger.log("languageChanged", l2);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred2.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback) callback(err, function() {
        return _this2.t(...arguments);
      });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const l2 = isString(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l2) {
        if (!this.language) {
          setLngProps(l2);
        }
        if (!this.translator.language) this.translator.changeLanguage(l2);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l2);
      }
      this.loadResources(l2, (err) => {
        done(err, l2);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred2;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      if (options.keyPrefix !== "") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k2) => `${options.keyPrefix}${keySeparator}${k2}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (isString(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l2, n2) => {
      const loadState = this.services.backendConnector.state[`${l2}|${n2}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred2 = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString(ns)) ns = [ns];
    ns.forEach((n2) => {
      if (this.options.ns.indexOf(n2) < 0) this.options.ns.push(n2);
    });
    this.loadResources((err) => {
      deferred2.resolve();
      if (callback) callback(err);
    });
    return deferred2;
  }
  loadLanguages(lngs, callback) {
    const deferred2 = defer();
    if (isString(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred2.resolve();
      if (callback) callback(err);
    });
    return deferred2;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m2) => {
      clone[m2] = this[m2];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      clone.store = new ResourceStore(this.store.data, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
const htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "©",
  "&#169;": "©",
  "&reg;": "®",
  "&#174;": "®",
  "&hellip;": "…",
  "&#8230;": "…",
  "&#x2F;": "/",
  "&#47;": "/"
};
const unescapeHtmlEntity = (m2) => htmlEntities[m2];
const unescape = (text2) => text2.replace(matchHtmlEntity, unescapeHtmlEntity);
let defaultOptions$1 = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape
};
const setDefaults = (options = {}) => {
  defaultOptions$1 = {
    ...defaultOptions$1,
    ...options
  };
};
const initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults(instance2.options.react);
  }
};
const {
  slice,
  forEach
} = [];
function defaults(obj) {
  forEach.call(slice.call(arguments, 1), (source) => {
    if (source) {
      for (const prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
function hasXSS(input) {
  if (typeof input !== "string") return false;
  const xssPatterns = [/<\s*script.*?>/i, /<\s*\/\s*script\s*>/i, /<\s*img.*?on\w+\s*=/i, /<\s*\w+\s*on\w+\s*=.*?>/i, /javascript\s*:/i, /vbscript\s*:/i, /expression\s*\(/i, /eval\s*\(/i, /alert\s*\(/i, /document\.cookie/i, /document\.write\s*\(/i, /window\.location/i, /innerHTML/i];
  return xssPatterns.some((pattern) => pattern.test(input));
}
const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
const serializeCookie = function(name, val) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    path: "/"
  };
  const opt = options;
  const value2 = encodeURIComponent(val);
  let str = `${name}=${value2}`;
  if (opt.maxAge > 0) {
    const maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge)) throw new Error("maxAge should be a Number");
    str += `; Max-Age=${Math.floor(maxAge)}`;
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += `; Domain=${opt.domain}`;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += `; Path=${opt.path}`;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) str += "; HttpOnly";
  if (opt.secure) str += "; Secure";
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  if (opt.partitioned) str += "; Partitioned";
  return str;
};
const cookie = {
  create(name, value2, minutes, domain) {
    let cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    if (minutes) {
      cookieOptions.expires = /* @__PURE__ */ new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
    }
    if (domain) cookieOptions.domain = domain;
    document.cookie = serializeCookie(name, encodeURIComponent(value2), cookieOptions);
  },
  read(name) {
    const nameEQ = `${name}=`;
    const ca = document.cookie.split(";");
    for (let i2 = 0; i2 < ca.length; i2++) {
      let c2 = ca[i2];
      while (c2.charAt(0) === " ") c2 = c2.substring(1, c2.length);
      if (c2.indexOf(nameEQ) === 0) return c2.substring(nameEQ.length, c2.length);
    }
    return null;
  },
  remove(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  // Deconstruct the options object and extract the lookupCookie property
  lookup(_ref) {
    let {
      lookupCookie
    } = _ref;
    if (lookupCookie && typeof document !== "undefined") {
      return cookie.read(lookupCookie) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupCookie,
      cookieMinutes,
      cookieDomain,
      cookieOptions
    } = _ref2;
    if (lookupCookie && typeof document !== "undefined") {
      cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  // Deconstruct the options object and extract the lookupQuerystring property
  lookup(_ref) {
    var _a2;
    let {
      lookupQuerystring
    } = _ref;
    let found;
    if (typeof window !== "undefined") {
      let {
        search: search2
      } = window.location;
      if (!window.location.search && ((_a2 = window.location.hash) == null ? void 0 : _a2.indexOf("?")) > -1) {
        search2 = window.location.hash.substring(window.location.hash.indexOf("?"));
      }
      const query = search2.substring(1);
      const params = query.split("&");
      for (let i2 = 0; i2 < params.length; i2++) {
        const pos = params[i2].indexOf("=");
        if (pos > 0) {
          const key = params[i2].substring(0, pos);
          if (key === lookupQuerystring) {
            found = params[i2].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
let hasLocalStorageSupport = null;
const localStorageAvailable = () => {
  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = typeof window !== "undefined" && window.localStorage !== null;
    if (!hasLocalStorageSupport) {
      return false;
    }
    const testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo");
    window.localStorage.removeItem(testKey);
  } catch (e) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
};
var localStorage = {
  name: "localStorage",
  // Deconstruct the options object and extract the lookupLocalStorage property
  lookup(_ref) {
    let {
      lookupLocalStorage
    } = _ref;
    if (lookupLocalStorage && localStorageAvailable()) {
      return window.localStorage.getItem(lookupLocalStorage) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupLocalStorage property
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupLocalStorage
    } = _ref2;
    if (lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(lookupLocalStorage, lng);
    }
  }
};
let hasSessionStorageSupport = null;
const sessionStorageAvailable = () => {
  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = typeof window !== "undefined" && window.sessionStorage !== null;
    if (!hasSessionStorageSupport) {
      return false;
    }
    const testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo");
    window.sessionStorage.removeItem(testKey);
  } catch (e) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
};
var sessionStorage$1 = {
  name: "sessionStorage",
  lookup(_ref) {
    let {
      lookupSessionStorage
    } = _ref;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      return window.sessionStorage.getItem(lookupSessionStorage) || void 0;
    }
    return void 0;
  },
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupSessionStorage
    } = _ref2;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup(options) {
    const found = [];
    if (typeof navigator !== "undefined") {
      const {
        languages,
        userLanguage,
        language: language2
      } = navigator;
      if (languages) {
        for (let i2 = 0; i2 < languages.length; i2++) {
          found.push(languages[i2]);
        }
      }
      if (userLanguage) {
        found.push(userLanguage);
      }
      if (language2) {
        found.push(language2);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  // Deconstruct the options object and extract the htmlTag property
  lookup(_ref) {
    let {
      htmlTag: htmlTag2
    } = _ref;
    let found;
    const internalHtmlTag = htmlTag2 || (typeof document !== "undefined" ? document.documentElement : null);
    if (internalHtmlTag && typeof internalHtmlTag.getAttribute === "function") {
      found = internalHtmlTag.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  // Deconstruct the options object and extract the lookupFromPathIndex property
  lookup(_ref) {
    var _a2;
    let {
      lookupFromPathIndex
    } = _ref;
    if (typeof window === "undefined") return void 0;
    const language2 = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
    if (!Array.isArray(language2)) return void 0;
    const index2 = typeof lookupFromPathIndex === "number" ? lookupFromPathIndex : 0;
    return (_a2 = language2[index2]) == null ? void 0 : _a2.replace("/", "");
  }
};
var subdomain = {
  name: "subdomain",
  lookup(_ref) {
    var _a2, _b;
    let {
      lookupFromSubdomainIndex
    } = _ref;
    const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex === "number" ? lookupFromSubdomainIndex + 1 : 1;
    const language2 = typeof window !== "undefined" && ((_b = (_a2 = window.location) == null ? void 0 : _a2.hostname) == null ? void 0 : _b.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i));
    if (!language2) return void 0;
    return language2[internalLookupFromSubdomainIndex];
  }
};
let canCookies = false;
try {
  document.cookie;
  canCookies = true;
} catch (e) {
}
const order = ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"];
if (!canCookies) order.splice(1, 1);
const getDefaults = () => ({
  order,
  lookupQuerystring: "lng",
  lookupCookie: "i18next",
  lookupLocalStorage: "i18nextLng",
  lookupSessionStorage: "i18nextLng",
  // cache user language
  caches: ["localStorage"],
  excludeCacheFor: ["cimode"],
  // cookieMinutes: 10,
  // cookieDomain: 'myDomain'
  convertDetectedLanguage: (l2) => l2
});
class Browser {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options);
  }
  init() {
    let services = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      languageUtils: {}
    };
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.services = services;
    this.options = defaults(options, this.options || {}, getDefaults());
    if (typeof this.options.convertDetectedLanguage === "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1) {
      this.options.convertDetectedLanguage = (l2) => l2.replace("-", "_");
    }
    if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
    this.i18nOptions = i18nOptions;
    this.addDetector(cookie$1);
    this.addDetector(querystring);
    this.addDetector(localStorage);
    this.addDetector(sessionStorage$1);
    this.addDetector(navigator$1);
    this.addDetector(htmlTag);
    this.addDetector(path);
    this.addDetector(subdomain);
  }
  addDetector(detector) {
    this.detectors[detector.name] = detector;
    return this;
  }
  detect() {
    let detectionOrder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.order;
    let detected = [];
    detectionOrder.forEach((detectorName) => {
      if (this.detectors[detectorName]) {
        let lookup = this.detectors[detectorName].lookup(this.options);
        if (lookup && typeof lookup === "string") lookup = [lookup];
        if (lookup) detected = detected.concat(lookup);
      }
    });
    detected = detected.filter((d2) => d2 !== void 0 && d2 !== null && !hasXSS(d2)).map((d2) => this.options.convertDetectedLanguage(d2));
    if (this.services && this.services.languageUtils && this.services.languageUtils.getBestMatchFromCodes) return detected;
    return detected.length > 0 ? detected[0] : null;
  }
  cacheUserLanguage(lng) {
    let caches = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.caches;
    if (!caches) return;
    if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
    caches.forEach((cacheName) => {
      if (this.detectors[cacheName]) this.detectors[cacheName].cacheUserLanguage(lng, this.options);
    });
  }
}
Browser.type = "languageDetector";
const km$8 = "km";
const m$8 = "m";
const to$8 = "to";
const or$2 = "or";
const logout$3 = "Log out";
const save$8 = "Save";
const cancel$8 = "Cancel";
const ok$3 = "OK";
const create$8 = "Create";
const disasters$8 = "Disasters";
const loading$8 = "Loading...";
const preparing_data = "Preparing data";
const loading_events$2 = "Loading disasters";
const legend$8 = "Legend";
const maps$8 = "maps";
const vertical_direction$8 = "Vertical direction";
const horizontal_direction$8 = "Horizontal direction";
const legend_presentation$8 = "Legend presentation";
const layers$8 = "Layers";
const toolbar$8 = { "map_ruler": "Measure distance", "locate_me": "Locate me", "panel_title": "Toolbar", "download": "Download", "delete": "Delete", "boundary_selector": "Select admin boundary", "create_layer": "Create layer", "geometry_uploader": "Upload GeoJSON", "focused_geometry_editor": "Draw or edit geometry", "edit_in_osm": "Edit map in OSM", "record_sensors": "Record sensors", "tools_label": "Tools", "selected_area_label": "Selected area", "upload_mcda": "Upload MCDA" };
const layer_actions$8 = { "tooltips": { "erase": "Erase", "download": "Download", "edit": "Edit", "hide": "Hide", "show": "Show", "delete": "Delete" } };
const feed$8 = "Feed";
const deselect$8 = "Deselect";
const spinner_text$8 = "Gathering data";
const updated$8 = "Updated";
const started$2 = "Started";
const created = "Created";
const mapping_types = "Mapping types";
const osm_gaps = "OSM gaps";
const no_data_received$8 = "No data received";
const wrong_data_received$8 = "Wrong data received";
const error$a = "Error";
const sort_icon$8 = "Sort Icon";
const configs$8 = { "Kontur_public_feed": "Kontur Public", "Kontur_public_feed_description": "The feed contains real-time data about Cyclones, Droughts, Earthquakes, Floods, Volcanoes, Wildfires." };
const errors$8 = { "default": "Sorry, we are having issues which will be fixed soon", "timeout": "Request timeout", "cannot_connect": "Cannot connect to server", "forbidden": "Forbidden", "not_found": "Not found", "unknown": "Unknown", "server_error": "Server error", "error_try_again": "Something went wrong. Please try again" };
const categories$8 = { "overlays": "Overlays", "basemap": "Basemap" };
const groups$8 = { "layers_in_selected_area": "Layers in selected area", "your_layers": "Your layers", "kontur_analytics": "Kontur analytics", "qa": "OpenStreetMap inspector", "osmbasedmap": "OpenStreetMap based", "other": "Other", "elevation": "Elevation", "photo": "Imagery", "map": "Map" };
const advanced_analytics_data_list$8 = { "load_world_data": "Load World Data", "numerator": "Numerator", "normalized_by": "Normalized By", "sum": "Sum", "min": "Min", "max": "Max", "mean": "Mean", "stddev": "Stddev", "median": "Median", "filter_numerator": "Filter Numerator", "filter_denominator": "Filter Denominator" };
const mcda$8 = { "title": "Multi-criteria decision analysis", "name": "Create MCDA", "modal_title": "Multi-criteria decision analysis", "modal_input_name": "Analysis name", "modal_input_name_placeholder": "e.g., Climate change", "modal_input_indicators": "Layer list", "modal_input_indicators_placeholder": "Select layers", "modal_input_indicators_no_options": "No options", "btn_save": "Save analysis", "error_analysis_name_cannot_be_empty": "Analysis name cannot be empty", "error_invalid_file": "Invalid MCDA file format", "error_invalid_parameter": "Invalid '{{parameter}}' parameter", "error_invalid_layer_parameter": "Invalid '{{parameter}}' parameter in '{{axisName}}' layer", "error_wrong_mcda_version": "Wrong MCDA version", "legend_title": "Legend", "legend_subtitle": "Hexagons are colored based on analysis layer settings. Click a hexagon to see its values.", "layer_editor": { "save_changes": "Save changes", "range": "Value range", "outliers": "Outliers", "reverse_to_good_bad": "Reverse to Good → Bad", "reverse_to_bad_good": "Reverse to Bad → Good", "weight": "Weight", "transform": "Transform", "transformation": "Transformation", "normalize": "Normalize", "normalization": "Normalization", "range_buttons": { "full_range": "Full range", "3_sigma": "3σ", "2_sigma": "2σ", "1_sigma": "1σ" }, "outliers_options": { "clamp": "Clamp", "hide": "Hide", "dont_modify": "Don't modify" }, "transformations": { "no_transformation": "No transformation", "square_root": "Square root: sign(x)⋅√|x|", "cube_root": "Cube root: ∛x", "log_one": "log₁₀(x - xmin + 1)", "log_epsilon": "log₁₀(x - xmin + ε)" }, "no": "No", "max_min": "Max-min", "errors": { "weight_cannot_be_empty": "Weight cannot be empty", "weight_must_be_a_number": "Weight must be a valid number", "range_from_cannot_be_bigger": "The ‘from’ value cannot be bigger than the ‘to’ value", "range_cannot_be_empty": "Range cannot be empty", "range_must_be_a_number": "Range must be a valid number" }, "tips": { "range": "The values that will be considered the worst and the best in your analysis.", "sentiment": "Determine the direction of sentiment for the layer's impact on the analysis:\n* **Bad → Good**: Higher values indicate a positive sentiment.\n* **Good → Bad**: Higher values indicate a negative sentiment.", "weight": "By default, all layers contribute equally to the analysis through a weighted average. Adjusting the increased weight of a layer (2, 3, etc.) allows you to assign additional importance to it in the analysis.", "transform": "Apply calculations to the values. Achieving a more linear distribution will provide more useful information for analysis.\n\n **Note**: Calculations are done before normalization.", "normalize": "Adjusts values to a standardized scale. This helps compare them easily and make decisions.\n* **Standard score scaling**: This option adjusts values to a standardized scale, ensuring they are all comparable.\n* **No (for specialists only)**: Leaves values unmodified.", "outliers": "* **Clamp**: Set values above the range to 1 and below the range to 0.\n* **Don’t modify**: Keep 0 and 1 for min and max, but allow outlier scores beyond this range.\n* **Exclude**: Exclude areas where values are out of range." } }, "bad": "Bad", "good": "Good" };
const multivariate$8 = { "multivariate_analysis": "Multivariate Analysis", "create_analysis_layer": "Create analysis layer", "upload_analysis_layer": "Upload analysis layer", "popup": { "score_header": "Score {{level}}", "compare_header": "Compare {{level}}" }, "score": "Score", "compare": "Compare", "hide_area": "Hide area" };
const search$8 = { "search_location": "Search location", "info_block": "You can search for 📍 locations", "info_block_with_mcda": "You can search for 📍 locations or ask ✨ AI your question like “Where is dead wood”", "input_placeholder": "Search", "input_placeholder_mcda": "Search or ask AI", "locations_no_result": "No locations found", "mcda_loading_message": "AI is generating an analysis for you", "mcda_no_result": "No AI suggestion", "mcda_error_message": "AI engine did not respond. Please try again later", "mcda_create_analysis": "Create analysis", "upload_analysis": "“{{name}}” Multi-Criteria Decision Analysis has been created" };
const event_list$8 = { "warning_title": "Cannot filter by map view", "warning_description": "Map is not ready yet, try later", "bbox_filter_button": "Filter by map view", "analytics": { "affected_people": { "tooltip": "Affected people", "value": "No humanitarian impact" }, "settled_area_tooltip": "Settled area", "loss_tooltip": "Estimated loss" }, "no_event_in_feed": "The disaster was not found in the current disaster feed", "no_selected_disaster": "No disaster selected", "chose_disaster": "Choose disaster", "no_historical_disasters": "No historical disasters in this area", "no_feed_disasters": "No disasters in this feed", "no_feed_disasters_matching_your_filters": "No disasters matching your filters", "no_disasters": "No disasters", "severity_unknown": "Unknown", "severity_termination": "Termination", "severity_minor": "Minor", "severity_moderate": "Moderate", "severity_severe": "Severe", "severity_extreme": "Extreme", "open_timeline_button": "Timeline" };
const create_layer$8 = { "edit_layer": "Edit Layer", "edit_features": "Edit Features", "delete_layer": "Delete Layer", "create_layer": "Create Layer", "saving_layer": "Saving layer...", "field_name": "Field name", "layer_name": "Layer name", "marker_icon": "Marker icon", "type": "Type", "select": "Select", "short_text": "Short Text", "long_text": "Long Text", "link": "Link", "image": "Image", "fields": "Fields", "add_field": "Add field", "location": "Location", "edit_feature_placeholder": "Select some feature for start edit feature properties" };
const analytics_panel$8 = { "header_title": "Analytics", "error_loading": "Failed receiving data about selected area. It may be too large.", "info_short": "Calculations are made for selected area" };
const advanced_analytics_panel$8 = { "header_title": "Advanced analytics", "error": "Error while fetching advanced analytics data" };
const advanced_analytics_empty$8 = { "not_found": "Sorry, the requested disaster was not found", "error": "An error occurred", "analytics_for_selected": "Analytics for selected area", "will_be_provided": "will be provided here", "no_analytics": "No analytics for the selected area" };
const llm_analytics$8 = { "header": "AI insights", "placeholder": { "select_area": "Select area (<icon1 />,<icon2 />,<icon3 />) you want to explore to get AI Insights.", "you_can_also": "You can also:", "fill_bio": "<icon /> <lnk>Fill out analysis objectives</lnk> to personalize AI analysis", "select_and_save_as_reference_area": "<icon /> Select an area and save it as a reference to compare with another one", "learn_more": "<lnk><icon/> Learn more about AI Insights</lnk>" } };
const draw_tools$8 = { "area": "Polygon", "line": "Line", "point": "Point", "finish_drawing": "Finish Drawing", "caption": "Click on the map to begin drawing", "no_geometry_error": "No drawn geometry to download", "overlap_error": "Polygon should not overlap itself", "save_features": "Save features" };
const boundary_selector$8 = { "title": "Focus to administrative boundary" };
const geometry_uploader$8 = { "title": "Focus to uploaded geometry", "error": "Error while reading uploaded file" };
const focus_geometry$8 = { "title": "Focus to freehand geometry" };
const focus_geometry_layer$3 = { "settings": { "name": "Selected area" } };
const reference_area_layer$8 = { "settings": { "name": "Reference area" } };
const drawings$3 = { "self_directions_not_supported": "Self intersections are not supported" };
const bivariate$8 = { "panel": { "header": "Bivariate matrix" }, "matrix": { "caption": { "base_axis": "Base axis", "annex_axis": "Annex axis", "tooltip": { "p1": "Charts involving the Base and Annex axes help establish a relationship between two data sets.", "li1": "Annex axis - parameters that we analyse", "li2": "Base axis - reference point in the analysis", "b": "Ex: the best location to open a cafe", "p2": "We can explore the number of eatery places (Annex axis) against Population density (Base axis).", "p3": "In this scenario, we are first interested in a small number of eatery places, and the number of people in that place gives us additional information." } }, "header": { "title": "Choose two layers to explore correlations", "hint": "Layers and correlations are displayed for the current Selected Area" }, "icon": { "population": "Value divided by Population", "area_km2": "Value divided by Area", "total_building_count": "Value divided by Total Buildings Estimate", "populated_area_km2": "Value divided by Populated Area", "one": "Without divider", "roads": "Value divided by Total Roads Length" }, "progress": { "rendering": "Rendering", "applied": "Applied on the map" }, "loading_error": "Unfortunately, we cannot display the matrix. Try refreshing the page or come back later." }, "legend": { "high": "High", "low": "Low", "medium": "Medium" }, "color_manager": { "not_defined": "Not defined", "sentiments_combinations_filter": "Sentiments combinations", "layers_filter": "Layers", "no_legends": "There are no legends satisfying the conditions.", "no_data": "No Data.", "sentiments_tab": "Sentiments", "color_legends_tab": "Color Legends", "layers_tab": "Layers (indicators)" } };
const sidebar$8 = { "biv_color_manager": "Сolor manager", "edit_osm": "Edit in OpenStreetMap", "ruler": "Ruler", "collapse": "Collapse", "expand": "Expand", "icon_alt": "Application logo" };
const login$8 = { "email": "Email", "password": "Password", "login_button": "Login", "sign_up": "Sign up", "logging_in": "Logging in...", "log_in": "Log in", "forgot_password": "Forgot password?", "description": "Please log in to change your settings", "error": { "email_empty": "Email cannot be empty", "email_invalid": "Email has to be valid", "password": "Password cannot be empty", "connect": "Could not connect to authentication service" } };
const currency$8 = { "usd": "USD" };
const subscription$8 = { "title": "Plans & Pricing", "price_summary": "* Billed as ${{pricePerYear}} USD once yearly", "unauthorized_button": "Sign in to subscribe", "current_plan_button": "Current plan", "sales_button": "Contact sales", "book_demo_button": "Book a demo", "request_trial_button": "Request trial", "errors": { "payment_initialization": "There was an error during payment initialization. Please try again or contact our support" }, "success_modal": { "title": "Success", "thank_you_for_subscribing": "Thank you for subscribing to our platform!", "after_the_page_refreshes": "After the page refreshes, you can start using Kontur Atlas" } };
const reports$8 = { "title": "Disaster Ninja Reports", "no_data": "No data for this report", "sorting": "Sorting data...", "loading": "Loading data", "open_josm": "Open via JOSM remote control", "josm_logo_alt": "JOSM logo", "see_all": "See all reports", "wrong_id": "Wrong report ID", "description": "<0>Kontur </0> generates several reports that help validate OpenStreetMap quality. They contain links to areas on <4>osm.org </4> and links to open them in the JOSM editor with enabled remote control for editing." };
const modes$8 = { "map": "Map", "about": "About", "cookies": "Cookies", "reports": "Reports", "report": "Report", "profile": "Profile", "privacy": "Privacy", "terms": "Terms", "user_guide": "User guide", "external": { "upload_imagery": "Upload imagery", "imagery_catalog": "Imagery catalog" } };
const profile$8 = { "interfaceTheme": "Theme", "interfaceLanguage": "Language", "units": "Units", "fullName": "Full name", "email": "Email", "metric": "metric", "imperialBeta": "imperial (beta)", "profileSettingsHeader": "Personalize your experience", "your_current_job": "your current job", "area_of_expertise": "area of expertise", "challenges": "challenges", "personalization_prompt": "For better personalization, please include details such as:", "ai_tools_compatibility": "This information is compatible with AI tools", "improves_analysis": "Improves analysis", "bio_placeholder": "Bio", "bio_textarea_placeholder": "e.g. GIS specialist with 5+ years of experience in disaster risk analysis, focused on urban resilience.", "analysis_objectives": "Analysis objectives", "objectives_textarea_placeholder": "e.g. Urban planning analysis with a focus on climate resilience. My current challenge is improving flood risk mapping.", "appSettingsHeader": "Settings", "your_organization": "Your organization", "your_contacts": "Your contact info", "organization_name": "Organization name", "position": "Position", "gis_specialists": "GIS specialists in your team", "saveButton": "Save changes", "phone_number": "Phone number with country code", "linkedin": "LinkedIn profile", "konturTheme": "Kontur", "HOTTheme": "HOT", "defaultDisasterFeed": "Default disaster feed", "defaultOSMeditor": "Default OpenStreetMap editor (beta)", "successNotification": "All changes have been applied successfully", "dont_know": "I don’t know", "languageOption": { "en": "English", "es": "Spanish", "ar": "Arabic", "ko": "Korean", "id": "Indonesian", "de": "German", "be": "Belarusian", "ru": "Russian", "uk": "Ukrainian" }, "reference_area": { "title": "Reference area", "freehand_geometry": "Freehand geometry", "to_replace_reference_area": 'You can redefine your reference area on map. Select an area and click "Save as reference area" on toolbar.\n', "description": "Save an area you are familiar with as a reference. We will use it as a baseline to compare other areas and explain the differences.", "set_the_reference_area": "Set area on map", "tooltip_text": "1.Select an area of interest on the map using the Admin Boundary or Draw Geometry tool.\n\n 2. Click the 'Save as Reference' button on the toolbar.", "accessing_location": "Accessing your location", "accessing_location_error": "Error. Try another way.", "select_location": "Select my current location", "notification": "Your reference area {{name}} has been saved" } };
const current_event$3 = { "not_found_request": "Sorry, the requested disaster was not found" };
const locate_me$8 = { "get_location_error": "Error while getting location", "feature_title": "Locate me" };
const episode$3 = "Timeline";
const loading_episodes$8 = "Loading Episodes";
const zoom_to_world$2 = "Zoom to the whole world";
const cookie_banner$8 = { "header": "We value your privacy", "body": "We use absolutely necessary cookies to provide you personalized services and optional cookies to improve {{appName}} and your experience. You can manage cookie settings or withdraw consent to optional cookies at any time.\nFor more information, please, check our [Privacy Policy](about/privacy)", "decline_all": "Decline optional cookies", "accept_all": "Accept optional cookies" };
const live_sensor$8 = { "start": "Start sensor recording", "finish": "Stop sensor recording", "finishMessage": "Recording has been finished", "startMessage": "Recording has been started", "noSensorsError": "Your device does not have the required sensors" };
const layer_features_panel$8 = { "empty": "Layer features within selected area will be provided here", "noFeatureSelected": "No layer feature selected", "chooseFeature": "Choose layer feature", "listInfo": "The list is filtered by selected area and sorted by project number", "error_loading": "Failed to load layer features data. Please try again.", "no_features": "No features found in the selected area." };
const reference_area$8 = { "save_as_reference_area": "Save as reference area", "error_couldnt_save": "Unfortunately, we could not save your reference area. Please try again.", "selected_area_saved_as_reference_area": "Selected area has been saved as reference area in your profile" };
const en_common = {
  km: km$8,
  m: m$8,
  to: to$8,
  or: or$2,
  logout: logout$3,
  save: save$8,
  cancel: cancel$8,
  ok: ok$3,
  create: create$8,
  disasters: disasters$8,
  loading: loading$8,
  preparing_data,
  loading_events: loading_events$2,
  legend: legend$8,
  maps: maps$8,
  vertical_direction: vertical_direction$8,
  horizontal_direction: horizontal_direction$8,
  legend_presentation: legend_presentation$8,
  layers: layers$8,
  toolbar: toolbar$8,
  layer_actions: layer_actions$8,
  feed: feed$8,
  deselect: deselect$8,
  spinner_text: spinner_text$8,
  updated: updated$8,
  started: started$2,
  created,
  mapping_types,
  osm_gaps,
  no_data_received: no_data_received$8,
  wrong_data_received: wrong_data_received$8,
  error: error$a,
  sort_icon: sort_icon$8,
  configs: configs$8,
  errors: errors$8,
  categories: categories$8,
  groups: groups$8,
  advanced_analytics_data_list: advanced_analytics_data_list$8,
  mcda: mcda$8,
  multivariate: multivariate$8,
  search: search$8,
  event_list: event_list$8,
  create_layer: create_layer$8,
  analytics_panel: analytics_panel$8,
  advanced_analytics_panel: advanced_analytics_panel$8,
  advanced_analytics_empty: advanced_analytics_empty$8,
  llm_analytics: llm_analytics$8,
  draw_tools: draw_tools$8,
  boundary_selector: boundary_selector$8,
  geometry_uploader: geometry_uploader$8,
  focus_geometry: focus_geometry$8,
  focus_geometry_layer: focus_geometry_layer$3,
  reference_area_layer: reference_area_layer$8,
  drawings: drawings$3,
  bivariate: bivariate$8,
  sidebar: sidebar$8,
  login: login$8,
  currency: currency$8,
  subscription: subscription$8,
  reports: reports$8,
  modes: modes$8,
  profile: profile$8,
  current_event: current_event$3,
  locate_me: locate_me$8,
  episode: episode$3,
  loading_episodes: loading_episodes$8,
  zoom_to_world: zoom_to_world$2,
  cookie_banner: cookie_banner$8,
  live_sensor: live_sensor$8,
  layer_features_panel: layer_features_panel$8,
  reference_area: reference_area$8
};
const km$7 = "km";
const m$7 = "m";
const to$7 = "a";
const maps$7 = "mapas";
const save$7 = "Guardar";
const cancel$7 = "Cancelar";
const mcda$7 = { "btn_cancel": "Cancelar", "legend_title": "Leyenda", "layer_editor": { "outliers_options": {}, "save_changes": "Guardar cambios", "range_buttons": {}, "transformations": {}, "errors": {}, "tips": {} } };
const create$7 = "Crear";
const disasters$7 = "Desastres";
const loading$7 = "Cargando...";
const legend$7 = "Leyenda";
const vertical_direction$7 = "Dirección vertical";
const horizontal_direction$7 = "Dirección horizontal";
const legend_presentation$7 = "Presentación de la leyenda";
const layers$7 = "Capas";
const bivariate$7 = { "color_manager": { "layers_filter": "Capas", "not_defined": "No definido", "sentiments_combinations_filter": "Combinaciones de sentimientos", "no_legends": "No hay leyendas que cumplan las condiciones.", "no_data": "No hay datos.", "sentiments_tab": "Sentimientos", "color_legends_tab": "Leyendas de colores", "layers_tab": "Capas (indicadores)" }, "matrix": { "caption": { "base_axis": "Eje base", "annex_axis": "Eje anexo", "tooltip": { "p1": "Las gráficas que incluyen los ejes base y anexo ayudan a establecer una relación entre dos conjuntos de datos.", "li1": "Eje anexo: parámetros que analizamos", "li2": "Eje base: punto de referencia en el análisis", "b": "Ej.: la mejor ubicación para abrir una cafetería", "p2": "Podemos explorar el número de locales de comida (eje anexo) frente a la densidad de población (eje base).", "p3": "En este escenario, en primer lugar nos interesa un número reducido de locales de comida, y la cantidad de personas presentes nos da información adicional." } }, "header": { "title": "Elija dos capas para explorar las correlaciones", "hint": "Las capas y correlaciones se muestran para el área seleccionada actual" }, "icon": { "population": "Valor dividido por la población", "area_km2": "Valor dividido por el área", "total_building_count": "Valor dividido por la estimación total de edificios", "populated_area_km2": "Valor dividido por el área poblada", "one": "Sin divisor", "roads": "Valor dividido por la longitud total de las carreteras" }, "progress": { "rendering": "Renderizado", "applied": "Aplicado en el mapa" } }, "legend": { "high": "Alto", "low": "Bajo", "medium": "Medio" } };
const toolbar$7 = { "locate_me": "Localizarme" };
const locate_me$7 = { "feature_title": "Localizarme", "get_location_error": "Error al obtener la ubicación" };
const layer_actions$7 = { "tooltips": {} };
const feed$7 = "Fuente";
const deselect$7 = "Anular la selección";
const spinner_text$7 = "Recopilación de datos";
const updated$7 = "Actualizado";
const no_data_received$7 = "No se han recibido datos";
const wrong_data_received$7 = "Se han recibido datos erróneos";
const error$9 = "Error";
const sort_icon$7 = "Icono de ordenar";
const configs$7 = { "Kontur_public_feed": "Kontur Public", "Kontur_public_feed_description": "El feed contiene datos en tiempo real sobre Ciclones, Sequías, Terremotos, Inundaciones, Volcanes, Incendios forestales." };
const errors$7 = { "forbidden": "Prohibido", "not_found": "No encontrado", "unknown": "Desconocido" };
const event_list$7 = { "severity_unknown": "Desconocido", "analytics": { "affected_people": { "value": "Sin impacto humanitario" }, "loss_tooltip": "Pérdida estimada" }, "no_selected_disaster": "No se ha seleccionado ningún desastre", "chose_disaster": "Seleccione el desastre" };
const categories$7 = { "overlays": "Superposiciones", "basemap": "Mapa base" };
const groups$7 = { "layers_in_selected_area": "Capas en el área seleccionada", "other": "Otros", "elevation": "Elevación", "map": "Mapa" };
const modes$7 = { "map": "Mapa", "about": "Acerca de", "reports": "Informes", "profile": "Perfil" };
const advanced_analytics_data_list$7 = { "load_world_data": "Cargar datos mundiales", "numerator": "Numerador", "normalized_by": "Normalizado por", "sum": "Suma", "min": "Mín.", "max": "Máx.", "mean": "Media", "stddev": "Desv. est.", "median": "Mediana", "filter_denominator": "Filtrar Denominador" };
const profile$7 = { "saveButton": "Guardar cambios", "reference_area": {}, "email": "Correo electrónico", "interfaceTheme": "Tema", "interfaceLanguage": "Idioma", "units": "Unidades", "metric": "métricas", "imperialBeta": "imperiales (beta)", "bio_placeholder": "Bio", "appSettingsHeader": "Ajustes", "konturTheme": "Kontur", "HOTTheme": "HOT", "defaultDisasterFeed": "Feed de desastres predeterminado", "defaultOSMeditor": "Editor predeterminado de OpenStreetMap (beta)", "successNotification": "Todos los cambios se han aplicado correctamente", "languageOption": { "en": "Inglés", "es": "Español", "ar": "Árabe", "ko": "Сoreano", "id": "Indonesio", "de": "Alemán", "uk": "Ucranio" } };
const multivariate$7 = { "popup": {} };
const search$7 = { "search_location": "Buscar ubicación" };
const create_layer$7 = { "edit_layer": "Editar capa", "edit_features": "Editar características", "delete_layer": "Eliminar capa", "create_layer": "Crear capa", "saving_layer": "Guardando capa...", "field_name": "Nombre de campo", "layer_name": "Nombre de la capa", "marker_icon": "Icono de marcador", "type": "Tipo", "select": "Seleccionar", "short_text": "Texto corto", "long_text": "Texto largo", "link": "Enlace", "image": "Imagen", "fields": "Campos", "add_field": "Agregar campo", "location": "Ubicación", "edit_feature_placeholder": "Seleccione una característica para comenzar a editar las propiedades de la misma" };
const analytics_panel$7 = { "header_title": "Análisis" };
const advanced_analytics_panel$7 = { "header_title": "Análisis avanzado", "error": "Error en la obtención de datos de análisis Avanzado" };
const advanced_analytics_empty$7 = {};
const llm_analytics$7 = { "placeholder": {} };
const draw_tools$7 = { "line": "Línea", "point": "Punto", "finish_drawing": "Terminar el dibujo", "caption": "Haga clic en el mapa para empezar a dibujar", "no_geometry_error": "No hay geometría dibujada para descargar", "overlap_error": "El polígono no debe superponerse sobre sí mismo", "save_features": "Guardar características" };
const boundary_selector$7 = { "title": "Enfocar en el límite administrativo" };
const geometry_uploader$7 = { "title": "Enfocar en la geometría cargada", "error": "Error al leer el archivo cargado" };
const focus_geometry$7 = { "title": "Enfocar en la geometría a mano" };
const reference_area_layer$7 = { "settings": {} };
const sidebar$7 = { "biv_color_manager": "Administrador de color", "edit_osm": "Editar en OpenStreetMap", "ruler": "Regla", "collapse": "Contraer", "expand": "Expandir", "icon_alt": "Logotipo de la aplicación" };
const login$7 = { "email": "Correo electrónico", "password": "Contraseña", "login_button": "Inicio de sesión", "sign_up": "Registrarse", "logging_in": "Iniciando sesión...", "log_in": "Iniciar sesión", "description": "Acceda a su cuenta para cambiar los ajustes" };
const currency$7 = {};
const subscription$7 = { "errors": {}, "success_modal": {} };
const reports$7 = { "title": "Informes de Disaster Ninja", "no_data": "No hay datos para este informe", "sorting": "Ordenando datos...", "loading": "Cargando datos", "open_josm": "Abrir a través del control remoto JOSM", "josm_logo_alt": "Logotipo de JOSM", "see_all": "Ver todos los informes", "wrong_id": "ID de informe incorrecto", "description": "<0>Kontur </0> genera una serie de informes útiles para validar la calidad de OpenStreetMap. Contienen enlaces a zonas en <4>osm.org </4> y enlaces para abrirlas en el editor JOSM con control remoto habilitado para la edición." };
const about$7 = { "title": "¡Bienvenido a Disaster Ninja!", "intro": "¿Desea recibir notificaciones sobre desastres en curso? ¿Le interesan los datos de población instantáneos y otros datos analíticos de alguna región del mundo? Disaster Ninja muestra algunas de las capacidades de <2>Kontur</2> para ocuparse de estas necesidades.<br/><br/> Inicialmente la diseñamos como una herramienta de apoyo a los mapeadores de servicios humanitarios. Ahora ha ampliado sus funcionalidades y aplicaciones prácticas. Tanto si trabaja en la gestión de desastres como si construye una ciudad inteligente o realiza investigaciones sobre el cambio climático, Disaster Ninja puede ayudarle a:", "l1": "1. Estar al día con los últimos eventos peligrosos a nivel mundial.", "p1": "El panel de Desastres se actualiza continuamente para informarle sobre los acontecimientos en curso. Utiliza la información proporcionada por <2>Kontur Event Feed</2>, a la que también puede acceder a través de la interfaz de la aplicación.", "l2": "2. Centrarse en su área de interés.", "p2": "El panel de Herramientas de Dibujo le permite dibujar o subir su propia geometría en el mapa. También puede centrarse en un área o en una unidad administrativa - país, ciudad o región — expuesta a desastres.", "l3": "3. Recibir análisis de su área de interés.", "p3": "El panel de Análisis le muestra el número de personas que viven en la zona según <2>Kontur Population</2> y según una estimación de las zonas sin mapear en OpenStreetMap. Los clientes de Kontur tienen acceso a cientos de otros indicadores a través de Advance Analytics.", "l4": "4. Explorar los datos del mapa y sacar sus propias conclusiones.", "p4": "El panel Capas le ofrece varias opciones para mostrar dos indicadores en simultáneo en un mapa bivariado, p. ej:, la densidad de población y la distancia a la estación de bomberos más cercana. Utilice las leyendas de colores para evaluar qué áreas requieren atención. <br/>Consejo: en general, el verde indica riesgo bajo / pocas zonas sin mapear, el rojo — riesgo alto / muchas zonas sin mapear.", "p5": "Además, puede cambiar a Informes en el panel de la izquierda para acceder a los datos sobre posibles errores e inconsistencias en OpenStreetMap y ayudarle a realizar correcciones mapeando la zona correspondiente con el editor JOSM.", "goToMap": "Ir al mapa ahora", "p6": "Esperamos que esta herramienta le resulte valiosa. Utilice el chat de Disaster Ninja si tiene alguna pregunta sobre sus funcionalidades y estaremos encantados de ayudarle. También puede contactarnos por correo electrónico en <1>hello@kontur.io</1> si tiene algún comentario o sugerencia para mejorar la herramienta.<br/><br/> Disaster Ninja es un proyecto de código abierto. Encuentre el código en la <8>cuenta de GitHub de Kontur</8>." };
const loading_episodes$7 = "Cargando episodios";
const cookie_banner$7 = {};
const live_sensor$7 = {};
const layer_features_panel$7 = {};
const reference_area$7 = {};
const es_common = {
  km: km$7,
  m: m$7,
  to: to$7,
  maps: maps$7,
  save: save$7,
  cancel: cancel$7,
  mcda: mcda$7,
  create: create$7,
  disasters: disasters$7,
  loading: loading$7,
  legend: legend$7,
  vertical_direction: vertical_direction$7,
  horizontal_direction: horizontal_direction$7,
  legend_presentation: legend_presentation$7,
  layers: layers$7,
  bivariate: bivariate$7,
  toolbar: toolbar$7,
  locate_me: locate_me$7,
  layer_actions: layer_actions$7,
  feed: feed$7,
  deselect: deselect$7,
  spinner_text: spinner_text$7,
  updated: updated$7,
  no_data_received: no_data_received$7,
  wrong_data_received: wrong_data_received$7,
  error: error$9,
  sort_icon: sort_icon$7,
  configs: configs$7,
  errors: errors$7,
  event_list: event_list$7,
  categories: categories$7,
  groups: groups$7,
  modes: modes$7,
  advanced_analytics_data_list: advanced_analytics_data_list$7,
  profile: profile$7,
  multivariate: multivariate$7,
  search: search$7,
  create_layer: create_layer$7,
  analytics_panel: analytics_panel$7,
  advanced_analytics_panel: advanced_analytics_panel$7,
  advanced_analytics_empty: advanced_analytics_empty$7,
  llm_analytics: llm_analytics$7,
  draw_tools: draw_tools$7,
  boundary_selector: boundary_selector$7,
  geometry_uploader: geometry_uploader$7,
  focus_geometry: focus_geometry$7,
  reference_area_layer: reference_area_layer$7,
  sidebar: sidebar$7,
  login: login$7,
  currency: currency$7,
  subscription: subscription$7,
  reports: reports$7,
  about: about$7,
  loading_episodes: loading_episodes$7,
  cookie_banner: cookie_banner$7,
  live_sensor: live_sensor$7,
  layer_features_panel: layer_features_panel$7,
  reference_area: reference_area$7
};
const km$6 = "كم";
const m$6 = "م";
const to$6 = "إلى";
const maps$6 = "خرائط";
const save$6 = "حفظ";
const cancel$6 = "إلغاء";
const mcda$6 = { "btn_cancel": "إلغاء", "legend_title": "عنوان تفسيري", "layer_editor": { "outliers_options": {}, "save_changes": "حفظ التغييرات", "range_buttons": {}, "transformations": {}, "errors": {}, "tips": {} } };
const create$6 = "إنشاء";
const disasters$6 = "كوارث";
const loading$6 = "جارٍ التحميل...";
const legend$6 = "عنوان تفسيري";
const vertical_direction$6 = "الاتجاه الرأسي";
const horizontal_direction$6 = "الاتجاه الأفقي";
const legend_presentation$6 = "عرض العنوان التفسيري";
const layers$6 = "طبقات";
const bivariate$6 = { "color_manager": { "layers_filter": "طبقات", "not_defined": "غير معرف", "sentiments_combinations_filter": "تركيبات المشاعر", "no_legends": "لا توجد ملاحظات تفي بالشروط.", "no_data": "لايوجد بيانات.", "sentiments_tab": "المشاعر", "color_legends_tab": "مؤشرات اللون", "layers_tab": "الطبقات (المؤشرات)" }, "matrix": { "caption": { "base_axis": "المحور الأساسي", "annex_axis": "المحور الملحق", "tooltip": { "p1": "تساعد المخططات التي تتضمن محوري القاعدة والملحق في إنشاء علاقة بين مجموعتي بيانات.", "li1": "محور الملحق - المعلمات التي نقوم بتحليلها", "li2": "المحور الأساسي - النقطة المرجعية في التحليل", "b": "مثال: أفضل موقع لفتح مقهى", "p2": "يمكننا استكشاف عدد أماكن المطاعم (المحور الملحق) مقابل الكثافة السكانية (المحور الأساسي).", "p3": "في هذا السيناريو، نهتم أولاً بعدد صغير من أماكن تناول الطعام ويعطينا عدد الأشخاص في هذا المكان معلومات إضافية." } }, "header": { "title": "اختر طبقتين لاستكشاف الارتباطات", "hint": "يتم عرض الطبقات والارتباطات للمنطقة المحددة الحالية" }, "icon": { "population": "القيمة مقسومة على عدد السكان", "area_km2": "القيمة مقسومة على المنطقة", "total_building_count": "القيمة مقسومة على تقدير إجمالي المباني", "populated_area_km2": "القيمة مقسومة على المنطقة المأهولة", "one": "بدون فاصل", "roads": "القيمة مقسومة على إجمالي طول الطرق" }, "progress": { "rendering": "استدعاء", "applied": "مطبق على الخريطة" } }, "legend": { "high": "مرتفع", "low": "منخفض", "medium": "متوسط" } };
const toolbar$6 = { "locate_me": "حدد موقعي" };
const locate_me$6 = { "feature_title": "حدد موقعي", "get_location_error": "حدث خطأ أثناء الحصول على الموقع" };
const layer_actions$6 = { "tooltips": {} };
const feed$6 = "تغذية";
const deselect$6 = "إلغاء";
const spinner_text$6 = "جمع البيانات";
const updated$6 = "تحديث";
const no_data_received$6 = "لم تُستقبل أي بيانات";
const wrong_data_received$6 = "تم استلام بيانات خاطئة";
const error$8 = "خطأ";
const sort_icon$6 = "أيقونة الترتيب";
const configs$6 = { "Kontur_public_feed": "Kontur Public", "Kontur_public_feed_description": "يحتوي الموجز على بيانات فورية عن الأعاصير والجفاف والزلازل والفيضانات والبراكين وحرائق الغابات." };
const errors$6 = { "forbidden": "محظور", "not_found": "لم يتم العثور على", "unknown": "غير معروف" };
const event_list$6 = { "severity_unknown": "غير معروف", "analytics": { "affected_people": { "value": "لا أثر إنساني" }, "loss_tooltip": "الخسارة المقدرة" }, "no_selected_disaster": "لم يتم اختيار كارثة", "chose_disaster": "اختر كارثة" };
const categories$6 = { "overlays": "تراكميات", "basemap": "الخريطة الأساسية" };
const groups$6 = { "layers_in_selected_area": "طبقات في المنطقة المختارة", "other": "آخر", "elevation": "ارتفاع", "map": "الخريطة" };
const modes$6 = { "map": "الخريطة", "about": "عن", "reports": "التقارير", "profile": "الملف الشخصي" };
const advanced_analytics_data_list$6 = { "load_world_data": "تحميل بيانات العالم", "numerator": "البسط", "normalized_by": "تطبيع بواسطة", "sum": "مجموع", "min": "الحد الأدنى", "max": "الحد الأقصى", "mean": "المتوسط", "stddev": "Stddev", "median": "الوسيط", "filter_denominator": "مقام المرشح" };
const profile$6 = { "saveButton": "حفظ التغييرات", "reference_area": {}, "email": "البريد الإلكتروني", "interfaceTheme": "النسق", "interfaceLanguage": "اللغة", "units": "الوحدات", "metric": "المقياس", "imperialBeta": "إمبريالي (بيتا)", "bio_placeholder": "السيرة", "appSettingsHeader": "الإعدادات", "konturTheme": "Kontur", "HOTTheme": "حار", "defaultDisasterFeed": "موجز الكوارث الافتراضي", "defaultOSMeditor": "محرر OpenStreetMap الافتراضي (بيتا)", "successNotification": "تم تطبيق جميع التغييرات بنجاح", "languageOption": { "en": "الإنجليزية", "es": "الإسبانية", "ar": "العربية", "ko": "الكورية", "id": "الأندونيسية", "de": "ألمانية", "uk": "الأوكرانية" } };
const multivariate$6 = { "popup": {} };
const search$6 = { "search_location": "البحث عن الموقع" };
const create_layer$6 = { "edit_layer": "تعديل الطبقة", "edit_features": "تعديل الميزات", "delete_layer": "حذف الطبقة", "create_layer": "خلق الطبقة", "saving_layer": "حفظ الطبقة...", "field_name": "اسم المجال", "layer_name": "اسم الطبقة", "marker_icon": "رمز العلامة", "type": "النوع", "select": "تحديد", "short_text": "نص قصير", "long_text": "نص طويل", "link": "رابط", "image": "صورة", "fields": "مجالات", "add_field": "إضافة مجال", "location": "موقع", "edit_feature_placeholder": "حدد بعض الميزات لبدء تحرير خصائص الميزة" };
const analytics_panel$6 = { "header_title": "التحليلات" };
const advanced_analytics_panel$6 = { "header_title": "تحليلات متقدمة", "error": "خطأ أثناء جلب بيانات التحليلات المتقدمة" };
const advanced_analytics_empty$6 = {};
const llm_analytics$6 = { "placeholder": {} };
const draw_tools$6 = { "line": "خط", "point": "نقطة", "finish_drawing": "إنهاء الرسم", "caption": "انقر على الخريطة لبدء الرسم", "no_geometry_error": "لا يوجد مجسم مرسوم للتنزيل", "overlap_error": "يجب ألا يتداخل المضلع مع نفسه", "save_features": "حفظ الميزات" };
const boundary_selector$6 = { "title": "التركيز على الحدود الإدارية" };
const geometry_uploader$6 = { "title": "التركيز على المجسم المحمل", "error": "خطأ أثناء قراءة الملف الذي تم تحميله" };
const focus_geometry$6 = { "title": "ركز على المجسم الحر" };
const reference_area_layer$6 = { "settings": {} };
const sidebar$6 = { "biv_color_manager": "مدير الألوان", "edit_osm": "التعديل في OpenStreetMap", "ruler": "المسطرة", "collapse": "إغلاق", "expand": "فتح", "icon_alt": "شعار التطبيق" };
const login$6 = { "email": "البريد الإلكتروني", "password": "كلمة السر", "login_button": "تسجيل الدخول", "sign_up": "إنشاء حساب", "logging_in": "جارٍ تسجيل الدخول...", "log_in": "تسجيل الدخول", "description": "يرجى تسجيل الدخول لتغيير إعداداتك" };
const currency$6 = {};
const subscription$6 = { "errors": {}, "success_modal": {} };
const reports$6 = { "title": "تقارير Disaster Ninja", "no_data": "لا توجد بيانات لهذا التقرير", "sorting": "جارٍ ترتيب البيانات...", "loading": "جارٍ تحميل البيانات", "open_josm": "الفتح من خلال وحدة تحكم JOSM عن بعد", "josm_logo_alt": "شعار JOSM", "see_all": "عرض جميع التقارير", "wrong_id": "معرف التقرير خاطئ", "description": "ينشئ <0> Kontur</0> عدة تقارير تساعد في التحقق من جودة OpenStreetMap. تحتوي هذه التقارير على روابط لمناطق على <4> osm.org </4> وروابط يمكن فتحها في محرر JOSM مع تمكين التحكم عن بعد للتحرير." };
const about$6 = {};
const loading_episodes$6 = "جارٍ تجميل الحلقات";
const cookie_banner$6 = {};
const live_sensor$6 = {};
const layer_features_panel$6 = {};
const reference_area$6 = {};
const ar_common = {
  km: km$6,
  m: m$6,
  to: to$6,
  maps: maps$6,
  save: save$6,
  cancel: cancel$6,
  mcda: mcda$6,
  create: create$6,
  disasters: disasters$6,
  loading: loading$6,
  legend: legend$6,
  vertical_direction: vertical_direction$6,
  horizontal_direction: horizontal_direction$6,
  legend_presentation: legend_presentation$6,
  layers: layers$6,
  bivariate: bivariate$6,
  toolbar: toolbar$6,
  locate_me: locate_me$6,
  layer_actions: layer_actions$6,
  feed: feed$6,
  deselect: deselect$6,
  spinner_text: spinner_text$6,
  updated: updated$6,
  no_data_received: no_data_received$6,
  wrong_data_received: wrong_data_received$6,
  error: error$8,
  sort_icon: sort_icon$6,
  configs: configs$6,
  errors: errors$6,
  event_list: event_list$6,
  categories: categories$6,
  groups: groups$6,
  modes: modes$6,
  advanced_analytics_data_list: advanced_analytics_data_list$6,
  profile: profile$6,
  multivariate: multivariate$6,
  search: search$6,
  create_layer: create_layer$6,
  analytics_panel: analytics_panel$6,
  advanced_analytics_panel: advanced_analytics_panel$6,
  advanced_analytics_empty: advanced_analytics_empty$6,
  llm_analytics: llm_analytics$6,
  draw_tools: draw_tools$6,
  boundary_selector: boundary_selector$6,
  geometry_uploader: geometry_uploader$6,
  focus_geometry: focus_geometry$6,
  reference_area_layer: reference_area_layer$6,
  sidebar: sidebar$6,
  login: login$6,
  currency: currency$6,
  subscription: subscription$6,
  reports: reports$6,
  about: about$6,
  loading_episodes: loading_episodes$6,
  cookie_banner: cookie_banner$6,
  live_sensor: live_sensor$6,
  layer_features_panel: layer_features_panel$6,
  reference_area: reference_area$6
};
const km$5 = "킬로미터";
const m$5 = "미터";
const to$5 = "목적지";
const maps$5 = "지도";
const save$5 = "저장";
const cancel$5 = "취소";
const mcda$5 = { "btn_cancel": "취소", "legend_title": "범례", "layer_editor": { "outliers_options": {}, "save_changes": "변경 사항 저장", "range_buttons": {}, "transformations": {}, "errors": {}, "tips": {} } };
const create$5 = "생성";
const disasters$5 = "재난";
const loading$5 = "로딩 중...";
const legend$5 = "범례";
const vertical_direction$5 = "수직 방향";
const horizontal_direction$5 = "수평 방향";
const legend_presentation$5 = "범례 표시";
const layers$5 = "레이어";
const bivariate$5 = { "color_manager": { "layers_filter": "레이어", "not_defined": "정의되지 않음", "sentiments_combinations_filter": "감정 조합", "no_legends": "조건을 충족하는 범례가 없습니다.", "no_data": "데이터가 없습니다.", "sentiments_tab": "감정", "color_legends_tab": "색상 범례", "layers_tab": "레이어(지표)" }, "matrix": { "caption": { "base_axis": "기본 축", "annex_axis": "보조 축", "tooltip": { "p1": "기본 축과 보조 축이 포함된 차트를 통해 두 데이터 세트 간의 관계를 설정할 수 있습니다.", "li1": "보조 축 - 분석 대상 매개변수", "li2": "기본 축 - 분석의 기준점", "b": "예: 카페 개업에 최적의 위치", "p2": "인구 밀도(기본 축)에 대한 음식점 개수(보조 축)를 알아볼 수 있습니다.", "p3": "이 경우에는 주로 소수의 음식점에 관심이 있는 것이며, 추가적으로 그 장소에 있는 사람 수를 알아볼 수 있습니다." } }, "header": { "title": "상관 관계를 알아보려면 두 개의 레이어를 선택합니다.", "hint": "레이어와 상관 관계가 현재 선택된 영역에 표시됩니다." }, "icon": { "population": "인구로 나눈 값", "area_km2": "영역으로 나눈 값", "total_building_count": "전체 건물 추정치로 나눈 값", "populated_area_km2": "인구 밀집 지역으로 나눈 값", "one": "나누지 않음", "roads": "전체 도로 길이로 나눈 값" }, "progress": { "rendering": "렌더링", "applied": "지도에 적용됨" } }, "legend": { "high": "높음", "low": "낮음", "medium": "중간" } };
const toolbar$5 = { "locate_me": "내 위치 확인" };
const locate_me$5 = { "feature_title": "내 위치 확인", "get_location_error": "위치를 가져오는 중에 오류가 발생했습니다." };
const layer_actions$5 = { "tooltips": {} };
const feed$5 = "피드";
const deselect$5 = "선택 취소";
const spinner_text$5 = "데이터 수집";
const updated$5 = "업데이트됨";
const no_data_received$5 = "수신한 데이터 없음";
const wrong_data_received$5 = "잘못된 데이터 수신";
const error$7 = "오류";
const sort_icon$5 = "정렬 아이콘";
const configs$5 = { "Kontur_public_feed": "Kontur Public", "Kontur_public_feed_description": "피드에는 사이클론, 가뭄, 지진, 홍수, 화산 폭발, 산불에 대한 실시간 데이터가 포함됩니다." };
const errors$5 = { "forbidden": "사용할 수 없음", "not_found": "찾을 수 없음", "unknown": "알 수 없음" };
const event_list$5 = { "severity_unknown": "알 수 없음", "analytics": { "affected_people": { "value": "인도주의적 영향 없음" }, "loss_tooltip": "예상 손해" }, "no_selected_disaster": "선택된 재난 없음", "chose_disaster": "재난 선택" };
const categories$5 = { "overlays": "오버레이", "basemap": "백지도" };
const groups$5 = { "layers_in_selected_area": "선택 영역 내 레이어", "other": "기타", "elevation": "입면도", "map": "지도" };
const modes$5 = { "map": "지도", "about": "정보", "reports": "보고서", "profile": "프로필" };
const advanced_analytics_data_list$5 = { "load_world_data": "전 세계 데이터 로드하기", "numerator": "분자", "normalized_by": "정규화 기준:", "sum": "합계", "min": "최소", "max": "최대", "mean": "평균", "stddev": "표본 표준 편차", "median": "중앙값", "filter_denominator": "분모 필터" };
const profile$5 = { "saveButton": "변경 사항 저장", "reference_area": {}, "email": "이메일", "interfaceTheme": "주제", "interfaceLanguage": "언어", "units": "단위", "metric": "미터법", "imperialBeta": "영국식 단위(베타)", "bio_placeholder": "Bio", "appSettingsHeader": "설정", "konturTheme": "Kontur", "HOTTheme": "HOT", "defaultDisasterFeed": "기본 재난 피드", "defaultOSMeditor": "기본 OpenStreetMap 편집기(베타)", "successNotification": "모든 변경 사항이 성공적으로 적용되었습니다.", "languageOption": { "en": "영어", "es": "스페인어", "ar": "아랍어", "ko": "한국어", "id": "인도네시아 인", "de": "독일 말", "uk": "우크라이나 인" } };
const multivariate$5 = { "popup": {} };
const search$5 = { "search_location": "위치 검색" };
const create_layer$5 = { "edit_layer": "레이어 편집", "edit_features": "특성 편집", "delete_layer": "레이어 삭제", "create_layer": "레이어 생성", "saving_layer": "레이어 저장 중...", "field_name": "필드 이름", "layer_name": "레이어 이름", "marker_icon": "마커 아이콘", "type": "유형", "select": "선택", "short_text": "짧은 텍스트", "long_text": "긴 텍스트", "link": "링크", "image": "이미지", "fields": "필드", "add_field": "필드 추가", "location": "위치", "edit_feature_placeholder": "일부 특성을 선택하여 특성 속성 편집을 시작하세요." };
const analytics_panel$5 = { "header_title": "분석" };
const advanced_analytics_panel$5 = { "header_title": "고급 분석", "error": "고급 분석 데이터를 가져오는 중에 오류가 발생했습니다." };
const advanced_analytics_empty$5 = {};
const llm_analytics$5 = { "placeholder": {} };
const draw_tools$5 = { "line": "라인", "point": "점", "finish_drawing": "그리기 완료", "caption": "그리기를 시작하려면 지도를 클릭하세요.", "no_geometry_error": "다운로드할 수 있는 기하 도형이 없습니다.", "overlap_error": "다각형은 그 자체로 겹치지 않아야 합니다.", "save_features": "특성 저장" };
const boundary_selector$5 = { "title": "행정 경계에 초점 맞추기" };
const geometry_uploader$5 = { "title": "업로드된 기하 도형에 초점 맞추기", "error": "업로드된 파일을 읽는 중 오류가 발생했습니다." };
const focus_geometry$5 = { "title": "손으로 직접 그린 기하 도형에 초점 맞추기" };
const reference_area_layer$5 = { "settings": {} };
const sidebar$5 = { "biv_color_manager": "색상 관리자", "edit_osm": "OpenStreetMap에서 편집", "ruler": "눈금자", "collapse": "접기", "expand": "펼치기", "icon_alt": "애플리케이션 로고" };
const login$5 = { "email": "이메일", "password": "비밀번호", "login_button": "로그인", "sign_up": "가입", "logging_in": "로그인 중...", "log_in": "로그인", "description": "설정을 변경하려면 로그인하세요." };
const currency$5 = {};
const subscription$5 = { "errors": {}, "success_modal": {} };
const reports$5 = { "title": "Disaster Ninja 보고서", "no_data": "이 보고서에 데이터가 없습니다.", "sorting": "데이터 정렬 중...", "loading": "데이터 로딩 중", "open_josm": "JOSM 원격 제어를 통해 열기", "josm_logo_alt": "JOSM 로고", "see_all": "모든 보고서 보기", "wrong_id": "잘못된 보고서 ID", "description": "<0>Kontur</0>는 몇 가지 보고서를 생성하여 OpenStreetMap 품질을 평가하도록 지원합니다. 보고서에는 <4>osm.org </4>의 영역으로 연결되는 링크, 원격 제어가 활성화된 JOSM 편집기에서 해당 영역을 열어 편집할 수 있는 링크가 포함되어 있습니다." };
const about$5 = { "title": "Disaster Ninja에 오신 것을 환영합니다!", "intro": "현재 진행 중인 재난에 대해 알림을 받아보시겠습니까? 전 세계 모든 지역의 인구 데이터와 기타 분석 사항을 즉시 알아보고 싶으신가요? Disaster Ninja에서는 이러한 요구 사항을 해결하기 위해 몇 가지 <2>Kontur</2> 기능을 사용합니다.<br/><br/>처음에는 인도주의적인 문제를 다루기 위한 의사 결정 지원 도구로 고안되었지만, 이제는 기능과 용법이 여러 가지로 늘어났습니다. 재난 관리, 스마트 시티 구축, 기후 변화에 관한 연구 수행 등 어떤 업무를 하더라도 다음과 같은 도움을 드릴 수 있습니다.", "l1": "1. 전 세계의 최신 위험 이벤트의 동향을 알려 드립니다.", "p1": "재난 패널이 지속적으로 새로 고침 되어 현재 일어나는 이벤트에 대한 정보를 제공합니다. <2>Kontur 이벤트 피드</2>의 데이터를 사용하며, API를 통해서도 해당 데이터에 액세스할 수 있습니다.", "l2": "2. 관심 영역을 집중적으로 보여 드립니다.", "p2": "그리기 도구 패널을 사용하면 자체 기하 도형을 지도에 그리거나 업로드할 수 있습니다. 재난에 노출된 영역이나 행정 단위(예: 국가, 도시, 지역)에 초점을 맞출 수도 있습니다.", "l3": "3. 집중 영역에 대한 분석을 제공합니다.", "p3": "분석 패널은 <2>Kontur 인구</2>당 해당 영역에 거주하는 사람의 수와 OpenStreetMap 내 예상 매핑 갭을 보여줍니다. 그 외에도 Kontur 고객은 고급 분석을 통해 수백 가지 지표에 액세스할 수 있습니다.", "l4": "4. 지도의 데이터를 탐색하여 결론을 내릴 수 있습니다.", "p4": "레이어 패널을 사용하면 이변수 지도에서 두 가지 지표를 동시에 표시하는 다양한 옵션을 사용할 수 있게 됩니다(예: 인구 밀도, 가장 가까운 소방서까지의 거리). 색상 범례를 사용하여 주의가 필요한 영역을 평가하세요. <br/>힌트: 일반적으로 녹색은 저위험/적은 갭을 의미하고 빨간색은 고위험/많은 갭을 의미합니다.", "p5": "또한, 왼쪽 패널의 보고서로 이동하여 OpenStreetMap의 잠재적인 오류 및 불일치 데이터에 액세스하고, JOSM 편집기를 통해 각 영역을 매핑하여 해당 데이터를 수정할 수도 있습니다.", "goToMap": "지금 바로 지도로 이동하세요.", "p6": "이 도구가 많은 도움이 되기를 바랍니다. 기능에 대해 궁금한 점은 Disaster Ninja의 챗박스를 통해 언제든지 문의해 주시면 도와 드리겠습니다. 도구 개선에 대한 피드백이나 제안 사항이 있을 경우, <1>hello@kontur.io</1> 로 이메일 주셔도 됩니다.<br/><br/>Disaster Ninja는 오픈 소스 프로젝트입니다. <8>Kontur의 GitHub 계정</8>에서 코드를 찾아보세요." };
const loading_episodes$5 = "에피소드 로딩 중";
const cookie_banner$5 = {};
const live_sensor$5 = {};
const layer_features_panel$5 = {};
const reference_area$5 = {};
const ko_common = {
  km: km$5,
  m: m$5,
  to: to$5,
  maps: maps$5,
  save: save$5,
  cancel: cancel$5,
  mcda: mcda$5,
  create: create$5,
  disasters: disasters$5,
  loading: loading$5,
  legend: legend$5,
  vertical_direction: vertical_direction$5,
  horizontal_direction: horizontal_direction$5,
  legend_presentation: legend_presentation$5,
  layers: layers$5,
  bivariate: bivariate$5,
  toolbar: toolbar$5,
  locate_me: locate_me$5,
  layer_actions: layer_actions$5,
  feed: feed$5,
  deselect: deselect$5,
  spinner_text: spinner_text$5,
  updated: updated$5,
  no_data_received: no_data_received$5,
  wrong_data_received: wrong_data_received$5,
  error: error$7,
  sort_icon: sort_icon$5,
  configs: configs$5,
  errors: errors$5,
  event_list: event_list$5,
  categories: categories$5,
  groups: groups$5,
  modes: modes$5,
  advanced_analytics_data_list: advanced_analytics_data_list$5,
  profile: profile$5,
  multivariate: multivariate$5,
  search: search$5,
  create_layer: create_layer$5,
  analytics_panel: analytics_panel$5,
  advanced_analytics_panel: advanced_analytics_panel$5,
  advanced_analytics_empty: advanced_analytics_empty$5,
  llm_analytics: llm_analytics$5,
  draw_tools: draw_tools$5,
  boundary_selector: boundary_selector$5,
  geometry_uploader: geometry_uploader$5,
  focus_geometry: focus_geometry$5,
  reference_area_layer: reference_area_layer$5,
  sidebar: sidebar$5,
  login: login$5,
  currency: currency$5,
  subscription: subscription$5,
  reports: reports$5,
  about: about$5,
  loading_episodes: loading_episodes$5,
  cookie_banner: cookie_banner$5,
  live_sensor: live_sensor$5,
  layer_features_panel: layer_features_panel$5,
  reference_area: reference_area$5
};
const km$4 = "km";
const m$4 = "m";
const to$4 = "ke";
const maps$4 = "peta";
const save$4 = "Simpan";
const cancel$4 = "Batalkan";
const mcda$4 = { "btn_cancel": "Batalkan", "legend_title": "Legenda", "layer_editor": { "outliers_options": {}, "save_changes": "Simpan perubahan", "range_buttons": {}, "transformations": {}, "errors": {}, "tips": {} } };
const create$4 = "Buat";
const disasters$4 = "Bencana";
const loading$4 = "Memuat...";
const legend$4 = "Legenda";
const vertical_direction$4 = "Arah vertikal";
const horizontal_direction$4 = "Arah horizontal";
const legend_presentation$4 = "Penyajian legenda";
const layers$4 = "Lapisan";
const bivariate$4 = { "color_manager": { "layers_filter": "Lapisan", "not_defined": "Tidak terdefinisi", "sentiments_combinations_filter": "Gabungan sentimen", "no_legends": "Tidak ada legenda yang memenuhi kondisi ini.", "no_data": "Tidak Ada Data.", "sentiments_tab": "Sentimen", "color_legends_tab": "Legenda Warna", "layers_tab": "Lapisan (indikator)" }, "matrix": { "caption": { "base_axis": "Sumbu Dasar", "annex_axis": "Sumbu Tambahan", "tooltip": { "p1": "Diagram yang mencakup sumbu Dasar dan sumbu Tambahan membantu menetapkan hubungan antara dua kumpulan data.", "li1": "Sumbu Tambahan - parameter yang kita analisis", "li2": "Sumbu Dasar - titik referensi dalam analisis", "b": "Contoh: lokasi terbaik untuk membuka kafe", "p2": "Kita dapat menyelidiki jumlah tempat makan (sumbu Tambahan) terhadap Kerapatan populasi (sumbu Dasar).", "p3": "Dalam skenario ini, pada awalnya kita tertarik dengan beberapa tempat makan, lalu kita mendapatkan informasi tambahan dari jumlah orang di tempat itu." } }, "header": { "title": "Pilih dua lapisan untuk memeriksa korelasi", "hint": "Lapisan dan korelasi ditampilkan untuk Area Pilihan terkini" }, "icon": { "population": "Nilai dibagi dengan Populasi", "area_km2": "Nilai dibagi dengan Area", "total_building_count": "Nilai dibagi dengan Perkiraan Jumlah Bangunan", "populated_area_km2": "Nilai dibagi dengan Area Berpenduduk", "one": "Tanpa pembagi", "roads": "Nilai dibagi dengan Total Panjang Jalan" }, "progress": { "rendering": "Merender", "applied": "Diterapkan pada peta" } }, "legend": { "high": "Tinggi", "low": "Rendah", "medium": "Sedang" } };
const toolbar$4 = { "locate_me": "Temukan saya" };
const locate_me$4 = { "feature_title": "Temukan saya", "get_location_error": "Kesalahan saat memperoleh lokasi" };
const layer_actions$4 = { "tooltips": {} };
const feed$4 = "Feed";
const deselect$4 = "Batalkan Pilihan";
const spinner_text$4 = "Mengumpulkan data";
const updated$4 = "Diperbarui";
const no_data_received$4 = "Tidak ada data yang diterima";
const wrong_data_received$4 = "Data yang diterima salah";
const error$6 = "Kesalahan";
const sort_icon$4 = "Sortir Ikon";
const configs$4 = { "Kontur_public_feed": "Publik Kontur", "Kontur_public_feed_description": "Feed berisi data waktu-nyata tentang Angin Topan, Kekeringan, Gempa, Banjir, Gunung Meletus, Kebakaran Hutan." };
const errors$4 = { "forbidden": "Terlarang", "not_found": "Tidak ditemukan", "unknown": "Tidak diketahui" };
const event_list$4 = { "severity_unknown": "Tidak diketahui", "analytics": { "affected_people": { "value": "Tidak berdampak kemanusiaan" }, "loss_tooltip": "Estimasi kerugian" }, "no_selected_disaster": "Tidak ada bencana yang dipilih", "chose_disaster": "Pilih bencana" };
const categories$4 = { "overlays": "Tumpang Susun", "basemap": "Peta Dasar" };
const groups$4 = { "layers_in_selected_area": "Lapisan di area pilihan", "other": "Lainnya", "elevation": "Elevasi", "map": "Peta" };
const modes$4 = { "map": "Peta", "about": "Tentang", "reports": "Laporan", "profile": "Profil" };
const advanced_analytics_data_list$4 = { "load_world_data": "Memuat Data Dunia", "numerator": "Pembilang", "normalized_by": "Dinormalkan Dengan", "sum": "Jumlah", "min": "Min", "max": "Maks", "mean": "Rerata", "stddev": "Simpangan baku", "median": "Median", "filter_denominator": "Filter Penyebut" };
const profile$4 = { "saveButton": "Simpan perubahan", "reference_area": {}, "email": "Email", "interfaceTheme": "Tema", "interfaceLanguage": "Bahasa", "units": "Satuan", "metric": "metrik", "imperialBeta": "imperial (beta)", "bio_placeholder": "Bio", "appSettingsHeader": "Pengaturan", "konturTheme": "Kontur", "HOTTheme": "HANGAT", "defaultDisasterFeed": "Feed bencana bawaan", "defaultOSMeditor": "Editor OpenStreetMap bawaan (beta)", "successNotification": "Semua perubahan telah berhasil diterapkan", "languageOption": { "en": "Inggris", "es": "Spanyol", "ar": "Arab", "ko": "Korea", "id": "Indonesia", "de": "Jerman", "uk": "Orang Ukraina" } };
const multivariate$4 = { "popup": {} };
const search$4 = { "search_location": "Cari lokasi" };
const create_layer$4 = { "edit_layer": "Edit Lapisan", "edit_features": "Edit Fitur", "delete_layer": "Hapus Lapisan", "create_layer": "Buat Lapisan", "saving_layer": "Menyimpan lapisan...", "field_name": "Nama bidang", "layer_name": "Nama lapisan", "marker_icon": "Ikon penanda", "type": "Jenis", "select": "Pilih", "short_text": "Teks Singkat", "long_text": "Teks Panjang", "link": "Tautan", "image": "Gambar", "fields": "Bidang", "add_field": "Tambahkan bidang", "location": "Lokasi", "edit_feature_placeholder": "Pilih beberapa fitur untuk mulai mengedit properti fitur" };
const analytics_panel$4 = { "header_title": "Analitik" };
const advanced_analytics_panel$4 = { "header_title": "Analitik tingkat lanjut", "error": "Kesalahan saat mengambil data analitik tingkat lanjut" };
const advanced_analytics_empty$4 = {};
const llm_analytics$4 = { "placeholder": {} };
const draw_tools$4 = { "line": "Garis", "point": "Titik", "finish_drawing": "Selesai Menggambar", "caption": "Klik peta untuk mulai menggambar", "no_geometry_error": "Tidak ada gambar geometri untuk diunduh", "overlap_error": "Poligon tidak boleh bertumpang-tindih sendiri", "save_features": "Simpan fitur" };
const boundary_selector$4 = { "title": "Fokus ke batas administratif" };
const geometry_uploader$4 = { "title": "Fokus ke geometri unggahan", "error": "Kesalahan saat membaca file unggahan" };
const focus_geometry$4 = { "title": "Fokus ke geometri bebas" };
const reference_area_layer$4 = { "settings": {} };
const sidebar$4 = { "biv_color_manager": "Pengelola warna", "edit_osm": "Edit di OpenStreetMap", "ruler": "Penggaris", "collapse": "Ciutkan", "expand": "Bentangkan", "icon_alt": "Logo aplikasi" };
const login$4 = { "email": "Email", "password": "Kata Sandi", "login_button": "Masuk", "sign_up": "Daftar", "logging_in": "Masuk...", "log_in": "Masuk", "description": "Masuk untuk mengubah pengaturan Anda" };
const currency$4 = {};
const subscription$4 = { "errors": {}, "success_modal": {} };
const reports$4 = { "title": "Laporan Disaster Ninja", "no_data": "Tidak ada data untuk laporan ini", "sorting": "Menyortir data...", "loading": "Memuat data", "open_josm": "Buka melalui kendali jarak jaruh JOSM", "josm_logo_alt": "Logo JOSM", "see_all": "Lihat semua laporan", "wrong_id": "ID laporan salah", "description": "<0>Kontur </0> menghasilkan beberapa laporan yang membantu memvalidasi kualitas OpenStreetMap. Laporan tersebut berisi tautan ke area di <4>osm.org </4> dan tautan untuk membukanya di editor JOSM dengan kendali jarak jauh untuk pengeditan yang diaktifkan." };
const about$4 = { "title": "Selamat datang di Disaster Ninja!", "intro": "Apakah Anda ingin menerima kabar tentang bencana yang sedang terjadi? Anda tertarik dengan data populasi dan analitik lainnya yang tersaji seketika untuk wilayah mana pun di dunia? Disaster Ninja menampilkan beberapa kemampuan dari <2>Kontur</2> dalam mengatasi berbagai kebutuhan ini.<br/><br/>Pada awalnya, kami merancang alat ini sebagai alat bantu untuk pemetaan kemanusiaan. Kini, fungsionalitas dan kasus penggunaannya telah bertambah. Apakah Anda bekerja pada pengelolaan bencana, membangun kota cerdas, ataupun meneliti perubahan iklim, Disaster Ninja dapat membantu Anda untuk:", "l1": "1. Selalu mendapatkan kabar terbaru tentang kejadian berbahaya terkini di seluruh dunia.", "p1": "Panel Bencana disegarkan secara terus-menerus untuk memberi tahu Anda kejadian yang sedang berlangsung. Panel ini memakai data dari <2>Feed Kejadian Kontur</2>, yang juga dapat diakses melalui API.", "l2": "2. Fokus pada area perhatian Anda.", "p2": "Panel Peralatan Gambar memungkinkan Anda menggambar atau mengunggah geometri Anda sendiri pada peta. Anda juga dapat berfokus pada area yang terpapar bencana atau satuan administratif — negara, kota, atau wilayah.", "l3": "3. Dapatkan analitik untuk area yang menjadi fokus.", "p3": "Panel Analitik memperlihatkan jumlah orang yang tinggal di area tersebut untuk setiap <2>Populasi Kontur</2> dan perkiraan kesenjangan pemetaan di OpenStreetMap. Pelanggan Kontur memiliki akses ke ratusan indikator lainnya melalui Analitik Lanjut.", "l4": "4. Selidiki data pada peta dan buat kesimpulan.", "p4": "Panel Lapisan memberi Anda berbagai opsi untuk menampilkan dua indikator secara serentak pada peta bivariat, misalnya kepadatan populasi dan jarak ke stasiun pemadam kebakaran terdekat. Gunakan legenda warna untuk menilai area mana yang perlu diperhatikan. <br/>Petunjuk: secara umum, warna hijau menunjukkan risiko rendah/sedikit kesenjangan, warna merah — risiko tinggi/banyak kesenjangan.", "p5": "Selain itu, Anda dapat beralih ke Laporan di panel kiri untuk mengakses data tentang potensi kesalahan dan inkonsistensi di OpenStreetMap serta membantu memperbaikinya dengan memetakan masing-masing area menggunakan editor JOSM.", "goToMap": "Buka peta sekarang", "p6": "Kami berharap agar alat ini bermanfaat bagi Anda. Gunakan kotak obrolan di Disaster Ninja untuk setiap pertanyaan tentang fungsionalitas, dan kami dengan senang hati akan memandu Anda. Anda juga dapat menghubungi kami melalui email di <1>hello@kontur.io</1> jika Anda memiliki tanggapan atau saran untuk meningkatkan alat ini.<br/><br/>Disaster Ninja adalah proyek sumber terbuka. Temukan kodenya di <8>akun GitHub Kontur</8>." };
const loading_episodes$4 = "Memuat Episode";
const cookie_banner$4 = {};
const live_sensor$4 = {};
const layer_features_panel$4 = {};
const reference_area$4 = {};
const id_common = {
  km: km$4,
  m: m$4,
  to: to$4,
  maps: maps$4,
  save: save$4,
  cancel: cancel$4,
  mcda: mcda$4,
  create: create$4,
  disasters: disasters$4,
  loading: loading$4,
  legend: legend$4,
  vertical_direction: vertical_direction$4,
  horizontal_direction: horizontal_direction$4,
  legend_presentation: legend_presentation$4,
  layers: layers$4,
  bivariate: bivariate$4,
  toolbar: toolbar$4,
  locate_me: locate_me$4,
  layer_actions: layer_actions$4,
  feed: feed$4,
  deselect: deselect$4,
  spinner_text: spinner_text$4,
  updated: updated$4,
  no_data_received: no_data_received$4,
  wrong_data_received: wrong_data_received$4,
  error: error$6,
  sort_icon: sort_icon$4,
  configs: configs$4,
  errors: errors$4,
  event_list: event_list$4,
  categories: categories$4,
  groups: groups$4,
  modes: modes$4,
  advanced_analytics_data_list: advanced_analytics_data_list$4,
  profile: profile$4,
  multivariate: multivariate$4,
  search: search$4,
  create_layer: create_layer$4,
  analytics_panel: analytics_panel$4,
  advanced_analytics_panel: advanced_analytics_panel$4,
  advanced_analytics_empty: advanced_analytics_empty$4,
  llm_analytics: llm_analytics$4,
  draw_tools: draw_tools$4,
  boundary_selector: boundary_selector$4,
  geometry_uploader: geometry_uploader$4,
  focus_geometry: focus_geometry$4,
  reference_area_layer: reference_area_layer$4,
  sidebar: sidebar$4,
  login: login$4,
  currency: currency$4,
  subscription: subscription$4,
  reports: reports$4,
  about: about$4,
  loading_episodes: loading_episodes$4,
  cookie_banner: cookie_banner$4,
  live_sensor: live_sensor$4,
  layer_features_panel: layer_features_panel$4,
  reference_area: reference_area$4
};
const km$3 = "km";
const m$3 = "m";
const to$3 = "bis";
const maps$3 = "Karten";
const save$3 = "Speichern";
const cancel$3 = "Abbrechen";
const mcda$3 = { "btn_cancel": "Abbrechen", "legend_title": "Legende", "layer_editor": { "outliers_options": {}, "save_changes": "Änderungen speichern", "range_buttons": {}, "transformations": {}, "errors": {}, "tips": {} } };
const create$3 = "Erstellen";
const disasters$3 = "Katastrophen";
const loading$3 = "Wird geladen...";
const legend$3 = "Legende";
const vertical_direction$3 = "Vertikale Richtung";
const horizontal_direction$3 = "Horizontale Richtung";
const legend_presentation$3 = "Darstellung der Legende";
const layers$3 = "Ebenen";
const bivariate$3 = { "color_manager": { "layers_filter": "Ebenen", "not_defined": "Nicht definiert", "sentiments_combinations_filter": "Stimmungs-Kombinationen", "no_legends": "Es gibt keine Legenden, die den Kriterien entsprechen.", "no_data": "Keine Daten.", "sentiments_tab": "Stimmungen", "color_legends_tab": "Farbe Legenden", "layers_tab": "Ebenen (Indikatoren)" }, "matrix": { "caption": { "base_axis": "Basisachse", "annex_axis": "Hilfsachse", "tooltip": { "p1": "Diagramme mit der Basis- und der Hilfsachse helfen, eine Beziehung zwischen zwei Datensätzen herzustellen.", "li1": "Hilfsachse - Parameter, die wir analysieren", "li2": "Basisachse - Referenzpunkt in der Analyse", "b": "Beispiel: der beste Standort für die Eröffnung eines Cafés", "p2": "Wir können die Anzahl der Lokale (Hilfsachse) gegen die Bevölkerungsdichte (Basisachse) untersuchen.", "p3": "In diesem Szenario liegt unser Interesse zunächst auf einer kleinen Anzahl von Lokalen, wobei uns die Anzahl der Personen in diesem Ort zusätzliche Informationen liefert." } }, "header": { "title": "Wählen Sie zwei Ebenen, um Zusammenhänge zu untersuchen", "hint": "Die Ebenen und Zusammenhänge werden für den aktuellen ausgewählten Bereich angezeigt" }, "icon": { "population": "Wert geteilt durch Einwohnerzahl", "area_km2": "Wert geteilt durch Fläche", "total_building_count": "Wert geteilt durch geschätzte Gesamtbebauung", "populated_area_km2": "Wert geteilt durch bevölkerte Fläche", "one": "Ohne Teilung", "roads": "Wert geteilt durch die Gesamtlänge der Straßen" }, "progress": { "rendering": "Übertragung", "applied": "Wird auf die Karte angewendet" } }, "legend": { "high": "Hoch", "low": "Niedrig", "medium": "Mittel" } };
const toolbar$3 = { "locate_me": "Standort finden" };
const locate_me$3 = { "feature_title": "Standort finden", "get_location_error": "Fehler beim Abrufen des Standorts" };
const layer_actions$3 = { "tooltips": {} };
const feed$3 = "Feed";
const deselect$3 = "Auswahl aufheben";
const spinner_text$3 = "Daten sammeln";
const updated$3 = "Aktualisiert";
const no_data_received$3 = "Keine Daten erhalten";
const wrong_data_received$3 = "Falsche Daten empfangen";
const error$5 = "Fehler";
const sort_icon$3 = "Sortiersymbol";
const configs$3 = { "Kontur_public_feed": "Kontur Öffentlichkeit", "Kontur_public_feed_description": "Der Feed enthält Echtzeitdaten über Wirbelstürme, Dürren, Erdbeben, Überschwemmungen, Vulkanausbrüche und Waldbrände." };
const errors$3 = { "forbidden": "Verboten", "not_found": "Nicht gefunden", "unknown": "Unbekannt" };
const event_list$3 = { "severity_unknown": "Unbekannt", "analytics": { "affected_people": { "value": "Keine humanitären Auswirkungen" }, "loss_tooltip": "Geschätzter Verlust" }, "no_selected_disaster": "Keine Katastrophe ausgewählt", "chose_disaster": "Katastrophe auswählen" };
const categories$3 = { "overlays": "Überlagerungen", "basemap": "Basiskarte" };
const groups$3 = { "layers_in_selected_area": "Ebenen im ausgewählten Bereich", "other": "Andere", "elevation": "Höhe", "map": "Karte" };
const modes$3 = { "map": "Karte", "about": "Über uns", "reports": "Berichte", "profile": "Profil" };
const advanced_analytics_data_list$3 = { "load_world_data": "Weltdaten laden", "numerator": "Zähler", "normalized_by": "Normalisiert auf", "sum": "Summe", "min": "Min", "max": "Max", "mean": "Mittelwert", "stddev": "SD", "median": "Median", "filter_denominator": "Filter Nenner" };
const profile$3 = { "saveButton": "Änderungen speichern", "reference_area": {}, "email": "E-Mail", "interfaceTheme": "Thema", "interfaceLanguage": "Sprache", "units": "Einheiten", "metric": "metrisch", "imperialBeta": "imperial (beta)", "bio_placeholder": "Bio", "appSettingsHeader": "Einstellungen", "konturTheme": "Kontur", "HOTTheme": "HOT", "defaultDisasterFeed": "Standardmäßige Katastrophenmeldung", "defaultOSMeditor": "Standardmäßiger OpenStreetMap-Editor (Beta)", "successNotification": "Alle Änderungen wurden erfolgreich übernommen", "languageOption": { "en": "Englisch", "es": "Spanisch", "ar": "Arabisch", "ko": "Koreanisch", "id": "Indonesisch", "de": "Deutsch", "uk": "Ukrainisch" } };
const multivariate$3 = { "popup": {} };
const search$3 = { "search_location": "Standort suchen" };
const create_layer$3 = { "edit_layer": "Ebene bearbeiten", "edit_features": "Merkmale bearbeiten", "delete_layer": "Ebene löschen", "create_layer": "Ebene erstellen", "saving_layer": "Ebene wird gespeichert...", "field_name": "Feldname", "layer_name": "Name der Ebene", "marker_icon": "Markierungssymbol", "type": "Typ", "select": "Auswählen", "short_text": "Kurzer Text", "long_text": "Langer Text", "link": "Link", "image": "Bild", "fields": "Felder", "add_field": "Feld hinzufügen", "location": "Standort", "edit_feature_placeholder": "Wählen Sie einige Merkmale aus, um Merkmalseigenschaften zu bearbeiten" };
const analytics_panel$3 = { "header_title": "Analytik" };
const advanced_analytics_panel$3 = { "header_title": "Erweiterte Analytik", "error": "Fehler beim Abrufen von erweiterten Analysedaten" };
const advanced_analytics_empty$3 = {};
const llm_analytics$3 = { "placeholder": {} };
const draw_tools$3 = { "line": "Linie", "point": "Punkt", "finish_drawing": "Zeichnen beenden", "caption": "Klicken Sie auf die Karte, um mit dem Zeichnen zu beginnen", "no_geometry_error": "Keine gezeichnete Formen zum Herunterladen", "overlap_error": "Das Polygon darf sich nicht überschneiden", "save_features": "Merkmale speichern" };
const boundary_selector$3 = { "title": "Fokus auf die Verwaltungsgrenze" };
const geometry_uploader$3 = { "title": "Fokus auf die hochgeladene geometrische Form", "error": "Fehler beim Lesen der hochgeladenen Datei" };
const focus_geometry$3 = { "title": "Fokus auf freihändig gezeichnete Formen" };
const reference_area_layer$3 = { "settings": {} };
const sidebar$3 = { "biv_color_manager": "Farbmanager", "edit_osm": "In OpenStreetMap bearbeiten", "ruler": "Lineal", "collapse": "Zusammenklappen", "expand": "Erweitern", "icon_alt": "Logo der Anwendung" };
const login$3 = { "email": "E-Mail", "password": "Passwort", "login_button": "Anmelden", "sign_up": "Registrieren", "logging_in": "Anmelden...", "log_in": "Einloggen", "description": "Bitte melden Sie sich an, um Ihre Einstellungen zu ändern" };
const currency$3 = {};
const subscription$3 = { "errors": {}, "success_modal": {} };
const reports$3 = { "title": "Disaster Ninja Berichte", "no_data": "Keine Daten für diesen Bericht", "sorting": "Daten werden sortiert...", "loading": "Daten werden geladen", "open_josm": "Öffnen über die JOSM-Fernsteuerung", "josm_logo_alt": "JOSM-Logo", "see_all": "Alle Berichte anzeigen", "wrong_id": "Falsche Berichts-ID", "description": "<0>Kontur </0> generiert verschiedene Berichte, die bei der Überprüfung der Qualität von OpenStreetMap helfen. Sie enthalten Links zu Gebieten auf <4>osm.org </4> und Links, um sie im JOSM-Editor mit aktivierter Fernsteuerung zur Bearbeitung öffnen zu können." };
const about$3 = { "title": "Willkommen bei Disaster Ninja!", "intro": "Möchten Sie über aktuelle Katastrophen informiert werden? Sind Sie an sofortigen Bevölkerungsdaten und anderen Analysen für eine beliebige Region auf der Welt interessiert? Disaster Ninja zeigt Ihnen einige der Funktionen von <2>Kontur</2>, mit denen diese Anforderungen umgesetzt werden können.<br/><br/>Ursprünglich haben wir es als Entscheidungshilfe für Kartografen im humanitären Bereich entwickelt. Mittlerweile ist der Funktionsumfang und der Anwendungsbereich des Programms erweitert worden. Ganz gleich, ob Sie im Katastrophenmanagement tätig sind, eine intelligente Stadt bauen oder über den Klimawandel forschen, Disaster Ninja kann Ihnen dabei helfen:", "l1": "1. Über die aktuellen Gefahrenereignisse weltweit auf dem Laufenden zu bleiben.", "p1": "Das Bedienfeld von Disasters wird kontinuierlich aktualisiert, um Sie über aktuelle Ereignisse zu informieren. Es bezieht die Daten aus dem <2>Kontur Ereignis-Feed</2>, auf den Sie auch über eine API zugreifen können.", "l2": "2. Den Fokus auf Ihr Interessengebiet zu legen.", "p2": "Mit den Zeichenwerkzeugen können Sie Ihre eigene geometrische Form auf die Karte zeichnen oder hochladen. Sie können sich auch auf ein von einer Katastrophe betroffenes Gebiet oder eine Verwaltungseinheit - ein Land, eine Stadt oder eine Region - konzentrieren.", "l3": "3. Die Analytik für den ausgewählten Bereich aufrufen.", "p3": "Das Bedienfeld Analytik zeigt die Anzahl der in diesem Gebiet lebenden Menschen pro <2>Kontur Bevölkerung</2> und geschätzte Kartierungslücken in OpenStreetMap. Kontur-Kunden haben über Erweiterte Analytik Zugang zu Hunderten von weiteren Indikatoren.", "l4": "4. Die Daten auf der Karte entdecken und Schlussfolgerungen ziehen.", "p4": "Das Ebenen-Panel bietet Ihnen verschiedene Optionen, um zwei Indikatoren gleichzeitig auf einer bivariaten Karte anzuzeigen, z. B. die Bevölkerungsdichte und die Entfernung zur nächsten Feuerwache. Verwenden Sie die Farblegende, um zu beurteilen, welche Bereiche Aufmerksamkeit erfordern. <br/>Tipp: Im Allgemeinen bedeutet grün ein geringes Risiko / wenige Lücken, rot ein hohes Risiko / viele Lücken.", "p5": "Außerdem können Sie im linken Bereich zu Berichte wechseln, um auf Daten zu potenziellen Fehlern und Unstimmigkeiten in OpenStreetMap zuzugreifen und dabei zu helfen, diese zu beheben, indem Sie das entsprechende Gebiet mit dem JOSM-Editor kartieren.", "goToMap": "Jetzt die Karte aufrufen", "p6": "Wir hoffen, dass dieses Tool Ihnen von Nutzen ist. Wenn Sie Fragen zur Funktionalität haben, können Sie die Chatbox auf Disaster Ninja nutzen, und wir helfen Ihnen gerne weiter. Sie können uns auch eine E-Mail an <1>hello@kontur.io</1> schreiben, wenn Sie Feedback oder Vorschläge zur Verbesserung des Tools haben.<br/><br/>Disaster Ninja ist ein Open-Source-Projekt. Sie finden den Code in <8>Konturs GitHub-Konto</8>." };
const loading_episodes$3 = "Episoden werden geladen";
const cookie_banner$3 = {};
const live_sensor$3 = {};
const layer_features_panel$3 = {};
const reference_area$3 = {};
const de_common = {
  km: km$3,
  m: m$3,
  to: to$3,
  maps: maps$3,
  save: save$3,
  cancel: cancel$3,
  mcda: mcda$3,
  create: create$3,
  disasters: disasters$3,
  loading: loading$3,
  legend: legend$3,
  vertical_direction: vertical_direction$3,
  horizontal_direction: horizontal_direction$3,
  legend_presentation: legend_presentation$3,
  layers: layers$3,
  bivariate: bivariate$3,
  toolbar: toolbar$3,
  locate_me: locate_me$3,
  layer_actions: layer_actions$3,
  feed: feed$3,
  deselect: deselect$3,
  spinner_text: spinner_text$3,
  updated: updated$3,
  no_data_received: no_data_received$3,
  wrong_data_received: wrong_data_received$3,
  error: error$5,
  sort_icon: sort_icon$3,
  configs: configs$3,
  errors: errors$3,
  event_list: event_list$3,
  categories: categories$3,
  groups: groups$3,
  modes: modes$3,
  advanced_analytics_data_list: advanced_analytics_data_list$3,
  profile: profile$3,
  multivariate: multivariate$3,
  search: search$3,
  create_layer: create_layer$3,
  analytics_panel: analytics_panel$3,
  advanced_analytics_panel: advanced_analytics_panel$3,
  advanced_analytics_empty: advanced_analytics_empty$3,
  llm_analytics: llm_analytics$3,
  draw_tools: draw_tools$3,
  boundary_selector: boundary_selector$3,
  geometry_uploader: geometry_uploader$3,
  focus_geometry: focus_geometry$3,
  reference_area_layer: reference_area_layer$3,
  sidebar: sidebar$3,
  login: login$3,
  currency: currency$3,
  subscription: subscription$3,
  reports: reports$3,
  about: about$3,
  loading_episodes: loading_episodes$3,
  cookie_banner: cookie_banner$3,
  live_sensor: live_sensor$3,
  layer_features_panel: layer_features_panel$3,
  reference_area: reference_area$3
};
const km$2 = "км";
const m$2 = "м";
const to$2 = "до";
const maps$2 = "мапи";
const logout$2 = "Вийти";
const save$2 = "Зберегти";
const cancel$2 = "Скасувати";
const mcda$2 = { "btn_cancel": "Скасувати", "legend_title": "Легенда", "layer_editor": { "outliers_options": { "hide": "Приховати" }, "save_changes": "Зберегти зміни", "range_buttons": {}, "transformations": {}, "errors": {}, "tips": {} } };
const ok$2 = "OK";
const create$2 = "Створити";
const disasters$2 = "Катастрофа";
const loading$2 = "Завантаження...";
const legend$2 = "Легенда";
const vertical_direction$2 = "По вертикалі";
const horizontal_direction$2 = "По горизонталі";
const legend_presentation$2 = "Презентація легенди";
const layers$2 = "Шари";
const bivariate$2 = { "color_manager": { "layers_filter": "Шари", "not_defined": "Не задано", "sentiments_combinations_filter": "Комбінація сентиментів", "no_legends": "Немає легенд, що задовольняють умовам.", "no_data": "Немає даних.", "sentiments_tab": "Сентименти", "color_legends_tab": "Легенда кольорів", "layers_tab": "Шари (індикатори)" }, "panel": { "header": "Біваріативна Матриця" }, "matrix": { "caption": { "base_axis": "Базова вісь", "annex_axis": "Додаткова вісь", "tooltip": { "p1": "Діаграми, що містять базову та додаткову осі, допомагають встановити зв’язок між двома наборами даних.", "li1": "Додаткова вісь - параметри, які ми аналізуємо", "li2": "Базова вісь - орієнтир при аналізі", "b": "Наприклад: найкраще місце щоб відкрити кафе", "p2": "Ми можемо дослідити кількість закладів харчування (додаткова вісь) проти щільності населення (базова вісь).", "p3": "У цьому сценарії нас спочатку цікавить невелика кількість закладів харчування, а кількість людей у цьому місці дає нам додаткову інформацію." } }, "header": { "title": "Виберіть два шари, щоб дослідити їх кореляції", "hint": "Шари та кореляції показані для виділеної області" }, "icon": { "population": "Значення, поділене на кількість населення", "area_km2": "Значення, поділене на площу", "total_building_count": "Значення, поділене на загальну кількість будівель", "populated_area_km2": "Значення, поділене на заселену площу", "one": "Без знаменника", "roads": "Значення, поділене на загальну довжину доріг" }, "progress": { "rendering": "Візуалізація", "applied": "Нанесено на карту" }, "loading_error": "На жаль, ми не можемо показати матрицю. Спробуйте оновити сторінку або зачекать." }, "legend": { "high": "Високий", "low": "Низький", "medium": "Середній" } };
const toolbar$2 = { "map_ruler": "Виміряти відстань", "locate_me": "Знайти мене", "panel_title": "Панель інструментів", "download": "Завантажити", "delete": "Видалити", "boundary_selector": "Вибрати адміністративний кордон", "create_layer": "Створити шар", "geometry_uploader": "Завантажити GeoJSON", "focused_geometry_editor": "Намалювати або редагувати геометрію", "edit_in_osm": "Редагувати мапу в OpenStreetMap", "record_sensors": "Записати дані сенсорів", "tools_label": "Інструменти", "selected_area_label": "Вибрана область", "upload_mcda": "Завантажити MCDA" };
const locate_me$2 = { "feature_title": "Знайти мене", "get_location_error": "Помилка під час визначення місцеположення" };
const layer_actions$2 = { "tooltips": { "download": "Завантажити", "erase": "Стерти", "edit": "Редагувати", "hide": "Приховати", "show": "Показати" } };
const focus_geometry_layer$2 = { "settings": { "name": "Вибрана область" } };
const feed$2 = "Стрічка";
const deselect$2 = "Зняти вибір";
const spinner_text$2 = "Збираємо дані";
const updated$2 = "Оновлено";
const no_data_received$2 = "Немає даних";
const wrong_data_received$2 = "Отримано неправильні дані";
const error$4 = "Помилка";
const sort_icon$2 = "Значок сортування";
const configs$2 = { "Kontur_public_feed_description": "Стрічка містить дані в реальному часі про циклони, посухи, землетруси, повені, вулкани, лісові пожежі." };
const errors$2 = { "default": "Вибачте, у нас виникли проблеми, які незабаром будуть вирішені", "timeout": "Час очікування запиту минув", "cannot_connect": "Не вдається під'єднатися до сервера", "forbidden": "Заборонено", "not_found": "Не знайдено", "unknown": "Невідомий", "server_error": "Помилка серверу", "error_try_again": "Щось пішло не так. Будь ласка, спробуйте знову" };
const event_list$2 = { "severity_unknown": "Невідомий", "warning_description": "Карта ще не готова, спробуйте пізніше", "analytics": { "affected_people": { "tooltip": "Люди які постраждали", "value": "Жодного гуманітарного впливу" }, "settled_area_tooltip": "Заселений район", "loss_tooltip": "Орієнтовні збитки" }, "no_selected_disaster": "Катастрофа не вибрана", "chose_disaster": "Виберіть катастрофу", "no_historical_disasters": "Катастроф на цій території не знайдено", "no_feed_disasters": "У стрічці немає катастроф", "no_disasters": "Ніяких катастроф", "severity_termination": "Припинення", "severity_minor": "Незначний", "severity_moderate": "Помірний", "severity_severe": "Сильний", "severity_extreme": "Екстримальний", "open_timeline_button": "Відкрити темпоральну шкалу" };
const categories$2 = { "overlays": "Оверлеї", "basemap": "Базова карта" };
const groups$2 = { "layers_in_selected_area": "Шари у вибраній області", "your_layers": "Ваші шари", "kontur_analytics": "Аналітика Kontur", "qa": "Інспектор OpenStreetMap", "osmbasedmap": "На основі OpenStreetMap", "other": "Інше", "elevation": "Рел'єф", "photo": "Зображення", "map": "Мапа" };
const modes$2 = { "map": "Мапа", "about": "Про нас", "reports": "Звіти", "profile": "Профіль", "privacy": "Конфіденційність" };
const advanced_analytics_data_list$2 = { "load_world_data": "Завантажити дані на всю планету", "numerator": "Чисельник", "normalized_by": "Нормалізовано за", "sum": "Сума", "min": "Мін.", "max": "Макс.", "mean": "Середнє", "stddev": "Стандартне відхилення", "median": "Медіана", "filter_numerator": "Фільтр чисельника", "filter_denominator": "Фільтр знаменника" };
const profile$2 = { "saveButton": "Зберегти зміни", "reference_area": {}, "email": "Електронна пошта", "interfaceTheme": "Тема", "interfaceLanguage": "Мова", "units": "Одиниці вимірювання", "metric": "метрична система", "imperialBeta": "англійська система (бета)", "bio_placeholder": "Про себе", "appSettingsHeader": "Налаштування", "position": "Позиція", "defaultDisasterFeed": "Стрічка катастроф за замовчуванням", "defaultOSMeditor": "Редактор OpenStreetMap за замовчуванням (бета)", "successNotification": "Усі зміни успішно застосовано", "languageOption": { "en": "Англійська", "es": "Іспанська", "ar": "Арабська", "ko": "Корейська", "id": "Індонезійська", "de": "Німецька", "be": "Білоруська", "ru": "Російська", "uk": "Українська" } };
const multivariate$2 = { "popup": {} };
const search$2 = { "search_location": "Знайти місцеположення", "mcda_create_analysis": "Створити аналіз" };
const episode$2 = "Відкрити темпоральну шкалу";
const create_layer$2 = { "edit_layer": "Редагувати шар", "edit_features": "Редагувати об'єкт", "delete_layer": "Видалити шар", "create_layer": "Створити шар", "saving_layer": "Зберігаємо зміни...", "field_name": "Назва поля", "layer_name": "Назва шару", "marker_icon": "Значок маркера", "type": "Тип", "select": "Вибрати", "short_text": "Текст(короткий)", "long_text": "Текст(довгий)", "link": "Посилання", "image": "Зображення", "fields": "Поля", "add_field": "Додати поле", "location": "Позиція", "edit_feature_placeholder": "Виберіть об’єкт для редагування його значень" };
const analytics_panel$2 = { "header_title": "Аналітика", "info_short": "Аналітика для обраної території" };
const advanced_analytics_panel$2 = { "header_title": "Розширена аналітика", "error": "Помилка під час отримання даних розширеної аналітики" };
const advanced_analytics_empty$2 = { "not_found": "Вибачте, запитана катастрофа не знайдена", "error": "Сталася помилка", "analytics_for_selected": "Аналітика для обраної території", "will_be_provided": "буде надано тут" };
const current_event$2 = { "not_found_request": "Вибачте, запитана катастрофа не знайдена" };
const llm_analytics$2 = { "placeholder": {} };
const draw_tools$2 = { "line": "Лінія", "point": "Точка", "finish_drawing": "Закінчити малювання", "caption": "Натисніть на карту, щоб почати малювати", "no_geometry_error": "Немає геометрії для завантаження", "overlap_error": "Полігон не має перетинати сам себе", "save_features": "Зберегти об'єкти" };
const boundary_selector$2 = { "title": "Фокусувати на адміністративну одиницю" };
const geometry_uploader$2 = { "title": "Фокусувати на завантажену геометрію", "error": "Помилка під час завантаження файлу" };
const focus_geometry$2 = { "title": "Фокусувати на намальовану геометрію" };
const reference_area_layer$2 = { "settings": {} };
const drawings$2 = { "self_directions_not_supported": "Самоперетин не підтримується!" };
const sidebar$2 = { "biv_color_manager": "Редактор кольорів", "edit_osm": "Редагувати в OpenStreetMap", "ruler": "Лінійка", "collapse": "Згорнути", "expand": "Розгорнути", "icon_alt": "Логотип аплікації" };
const login$2 = { "email": "Електронна пошта", "password": "Пароль", "login_button": "Логін", "sign_up": "Зареєструватися", "logging_in": "Входимо...", "log_in": "Увійти", "forgot_password": "Забули пароль?", "description": "Увійдіть, щоб змінити налаштування", "error": { "email_empty": "Електронна пошта не може бути пустою", "email_invalid": "Електронна пошта має бути коректною", "password": "Пароль не може бути пустим", "connect": "Не вдалося під'єднатися до служби аутентифікації" } };
const currency$2 = {};
const subscription$2 = { "errors": {}, "success_modal": {} };
const reports$2 = { "title": "Звіти Disaster Ninja", "no_data": "Нема даних для звіту", "sorting": "Сортуємо дані...", "loading": "Завантажуємо дані", "open_josm": "Відкрити в JOSM", "josm_logo_alt": "Логотип JOSM", "see_all": "Дивитися всі звіти", "wrong_id": "Неправильний ID звіту", "description": "<0>Kontur </0> генерує декілька звітів які допомагають перевіряти якість даних OpenStreetMap. Вони містять посилання на <4>osm.org</4> і посилання, щоб відкрити їх у редакторі JOSM для редагування." };
const about$2 = { "title": "Вітаємо на Disaster Ninja!", "intro": "Ви хочете отримувати повідомлення про катастрофи? Вас цікавлять миттєві дані про населення та інша аналітика для будь-якого регіону світу? Disaster Ninja від <2>Kontur</2> може задовольнити ці потреби.<br/><br/> Ми розробили це як інструмент підтримки прийняття рішень для гуманітарних картографів. Тепер його функціональність зросла. Незалежно від того, чи працюєте ви в сфері боротьби зі стихійними лихами, будуєте розумне місто чи проводите дослідження щодо зміни клімату, Disaster Ninja може вам допомогти:", "l1": "1. Будьте в курсі останніх катастроф у всьому світі.", "p1": "Панель Катастроф постійно оновлюється, щоб інформувати вас про поточні події. Дані отримані з каналу подій <2>Kontur</2>, до якого також можна отримати доступ через API.", "l2": "2. Фокусуйтеся на вашій сфері інтересів.", "p2": 'Панель "Інструменти малювання" дозволяє малювати або завантажувати власну геометрію на карту. Ви також можете фокусуватися на області, що постраждала від стихійного лиха, або на адміністративній одиниці — країна, район чи місто.', "l3": "3. Отримайте аналітику для вибраної області.", "p3": "Панель Аналітика показує кількість людей, які проживають у цьому регіоні на основі <2>населення Kontur</2> і потенційні прогалини картографування в OpenStreetMap. Клієнти Kontur мають доступ до сотень інших показників за допомогою Детальної Аналітики.", "l4": "4. Досліджуйте дані на карті та робіть висновки.", "p4": 'Панель "Шари" надає різні параметри для одночасного відображення двох індикаторів на карті, наприклад, щільність населення та відстань до найближчої пожежної частини. Використовуйте легенду кольорів, щоб визначити, які області потребують уваги. <br/>Підказка: загалом зелений колір означає низький ризик / мало прогалин, червоний — високий ризик / багато прогалин.', "p5": "Крім того, ви можете перейти до звітів на лівій панелі, щоб отримати доступ до даних про потенційні помилки та невідповідності в даних OpenStreetMap і допомогти їх виправити, наприклад за допомогою редактора JOSM.", "goToMap": "Перейти до мапи", "p6": "Ми сподіваємося, що цей інструмент буде корисний. Використовуйте вікно чату на Disaster Ninja, щоб задати будь-які запитання щодо функціональності, і ми з радістю допоможемо вам. Ви також можете зв’язатися з нами електронною поштою <1>hello@kontur.io</1> якщо у вас є відгуки чи пропозиції щодо вдосконалення інструменту.<br/><br/> Disaster Ninja є проєктом з відкритим кодом. Дивіться код в обліковому записі GitHub <8>Kontur</8>." };
const loading_episodes$2 = "Завантаження епізодів";
const cookie_banner$2 = { "header": "Ми цінуємо вашу приватність", "body": "Ми використовуємо абсолютно необхідні файли cookies, щоб надавати вам персоналізовані послуги, і додаткові файли cookies, щоб покращити Disaster Ninja та ваш досвід. Ви можете будь-коли змінити налаштування файлів cookies або відкликати згоду на використання додаткових файлів cookies.\nЩоб дізнатися більше, перегляньте нашу [Політику конфіденційності](about/privacy)", "decline_all": "Відхилити файли cookies", "accept_all": "Прийняти файли cookies" };
const live_sensor$2 = { "start": "Почати запис даних з сенсорів", "finish": "Зупинити запис даних з сенсорів", "finishMessage": "Запис даних завершенно", "startMessage": "Запис даних розпочато", "noSensorsError": "Ваш пристрій не має необхідних сенсорів" };
const layer_features_panel$2 = {};
const reference_area$2 = {};
const uk_common = {
  km: km$2,
  m: m$2,
  to: to$2,
  maps: maps$2,
  logout: logout$2,
  save: save$2,
  cancel: cancel$2,
  mcda: mcda$2,
  ok: ok$2,
  create: create$2,
  disasters: disasters$2,
  loading: loading$2,
  legend: legend$2,
  vertical_direction: vertical_direction$2,
  horizontal_direction: horizontal_direction$2,
  legend_presentation: legend_presentation$2,
  layers: layers$2,
  bivariate: bivariate$2,
  toolbar: toolbar$2,
  locate_me: locate_me$2,
  layer_actions: layer_actions$2,
  focus_geometry_layer: focus_geometry_layer$2,
  feed: feed$2,
  deselect: deselect$2,
  spinner_text: spinner_text$2,
  updated: updated$2,
  no_data_received: no_data_received$2,
  wrong_data_received: wrong_data_received$2,
  error: error$4,
  sort_icon: sort_icon$2,
  configs: configs$2,
  errors: errors$2,
  event_list: event_list$2,
  categories: categories$2,
  groups: groups$2,
  modes: modes$2,
  advanced_analytics_data_list: advanced_analytics_data_list$2,
  profile: profile$2,
  multivariate: multivariate$2,
  search: search$2,
  episode: episode$2,
  create_layer: create_layer$2,
  analytics_panel: analytics_panel$2,
  advanced_analytics_panel: advanced_analytics_panel$2,
  advanced_analytics_empty: advanced_analytics_empty$2,
  current_event: current_event$2,
  llm_analytics: llm_analytics$2,
  draw_tools: draw_tools$2,
  boundary_selector: boundary_selector$2,
  geometry_uploader: geometry_uploader$2,
  focus_geometry: focus_geometry$2,
  reference_area_layer: reference_area_layer$2,
  drawings: drawings$2,
  sidebar: sidebar$2,
  login: login$2,
  currency: currency$2,
  subscription: subscription$2,
  reports: reports$2,
  about: about$2,
  loading_episodes: loading_episodes$2,
  cookie_banner: cookie_banner$2,
  live_sensor: live_sensor$2,
  layer_features_panel: layer_features_panel$2,
  reference_area: reference_area$2
};
const km$1 = "км";
const m$1 = "м";
const to$1 = "да";
const or$1 = "ці";
const maps$1 = "Мапы";
const logout$1 = "Выйсці";
const save$1 = "Захаваць";
const cancel$1 = "Адмяніць";
const mcda$1 = { "btn_cancel": "Адмяніць", "legend_title": "Легенда", "layer_editor": { "outliers_options": { "hide": "Схаваць", "clamp": "Абмежаваць", "dont_modify": "Не змяняць" }, "save_changes": "Захаваць змены", "range": "Дыяпазон значэнняў", "outliers": "Выбітныя значэнні", "reverse_to_good_bad": "Перавярнуць на Добра → Дрэнна", "reverse_to_bad_good": "Перавярнуць на Дрэнна → Добра", "weight": "Вага", "transform": "Трансфармаваць", "transformation": "Трансфармацыя", "normalize": "Нармалізаваць", "normalization": "Нармалізацыя", "range_buttons": { "full_range": "Поўны дыяпазон", "3_sigma": "3σ", "2_sigma": "2σ", "1_sigma": "1σ" }, "transformations": { "no_transformation": "Без трансфармацыі", "square_root": "Квадратны корань: sign(x)⋅√|x|", "cube_root": "Кубічны корань: ∛x", "log": "log₁₀(x - xmin + 1)", "log_epsilon": "log₁₀(x - xmin + ε)" }, "no": "Без нармалізацыі", "max_min": "Максімум-мінімум", "errors": { "weight_cannot_be_empty": "Вага не можа быць пустой", "weight_must_be_a_number": "Вага павінна быць лікам", "range_from_cannot_be_bigger": "Значэнне ‘ад’ не можа быць большым за значэнне ‘да’", "range_cannot_be_empty": "Дыяпазон не можа быць пустым", "range_must_be_a_number": "Дыяпазон павінен быць лікам" }, "tips": { "range": "Значэнні, якія будуць лічыцца найгоршымі і найлепшымі ў вашым аналізе.", "sentiment": "Вызначце кірунак уздзеяння для аналізу:\n* **Дрэнна → Добра**: Больш высокія значэнні паказваюць на станоўчы напрамак.\n* **Добра → Дрэнна**: Больш высокія значэнні паказваюць на адмоўны напрамак.", "weight": "Па змаўчанні ўсе слаі аднолькава ўплываюць на аналіз праз узважаную сярэднюю. Павелічэнне вагі слоя (напрыклад, 2, 3 і г.д.) дазваляе вам надаць яму большую важкасць у аналізе.", "transform": "Прымяняйце разлікі да значэнняў. Атрыманне больш лінейнага размеркавання забяспечыць карысную інфармацыю для аналізу.\n\n **Заўвага**: Разлікі выконваюцца перад нармалізацыяй.", "normalize": "Прыводзіць значэнні да стандартызаванай шкалы. Гэта дапамагае лёгка параўноўваць іх і прымаць рашэнні.\n* **Стандартная шкала адзнак**: Гэты варыянт прыводзіць значэнні да стандартызаванай шкалы, робячы іх супастаўнымі.\n* **Не (толькі для спецыялістаў)**: Пакідае значэнні без змен.", "outliers": "* **Абмежаваць**: Задаць значэнні вышэй за дыяпазон як 1, ніжэй — як 0.\n* **Не змяняць**: Захаваць 0 і 1 як мінімум і максімум, але дапускаць значэнні за межамі гэтага дыяпазону.\n* **Выключыць**: Выключыць з аналізу вобласці, дзе значэнні выходзяць за межы дыяпазону." } }, "title": "Шматкрытэрыяльны аналіз", "modal_title": "Шматкрытэрыяльны аналіз", "name": "Стварыць аналіз", "modal_input_name": "Назва аналізу", "modal_input_name_placeholder": "Напрыклад, Кліматычныя змены", "modal_input_indicators": "Спіс слаёў", "modal_input_indicators_placeholder": "Абраць слаі", "modal_input_indicators_no_options": "Няма варыянтаў", "btn_save": "Захаваць аналіз", "error_analysis_name_cannot_be_empty": "Назва аналізу не можа быць пустой", "error_bad_layer_data": "Няправільныя даныя слоя шматкрытэрыяльнага аналізу", "error_invalid_file": "Няправільны фармат файла шматкрытэрыяльнага аналізу", "error_invalid_parameter": "Няправільны параметр '{{parameter}}'", "error_invalid_layer_parameter": "Няправільны параметр '{{parameter}}' у слоі '{{axisName}}'", "error_wrong_mcda_version": "Няправільная версія MCDA", "legend_subtitle": "Шасцікутнікі афарбаваны згодна з наладамі аналітычных слаёў. Націсніце на шасцікутнік, каб убачыць яго значэнні.", "bad": "Дрэнна", "good": "Добра" };
const ok$1 = "ОК";
const create$1 = "Стварыць";
const disasters$1 = "Катастрофы";
const loading$1 = "Загрузка...";
const loading_events$1 = "Загрузка катастроф";
const legend$1 = "Легенда";
const vertical_direction$1 = "Вертыкальны напрамак";
const horizontal_direction$1 = "Гарызантальны напрамак";
const legend_presentation$1 = "Адлюстраванне легенды";
const layers$1 = "Слаі";
const bivariate$1 = { "color_manager": { "layers_filter": "Слаі", "not_defined": "Не вызначана", "sentiments_combinations_filter": "Спалучэнні напрамкаў", "no_legends": "Няма легенд, якія адпавядаюць умовам.", "no_data": "Няма даных", "sentiments_tab": "Напрамак", "color_legends_tab": "Каляровыя легенды", "layers_tab": "Слаі (індыкатары)" }, "panel": { "header": "Біварыятыўная матрыца" }, "matrix": { "caption": { "base_axis": "Базавая вось", "annex_axis": "Дапаможная вось", "tooltip": { "p1": "Графікі, якія выкарыстоўваюць базавую і дапаможную восі, дапамагаюць вызначыць сувязь паміж двума наборамі даных.", "li1": "Дапаможная вось - параметры, якія мы аналізуем", "li2": "Базавая вось - апорная кропка ў аналізе", "b": "Напрыклад: найлепшае месца для адкрыцця кавярні", "p2": "Мы можам даследаваць колькасць месцаў грамадскага харчавання (дапаможная вось) у параўнанні са шчыльнасцю насельніцтва (базавая вось).", "p3": "У гэтым выпадку нас найперш цікавіць невялікая колькасць месцаў грамадскага харчавання, а колькасць людзей у гэтым месцы дае дадатковую інфармацыю." } }, "header": { "title": "Выберыце два слоя для даследавання карэляцый", "hint": "Слаі і карэляцыі адлюстроўваюцца для вылучанай вобласці" }, "icon": { "population": "Значэнне, падзеленае на насельніцтва", "area_km2": "Значэнне, падзеленае на плошчу", "total_building_count": "Значэнне, падзеленае на агульную колькасць будынкаў", "populated_area_km2": "Значэнне, падзеленае на заселеную тэрыторыю", "one": "Без дзялення", "roads": "Значэнне, падзеленае на агульную даўжыню дарог" }, "progress": { "rendering": "Адмалёўка", "applied": "Ужыта на карце" }, "loading_error": "На жаль, мы не можам адлюстраваць матрыцу. Паспрабуйце абнавіць старонку ці вярнуцца пазней." }, "legend": { "high": "Высокі", "low": "Нізкі", "medium": "Сярэдні" } };
const toolbar$1 = { "map_ruler": "Вымераць адлегласць", "locate_me": "Вызначыць маё месцазнаходжанне", "panel_title": "Панэль інструментаў", "download": "Спампаваць", "delete": "Выдаліць", "boundary_selector": "Вылучыць адміністрацыйную мяжу", "create_layer": "Стварыць слой", "geometry_uploader": "Загрузіць GeoJSON", "focused_geometry_editor": "Маляваць або рэдагаваць геаметрыю", "edit_in_osm": "Рэдагаваць мапу ў OSM", "record_sensors": "Запісваць даныя датчыкаў", "tools_label": "Інструменты", "selected_area_label": "Вылучаная вобласць", "upload_mcda": "Загрузіць аналіз" };
const locate_me$1 = { "feature_title": "Вызначыць маё месцазнаходжанне", "get_location_error": "Памылка пры атрыманні месцазнаходжання" };
const layer_actions$1 = { "tooltips": { "download": "Спампаваць", "erase": "Сцерці", "edit": "Рэдагаваць", "hide": "Схаваць", "show": "Паказаць" } };
const focus_geometry_layer$1 = { "settings": { "name": "Вылучаная вобласць" } };
const feed$1 = "Стужка";
const deselect$1 = "Зняць вылучэнне";
const spinner_text$1 = "Збор даных";
const updated$1 = "Абноўлена";
const started$1 = "Пачалося";
const no_data_received$1 = "Даныя не атрыманы";
const wrong_data_received$1 = "Атрыманы памылковыя даныя";
const error$3 = "Памылка";
const sort_icon$1 = "Сартаванне";
const configs$1 = { "Kontur_public_feed": "Kontur Public", "Kontur_public_feed_description": "Стужка змяшчае даныя ў рэжыме рэальнага часу аб цыклонах, засухах, землятрусах, паводках, вулканах і лясных пажарах." };
const errors$1 = { "default": "Прабачце, узніклі праблемы, якія хутка будуць выпраўлены", "timeout": "Час чакання запыту скончыўся", "cannot_connect": "Не атрымалася злучыцца з серверам", "forbidden": "Забаронена", "not_found": "Не знойдзена", "unknown": "Невядома", "server_error": "Памылка сервера", "error_try_again": "Нешта пайшло не так. Калі ласка, паспрабуйце зноў" };
const event_list$1 = { "severity_unknown": "Невядома", "warning_title": "Немагчыма адфільтраваць па віду мапы", "warning_description": "Мапа яшчэ не гатовая, паспрабуйце пазней", "bbox_filter_button": "Адфільтраваць па віду мапы", "analytics": { "affected_people": { "tooltip": "Пацярпелыя людзі", "value": "Няма гуманітарных наступстваў" }, "settled_area_tooltip": "Заселеная тэрыторыя", "loss_tooltip": "Прыблізныя страты" }, "no_event_in_feed": "Катастрофа не была знойдзеная ў цякучай стужцы катастроф", "no_selected_disaster": "Катастрофа не выбрана", "chose_disaster": "Выбраць катастрофу", "no_historical_disasters": "Няма гістарычных катастроф у дадзеным раёне", "no_feed_disasters": "Няма катастроф у гэтай стужцы", "no_feed_disasters_matching_your_filters": "Няма катастроф, што адпавядаюць вашым фільтрам", "no_disasters": "Няма катастроф", "severity_termination": "Спыненне", "severity_minor": "Нязначная", "severity_moderate": "Умераная", "severity_severe": "Сур'ёзная", "severity_extreme": "Экстрэмальная", "open_timeline_button": "Часавая шкала" };
const categories$1 = { "overlays": "Оверлэі", "basemap": "Базавая мапа" };
const groups$1 = { "layers_in_selected_area": "Слаі ў вылучанай зоне", "your_layers": "Вашы слаі", "kontur_analytics": "Аналітыка Kontur", "qa": "Інспектар OpenStreetMap", "osmbasedmap": "На аснове OpenStreetMap", "other": "Іншае", "elevation": "Вышыня", "photo": "Здымкі", "map": "Мапа" };
const modes$1 = { "map": "Мапа", "about": "Пра сервіс", "cookies": "Файлы cookie", "reports": "Справаздачы", "report": "Справаздача", "profile": "Профіль", "privacy": "Прыватнасць", "terms": "Умовы", "user_guide": "Дапаможнік" };
const advanced_analytics_data_list$1 = { "load_world_data": "Загрузіць сусветныя даныя", "numerator": "Лічнік", "normalized_by": "Нармалізавана па", "sum": "Сума", "min": "Мінімум", "max": "Максімум", "mean": "Сярэдняе", "stddev": "Стандартнае адхіленне", "median": "Медыяна", "filter_numerator": "Фільтр па лічніку", "filter_denominator": "Фільтр па назоўніку" };
const profile$1 = { "saveButton": "Захаваць змены", "reference_area": { "title": "Эталонная вобласць", "freehand_geometry": "Адвольная геаметрыя", "to_replace_reference_area": 'Вы можаце пераназначыць вашу эталонную вобласць на карце. Вылучыце вобласць і націсніце "Захаваць як эталонную вобласць" у панэлі інструментаў.\n', "description": "Захавайце знаёмую вам вобласць як эталонную. Мы будзем выкарыстоўваць яе як падставу для параўнання іншых абласцей і тлумачэння адрозненняў.", "set_the_reference_area": "Вылучыць вобласць на карце", "tooltip_text": "1. Вылучыце вобласць цікавасці на карце, выкарыстоўваючы інструменты 'Адміністрацыйныя межы' або 'Маляванне геаметрыі'. <br/> 2. Націсніце кнопку 'Захаваць як эталонную вобласць' у панэлі інструментаў.", "accessing_location": "Атрыманне вашага месцазнаходжання", "accessing_location_error": "Памылка. Паспрабуйце іншы спосаб.", "select_location": "Абраць маю цякучае месцазнаходжанне", "notification": "Ваша эталонная вобласць {{name}} была захаваная" }, "email": "Электронная пошта", "interfaceTheme": "Тэма", "interfaceLanguage": "Мова", "units": "Адзінкі вымярэння", "fullName": "Поўнае імя", "metric": "метрычная сістэма", "imperialBeta": "імперская сістэма (бэта)", "profileSettingsHeader": "Наладзьце свой вопыт выкарыстання", "your_current_job": "ваша цяперашняя праца", "area_of_expertise": "сфера дзейнасці", "challenges": "праблемы", "personalization_prompt": "Для лепшай персаналізацыі, калі ласка, пазначце наступнае:", "ai_tools_compatibility": "Гэтая інфармацыя сумяшчальная з інструментамі AI", "improves_analysis": "Паляпшае аналіз", "bio_placeholder": "Аб сабе", "bio_textarea_placeholder": "Напрыклад, спецыяліст у галіне ГІС з 5+ гадамі вопыту ў аналізе рызыкаў катастроф, арыентаваны на гарадскую ўстойлівасць.", "analysis_objectives": "Мэты аналізу", "objectives_textarea_placeholder": "Напрыклад, аналіз гарадскога планавання з акцэнтам на кліматычную ўстойлівасць. Мая цяперашняя задача — паляпшэнне картаграфавання рызыкаў паводак.", "appSettingsHeader": "Налады", "your_organization": "Ваша арганізацыя", "your_contacts": "Вашыя кантактныя даныя", "organization_name": "Назва арганізацыі", "position": "Пасада", "gis_specialists": "ГІС-спецыялісты ў вашай камандзе", "phone_number": "Нумар тэлефона з кодам краіны", "linkedin": "Профіль у LinkedIn", "konturTheme": "Kontur", "HOTTheme": "HOT", "defaultDisasterFeed": "Стужка катастроф па змаўчанні", "defaultOSMeditor": "Рэдактар OpenStreetMap па змаўчанні (бэта)", "successNotification": "Усе змены былі паспяхова захаваны", "dont_know": "Я не ведаю", "languageOption": { "en": "Англійская", "es": "Іспанская", "ar": "Арабская", "ko": "Карэйская", "id": "Інданезійская", "de": "Нямецкая", "be": "Беларуская", "ru": "Руская", "uk": "Украінская" } };
const multivariate$1 = { "upload_analysis_layer": "Загрузіць аналітычны слой", "popup": { "score_header": "Адзнака {{level}}", "base_header": "Аснова {{level}}" } };
const search$1 = { "search_location": "Пошук месца", "info_block": "Вы можаце шукаць 📍 месцы", "info_block_with_mcda": "Вы можаце шукаць 📍 месцы або задаць ✨ AI ваша пытанне, напрыклад: «Дзе знаходзіцца сухастой?»", "input_placeholder": "Пошук", "input_placeholder_mcda": "Шукаць або спытацца ў AI", "locations_no_result": "Няма знойдзеных месцаў", "mcda_loading_message": "AI стварае аналіз для вас", "mcda_no_result": "Няма прапаноў ад AI", "mcda_error_message": "AI не адказаў. Паспрабуйце пазней", "mcda_create_analysis": "Стварыць аналіз", "upload_analysis": "“{{name}}” шматкрытэрыяльны аналіз быў створаны" };
const episode$1 = "Часавая шкала";
const create_layer$1 = { "edit_layer": "Рэдагаваць слой", "edit_features": "Рэдагаваць аб'екты", "delete_layer": "Выдаліць слой", "create_layer": "Стварыць слой", "saving_layer": "Захаванне слоя...", "field_name": "Назва поля", "layer_name": "Назва слоя", "marker_icon": "Іконка маркера", "type": "Тып", "select": "Выбраць", "short_text": "Кароткі тэкст", "long_text": "Доўгі тэкст", "link": "Спасылка", "image": "Выява", "fields": "Палі", "add_field": "Дадаць поле", "location": "Месцазнаходжанне", "edit_feature_placeholder": "Выберыце аб'ект для пачатку рэдагавання яго ўласцівасцей" };
const analytics_panel$1 = { "header_title": "Аналітыка", "error_loading": "Не атрымалася атрымаць даныя аб вылучанай вобласці. Магчыма, яна занадта вялікая.", "info_short": "Разлікі зробленыя для вылучанай вобласці" };
const advanced_analytics_panel$1 = { "header_title": "Пашыраная аналітыка", "error": "Памылка падчас атрымання даных пашыранай аналітыкі" };
const advanced_analytics_empty$1 = { "not_found": "Прабачце, запытаная катастрофа не знойдзена", "error": "Адбылася памылка", "analytics_for_selected": "Аналітыка для вылучанай вобласці", "will_be_provided": "будзе пададзена тут", "no_analytics": "Няма аналітыкі для вылучанай вобласці" };
const current_event$1 = { "not_found_request": "Прабачце, запытаная катастрофа не знойдзена" };
const llm_analytics$1 = { "header": "Аналітыка AI", "placeholder": { "select_area": "Вылучыце вобласць (<icon1 />,<icon2 />,<icon3 />), якую хочаце даследаваць для атрымання Аналітыкі AI.", "you_can_also": "Вы таксама можаце:", "fill_bio": "<icon /> <lnk>Запоўніце мэты аналізу</lnk>, каб персаналізаваць AI аналіз", "select_and_save_as_reference_area": "<icon /> Вылучыце вобласць і захавайце яе як эталонную для параўнання з іншай", "learn_more": "<lnk><icon/> Даведайцеся больш пра Аналітыку AI</lnk>" } };
const draw_tools$1 = { "area": "Шматкутнік", "line": "Лінія", "point": "Кропка", "finish_drawing": "Скончыць маляванне", "caption": "Націсніце на мапу, каб пачаць маляванне", "no_geometry_error": "Няма намаляванай геаметрыі для загрузкі", "overlap_error": "Шматкутнік не павінен перакрываць сам сябе", "save_features": "Захаваць аб'екты" };
const boundary_selector$1 = { "title": "Фокус на адміністрацыйную мяжу" };
const geometry_uploader$1 = { "title": "Фокус на загружаную геаметрыю", "error": "Памылка пры чытанні загружанага файла" };
const focus_geometry$1 = { "title": "Фокус на адвольную геаметрыю" };
const reference_area_layer$1 = { "settings": { "name": "Эталонная вобласць" } };
const drawings$1 = { "self_directions_not_supported": "Самаперакрыцці не падтрымліваюцца" };
const sidebar$1 = { "edit_osm": "Рэдагаваць у OpenStreetMap", "ruler": "Лінейка", "collapse": "Згарнуць", "expand": "Разгарнуць", "icon_alt": "Лагатып дадатку" };
const login$1 = { "email": "Электронная пошта", "password": "Пароль", "login_button": "Увайсці", "sign_up": "Зарэгістравацца", "logging_in": "Уваход...", "log_in": "Увайсці", "forgot_password": "Забыліся пароль?", "description": "Калі ласка, увайдзіце, каб змяніць налады", "error": { "email_empty": "Поле электроннай пошты не можа быць пустым", "email_invalid": "Увядзіце сапраўдны адрас электроннай пошты", "password": "Поле пароля не можа быць пустым", "connect": "Не ўдалося падключыцца да службы аўтэнтыфікацыі" } };
const currency$1 = { "usd": "USD" };
const subscription$1 = { "title": "Тарыфы і цэны", "price_summary": "* Выстаўляецца рахунак ${{pricePerYear}} USD раз на год", "unauthorized_button": "Увайдзіце, каб аформіць падпіску", "current_plan_button": "Цяперашні план", "sales_button": "Звязацца з аддзелам продажаў", "book_demo_button": "Замовіць дэма", "request_trial_button": "Запытаць пробны перыяд", "errors": { "payment_initialization": "Адбылася памылка падчас ініцыялізацыі плацяжу. Калі ласка, паспрабуйце яшчэ раз ці звяжыцеся са службай падтрымкі" }, "success_modal": { "title": "Паспяхова", "thank_you_for_subscribing": "Дзякуй за падпіску на нашу платформу!", "after_the_page_refreshes": "Пасля абнаўлення старонкі вы можаце пачаць выкарыстоўваць Kontur Atlas" } };
const reports$1 = { "title": "Справаздачы Disaster Ninja", "no_data": "Няма даных для гэтай справаздачы", "sorting": "Сартыроўка даных...", "loading": "Загрузка даных", "open_josm": "Адкрыць праз дыстанцыйнае кіраванне JOSM", "josm_logo_alt": "Лагатып JOSM", "see_all": "Паглядзець усе справаздачы", "wrong_id": "Няправільны ідэнтыфікатар справаздачы", "description": "<0>Kontur </0> стварае некалькі справаздач, якія дапамагаюць ацаніць якасць OpenStreetMap. Яны ўтрымліваюць спасылкі на вобласці на <4>osm.org </4> і спасылкі для адкрыцця іх у рэдактары JOSM з уключаным дыстанцыйным кіраваннем." };
const about$1 = {};
const loading_episodes$1 = "Загрузка эпізодаў";
const zoom_to_world$1 = "Аддаліцца да ўсяго свету";
const cookie_banner$1 = { "header": "Мы цэнім вашу прыватнасць", "body": "Мы выкарыстоўваем неабходныя файлы cookie для прадастаўлення вам персаналізаваных паслуг, а таксама дадатковыя файлы cookie для паляпшэння {{appName}} і вашага вопыту выкарыстання. Вы можаце кіраваць наладамі cookie або адклікаць згоду на дадатковыя cookie ў любы момант.\nДля атрымання дадатковай інфармацыі азнаёмцеся з нашай [Палітыкай прыватнасці](about/privacy)", "decline_all": "Адмовіцца ад дадатковых cookie", "accept_all": "Прыняць дадатковыя cookie" };
const live_sensor$1 = { "start": "Пачаць запіс з датчыкаў", "finish": "Спыніць запіс з датчыкаў", "finishMessage": "Запіс завершаны", "startMessage": "Запіс пачаты", "noSensorsError": "Вашае прылада не мае неабходных датчыкаў" };
const layer_features_panel$1 = { "empty": "Аб'екты слоя ў вылучанай вобласці будуць паказаны тут", "noFeatureSelected": "Не абраны аб'ект слоя", "chooseFeature": "Абярыце аб'ект слоя", "listInfo": "Спіс адфільтраваны па вылучанай вобласці і адсартаваны па нумары праекта", "error_loading": "Не атрымалася загрузіць даныя аб'ектаў слоя. Калі ласка, паспрабуйце яшчэ раз.", "no_features": "У вылучанай вобласці не знойдзена аб'ектаў." };
const reference_area$1 = { "save_as_reference_area": "Захаваць як эталонную вобласць", "error_couldnt_save": "На жаль, не атрымалася захаваць вашу эталонную вобласць. Калі ласка, паспрабуйце яшчэ раз.", "selected_area_saved_as_reference_area": "Вылучаная вобласць была захаваная як эталонная ў вашым профілі" };
const be_common = {
  km: km$1,
  m: m$1,
  to: to$1,
  or: or$1,
  maps: maps$1,
  logout: logout$1,
  save: save$1,
  cancel: cancel$1,
  mcda: mcda$1,
  ok: ok$1,
  create: create$1,
  disasters: disasters$1,
  loading: loading$1,
  loading_events: loading_events$1,
  legend: legend$1,
  vertical_direction: vertical_direction$1,
  horizontal_direction: horizontal_direction$1,
  legend_presentation: legend_presentation$1,
  layers: layers$1,
  bivariate: bivariate$1,
  toolbar: toolbar$1,
  locate_me: locate_me$1,
  layer_actions: layer_actions$1,
  focus_geometry_layer: focus_geometry_layer$1,
  feed: feed$1,
  deselect: deselect$1,
  spinner_text: spinner_text$1,
  updated: updated$1,
  started: started$1,
  no_data_received: no_data_received$1,
  wrong_data_received: wrong_data_received$1,
  error: error$3,
  sort_icon: sort_icon$1,
  configs: configs$1,
  errors: errors$1,
  event_list: event_list$1,
  categories: categories$1,
  groups: groups$1,
  modes: modes$1,
  advanced_analytics_data_list: advanced_analytics_data_list$1,
  profile: profile$1,
  multivariate: multivariate$1,
  search: search$1,
  episode: episode$1,
  create_layer: create_layer$1,
  analytics_panel: analytics_panel$1,
  advanced_analytics_panel: advanced_analytics_panel$1,
  advanced_analytics_empty: advanced_analytics_empty$1,
  current_event: current_event$1,
  llm_analytics: llm_analytics$1,
  draw_tools: draw_tools$1,
  boundary_selector: boundary_selector$1,
  geometry_uploader: geometry_uploader$1,
  focus_geometry: focus_geometry$1,
  reference_area_layer: reference_area_layer$1,
  drawings: drawings$1,
  sidebar: sidebar$1,
  login: login$1,
  currency: currency$1,
  subscription: subscription$1,
  reports: reports$1,
  about: about$1,
  loading_episodes: loading_episodes$1,
  zoom_to_world: zoom_to_world$1,
  cookie_banner: cookie_banner$1,
  live_sensor: live_sensor$1,
  layer_features_panel: layer_features_panel$1,
  reference_area: reference_area$1
};
const km = "км";
const m = "м";
const to = "до";
const or = "или";
const maps = "Карты";
const logout = "Выйти";
const save = "Сохранить";
const cancel = "Отменить";
const mcda = { "btn_cancel": "Отменить", "legend_title": "Легенда", "layer_editor": { "outliers_options": { "hide": "Скрыть", "clamp": "Ограничить", "dont_modify": "Не изменять" }, "save_changes": "Сохранить изменения", "range": "Диапазон значений", "outliers": "Выпадающие значения", "reverse_to_good_bad": "Перевернуть: Хорошо → Плохо", "reverse_to_bad_good": "Перевернуть: Плохо → Хорошо", "weight": "Вес", "transform": "Трансформировать", "transformation": "Трансформация", "normalize": "Нормализовать", "normalization": "Нормализация", "range_buttons": { "full_range": "Полный диапазон", "3_sigma": "3σ", "2_sigma": "2σ", "1_sigma": "1σ" }, "transformations": { "no_transformation": "Без трансформации", "square_root": "Квадратный корень: sign(x)⋅√|x|", "cube_root": "Кубический корень: ∛x", "log": "log₁₀(x - xmin + 1)", "log_epsilon": "log₁₀(x - xmin + ε)" }, "no": "Без нормализации", "max_min": "Макс-мин", "errors": { "weight_cannot_be_empty": "Вес не может быть пустым", "weight_must_be_a_number": "Вес должен быть числом", "range_from_cannot_be_bigger": "Значение «от» не может быть больше, чем значение «до»", "range_cannot_be_empty": "Диапазон не может быть пустым", "range_must_be_a_number": "Диапазон должен быть числом" }, "tips": { "range": "Значения, которые будут считаться наихудшими и наилучшими в вашем анализе.", "sentiment": "Определите направление коннотаций слоя на анализ:\n* **Плохо → Хорошо**: Более высокие значения указывают на положительное направление.\n* **Хорошо → Плохо**: Более высокие значения указывают на отрицательное направление.", "weight": "По умолчанию все слои вносят равный вклад в анализ через средневзвешенное значение. Увеличение веса слоя (2, 3 и т. д.) позволяет придать ему дополнительную значимость в анализе.", "transform": "Примените вычисления к значениям. Достижение более линейного распределения обеспечит более полезную информацию для анализа.\n\n **Примечание**: Вычисления выполняются перед нормализацией.", "normalize": "Приводит значения к стандартизированной шкале. Это упрощает их сравнение и принятие решений.\n* **Стандартная шкала оценки**: Этот вариант приводит значения к стандартизированной шкале, чтобы они были сопоставимы.\n* **Нет (только для специалистов)**: Оставляет значения без изменений.", "outliers": "* **Ограничить**: Установить значения выше диапазона как 1, а ниже диапазона – как 0.\n* **Не изменять**: Сохранить 0 и 1 для минимального и максимального значений, но допустить выбросы за пределами этого диапазона.\n* **Исключить**: Исключить области, где значения выходят за пределы диапазона." } }, "title": "Многокритериальный анализ", "modal_title": "Многокритериальный анализ", "name": "Создать анализ", "modal_input_name": "Название анализа", "modal_input_name_placeholder": "Например, Изменение климата", "modal_input_indicators": "Список слоёв", "modal_input_indicators_placeholder": "Выберите слои", "modal_input_indicators_no_options": "Нет доступных вариантов", "btn_save": "Сохранить анализ", "error_analysis_name_cannot_be_empty": "Название анализа не может быть пустым", "error_bad_layer_data": "Некорректные данные слоя многокритериального анализа", "error_invalid_file": "Некорректный формат файла многокритериального анализа", "error_invalid_parameter": "Некорректный параметр '{{parameter}}'", "error_invalid_layer_parameter": "Некорректный параметр '{{parameter}}' в слое '{{axisName}}'", "error_wrong_mcda_version": "Неподдерживаемая версия многокритериального анализа", "legend_subtitle": "Шестиугольники окрашены в соответствии с настройками анализа слоя. Нажмите на шестиугольник, чтобы увидеть его значения.", "bad": "Плохо", "good": "Хорошо" };
const ok = "ОК";
const create = "Создать";
const disasters = "Катастрофы";
const loading = "Загрузка...";
const loading_events = "Загрузка катастроф";
const legend = "Легенда";
const vertical_direction = "Вертикальное направление";
const horizontal_direction = "Горизонтальное направление";
const legend_presentation = "Отображение легенды";
const layers = "Слои";
const bivariate = { "color_manager": { "layers_filter": "Слои", "not_defined": "Не определено", "sentiments_combinations_filter": "Комбинации направлений", "no_legends": "Нет легенд, удовлетворяющих условиям.", "no_data": "Нет данных.", "sentiments_tab": "Направление", "color_legends_tab": "Цветовые легенды", "layers_tab": "Слои (индикаторы)" }, "panel": { "header": "Бивариативная матрица" }, "matrix": { "caption": { "base_axis": "Базовая ось", "annex_axis": "Дополнительная ось", "tooltip": { "p1": "Графики с базовой и дополнительной осями помогают установить взаимосвязь между двумя наборами данных.", "li1": "Дополнительная ось – параметры, которые мы анализируем", "li2": "Базовая ось – эталонная точка в анализе", "b": "Например: лучшее место для открытия кафе", "p2": "Мы можем изучить количество мест общественного питания (дополнительная ось) по отношению к плотности населения (базовая ось).", "p3": "В этом сценарии нас интересует небольшое количество мест общественного питания, а количество людей в этом месте даёт дополнительную информацию." } }, "header": { "title": "Выберите два слоя для исследования корреляций", "hint": "Слои и корреляции отображаются для текущей выделенной области" }, "icon": { "population": "Значение, делённое на население", "area_km2": "Значение, делённое на площадь", "total_building_count": "Значение, делённое на общее количество зданий", "populated_area_km2": "Значение, делённое на заселённую площадь", "one": "Без делителя", "roads": "Значение, делённое на общую длину дорог" }, "progress": { "rendering": "Отрисовка", "applied": "Применено на карте" }, "loading_error": "К сожалению, мы не можем отобразить матрицу. Попробуйте обновить страницу или зайдите позже." }, "legend": { "high": "Высокий", "low": "Низкий", "medium": "Средний" } };
const toolbar = { "map_ruler": "Измерить расстояние", "locate_me": "Определить моё местоположение", "panel_title": "Панель инструментов", "download": "Скачать", "delete": "Удалить", "boundary_selector": "Выделить административную границу", "create_layer": "Создать слой", "geometry_uploader": "Загрузить GeoJSON", "focused_geometry_editor": "Рисовать или редактировать геометрию", "edit_in_osm": "Редактировать карту в OSM", "record_sensors": "Записать данные с датчиков", "tools_label": "Инструменты", "selected_area_label": "Выделенная область", "upload_mcda": "Загрузить анализ" };
const locate_me = { "feature_title": "Определить моё местоположение", "get_location_error": "Ошибка при определении местоположения" };
const layer_actions = { "tooltips": { "download": "Скачать", "erase": "Стереть", "edit": "Редактировать", "hide": "Скрыть", "show": "Показать" } };
const focus_geometry_layer = { "settings": { "name": "Выделенная область" } };
const feed = "Лента";
const deselect = "Снять выделение";
const spinner_text = "Сбор данных";
const updated = "Обновлено";
const started = "Запущено";
const no_data_received = "Данные не получены";
const wrong_data_received = "Получены неверные данные";
const error$2 = "Ошибка";
const sort_icon = "Сортировка";
const configs = { "Kontur_public_feed": "Kontur Public", "Kontur_public_feed_description": "Лента содержит данные в реальном времени о циклонах, засухах, землетрясениях, наводнениях, вулканах, лесных пожарах." };
const errors = { "default": "Извините, у нас возникли проблемы, которые скоро будут исправлены", "timeout": "Время ожидания запроса истекло", "cannot_connect": "Не удается подключиться к серверу", "forbidden": "Доступ запрещен", "not_found": "Не найдено", "unknown": "Неизвестно", "server_error": "Ошибка сервера", "error_try_again": "Что-то пошло не так. Пожалуйста, попробуйте снова" };
const event_list = { "severity_unknown": "Неизвестно", "warning_title": "Невозможно отфильтровать по виду карты", "warning_description": "Карта еще не готова, попробуйте позже", "bbox_filter_button": "Фильтровать по виду карты", "analytics": { "affected_people": { "tooltip": "Пострадавшие люди", "value": "Гуманитарного воздействия нет" }, "settled_area_tooltip": "Заселённая территория", "loss_tooltip": "Предполагаемый ущерб" }, "no_event_in_feed": "Катастрофа не найдена в текущей ленте катастроф", "no_selected_disaster": "Катастрофа не выбрана", "chose_disaster": "Выберите катастрофу", "no_historical_disasters": "В этой области нет исторических катастроф", "no_feed_disasters": "В этой ленте нет катастроф", "no_feed_disasters_matching_your_filters": "Нет катастроф, соответствующих вашим фильтрам", "no_disasters": "Нет катастроф", "severity_termination": "Прекращение", "severity_minor": "Незначительное", "severity_moderate": "Умеренное", "severity_severe": "Серьезное", "severity_extreme": "Экстремальное", "open_timeline_button": "Таймлайн" };
const categories = { "overlays": "Оверлеи", "basemap": "Базовая карта" };
const groups = { "layers_in_selected_area": "Слои в выделенной области", "your_layers": "Ваши слои", "kontur_analytics": "Аналитика Kontur", "qa": "Инспектор OpenStreetMap", "osmbasedmap": "На основе OpenStreetMap", "other": "Другое", "elevation": "Высота", "photo": "Изображения", "map": "Карта" };
const modes = { "map": "Карта", "about": "О сервисе", "cookies": "Файлы cookie", "reports": "Отчёты", "report": "Отчёт", "profile": "Профиль", "privacy": "Конфиденциальность", "terms": "Условия", "user_guide": "Руководство" };
const advanced_analytics_data_list = { "load_world_data": "Загрузить мировые данные", "numerator": "Числитель", "normalized_by": "Нормализовано по", "sum": "Сумма", "min": "Минимум", "max": "Максимум", "mean": "Среднее", "stddev": "Стандартное отклонение", "median": "Медиана", "filter_numerator": "Фильтр числителя", "filter_denominator": "Фильтр знаменателя" };
const profile = { "saveButton": "Сохранить изменения", "reference_area": { "title": "Эталонная область", "freehand_geometry": "Свободная геометрия", "to_replace_reference_area": 'Вы можете переопределить свою эталонную область на карте. Выберите область и нажмите "Сохранить как эталонную область" на панели инструментов.\n', "description": "Сохраните знакомую вам область как эталонную. Мы будем использовать её в качестве основания для сравнения с другими областями и объяснения различий.", "set_the_reference_area": "Выделить область на карте", "tooltip_text": "1. Выделите интересующую область на карте, используя инструмент границ администраций или инструмент рисования геометрии. <br/> 2. Нажмите кнопку 'Сохранить как эталонную область' на панели инструментов.", "accessing_location": "Определение вашего местоположения", "accessing_location_error": "Ошибка. Попробуйте другой способ.", "select_location": "Выбрать моё текущее местоположение", "notification": "Ваша эталонная область {{name}} была сохранена" }, "email": "Электронная почта", "interfaceTheme": "Тема", "interfaceLanguage": "Язык", "units": "Единицы измерения", "fullName": "Полное имя", "metric": "метрическая", "imperialBeta": "имперская (бета)", "profileSettingsHeader": "Персонализируйте свой опыт", "your_current_job": "ваша текущая должность", "area_of_expertise": "область экспертизы", "challenges": "проблемы", "personalization_prompt": "Для лучшей персонализации укажите, например:", "ai_tools_compatibility": "Эта информация совместима с инструментами AI", "improves_analysis": "Улучшает аналитику", "bio_placeholder": "О себе", "bio_textarea_placeholder": "Например, ГИС-специалист с более чем 5-летним опытом анализа рисков катастроф, с фокусом на устойчивость городов.", "analysis_objectives": "Цели анализа", "objectives_textarea_placeholder": "Например, анализ городского планирования с акцентом на устойчивость к климатическим изменениям. Моя текущая задача — улучшение картографирования рисков наводнений.", "appSettingsHeader": "Настройки", "your_organization": "Ваша организация", "your_contacts": "Ваши контактные данные", "organization_name": "Название организации", "position": "Должность", "gis_specialists": "ГИС-специалисты в вашей команде", "phone_number": "Номер телефона с кодом страны", "linkedin": "Профиль в LinkedIn", "konturTheme": "Kontur", "HOTTheme": "HOT", "defaultDisasterFeed": "Лента катастроф по умолчанию", "defaultOSMeditor": "Редактор OpenStreetMap по умолчанию (бета)", "successNotification": "Все изменения успешно применены", "dont_know": "Не знаю", "languageOption": { "en": "Английский", "es": "Испанский", "ar": "Арабский", "ko": "Корейский", "id": "Индонезийский", "de": "Немецкий", "be": "Белорусский", "ru": "Русский", "uk": "Украинский" } };
const multivariate = { "upload_analysis_layer": "Загрузить слой анализа", "popup": { "score_header": "Оценка {{level}}", "base_header": "Основа {{level}}" } };
const search = { "search_location": "Поиск мест", "info_block": "Вы можете искать 📍 места", "info_block_with_mcda": "Вы можете искать 📍 места или задать ✨ AI вопрос, например: «Где находится сухостой?»", "input_placeholder": "Поиск", "input_placeholder_mcda": "Найти или спросить AI", "locations_no_result": "Места не найдены", "mcda_loading_message": "AI создаёт анализ для вас", "mcda_no_result": "Нет предложений от AI", "mcda_error_message": "AI не ответил. Пожалуйста, попробуйте позже", "mcda_create_analysis": "Создать анализ", "upload_analysis": "Многокритериальный анализ «{{name}}» создан" };
const episode = "Таймлайн";
const create_layer = { "edit_layer": "Редактировать слой", "edit_features": "Редактировать объекты", "delete_layer": "Удалить слой", "create_layer": "Создать слой", "saving_layer": "Сохранение слоя...", "field_name": "Название поля", "layer_name": "Название слоя", "marker_icon": "Иконка маркера", "type": "Тип", "select": "Выбрать", "short_text": "Короткий текст", "long_text": "Длинный текст", "link": "Ссылка", "image": "Изображение", "fields": "Поля", "add_field": "Добавить поле", "location": "Местоположение", "edit_feature_placeholder": "Выберите объект, чтобы начать редактирование его свойств" };
const analytics_panel = { "header_title": "Аналитика", "error_loading": "Не удалось получить данные о выделенной области. Возможно, она слишком велика.", "info_short": "Расчеты выполняются для выделенной области" };
const advanced_analytics_panel = { "header_title": "Расширенная аналитика", "error": "Ошибка при получении данных расширенной аналитики" };
const advanced_analytics_empty = { "not_found": "Извините, запрашиваемая катастрофа не найдена", "error": "Произошла ошибка", "analytics_for_selected": "Аналитика для выделенной области", "will_be_provided": "будет представлена здесь", "no_analytics": "Нет аналитики для выделенной области" };
const current_event = { "not_found_request": "Извините, запрашиваемая катастрофа не найдена" };
const llm_analytics = { "header": "Аналитика AI", "placeholder": { "select_area": "Выберите область (<icon1 />,<icon2 />,<icon3 />), которую хотите исследовать, чтобы получить аналитику AI.", "you_can_also": "Вы также можете:", "fill_bio": "<icon /> <lnk>Заполните цели анализа</lnk>, чтобы персонализировать AI анализ", "select_and_save_as_reference_area": "<icon /> Выберите область и сохраните её как эталонную, чтобы сравнивать с другой", "learn_more": "<lnk><icon/> Узнать больше об аналитике AI</lnk>" } };
const draw_tools = { "area": "Многоугольник", "line": "Линия", "point": "Точка", "finish_drawing": "Завершить рисование", "caption": "Нажмите на карту, чтобы начать рисование", "no_geometry_error": "Нет нарисованной геометрии для загрузки", "overlap_error": "Полигон не должен пересекаться сам с собой", "save_features": "Сохранить объекты" };
const boundary_selector = { "title": "Фокус на административной границе" };
const geometry_uploader = { "title": "Фокус на загруженной геометрии", "error": "Ошибка при чтении загруженного файла" };
const focus_geometry = { "title": "Фокус на свободно нарисованной геометрии" };
const reference_area_layer = { "settings": { "name": "Эталонная область" } };
const drawings = { "self_directions_not_supported": "Самопересечения не поддерживаются" };
const sidebar = { "biv_color_manager": "Менеджер цветов", "edit_osm": "Редактировать в OpenStreetMap", "ruler": "Линейка", "collapse": "Свернуть", "expand": "Развернуть", "icon_alt": "Логотип приложения" };
const login = { "email": "Электронная почта", "password": "Пароль", "login_button": "Войти", "sign_up": "Регистрация", "logging_in": "Вход в систему...", "log_in": "Войти", "forgot_password": "Забыли пароль?", "description": "Пожалуйста, войдите в систему, чтобы изменить настройки", "error": { "email_empty": "Поле электронной почты не может быть пустым", "email_invalid": "Введите корректный адрес электронной почты", "password": "Пароль не может быть пустым", "connect": "Не удалось подключиться к службе аутентификации" } };
const currency = { "usd": "USD" };
const subscription = { "title": "Тарифы и цены", "price_summary": "* Выставляется счёт на ${{pricePerYear}} USD раз в год", "unauthorized_button": "Войдите, чтобы подписаться", "current_plan_button": "Текущий план", "sales_button": "Связаться с отделом продаж", "book_demo_button": "Записаться на демонстрацию", "request_trial_button": "Запросить пробную версию", "errors": { "payment_initialization": "Произошла ошибка при инициализации платежа. Попробуйте снова или свяжитесь со службой поддержки" }, "success_modal": { "title": "Успех", "thank_you_for_subscribing": "Спасибо за подписку на нашу платформу!", "after_the_page_refreshes": "После обновления страницы вы сможете начать использовать Kontur Atlas" } };
const reports = { "title": "Отчёты Disaster Ninja", "no_data": "Нет данных для этого отчёта", "sorting": "Сортировка данных...", "loading": "Загрузка данных", "open_josm": "Открыть через удалённое управление JOSM", "josm_logo_alt": "Логотип JOSM", "see_all": "Посмотреть все отчёты", "wrong_id": "Неверный идентификатор отчёта", "description": "<0>Kontur </0> создаёт несколько отчётов, которые помогают проверять качество OpenStreetMap. Они содержат ссылки на области на <4>osm.org</4> и ссылки для открытия их в редакторе JOSM с включённым удалённым управлением." };
const about = {};
const loading_episodes = "Загрузка эпизодов";
const zoom_to_world = "Отдалиться ко всему миру";
const cookie_banner = { "header": "Мы ценим вашу конфиденциальность", "body": "Мы используем исключительно необходимые файлы cookie для предоставления персонализированных услуг, а также дополнительные файлы cookie для улучшения {{appName}} и вашего опыта. Вы можете управлять настройками cookie или отозвать согласие на их использование в любое время.\nДополнительную информацию можно найти в нашей [Политике конфиденциальности](about/privacy).", "decline_all": "Отклонить необязательные файлы cookie", "accept_all": "Принять необязательные файлы cookie" };
const live_sensor = { "start": "Начать запись данных с сенсоров", "finish": "Остановить запись данных с сенсоров", "finishMessage": "Запись завершена", "startMessage": "Запись началась", "noSensorsError": "Ваше устройство не имеет необходимые сенсоры" };
const layer_features_panel = { "empty": "Здесь будут отображены объекты слоёв в выделенной области", "noFeatureSelected": "Не выбрано ни одного объекта слоя", "chooseFeature": "Выберите объект слоя", "listInfo": "Список отфильтрован по выделенной области и отсортирован по номеру проекта", "error_loading": "Не удалось загрузить данные об объектах слоя. Попробуйте снова.", "no_features": "В выделенной области не найдено ни одного объекта." };
const reference_area = { "save_as_reference_area": "Сохранить как эталонную область", "error_couldnt_save": "К сожалению, не удалось сохранить вашу эталонную область. Попробуйте снова.", "selected_area_saved_as_reference_area": "Выбранная область сохранена как эталонная область в вашем профиле" };
const ru_common = {
  km,
  m,
  to,
  or,
  maps,
  logout,
  save,
  cancel,
  mcda,
  ok,
  create,
  disasters,
  loading,
  loading_events,
  legend,
  vertical_direction,
  horizontal_direction,
  legend_presentation,
  layers,
  bivariate,
  toolbar,
  locate_me,
  layer_actions,
  focus_geometry_layer,
  feed,
  deselect,
  spinner_text,
  updated,
  started,
  no_data_received,
  wrong_data_received,
  error: error$2,
  sort_icon,
  configs,
  errors,
  event_list,
  categories,
  groups,
  modes,
  advanced_analytics_data_list,
  profile,
  multivariate,
  search,
  episode,
  create_layer,
  analytics_panel,
  advanced_analytics_panel,
  advanced_analytics_empty,
  current_event,
  llm_analytics,
  draw_tools,
  boundary_selector,
  geometry_uploader,
  focus_geometry,
  reference_area_layer,
  drawings,
  sidebar,
  login,
  currency,
  subscription,
  reports,
  about,
  loading_episodes,
  zoom_to_world,
  cookie_banner,
  live_sensor,
  layer_features_panel,
  reference_area
};
const I18N_FALLBACK_LANGUAGE = "en";
const languageResources = {
  en: { common: en_common },
  es: { common: es_common },
  ar: { common: ar_common },
  ko: { common: ko_common },
  id: { common: id_common },
  de: { common: de_common },
  uk: { common: uk_common },
  be: { common: be_common },
  ru: { common: ru_common }
};
instance.use(Browser).use(initReactI18next).init({
  fallbackLng: I18N_FALLBACK_LANGUAGE,
  debug: false,
  defaultNS: "common",
  interpolation: {
    escapeValue: false
  },
  contextSeparator: ":",
  pluralSeparator: ":",
  resources: {
    ...languageResources
  }
});
const TranslationService = {
  t: (key, options) => {
    const translation = instance.t(key, options);
    if (typeof translation === "string") return translation;
    if ((options == null ? void 0 : options.returnObjects) && typeof translation === "object") {
      return translation;
    }
    console.error(`Not supported translation result for key: ${key}`);
    return key;
  },
  getSupportedLanguage: (preferredLanguages, fallbackLanguage) => {
    for (const langCode of preferredLanguages) {
      try {
        const language2 = new Intl.Locale(langCode).language;
        if (language2 in languageResources) {
          return language2;
        }
      } catch {
        console.error("Couldn't parse language code:", langCode);
      }
    }
    if (!(fallbackLanguage in languageResources)) {
      console.error(`Provided fallback language (${fallbackLanguage}) isn't supported`);
    }
    return fallbackLanguage;
  },
  instance
};
function getAsset(asset, abortController) {
  const endpoint = `/apps/${configRepo.get().id}/assets`;
  return apiClient.get(`${endpoint}/${asset}`, void 0, {
    headers: { "user-language": TranslationService.instance.language },
    signal: void 0
  });
}
const PagesDocumentElementRenderers = {
  css: CssElement,
  md: MarkdownElement
};
function fetchPagesDocument(doc) {
  return Promise.all(
    doc.map(async (element) => {
      if (element.url) {
        try {
          const res = await getAsset(element.url);
          return { ...element, data: res };
        } catch (error2) {
          console.error(`Failed to load asset from ${element.url}:`, error2);
        }
      }
      return { ...element, data: element.data || "" };
    })
  );
}
function CssElement({ data }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: data });
}
function MarkdownElement({ data }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "app-pages-element-markdown", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MarkdownContent, { content: data }) });
}
function PagesDocument({
  doc,
  wrapperComponent: Wrapper = Article,
  id
}) {
  const data = usePromise(fetchPagesDocument, [doc]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Wrapper, { id: `app-pages-docid-${id}`, children: data.map((element, index2) => {
    const Renderer = PagesDocumentElementRenderers[element.type];
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Renderer, { ...element }, index2);
  }) });
}
const PaymentPlanCardFooter = reactExports.memo(function PaymentPlanCardFooter2({
  planConfig,
  isUserAuthorized,
  currentSubscription,
  billingOption
}) {
  if (billingOption == null ? void 0 : billingOption.pricePerYear) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { type: "caption", children: TranslationService.t("subscription.price_summary", {
      pricePerYear: billingOption.pricePerYear.toLocaleString("en-US")
    }) });
  }
  return null;
});
const priceWrap = "_priceWrap_11z70_1";
const dollarSign = "_dollarSign_11z70_7";
const amount = "_amount_11z70_15";
const perMonth = "_perMonth_11z70_21";
const s$k = {
  priceWrap,
  dollarSign,
  amount,
  perMonth
};
function Price({ amount: amount2, className }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clsx(s$k.priceWrap, className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$k.dollarSign, children: "$" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$k.amount, children: amount2.toLocaleString("en-US") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$k.perMonth, children: [
      TranslationService.t("currency.usd"),
      " / mo*"
    ] })
  ] });
}
const planCard = "_planCard_q8sg6_1";
const initialPrice = "_initialPrice_q8sg6_88";
const price = "_price_q8sg6_94";
const hidden = "_hidden_q8sg6_98";
const buttonWrapper = "_buttonWrapper_q8sg6_124";
const footerWrapper = "_footerWrapper_q8sg6_155";
const paymentPlanButton = "_paymentPlanButton_q8sg6_191";
const s$j = {
  planCard,
  initialPrice,
  price,
  hidden,
  buttonWrapper,
  footerWrapper,
  paymentPlanButton
};
const pricingWrap = "_pricingWrap_wgpmi_1";
const pricingPlans = "_pricingPlans_wgpmi_7";
const plans = "_plans_wgpmi_46";
const ss = {
  pricingWrap,
  pricingPlans,
  plans
};
const config$1 = {
  plans: [
    {
      id: "kontur_atlas_edu",
      name: "Educational",
      style: "basic",
      billingCycles: [
        {
          id: "month",
          initialPricePerMonth: null,
          pricePerMonth: 100,
          pricePerYear: null,
          billingMethods: [
            {
              id: "paypal",
              billingPlanId: "P-8GA97186HP797325NM2B7D7Y"
            }
          ]
        },
        {
          id: "year",
          initialPricePerMonth: 100,
          pricePerMonth: 95,
          pricePerYear: 1140,
          billingMethods: [
            {
              id: "paypal",
              billingPlanId: "P-02L9453417504204DM2B7FDQ"
            }
          ]
        }
      ]
    },
    {
      id: "kontur_atlas_pro",
      name: "Professional",
      style: "premium",
      billingCycles: [
        {
          id: "month",
          initialPricePerMonth: null,
          pricePerMonth: 1e3,
          pricePerYear: null,
          billingMethods: [
            {
              id: "paypal",
              billingPlanId: "P-47286102F9496000PM2B7FXA"
            }
          ]
        },
        {
          id: "year",
          initialPricePerMonth: 1e3,
          pricePerMonth: 950,
          pricePerYear: 11400,
          billingMethods: [
            {
              id: "paypal",
              billingPlanId: "P-9TD56337G94931803M2B7GTI"
            }
          ]
        }
      ]
    },
    {
      id: "kontur_atlas_custom",
      name: "Custom",
      style: "custom"
    }
  ]
};
const _plans = "# Educational\n\nFor students, hobbyists, and anyone testing the entry-level option before upgrading\n\n###### **edu**\n\n- Multi-criteria decision analyses\n- AI analytics\n- Favorite area of interest\n- Download analyses\n\n---\n\n# Professional\n\nFor GIS data analysts and managers who work with GIS on a daily basis\n\n###### **pro**\n\n- Multi-criteria decision analyses\n- AI analytics\n- Favorite area of interest\n- Download analyses\n- Customer support\n- Custom requests\n- Upload custom indicators for analytics\n\n---\n\n# Custom\n\n# Enterprise\n\nFor GIS data analysts and managers who work with GIS on a daily basis\nContact sales, book a demo or write to us at <info@kontur.io> for custom pricing and features\n\n###### **ent**\n\n- Multiple seats\n- Custom workflows\n- Custom features\n- Custom design\n- Training and onboarding\n- Support\n";
const css = `
.premium > .${s$j.planName}::before {
  content: '★';
  font-size: larger;
  padding-right: 4px;
}

.${s$j.planName} {
  font-family: var(--font-family);
  font-style: normal;
  font-weight: 600;
  font-size: 16px;
}

.${ss.pricingWrap} {
  & ul {
    list-style-type: none;
    padding-left: 0;
    & li::before {
      content: "✔";
      display: inline-block;
      margin-right: var(--double-unit);
      color: var(--strong-color);
    }
  }
}
`;
const Plans_fixture = {
  Plans: /* @__PURE__ */ jsxRuntimeExports.jsx(Plans, { markdown: _plans, styling: css, isUserAuthorized: false })
};
function Plans({ styling = "", markdown: markdown2 = _plans, isUserAuthorized = false }) {
  const [currentBillingCycleId] = useFixtureSelect("buttonType", {
    options: ["month", "year"]
  });
  const currentSubscription = {
    id: "1",
    billingPlanId: "1",
    billingSubscriptionId: "1"
  };
  const compiled = Xe(markdown2, {
    overrides: {
      a: MarkdownLink,
      img: MarkdownMedia
    },
    wrapper: null
  });
  console.warn(compiled);
  const structured = splitIntoSections(compiled);
  console.warn(structured);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ss.pricingWrap, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: styling }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ss.pricingPlans, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ss.plans, children: config$1.plans.map((plan, index2) => {
      var _a2, _b, _c;
      const planContent = structured[index2];
      const planName = (_a2 = planContent.shift()) == null ? void 0 : _a2.props.children[0];
      const highlightsBlock = planContent.pop();
      planContent.pop();
      const isCustom = !plan.billingCycles;
      const styleClass = plan.style;
      const billingOption = (_b = plan.billingCycles) == null ? void 0 : _b.find(
        (option) => option.id === currentBillingCycleId
      );
      const actionsBlock = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$j.buttonWrapper, children: [
        !isUserAuthorized && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: clsx(s$j.paymentPlanButton, styleClass), children: "Sign in to subscribe" }),
        isUserAuthorized && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "[PAYPAL BUTTONS INJECTED HERE]" })
      ] });
      const priceBlock = !isCustom && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        billingOption && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: clsx(s$j.initialPrice, {
              [s$j.hidden]: billingOption.id === "month"
            }),
            children: `$${(_c = billingOption == null ? void 0 : billingOption.initialPricePerMonth) == null ? void 0 : _c.toLocaleString("en-US")} USD`
          }
        ),
        billingOption && /* @__PURE__ */ jsxRuntimeExports.jsx(Price, { className: s$j.price, amount: billingOption.pricePerMonth })
      ] });
      const footerBlock = !isCustom && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$j.footerWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        PaymentPlanCardFooter,
        {
          planConfig: plan,
          isUserAuthorized,
          currentSubscription,
          billingOption
        }
      ) });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clsx(s$j.planCard, styleClass), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$j.planName, children: planName }),
        priceBlock,
        planContent,
        actionsBlock,
        highlightsBlock,
        footerBlock
      ] }, plan.id);
    }) }) })
  ] });
}
const fixture0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Plans_fixture
}, Symbol.toStringTag, { value: "Module" }));
const _configDataMock = {
  baseUrl: "/active/",
  initialUrl: "https://disaster.ninja/active/map?map=4.920/37.682/112.588&event=1c1eb9ce-2fb0-4660-ae2e-ee93d15f8874&layers=kontur_lines%2CactiveContributors%2CeventShape%2ChotProjects_outlines%2Cpopulation_density%2Cfocused-geometry",
  initialUrlData: {
    layers: ["kontur_lines", "population_density"]
  },
  apiGateway: "https://disaster.ninja/active/api",
  reportsApiGateway: "/active/reports",
  bivariateTilesRelativeUrl: "api/tiles/bivariate/v1/",
  bivariateTilesIndicatorsClass: "all",
  refreshIntervalSec: 300,
  sentryDsn: "",
  keycloakUrl: "https://keycloak01.kontur.io",
  keycloakRealm: "kontur",
  keycloakClientId: "kontur_platform",
  // intercomDefaultName: null,
  intercomAppId: "e59cl64z",
  intercomSelector: "#kontur_header_chat_btn",
  defaultFeed: "kontur-public",
  osmEditors: [
    {
      id: "josm",
      title: "JOSM",
      url: "https://www.openstreetmap.org/edit?editor=remote#map="
    },
    {
      id: "id",
      title: "iD",
      url: "https://www.openstreetmap.org/edit?editor=id&node=2188188227#map="
    },
    {
      id: "rapid",
      title: "RapiD",
      url: "https://mapwith.ai/rapid#map="
    }
  ],
  autofocusZoom: 13,
  mapBlankSpaceId: "map-view",
  mapBaseStyle: "https://prod-basemap-tileserver.k8s-01.konturlabs.com/layers/tiles/basemap/style_ninja_en.json",
  featuresByDefault: {
    events_list: true,
    current_event: true,
    reports: true,
    current_episode: true,
    episode_list: true,
    osm_edit_link: true,
    side_bar: true,
    analytics_panel: true,
    map_layers_panel: true,
    focused_geometry_layer: true,
    map_ruler: true,
    boundary_selector: true,
    draw_tools: true,
    geometry_uploader: true,
    legend_panel: true,
    // @ts-ignore
    url_store: true,
    feature_settings: true,
    layers_in_area: true,
    toasts: true,
    interactive_map: true,
    feed_selector: true,
    header: true,
    intercom: true,
    geocoder: true,
    communities: true,
    tooltip: true
  },
  id: "9043acf9-2cf3-48ac-9656-a5d7c4b7593d",
  name: "Kontur Atlas",
  description: "Kontur SAAS application",
  ownedByUser: false,
  extent: [-135, 0, 63, 62],
  sidebarIconUrl: "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/favicon.svg",
  faviconUrl: "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/favicon.svg",
  faviconPack: {
    "favicon.svg": "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/favicon.svg",
    "favicon.ico": "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/favicon.ico",
    "apple-touch-icon.png": "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/apple-touch-icon.png",
    "icon-192x192.png": "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/icon-192x192.png",
    "icon-512x512.png": "/active/api/apps/9043acf9-2cf3-48ac-9656-a5d7c4b7593d/assets/icon-512x512.png"
  },
  // @ts-ignore
  features: {
    side_bar: true,
    intercom: true,
    tooltip: true,
    subscription: {
      billingMethodsDetails: [
        {
          id: "paypal",
          clientId: "xxxxxxx-xxxx-xxxxxxxxxxxxxx"
        }
      ],
      billingCyclesDetails: [
        {
          id: "month",
          name: "Monthly",
          note: null
        },
        {
          id: "year",
          name: "Annually",
          note: "Save 5%"
        }
      ],
      plans: [
        {
          id: "kontur_atlas_edu",
          name: "Educational",
          style: "basic",
          billingCycles: [
            {
              id: "month",
              initialPricePerMonth: null,
              pricePerMonth: 100,
              pricePerYear: null,
              billingMethods: [
                {
                  id: "paypal",
                  billingPlanId: "P-000000000000000000000000"
                }
              ]
            },
            {
              id: "year",
              initialPricePerMonth: 100,
              pricePerMonth: 95,
              pricePerYear: 1140,
              billingMethods: [
                {
                  id: "paypal",
                  billingPlanId: "P-000000000000000000000000"
                }
              ]
            }
          ]
        },
        {
          id: "kontur_atlas_pro",
          name: "Professional",
          style: "premium",
          billingCycles: [
            {
              id: "month",
              initialPricePerMonth: null,
              pricePerMonth: 1e3,
              pricePerYear: null,
              billingMethods: [
                {
                  id: "paypal",
                  billingPlanId: "P-000000000000000000000000"
                }
              ]
            },
            {
              id: "year",
              initialPricePerMonth: 1e3,
              pricePerMonth: 950,
              pricePerYear: 11400,
              billingMethods: [
                {
                  id: "paypal",
                  billingPlanId: "P-000000000000000000000000"
                }
              ]
            }
          ]
        },
        {
          id: "kontur_atlas_custom",
          name: "Custom",
          style: "custom",
          actions: [
            {
              name: "contact_sales",
              params: {
                link: "https://calendly.com/"
              }
            },
            {
              name: "book_a_demo"
            }
          ]
        }
      ]
    },
    app_login: true,
    toasts: true,
    use_3rdparty_analytics: true,
    about_page: {
      tabId: "about",
      assetUrl: "about.md",
      subTabs: [
        {
          tabId: "terms",
          assetUrl: "terms.md"
        },
        {
          tabId: "privacy",
          assetUrl: "privacy.md"
        },
        {
          tabId: "user-guide",
          assetUrl: "user_guide.md"
        }
      ]
    }
  },
  public: true,
  initialUser: {
    username: "",
    email: "",
    fullName: "",
    language: "en",
    useMetricUnits: true,
    subscribedToKonturUpdates: false,
    bio: "",
    osmEditor: "josm",
    defaultFeed: "kontur-public",
    theme: "kontur"
  },
  defaultLayers: [
    {
      id: "kontur_lines",
      source: {
        type: "maplibre-style-url",
        urls: [
          "https://prod-basemap-tileserver.k8s-01.konturlabs.com/layers/tiles/basemap/style_ninja_en.json"
        ]
      },
      ownedByUser: false
    },
    {
      id: "population_density",
      // @ts-ignore
      source: {
        urls: [
          "https://disaster.ninja/active/api/tiles/bivariate/v1/{z}/{x}/{y}.mvt?indicatorsClass=general"
        ]
      },
      // @ts-ignore
      legend: {
        type: "simple",
        steps: [
          {
            stepName: "0 - 1.27",
            stepShape: "square",
            style: {
              color: "#F0F0D6",
              "fill-color": "#F0F0D6",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "1.27 - 2.45",
            stepShape: "square",
            style: {
              color: "#ECECC4",
              "fill-color": "#ECECC4",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "2.45 - 5.75",
            stepShape: "square",
            style: {
              color: "#EAEAB0",
              "fill-color": "#EAEAB0",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "5.75 - 12.43",
            stepShape: "square",
            style: {
              color: "#E8E89D",
              "fill-color": "#E8E89D",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "12.43 - 28.47",
            stepShape: "square",
            style: {
              color: "#E1D689",
              "fill-color": "#E1D689",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "28.47 - 66.03",
            stepShape: "square",
            style: {
              color: "#DAC075",
              "fill-color": "#DAC075",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "66.03 - 172.46",
            stepShape: "square",
            style: {
              color: "#D1A562",
              "fill-color": "#D1A562",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "172.46 - 535.67",
            stepShape: "square",
            style: {
              color: "#C98A50",
              "fill-color": "#C98A50",
              "fill-opacity": 0.8
            }
          },
          {
            stepName: "535.67 - 46200",
            stepShape: "square",
            style: {
              color: "#BF6C3F",
              "fill-color": "#BF6C3F",
              "fill-opacity": 0.8
            }
          }
        ]
      },
      ownedByUser: false
    }
  ],
  activeLayers: ["kontur_lines", "population_density"]
};
configRepo.get = () => _configDataMock;
const _md = `![Kontur Atlas](about-atlas-1.png)

# Kontur Atlas

Atlas is your GPS for big decisions. It's a tool that helps you use maps and data to figure out a wide range of things, from where to open a new store to exploring environmental sustainability.

![Geospatial Data with Ease](about-atlas-2.png)

## Geospatial Data with Ease

### Browse & Choose Data

We've got tons of info like who lives where and how people get around. Find the data that'll answer your questions.

### Make Maps

With a few clicks, Atlas turns that data into maps and visuals so it's easy to understand.

### Analyze & Decide

Use these insights to make smart decisions, like picking the perfect spot for your next big project or making concussions based on spatial patterns.

### Jump in and start exploring

Your next big opportunity is waiting to be mapped out!

## _[Subscribe to Atlas](/pricing)_ wrapped in "\\_"

### **[Subscribe to Atlas](/pricing)** "\\_\\_"

### **_[Subscribe to Atlas](/pricing)_** "\\_\\_\\*"

## How to Use

---

![youtube](https://www.youtube.com/embed/g7WMD10DMPs?si=Gl6RdNM0L3ufi0uF::800,470,true)

### Area Selection

To choose an area for analysis, you can use the toolbar to select an administrative unit, draw a shape manually, or import a GeoJSON file.

![youtube](https://www.youtube.com/embed/aCXaAYEW0oM::800,470,true)

### Analytics Panel

This panel displays essential data about your selected area.

#### AI Insights

Compares your area's data with global averages, alerting you to any significant discrepancies.

#### Personalized AI Insights

Reference Area: This allows you to set a known area as a reference point for comparisons and highlights differences.
Bio: Here, you can record details like who you're working for, your analysis purpose, and key topics, helping to personalize AI conclusions.

![youtube](https://www.youtube.com/embed/Md5Mex-POBo::800,470,true)

### Creating Custom Analysis

To create your own analysis, select the "MCDA" button in the toolbar.

#### Choosing Relevant Layers

Start by picking data layers appropriate for your requirements — this could include anything from population density to environmental risk factors.

#### Browse the map

By default, the map displays red hexagons in high-value areas and green hexagons where values are minimal. Click on any hexagon to access detailed info for that particular sector.

#### Layer Customization

Enhance your analysis by fine-tuning the range and what is bad and good of each layer. This means you can focus specifically on aspects crucial to your study.

---

### _[Learn more on kontur.io](https://www.kontur.io/atlas)_
`;
const _css = "article {\n  & * {\n    outline: lime solid thin;\n  }\n}\n";
console.info("test app id", configRepo.get().id);
const PagesDocument_fixture = {
  "PagesDocument with custom css": /* @__PURE__ */ jsxRuntimeExports.jsx(
    PagesDocument,
    {
      id: "",
      doc: [
        {
          type: "md",
          data: `
#Kontur Atlas
Atlas is your GPS for big decisions. It's a tool that helps you use maps and data to figure out a wide range of things, from where to open a new store to exploring environmental sustainability.
`
        },
        {
          type: "css",
          data: `
h1 { background-color: #f2f2f2; }
p { background-color: #BF6C3F; }
`
        }
      ]
    }
  ),
  "Links test": /* @__PURE__ */ jsxRuntimeExports.jsx(
    PagesDocument,
    {
      id: "",
      doc: [
        {
          type: "md",
          data: `
[Link](https://example.com)

Controller using this email: [hello@kontur.io](mailto:hello@kontur.io) or contact address.

Controller using this email: <hello@kontur.io> or contact address.

hello@kontur.io

kancelaria@uodo.gov.pl

ng: <kancelaria@uodo.gov.pl>

http://www.youronlinechoices.com/

ng: <http://www.youronlinechoices.com/>
`
        }
      ]
    }
  ),
  "PagesDocument markdown sample": /* @__PURE__ */ jsxRuntimeExports.jsx(
    PagesDocument,
    {
      id: "",
      doc: [
        {
          type: "md",
          data: _md
        },
        {
          type: "css",
          data: _css
        }
      ]
    }
  )
};
const fixture1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PagesDocument_fixture
}, Symbol.toStringTag, { value: "Module" }));
const eventCardLayoutTemplate = {
  type: "Card",
  action: "focusEvent",
  $props: { active: "active" },
  children: [
    {
      type: "Row",
      children: [
        { type: "Title", $value: "eventName" },
        { type: "Severity", $value: "severity" }
      ]
    },
    {
      type: "Text",
      $value: "location"
    },
    {
      type: "Row",
      children: [
        { type: "Field", $value: "affectedPopulation" },
        { type: "Field", $value: "settledArea" },
        { type: "Field", $value: "osmGaps" },
        { type: "Field", $value: "loss" }
      ]
    },
    {
      type: "Text",
      $value: "description",
      $if: "active"
    },
    {
      type: "IconButton",
      icon: "Play24",
      value: "Play episodes",
      action: "playEpisodes",
      $if: "showEpisodesButton"
    },
    {
      type: "Row",
      $if: "active",
      children: [
        {
          $value: "externalUrls",
          $template: {
            type: "Url"
          }
        }
      ]
    },
    {
      type: "Field",
      $value: "startedAt"
    },
    {
      type: "Field",
      $value: "updatedAt"
    }
  ]
};
const fieldsRegistry = {
  default: {
    type: "text"
  },
  affectedPopulation: {
    type: "number",
    tooltip: TranslationService.t("event_list.analytics.affected_people.tooltip"),
    icon: "People16",
    format: "number"
  },
  settledArea: {
    type: "number",
    tooltip: TranslationService.t("event_list.analytics.settled_area_tooltip"),
    icon: "Area16",
    format: "square_km"
  },
  osmGaps: {
    type: "number",
    tooltip: TranslationService.t("osm_gaps"),
    icon: "OsmGaps16",
    format: "percentage_rounded"
  },
  loss: {
    type: "number",
    tooltip: TranslationService.t("event_list.analytics.loss_tooltip"),
    icon: "DollarCircle16",
    format: "compact_currency"
  },
  // date
  startedAt: {
    type: "date",
    label: TranslationService.t("started"),
    format: "date"
  },
  created: {
    type: "date",
    label: TranslationService.t("created"),
    format: "date"
  },
  updatedAt: {
    type: "date",
    label: TranslationService.t("updated"),
    format: "date"
  },
  // HOT
  mappingTypes: {
    type: "text",
    label: TranslationService.t("mapping_types")
  },
  projectId: {
    type: "number",
    text: (v2) => `#${v2}`
  }
};
fieldsRegistry["lastUpdated"] = fieldsRegistry.updatedAt;
const language = TranslationService.instance.language || "default";
const dateFormatter = new Intl.DateTimeFormat(language, {
  hour: "numeric",
  minute: "numeric",
  year: "numeric",
  month: "short",
  day: "numeric",
  timeZoneName: "short"
}).format;
const numberFormatter = new Intl.NumberFormat(language);
const number_f000_Formatter = new Intl.NumberFormat(language, {
  maximumFractionDigits: 3
});
const percentFormatter = new Intl.NumberFormat(language, {
  style: "percent",
  maximumFractionDigits: 0
});
const currencyFormatter = new Intl.NumberFormat(language, {
  style: "currency",
  currency: "USD"
});
const compactCurrencyFormatter = new Intl.NumberFormat(language, {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 0
});
const formatsRegistry = {
  date(date) {
    return date ? dateFormatter(new Date(date)) : "";
  },
  square_km(value2) {
    return `${number_f000_Formatter.format(value2)} km²`;
  },
  percentage_rounded(value2) {
    return percentFormatter.format(value2 / 100);
  },
  currency(value2) {
    return currencyFormatter.format(value2);
  },
  compact_currency(value2) {
    return compactCurrencyFormatter.format(value2);
  },
  number(value2) {
    return numberFormatter.format(value2);
  },
  text(v2) {
    return "" + v2;
  },
  url_domain(url2, placeholder = "www") {
    try {
      const domain = new URL(url2).hostname.replace(/^www\./, "");
      return domain;
    } catch (_2) {
    }
    return placeholder;
  }
};
function compilePathAccessor(path2) {
  const segments = path2.split(".");
  const code = `
    return function(data) {
      return data${segments.map((segment) => {
    if (/^\\d+$/.test(segment)) {
      return `?.[${segment}]`;
    }
    if (/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(segment)) {
      return `?.${segment}`;
    }
    const safe = segment.replace(/"/g, `\\"`);
    return `?.["${safe}"]`;
  }).join("")};
    }
  `;
  return new Function(code)();
}
function compileAccessors(paths) {
  const accessors = {};
  for (const path2 of paths) {
    accessors[path2] = compilePathAccessor(path2);
  }
  return accessors;
}
function extractDataBindingPaths(node, seen = /* @__PURE__ */ new Set()) {
  if (!node || typeof node !== "object" || seen.has(node)) return [];
  seen.add(node);
  const paths = [];
  if (node.$value && typeof node.$value === "string") {
    paths.push(node.$value);
  }
  if (node.$context && typeof node.$context === "string") {
    paths.push(node.$context);
  }
  if (node.$props && typeof node.$props === "object") {
    for (const propPath of Object.values(node.$props)) {
      if (typeof propPath === "string") {
        paths.push(propPath);
      }
    }
  }
  if (node.$if && typeof node.$if === "string") {
    paths.push(node.$if);
  }
  if (node.$template && typeof node.$template === "object") {
    paths.push(...extractDataBindingPaths(node.$template, seen));
  }
  if (Array.isArray(node.children)) {
    for (const child of node.children) {
      paths.push(...extractDataBindingPaths(child, seen));
    }
  } else if (node.children && typeof node.children === "object") {
    paths.push(...extractDataBindingPaths(node.children, seen));
  }
  return [...new Set(paths)];
}
function useUniLayoutCompiledAccessors(layoutDefinition) {
  return reactExports.useMemo(() => {
    const paths = extractDataBindingPaths(layoutDefinition);
    return compileAccessors(paths);
  }, [layoutDefinition]);
}
const UniLayoutContext = React.createContext(null);
const useUniLayoutContext = () => {
  const context2 = React.useContext(UniLayoutContext);
  if (!context2) {
    throw new Error("useUniLayoutContext must be used within a UniLayout");
  }
  return context2;
};
const defaultFormatter = (v2) => v2 !== null && v2 !== void 0 ? String(v2) : "";
function useUniLayoutContextValue({
  layout,
  actionHandler = () => {
  },
  customFieldsRegistry = {},
  customFormatsRegistry = {}
}) {
  const mergedFormatsRegistry = reactExports.useMemo(
    () => ({
      ...formatsRegistry,
      ...customFormatsRegistry
    }),
    [customFormatsRegistry]
  );
  const mergedFieldsRegistry = reactExports.useMemo(
    () => ({
      ...fieldsRegistry,
      ...customFieldsRegistry
    }),
    [customFieldsRegistry]
  );
  const precompiledAccessors = useUniLayoutCompiledAccessors(layout);
  const getFormattedValue = reactExports.useCallback(
    (fieldMeta, rawValue) => {
      if (rawValue === null || rawValue === void 0) return "";
      const formatKey = (fieldMeta == null ? void 0 : fieldMeta.format) || "text";
      const formatter = mergedFormatsRegistry[formatKey] || defaultFormatter;
      const formattedValue = formatter(rawValue);
      return (fieldMeta == null ? void 0 : fieldMeta.text) ? fieldMeta.text(formattedValue) : formattedValue;
    },
    [mergedFormatsRegistry]
  );
  return reactExports.useMemo(
    () => ({
      fieldsRegistry: mergedFieldsRegistry,
      formatsRegistry: mergedFormatsRegistry,
      precompiledAccessors,
      actionHandler,
      getFormattedValue
    }),
    [
      precompiledAccessors,
      actionHandler,
      mergedFieldsRegistry,
      mergedFormatsRegistry,
      getFormattedValue
    ]
  );
}
const isErrorWithMessage = (e) => {
  return e !== null && typeof e === "object" && "message" in e;
};
const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const toCapitalizedList = (arr) => arr.map(capitalize).join(", ");
const spacesToUnderscore = (str) => str.replace(/\s+/g, "_");
const sumBy = (arr, prop) => arr.reduce((acc, item) => acc + item[prop], 0);
function isNumber(value2) {
  return typeof value2 === "number" && isFinite(value2);
}
const haveValue = (val) => val !== void 0 && val !== null;
const row$2 = "_row_6zanc_1";
const s$i = {
  row: row$2
};
function Row({ wrap = true, children, className, style: style2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: clsx(s$i.row, className),
      style: { ...style2, flexWrap: wrap ? "wrap" : "nowrap" },
      children
    }
  );
}
const card$1 = "_card_aste0_1";
const selected$3 = "_selected_aste0_16";
const cardContent = "_cardContent_aste0_29";
const clickable = "_clickable_aste0_35";
const s$h = {
  card: card$1,
  selected: selected$3,
  cardContent,
  clickable
};
function Card({
  children,
  active: active2,
  action: action2,
  className,
  style: style2,
  handleAction
}) {
  const handleClick = React.useCallback(() => {
    if (action2 && handleAction) {
      handleAction(action2);
    }
  }, [action2, handleAction]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: clsx(s$h.card, active2 && s$h.selected, action2 && s$h.clickable, className),
      style: style2,
      onClick: action2 ? handleClick : void 0,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$h.cardContent, children })
    }
  );
}
const indicator$1 = "_indicator_h9oko_1";
const s$g = {
  indicator: indicator$1
};
const SEVERITY_CONFIG = {
  UNKNOWN: {
    level: 0,
    color: null,
    text: TranslationService.t("event_list.severity_unknown")
  },
  TERMINATION: {
    level: 1,
    color: "#FFDF35",
    text: TranslationService.t("event_list.severity_termination")
  },
  MINOR: {
    level: 2,
    color: "#FFB800",
    text: TranslationService.t("event_list.severity_minor")
  },
  MODERATE: {
    level: 3,
    color: "#FF8A00",
    text: TranslationService.t("event_list.severity_moderate")
  },
  SEVERE: {
    level: 4,
    color: "#FF3D00",
    text: TranslationService.t("event_list.severity_severe")
  },
  EXTREME: {
    level: 5,
    color: "#EA2A00",
    text: TranslationService.t("event_list.severity_extreme")
  }
};
const SEVERITY_LEVELS = Object.values(SEVERITY_CONFIG).filter(({ level }) => level > 0);
const COLORS = SEVERITY_LEVELS.map(({ color }) => color);
function SeverityIndicatorImpl({ value: value2, className }) {
  if (!SEVERITY_CONFIG[value2]) {
    return null;
  }
  const pivot = SEVERITY_CONFIG[value2].level;
  const tooltip = SEVERITY_CONFIG[value2].text;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleTooltip, { content: tooltip, placement: "top", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: clsx(s$g.indicator, className), children: COLORS.map((color, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        backgroundColor: i2 < pivot ? color ?? "none" : "#eceeef"
      }
    },
    i2
  )) }) });
}
const SeverityIndicator = reactExports.memo(SeverityIndicatorImpl);
const url = "_url_1o8yo_1";
const icon$2 = "_icon_1o8yo_12";
const s$f = {
  url,
  icon: icon$2
};
function Url(props) {
  const { value: value2 = "#", label: label2, newTab = true, className } = props;
  const displayText = label2 || (value2 ? formatsRegistry.url_domain(value2) : "");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "a",
    {
      href: value2,
      className: clsx(s$f.url, className),
      target: newTab ? "_blank" : void 0,
      rel: newTab ? "noopener noreferrer" : void 0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: displayText }),
        newTab && /* @__PURE__ */ jsxRuntimeExports.jsx(Memo$9, { className: s$f.icon })
      ]
    }
  );
}
const titleText = "_titleText_kpgt4_1";
const text = "_text_kpgt4_8";
const alignStart = "_alignStart_kpgt4_14";
const baseStyles = {
  titleText,
  text,
  alignStart
};
function Title({ value: value2, className }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: clsx(baseStyles.titleText, className), children: value2 });
}
function Text({ value: value2, className }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: clsx(baseStyles.text, className), children: value2 });
}
const badge = "_badge_108ln_1";
const error$1 = "_error_108ln_12";
const success = "_success_108ln_17";
const warning = "_warning_108ln_22";
const info = "_info_108ln_27";
const neutral = "_neutral_108ln_32";
const s$e = {
  badge,
  error: error$1,
  success,
  warning,
  info,
  neutral
};
const Variants = {
  error: s$e.error,
  success: s$e.success,
  warning: s$e.warning,
  info: s$e.info,
  neutral: s$e.neutral
};
function Badge({
  value: value2,
  variant = "neutral",
  mapping,
  className = "",
  style: style2 = {}
}) {
  if (value2 === void 0) return null;
  const key = ("" + value2).toLowerCase();
  const computedVariant = (mapping == null ? void 0 : mapping[key]) ?? variant;
  const variantClass = Variants[computedVariant.toLowerCase()] ?? "";
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: clsx(s$e.badge, variantClass, className), style: style2, children: value2 });
}
const progress = "_progress_2aklk_1";
const caption = "_caption_2aklk_9";
const desc = "_desc_2aklk_13";
const stack = "_stack_2aklk_19";
const s$d = {
  progress,
  caption,
  desc,
  stack
};
function StackedProgressBar({
  value: items,
  caption: caption2,
  className
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clsx(s$d.progress, className), children: [
    caption2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$d.caption, children: caption2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$d.stack, children: items.map(({ color, value: value2 }, i2) => {
      const style2 = {};
      if (color) style2["backgroundColor"] = color;
      const clampedValue = Math.max(0, Math.min(100, value2));
      style2["width"] = clampedValue + "%";
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: style2 }, i2);
    }).reverse() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$d.desc, children: items.map(({ color, title: title2, value: value2 }, i2) => {
      const style2 = {};
      if (color) style2["color"] = color;
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: style2, children: value2 + title2 }, i2);
    }) })
  ] });
}
function MappingProgress({
  percentValidated,
  percentMapped,
  caption: caption2
}) {
  const items = [
    {
      title: "% Validated",
      value: +percentValidated,
      color: "var(--success-strong)"
    },
    {
      title: "% Mapped",
      value: +percentMapped,
      color: "var(--faint-strong)"
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StackedProgressBar, { value: items, caption: caption2 });
}
const Icon = reactExports.forwardRef(({ icon: icon2, ...svgProps }, ref) => {
  const KonturIcon = icons[icon2];
  reactExports.useEffect(() => {
    if (!icons[icon2]) console.error(`Icon "${icon2}" not found`);
  }, [icon2]);
  return KonturIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(KonturIcon, { ref, ...svgProps }) : null;
});
Icon.displayName = "SvgIcon";
const container$2 = "_container_1vcfi_6";
const icon$1 = "_icon_1vcfi_13";
const value = "_value_1vcfi_18";
const label = "_label_1vcfi_23";
const s$c = {
  container: container$2,
  icon: icon$1,
  value,
  label
};
function Field({
  value: value2,
  $meta,
  className = "",
  showLabel = true,
  format
}) {
  const context2 = useUniLayoutContext();
  if (value2 === void 0) return null;
  const fieldMeta = $meta == null ? void 0 : $meta.value;
  const formattedValue = format && context2.formatsRegistry[format] ? context2.formatsRegistry[format](value2) : context2.getFormattedValue(fieldMeta, value2);
  const shouldShowLabel = showLabel && (fieldMeta == null ? void 0 : fieldMeta.label);
  const tooltip = fieldMeta == null ? void 0 : fieldMeta.tooltip;
  const content = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clsx(s$c.container, className), children: [
    (fieldMeta == null ? void 0 : fieldMeta.icon) && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { icon: fieldMeta.icon, className: s$c.icon }),
    shouldShowLabel && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$c.label, children: fieldMeta.label }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$c.value, children: formattedValue })
  ] });
  if (tooltip) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleTooltip, { content: tooltip, placement: "top", children: content });
  }
  return content;
}
const cardHeader = "_cardHeader_tv12g_1";
const imageContainer = "_imageContainer_tv12g_8";
const image = "_image_tv12g_8";
const icon = "_icon_tv12g_22";
const title = "_title_tv12g_27";
const subtitle = "_subtitle_tv12g_33";
const s$b = {
  cardHeader,
  imageContainer,
  image,
  icon,
  title,
  subtitle
};
function CardHeader({ image: image2, icon: icon2, value: value2, subtitle: subtitle2, className }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clsx(s$b.cardHeader, className), children: [
    image2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$b.imageContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: image2, alt: "", className: s$b.image }) }),
    icon2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { icon: icon2, className: s$b.icon }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$b.title, children: value2 }),
    subtitle2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$b.subtitle, children: subtitle2 })
  ] });
}
function IconButton({
  value: value2,
  $meta,
  icon: icon2,
  variant = "invert-outline",
  action: action2,
  handleAction,
  ...props
}) {
  const context2 = useUniLayoutContext();
  const fieldMeta = $meta == null ? void 0 : $meta.value;
  const formattedValue = context2.getFormattedValue(fieldMeta, value2);
  const tooltip = fieldMeta == null ? void 0 : fieldMeta.tooltip;
  const handler = reactExports.useCallback(() => {
    if (action2 && handleAction) {
      handleAction(action2);
    }
  }, [action2, handleAction]);
  const content = /* @__PURE__ */ jsxRuntimeExports.jsx(
    Button,
    {
      className: baseStyles.alignStart,
      variant,
      size: "tiny",
      onClick: action2 ? handler : void 0,
      iconBefore: icon2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { icon: icon2, style: { height: 16 } }),
      ...props,
      children: formattedValue
    }
  );
  if (tooltip) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleTooltip, { content: tooltip, placement: "top", children: content });
  }
  return content;
}
const componentsRegistry = {
  Card,
  Row,
  CardHeader,
  Title,
  Text,
  Field,
  IconButton,
  Url,
  Badge,
  MappingProgress,
  Severity: SeverityIndicator
};
const ErrorComponent = ({ type, error: error2, severity = "error" }) => {
  const style2 = {
    color: "white",
    backgroundColor: severity === "error" ? "red" : "orange",
    fontSize: "12px"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: style2, children: error2 ? `Error in ${type}: ${error2}` : `Unknown Component: ${type}` });
};
function isComponentNode(node) {
  return node && typeof node === "object" && (typeof node.type === "string" || node.$template);
}
function resolveBinding(dataPath, contextData, context2) {
  const accessor = context2.precompiledAccessors[dataPath];
  if (!accessor) {
    return createBindingError(`No accessor for "${dataPath}"`);
  }
  try {
    const value2 = accessor(contextData);
    const fieldMeta = context2.fieldsRegistry[dataPath] ?? context2.fieldsRegistry.default;
    return { value: value2, fieldMeta };
  } catch (error2) {
    return createBindingError(`Execution failed for "${dataPath}": ${String(error2)}`);
  }
}
function createBindingError(error2) {
  console.error(error2);
  return { value: void 0, fieldMeta: { type: "text" }, error: error2 };
}
function resolveComponent(type) {
  return componentsRegistry[type] || null;
}
function applyOverrides(fieldMeta, overrides = {}) {
  if (!overrides) return fieldMeta;
  return { ...fieldMeta, ...overrides };
}
function processNodeProps(node, data, context2) {
  const {
    props: staticProps,
    $value: dataBindingPath,
    $context: contextBindingPath,
    $props: propsBindings,
    overrides,
    type,
    key,
    children,
    $if,
    ...restNodeProps
  } = node;
  const resolvedProps = { ...restNodeProps, ...staticProps };
  let boundData = data;
  if (contextBindingPath && typeof contextBindingPath === "string") {
    const contextBindingResult = resolveBinding(contextBindingPath, data, context2);
    boundData = contextBindingResult.value;
  }
  if (dataBindingPath && typeof dataBindingPath === "string") {
    const dataBindingResult = resolveBinding(dataBindingPath, boundData, context2);
    const fieldMeta = (overrides == null ? void 0 : overrides.value) ? applyOverrides(dataBindingResult.fieldMeta, overrides.value) : dataBindingResult.fieldMeta;
    resolvedProps.value = dataBindingResult.value;
    resolvedProps.$meta = { value: fieldMeta };
  } else if (!dataBindingPath && haveValue(boundData) && !("value" in resolvedProps)) {
    resolvedProps.value = boundData;
    resolvedProps.$meta = { value: context2.fieldsRegistry.default };
  }
  if (propsBindings && typeof propsBindings === "object") {
    if (!resolvedProps.$meta) {
      resolvedProps.$meta = { value: {} };
    }
    for (const [propName, propPath] of Object.entries(propsBindings)) {
      if (typeof propPath !== "string") {
        continue;
      }
      const propBindingResult = resolveBinding(propPath, boundData, context2);
      const fieldMeta = (overrides == null ? void 0 : overrides[propName]) ? applyOverrides(propBindingResult.fieldMeta, overrides[propName]) : propBindingResult.fieldMeta;
      resolvedProps[propName] = propBindingResult.value;
      resolvedProps.$meta[propName] = fieldMeta;
    }
  }
  if (context2.actionHandler) {
    resolvedProps.handleAction = (action2, actionData) => {
      context2.actionHandler(action2, { ...boundData, ...actionData });
    };
  }
  return { resolvedProps, boundData };
}
function shouldProcessChildren(node) {
  return node.children !== void 0;
}
function renderChildren(children, data) {
  if (Array.isArray(children)) {
    return children.map((child, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutRendererInternal, { node: child, data }, (child == null ? void 0 : child.key) ?? index2));
  }
  if (children && (typeof children === "object" || typeof children === "string" || typeof children === "number" || reactExports.isValidElement(children))) {
    return reactExports.isValidElement(children) ? children : /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutRendererInternal, { node: children, data });
  }
  return null;
}
const LayoutRendererInternal = ({ node, data }) => {
  const context2 = useUniLayoutContext();
  if (node === null || node === void 0 || typeof node === "boolean") {
    return null;
  }
  if (typeof node === "string" || typeof node === "number") {
    return node;
  }
  if (reactExports.isValidElement(node)) {
    return node;
  }
  if (Array.isArray(node)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, { children: node.map((childNode, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      LayoutRendererInternal,
      {
        node: childNode,
        data
      },
      (childNode == null ? void 0 : childNode.key) ?? index2
    )) });
  }
  if (!node || typeof node !== "object") {
    return null;
  }
  const { resolvedProps, boundData } = processNodeProps(node, data, context2);
  if (node.$if) {
    const ifBindingResult = resolveBinding(node.$if, boundData, context2);
    if (!ifBindingResult.value) {
      return null;
    }
  }
  if (node.$template && Array.isArray(resolvedProps.value)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: resolvedProps.value.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutRendererInternal, { node: node.$template, data: item }, index2)) });
  }
  if (!isComponentNode(node) || !node.type) {
    return null;
  }
  const Component = resolveComponent(node.type);
  if (!Component) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorComponent, { type: node.type, severity: "warning" });
  }
  const childrenDataContext = boundData !== void 0 ? boundData : data;
  const renderedChildren = shouldProcessChildren(node) ? renderChildren(node.children, childrenDataContext) : null;
  try {
    return React.createElement(
      Component,
      { ...node.key !== void 0 && { key: node.key }, ...resolvedProps },
      renderedChildren
    );
  } catch (error2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorComponent, { type: node.type, error: `Render error: ${String(error2)}` });
  }
};
const UniLayoutRenderer = reactExports.memo(LayoutRendererInternal);
const eventSampleData = [
  {
    eventId: "cf2027b7-7932-4db1-9532-5315537129f4",
    eventName: "Drought Eastern Mediterranean, Middle East-2024",
    eventType: "DROUGHT",
    description: "The  Drought alert level is Orange.",
    location: "Egypt, Israel, Iraq, Islamic Republic of Iran, Jordan, Lebanon, Gaza Strip, Saudi Arabia, Syria, Turkmenistan, Türkiye",
    severity: "SEVERE",
    affectedPopulation: 170326791,
    settledArea: 313256.1139786269,
    osmGaps: 32,
    startedAt: "2023-08-11T00:00:00Z",
    updatedAt: "2025-04-14T06:01:01.975Z",
    externalUrls: [
      "https://www.gdacs.org/report.aspx?eventtype=DR&eventid=1017535",
      "https://www.gdacs.org/report.aspx?eventid=1017535&episodeid=8&eventtype=DR"
    ],
    bbox: [29.000000000000057, 26.000000000000068, 59.99999999999994, 41.000000000000014],
    centroid: [34.000000000000135, 38.50000000000003],
    episodeCount: 1,
    active: true,
    showEpisodesButton: false
  },
  {
    eventId: "f84f21e0-65c9-48e0-8e37-f43dab2777f5",
    eventName: "Flood",
    eventType: "FLOOD",
    description: "On 17/11/2024, a flood started in Indonesia, lasting until 12/02/2025 (last update). The flood caused 37 deaths and 4190 displaced .",
    location: "Indonesia",
    severity: "MODERATE",
    affectedPopulation: 130969671,
    settledArea: 10031.986031753553,
    osmGaps: 3,
    startedAt: "2024-11-17T01:00:00Z",
    updatedAt: "2025-02-11T15:46:01.944Z",
    externalUrls: [
      "https://www.gdacs.org/report.aspx?eventtype=FL&eventid=1103025",
      "https://www.gdacs.org/report.aspx?eventid=1103025&episodeid=44&eventtype=FL"
    ],
    bbox: [98.1180632, -10.2927858, 140.76358974504504, 4.2304443],
    centroid: [98.8796722168584, 1.1440190000000001],
    episodeCount: 1
  },
  {
    eventId: "b725a2e4-613b-4a10-9916-be7575658bf6",
    eventName: "PRIV Cyclone OPHELIA",
    eventType: "CYCLONE",
    description: "NOTICE... LAND-BASED TROPICAL CYCLONE WATCHES AND WARNINGS ARE NO LONGER INCLUDED IN THE TROPICAL CYCLONE FORECAST/ADVISORY...(TCM). CURRENT LAND-BASED COASTAL WATCHES AND WARNINGS CAN BE FOUND IN THE MOST RECENTLY ISSUED TROPICAL CYCLONE PUBLIC ADVISORY...(TCP). POST-",
    severity: "MODERATE",
    affectedPopulation: 51764949,
    settledArea: 372775.86719946715,
    osmGaps: 6,
    loss: 1067531784,
    startedAt: "2023-09-21T15:00:00Z",
    updatedAt: "2023-09-24T03:02:08.627Z",
    externalUrls: ["https://www.nhc.noaa.gov/text/refresh/MIATCMAT1+shtml/240240.shtml"],
    bbox: [-82.8981311673097, 25.988304006373998, -70.88844047428728, 41.301760744151665],
    centroid: [-77.19293581123283, 35.92034184848231],
    episodeCount: 14
  },
  {
    eventId: "b78cb252-ca5b-4142-81c4-2580cb7185c5",
    eventName: "Flood",
    description: "On 12/10/2024, a flood started in Philippines, lasting until 23/10/2024 (last update). The flood caused 3 deaths and 12793 displaced .",
    location: "Philippines",
    severity: "MODERATE",
    affectedPopulation: 91292456,
    settledArea: 226593.78501049057,
    osmGaps: 24,
    startedAt: "2024-10-20T06:10:00.801Z",
    updatedAt: "2024-10-24T06:16:02.801Z",
    externalUrls: [
      "https://www.gdacs.org/report.aspx?eventtype=FL&eventid=1102952",
      "https://www.gdacs.org/report.aspx?eventid=1102952&episodeid=4&eventtype=FL"
    ],
    bbox: [114.1036921, 4.3833333, 126.8030411, 21.321928],
    centroid: [122.34333739191402, 13.3475474],
    episodeCount: 3,
    showEpisodesButton: true,
    active: true
  },
  {
    eventId: "7f76d4cd-9a6b-493c-8327-dcc5fb7ed62b",
    eventName: "Drought South America-2023",
    description: "The  Drought alert level is Orange.",
    location: "Bolivia, Brazil, Colombia, Ecuador, Peru, Venezuela",
    severity: "SEVERE",
    affectedPopulation: 83774237,
    settledArea: 22623.66198005802,
    osmGaps: 13,
    startedAt: "2024-12-01T01:01:05.006Z",
    updatedAt: "2024-12-08T06:01:05.566Z",
    externalUrls: [
      "https://www.gdacs.org/report.aspx?eventtype=DR&eventid=1016449",
      "https://www.gdacs.org/report.aspx?eventid=1016449&episodeid=44&eventtype=DR"
    ],
    bbox: [
      -79.99999999999982,
      -24.000999999999916,
      -40.80399999999995,
      10.999999999999964
    ],
    centroid: [-68.99999999999991, 8.499999999999986],
    episodeCount: 1
  },
  {
    eventId: "bc61af10-d5e0-4ac6-8209-517cc4cc1c18",
    eventName: "Cyclone KONG-REY-24",
    description: "From 25/10/2024 to 01/11/2024, a Tropical Storm (maximum wind speed of 241 km/h) KONG-REY-24 was active in NWPacific. The cyclone affects these countries: Philippines, Taiwan, China, Japan (vulnerability Medium). Estimated population affected by category 1 (120 km/h) wind speeds or higher is 15.764 million .",
    location: "Philippines, Taiwan, China, Japan",
    severity: "EXTREME",
    affectedPopulation: 327420839,
    settledArea: 338311.5725637373,
    osmGaps: 13,
    startedAt: "2024-11-01T10:01:01.723Z",
    updatedAt: "2024-11-02T10:06:02.723Z",
    externalUrls: [
      "https://www.gdacs.org/report.aspx?eventtype=TC&eventid=1001118",
      "https://www.gdacs.org/report.aspx?eventid=1001118&episodeid=32&eventtype=TC"
    ],
    bbox: [115.90902578825603, 12.11200000000004, 148.425513942233, 39.90399999999999],
    centroid: [120.5266357909849, 26.037351789489346],
    episodeCount: 1
  }
];
const hotData = [
  {
    teams: [],
    author: "naveenpf",
    k_type: "polygon",
    aoiBBOX: [75.956806, 10.176628, 76.874643, 10.774978],
    created: "2018-11-20T17:35:23.715104Z",
    private: false,
    campaigns: [{ id: 261, name: "2018 India Floods" }],
    interests: [{ id: 3, name: "disaster response" }],
    projectId: 5522,
    countryTag: ["India"],
    difficulty: "EASY",
    lastUpdated: "2019-11-27T02:54:50.781237Z",
    projectInfo: {
      name: "India flood mapping",
      locale: "en",
      description: "Monsoon rains have wreaked havoc throughout various states of India, resulting in a number of deaths and huge numbers of displaced citizens. OSM India, supported by HOT, have launched a response to aid relief efforts. This project is to map the buildings.\n\nNote that there may be some buildings already mapped -- please identify buildings that have NOT yet been mapped, and help to improve the quality of the building map edits that have already.",
      instructions: '**Imagery Source: Use Maxar Preimum Imagery to map.**\n\nPlease focus on adding only the buildings. Remember to trace the building footprint as accurately as possible - then press the "q" button on your keyboard to square the edges before tagging it as a building.\n\nMany of the tiles will already have buildings mapped -- if you find that the building footprints are not accurate, please correct them if possible.\n\n<h3>Video: Adding Buildings to Openstreetmap</h3>\n<iframe width="560" height="315" src="https://www.youtube.com/embed/E1YJV6I_rhY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>\n\n\n\n\n #### #osm_in #2018IndiaFloods',
      shortDescription: "Supporting local flood response in India due to monsoons.",
      perTaskInstructions: ""
    },
    mappingTypes: ["ROADS", "BUILDINGS"],
    organisation: 29,
    activeMappers: 0,
    defaultLocale: "en",
    percentMapped: 33,
    mappingEditors: ["ID", "JOSM", "POTLATCH_2", "FIELD_PAPERS"],
    projectPriority: "LOW",
    allowedUsernames: [],
    changesetComment: "#hotosm-project-5522 #osm_in #2018IndiaFloods #mmteamarm",
    organisationLogo: "https://cdn.hotosm.org/tasking-manager/uploads/1597218299183_817px-OpenStreetMap-India.svg.png",
    organisationName: "OSM India",
    organisationSlug: "osm-india",
    percentValidated: 0,
    taskCreationMode: "GRID",
    mappingPermission: "ANY",
    percentBadImagery: 0,
    validationEditors: ["ID", "JOSM", "POTLATCH_2", "FIELD_PAPERS"],
    validationPermission: "ANY"
  },
  {
    teams: [],
    author: "naveenpf",
    k_type: "polygon",
    aoiBBOX: [75.956806, 10.176628, 76.874643, 10.774978],
    created: "2018-11-16T08:00:28.447658Z",
    private: false,
    campaigns: [{ id: 261, name: "2018 India Floods" }],
    interests: [{ id: 3, name: "disaster response" }],
    projectId: 5496,
    countryTag: ["India"],
    difficulty: "EASY",
    lastUpdated: "2020-11-14T21:19:03.811366Z",
    projectInfo: {
      name: "Thrissur, Kerala Floods, India Road Network Improvement",
      locale: "en",
      description: "`You could join HOTOSM local slack #disaster channel while mapping these tasks` (https://slack.hotosm.org)\n\nMapping project in response to 2018 Flooding in Kerala\nThrissur , Kerala, India Road Network Improvement",
      instructions: 'Please focus on adding only the missing roads which are OSM highway=unclassified tagged.\n\n[The India Highway Tagging Guide](https://wiki.openstreetmap.org/wiki/India:Tags/Highway) has more information on properly classifying roads in India\n\n<h3>Video: Adding roads to Openstreetmap</h3>\n<iframe width="560" height="315" src="https://www.youtube.com/embed/ZBLwb2nisJQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>\n\nRoads Improvement Project Specific Instructions\n================================\n* The most recent imagery is DG Premium, be aware, DG Premium to zoom level 17 is newest, switches to older imagery zoomed past 17\n* Please add missing roads. Most will be "unclassified"\n\n #### #osm_in #2018IndiaFloods',
      shortDescription: "You can join HOTOSM local slack #disaster channel while mapping these tasks` (https://slack.hotosm.org)\n\nMapping project in response to 2018 Flooding in Kerala",
      perTaskInstructions: ""
    },
    mappingTypes: ["ROADS"],
    organisation: 29,
    activeMappers: 0,
    defaultLocale: "en",
    percentMapped: 98,
    mappingEditors: ["ID", "JOSM", "POTLATCH_2", "FIELD_PAPERS"],
    projectPriority: "HIGH",
    allowedUsernames: [],
    changesetComment: "#hotosm-project-5496 #osm_in #2018IndiaFloods",
    organisationLogo: "https://cdn.hotosm.org/tasking-manager/uploads/1597218299183_817px-OpenStreetMap-India.svg.png",
    organisationName: "OSM India",
    organisationSlug: "osm-india",
    percentValidated: 33,
    taskCreationMode: "GRID",
    mappingPermission: "ANY",
    percentBadImagery: 0,
    validationEditors: ["ID", "JOSM", "POTLATCH_2", "FIELD_PAPERS"],
    validationPermission: "ANY"
  },
  {
    teams: [],
    author: "geohacker",
    k_type: "polygon",
    aoiBBOX: [76.959254, 10.048946, 77.140251, 10.312653],
    created: "2020-08-10T05:25:03.149752Z",
    private: false,
    campaigns: [],
    interests: [
      {
        id: 3,
        name: "disaster response"
      },
      {
        id: 6,
        name: "disaster preparedness"
      }
    ],
    projectId: 9165,
    countryTag: ["India"],
    difficulty: "MODERATE",
    lastUpdated: "2023-07-08T15:10:18.497268Z",
    projectInfo: {
      name: "Munnar, Kerala - Landslide 2020 - Roads",
      locale: "en",
      description: "Over the last couple of years, the Monsoons have been causing unprecedented havoc through floods and landslides in the Kerala state. [In 2018](https://en.wikipedia.org/wiki/2018_Kerala_floods), Kerala saw the most devastating crises with 683 deaths and 140 people missing. With many parts of the state under red alert, more rains and flood is predicted. \n\nThis year, the community is coming together early to prepare. Currently the focus is Munnar, Kerala. The goal of this task is to map roads.\n\nIf you have questions about this task, join the [OSM Kerala Telegram Channel](https://t.me/osmkerala)",
      instructions: "### Imagery\nPlease use **Bing** & **Maxar Imagery** to trace the buildings.\nIf you find a huge offset with the existing data, please do not try to move all the data. See [LearnOSM](https://learnosm.org/en/hot-tips/imagery/)_ for detailed instructions on handling imagery offset, or Aerial Imagery & Alignment for adjusting in the iD editor.\n\n### Roads\n- Two-minute Tutorial: Roads - https://www.youtube.com/watch?v=ZBLwb2nisJQ\n- Map roads and paths that are visible using satellite imagery\n- Do not change alignment or delete existing data\n\n#### Quick tagging guide\n\nType | Tag \n-------|-------\nRoads connecting villages | `highway=unclassified`\nRoads connecting houses, drivable | `highway=residential`\nCongested residential areas, not wide | `highway=living_street`\nTrails covered by foot | `highway=path`\n\nMore detailed guide [is available here.](https://wiki.openstreetmap.org/wiki/India/Tags/Highway#Road_classification_and_tagging_scheme_for_India_.28proposal.29)",
      shortDescription: "OpenStreetMap India is mapping Munnar, Kerala which has been seeing higher rates of rainfalls again in 2020. Few days ago, a landslide claimed over 15 lives with more than 40 people still missing.\n\nThis task will focus on mapping roads. If you have questions about this task, join the [OSM Kerala Telegram Channel](https://t.me/osmkerala)",
      perTaskInstructions: ""
    },
    mappingTypes: ["ROADS"],
    organisation: 29,
    activeMappers: 0,
    defaultLocale: "en",
    percentMapped: 99,
    priorityAreas: [
      {
        type: "Polygon",
        coordinates: [
          [
            [77.032498, 10.191444],
            [77.070204, 10.196346],
            [77.086805, 10.176506],
            [77.050047, 10.145927],
            [77.02894, 10.130753],
            [77.006648, 10.130753],
            [76.988625, 10.136356],
            [76.972262, 10.154798],
            [76.985779, 10.159233],
            [77.009494, 10.176039],
            [77.013763, 10.181641],
            [77.033921, 10.180007],
            [77.032498, 10.191444]
          ]
        ]
      }
    ],
    mappingEditors: ["ID", "JOSM", "POTLATCH_2", "FIELD_PAPERS", "CUSTOM"],
    projectPriority: "LOW",
    allowedUsernames: [],
    changesetComment: "#kerala-floods-2020",
    organisationLogo: "https://cdn.hotosm.org/tasking-manager/uploads/1597218299183_817px-OpenStreetMap-India.svg.png",
    organisationName: "OSM India",
    organisationSlug: "osm-india",
    percentValidated: 87,
    taskCreationMode: "GRID",
    mappingPermission: "ANY",
    percentBadImagery: 0,
    validationEditors: ["ID", "JOSM", "POTLATCH_2", "FIELD_PAPERS", "CUSTOM"],
    validationPermission: "ANY",
    enforceRandomTaskSelection: false
  }
];
const hotProjectLayoutTemplate = {
  type: "Card",
  children: [
    {
      type: "Row",
      children: [
        {
          type: "Badge",
          $value: "projectId"
        },
        // Project priority with proper binding and overrides
        {
          type: "Badge",
          $props: {
            value: "projectPriority",
            variant: "projectPriority"
          },
          props: {
            mapping: {
              low: "neutral",
              medium: "info",
              high: "warning",
              urgent: "error"
            }
          }
        }
      ]
    },
    {
      type: "Title",
      $value: "projectInfo.name"
    },
    {
      type: "MappingProgress",
      $props: {
        percentValidated: "percentValidated",
        percentMapped: "percentMapped"
      }
    },
    {
      type: "Text",
      $value: "projectInfo.shortDescription"
    },
    {
      type: "Field",
      $value: "mappingTypes",
      showLabel: true
    },
    {
      type: "Field",
      $value: "created"
    },
    {
      type: "Field",
      $value: "lastUpdated"
    },
    {
      type: "Text",
      $value: "mappingEditors"
    },
    {
      type: "Url",
      $value: "projectId",
      // pre-transform: 'https://tasks.hotosm.org/projects/{value}' -> projectUrl,
      label: "Open in Tasking Manager"
    }
  ]
};
const complexDataSamples = [
  {
    countries: [
      {
        id: 0,
        name: "Madagascar"
      },
      {
        id: 1,
        name: "Comoros"
      }
    ],
    countryProfiles: [
      {
        countryId: 0,
        indicators: [
          {
            indicator: "gdp",
            value: 1906
          },
          {
            indicator: "inform_risk",
            value: 5.1
          }
        ]
      },
      {
        countryId: 1,
        indicators: [
          {
            indicator: "gdp",
            value: 1500
          },
          {
            indicator: "inform_risk",
            value: 4.8
          }
        ]
      }
    ],
    analytics: {
      geometry: [
        {
          indicator: "area_km2",
          value: 458583
        },
        {
          indicator: "populated_area",
          value: 36896
        }
      ],
      countries: [
        {
          countryId: 0,
          indicators: [
            {
              indicator: "area_km2",
              value: 3e5
            },
            {
              indicator: "populated_area",
              value: 4e6
            }
          ]
        },
        {
          countryId: 1,
          indicators: [
            {
              indicator: "area_km2",
              value: 158583
            },
            {
              indicator: "populated_area",
              value: 1716509
            }
          ]
        }
      ],
      geometryCountryIntersections: [
        {
          countryId: 0,
          indicators: [
            {
              indicator: "area_km2",
              value: 28e4
            },
            {
              indicator: "populated_area",
              value: 35e5
            }
          ]
        },
        {
          countryId: 1,
          indicators: [
            {
              indicator: "area_km2",
              value: 15e4
            },
            {
              indicator: "populated_area",
              value: 16e5
            }
          ]
        }
      ]
    }
  }
];
const complexDataLayout = {
  type: "Card",
  props: {
    title: "Country Analysis",
    className: "country-analysis-card"
  },
  children: [
    {
      type: "CardHeader",
      image: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzIgMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE2IDFMMzEgOHYxNkwxNiAzMUwxIDI0VjhMMTYgMVoiIGZpbGw9IiNlZWUiIHN0cm9rZT0iY3VycmVudENvbG9yIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB4PSI1MCUiIHk9IjU1JSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxNCIgZm9udC1mYW1pbHk9InN5c3RlbS11aSwgc2Fucy1zZXJpZiIgZmlsbD0iY3VycmVudENvbG9yIj5BQjwvdGV4dD48L3N2Zz4=",
      icon: "Area16",
      value: "Countries",
      subtitle: "Report"
    },
    {
      type: "Row",
      children: [
        {
          type: "IconButton",
          value: "Play",
          icon: "Play24",
          action: "play"
        },
        {
          type: "IconButton",
          value: "No icon button",
          action: "test"
        }
      ]
    },
    {
      $value: "countries",
      $template: {
        type: "Badge",
        $value: "name",
        variant: "primary"
      }
    },
    {
      type: "Title",
      value: "Country Profiles"
    },
    {
      $value: "countryProfiles",
      $template: {
        type: "Card",
        props: {
          title: "Country Profile",
          size: "small"
        },
        children: [
          {
            type: "Field",
            showLabel: true,
            value: "Country ID:",
            $props: {
              value: "countryId"
            }
          },
          {
            $value: "indicators",
            $template: {
              type: "Row",
              children: [
                {
                  type: "Field",
                  $value: "indicator",
                  showLabel: true
                },
                {
                  type: "Field",
                  $value: "value",
                  showLabel: false,
                  overrides: {
                    value: {
                      format: "number"
                    }
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      type: "Title",
      value: "Analytics"
    },
    {
      type: "Card",
      $context: "analytics",
      props: {
        title: "Geometry Indicators",
        size: "small"
      },
      children: [
        {
          $value: "geometry",
          $template: {
            type: "Row",
            children: [
              {
                type: "Field",
                $value: "indicator",
                showLabel: true
              },
              {
                type: "Field",
                $value: "value",
                showLabel: false,
                overrides: {
                  value: {
                    format: "number"
                  }
                }
              }
            ]
          }
        }
      ]
    },
    {
      type: "Title",
      value: "Country Analytics",
      $context: "analytics"
    },
    {
      $value: "countries",
      $context: "analytics",
      $template: {
        type: "Card",
        props: {
          title: "Country Analysis",
          size: "small"
        },
        children: [
          {
            type: "Field",
            showLabel: true,
            value: "Country ID:",
            $props: {
              value: "countryId"
            }
          },
          {
            $value: "indicators",
            $template: {
              type: "Row",
              children: [
                {
                  type: "Field",
                  $value: "indicator",
                  showLabel: true
                },
                {
                  type: "Field",
                  $value: "value",
                  overrides: {
                    value: {
                      format: "number",
                      icon: "Area16"
                    }
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      type: "Title",
      value: "Geometry-Country Intersections",
      $context: "analytics"
    },
    {
      $value: "geometryCountryIntersections",
      $context: "analytics",
      $template: {
        type: "Card",
        props: {
          title: "Intersection",
          size: "small"
        },
        children: [
          {
            type: "Field",
            showLabel: true,
            value: "Country ID:",
            $props: {
              value: "countryId"
            }
          },
          {
            $value: "indicators",
            $template: {
              type: "Row",
              children: [
                {
                  type: "Field",
                  $value: "indicator",
                  showLabel: true
                },
                {
                  type: "Field",
                  $value: "value",
                  overrides: {
                    value: {
                      format: "square_km",
                      icon: "Area16"
                    }
                  }
                }
              ]
            }
          }
        ]
      }
    }
  ]
};
const grid = "_grid_gg9uu_1";
const card = "_card_gg9uu_7";
const tcard = "_tcard_gg9uu_28";
const error = "_error_gg9uu_44";
const styles$7 = {
  grid,
  card,
  tcard,
  error
};
const useJsonState = (initialValue) => {
  const [json, setJson] = reactExports.useState(JSON.stringify(initialValue, null, 4));
  return [json, setJson];
};
const JsonEditor = ({
  value: value2,
  onChange: onChange2,
  placeholder,
  className = "",
  title: title2,
  visible = true
}) => {
  const [localValue, setLocalValue] = reactExports.useState(value2);
  const [hasError, setHasError] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setLocalValue(value2);
  }, [value2]);
  const handleChange = (newValue) => {
    setLocalValue(newValue);
    try {
      JSON.parse(newValue);
      onChange2(newValue);
      setHasError(false);
    } catch (error2) {
      setHasError(true);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: clsx(styles$7.tcard, { [styles$7.error]: hasError }, className),
      style: { display: visible ? "flex" : "none" },
      children: [
        title2 && /* @__PURE__ */ jsxRuntimeExports.jsx("legend", { children: title2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            value: localValue,
            onChange: (e) => handleChange(e.target.value),
            placeholder
          }
        )
      ]
    }
  );
};
const createLayoutDebugger = (initialLayout, initialData) => {
  return function LayoutDebuggerInstance() {
    const [maxCards] = useFixtureInput("Limit Data Samples", 4);
    const [showLayoutEditor] = useFixtureInput("Show Layout Editor", true);
    const [showDataEditor] = useFixtureInput("Show Data Editor", true);
    const [layoutJson, setLayoutJson] = useJsonState(initialLayout);
    const [dataJson, setDataJson] = useJsonState(initialData);
    const layout = JSON.parse(layoutJson);
    const limitedData = Array.isArray(initialData) ? JSON.parse(dataJson).slice(0, maxCards) : [JSON.parse(dataJson)];
    const handleAction = (action2, payload) => {
      console.info("Action triggered:", action2, payload);
      alert(`Action triggered: ${action2}
Payload: ${JSON.stringify(payload)}`);
    };
    const contextValue = useUniLayoutContextValue({
      layout,
      actionHandler: handleAction
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(UniLayoutContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$7.grid, children: limitedData.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$7.card, children: /* @__PURE__ */ jsxRuntimeExports.jsx(UniLayoutRenderer, { node: layout, data: item }) }, index2)) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "1rem" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          JsonEditor,
          {
            value: layoutJson,
            onChange: setLayoutJson,
            placeholder: "Edit Layout JSON",
            title: "Layout Editor",
            visible: showLayoutEditor
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          JsonEditor,
          {
            value: dataJson,
            onChange: setDataJson,
            placeholder: "Edit Data JSON",
            title: "Data Editor",
            visible: showDataEditor
          }
        )
      ] })
    ] });
  };
};
const LayoutDebugger_fixture = {
  "Event Card": createLayoutDebugger(eventCardLayoutTemplate, eventSampleData),
  "HOT Project Card": createLayoutDebugger(hotProjectLayoutTemplate, hotData),
  "Complex Demo": createLayoutDebugger(complexDataLayout, complexDataSamples)
};
const fixture2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: LayoutDebugger_fixture
}, Symbol.toStringTag, { value: "Module" }));
function UniLayout({
  layout,
  data,
  actionHandler = () => {
  },
  customFieldsRegistry = {},
  customFormatsRegistry = {},
  children
}) {
  const contextValue = useUniLayoutContextValue({
    layout,
    actionHandler,
    customFieldsRegistry,
    customFormatsRegistry
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(UniLayoutContext.Provider, { value: contextValue, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(UniLayoutRenderer, { node: layout, data }),
    children
  ] });
}
function FieldWrapper({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(UniLayout, { layout: { type: "Row" }, data: {}, children });
}
function FieldsRegistry() {
  const [sampleText] = useFixtureInput("Sample Text", "Foo Bar ...");
  const [sampleNumber] = useFixtureInput("Sample Number", -32465.27542);
  const [sampleDate] = useFixtureInput("Sample Date", "2023-05-28T14:30:00Z");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: "1rem" }, children: Object.entries(fieldsRegistry).map(([fieldName, fieldMeta]) => {
    let sampleValue = sampleText;
    if (fieldMeta.type === "number") {
      sampleValue = sampleNumber;
    } else if (fieldMeta.type === "date") {
      sampleValue = sampleDate;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7.card, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: fieldName }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("dl", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("dt", { children: "Type" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("dd", { children: fieldMeta.type }),
        fieldMeta.format && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("dt", { children: "Format" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("dd", { children: fieldMeta.format })
        ] }),
        fieldMeta.label && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("dt", { children: "Label" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("dd", { children: fieldMeta.label })
        ] }),
        fieldMeta.tooltip && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("dt", { children: "Tooltip" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("dd", { children: fieldMeta.tooltip })
        ] }),
        fieldMeta.icon && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("dt", { children: "Icon" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("dd", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { icon: fieldMeta.icon }),
            " ( ",
            fieldMeta.icon,
            " )"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("dt", { children: "Display" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("dd", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FieldWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Field,
          {
            value: sampleValue,
            $meta: { value: fieldMeta },
            showLabel: true
          }
        ) }) })
      ] }, `${fieldName}-meta`)
    ] }, fieldName);
  }) });
}
const fixture3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: FieldsRegistry
}, Symbol.toStringTag, { value: "Module" }));
function ComponentsRegistry() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: Object.keys(componentsRegistry).map((component) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: component }) }, component)) });
}
const fixture4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ComponentsRegistry
}, Symbol.toStringTag, { value: "Module" }));
const linkWidthWrap = "_linkWidthWrap_qkwt3_1";
const truncate = "_truncate_qkwt3_3";
const tail = "_tail_qkwt3_4";
const link = "_link_qkwt3_1";
const s$a = {
  linkWidthWrap,
  truncate,
  tail,
  link
};
const splitTail = (str, tailSize) => {
  const tail2 = str.slice(tailSize * -1);
  const body = str.slice(0, Math.max(0, str.length - tailSize));
  return [body, tail2];
};
const LinkRenderer = reactExports.memo(function(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: props.href, target: "_blank", rel: "noreferrer", onClick: stopPropagation, children: props.children });
});
function ShortLinkRenderer({
  children: linksArr,
  maxWidth = 190,
  truncateAmount = 12,
  href
}) {
  const passedLink = (linksArr == null ? void 0 : linksArr[0]) ?? href;
  const [leftPart, rightPart] = splitTail(passedLink, truncateAmount);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$a.linkWidthWrap, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$a.linkOverflowWrap, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "a",
    {
      className: s$a.link,
      target: "_blank",
      rel: "noreferrer",
      "data-truncate": rightPart,
      href,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: s$a.truncate, style: { maxWidth: maxWidth || "unset" }, children: leftPart }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: s$a.tail, children: rightPart })
      ]
    }
  ) }) });
}
function stopPropagation(e) {
  e.stopPropagation();
}
LinkRenderer.displayName = "LinkRenderer";
const LinkRenderer_fixture = /* @__PURE__ */ jsxRuntimeExports.jsxs("blockquote", { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
  "LinkRenderer: ",
  /* @__PURE__ */ jsxRuntimeExports.jsx(LinkRenderer, { href: "https://kontur.io", children: "kontur.io" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
  "ShortLinkRenderer short:",
  /* @__PURE__ */ jsxRuntimeExports.jsx(ShortLinkRenderer, { href: "https://kontur.io", children: ["kontur.io"] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
  "ShortLinkRenderer gdacs:",
  /* @__PURE__ */ jsxRuntimeExports.jsx(ShortLinkRenderer, { href: "https://www.gdacs.org/report.aspx?eventid=1102779&episodeid=6&eventtype=FL", children: ["gdacs.org/report.aspx?eventtype=EQ&eventid=1441158"] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
  "ShortLinkRenderer long:",
  /* @__PURE__ */ jsxRuntimeExports.jsx(ShortLinkRenderer, { href: "https://disaster.ninja/active/?layers=kontur_lines%2CactiveContributors%2CeventShape%2ChotProjects_outlines%2Cpopulation_density%2Cfocused-geometry", children: [
    "https://disaster.ninja/active/?layers=kontur_lines%2CactiveContributors%2CeventShape%2ChotProjects_outlines%2Cpopulation_density%2Cfocused-geometry"
  ] })
] });
const fixture5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: LinkRenderer_fixture
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @remix-run/router v1.21.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search: search2,
      hash
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search: search2,
        hash
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to2) {
    return typeof to2 === "string" ? to2 : createPath(to2);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant(value2, message) {
  if (value2 === false || value2 === null || typeof value2 === "undefined") {
    throw new Error(message);
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
function createLocation(current, to2, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$1({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to2 === "string" ? parsePath(to2) : to2, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to2 && to2.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search: search2 = "",
    hash = ""
  } = _ref;
  if (search2 && search2 !== "?") pathname += search2.charAt(0) === "?" ? search2 : "?" + search2;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path2) {
  let parsedPath = {};
  if (path2) {
    let hashIndex = path2.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path2.substr(hashIndex);
      path2 = path2.substr(0, hashIndex);
    }
    let searchIndex = path2.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path2.substr(searchIndex);
      path2 = path2.substr(0, searchIndex);
    }
    if (path2) {
      parsedPath.pathname = path2;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action2 = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$1({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action2 = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action: action2,
        location: history.location,
        delta
      });
    }
  }
  function push(to2, state) {
    action2 = Action.Push;
    let location = createLocation(history.location, to2, state);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2);
    let url2 = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url2);
    } catch (error2) {
      if (error2 instanceof DOMException && error2.name === "DataCloneError") {
        throw error2;
      }
      window2.location.assign(url2);
    }
    if (v5Compat && listener) {
      listener({
        action: action2,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to2, state) {
    action2 = Action.Replace;
    let location = createLocation(history.location, to2, state);
    index2 = getIndex();
    let historyState = getHistoryState(location, index2);
    let url2 = history.createHref(location);
    globalHistory.replaceState(historyState, "", url2);
    if (v5Compat && listener) {
      listener({
        action: action2,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to2) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to2 === "string" ? to2 : createPath(to2);
    href = href.replace(/ $/, "%20");
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action2;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to2) {
      return createHref(window2, to2);
    },
    createURL,
    encodeLocation(to2) {
      let url2 = createURL(to2);
      return {
        pathname: url2.pathname,
        search: url2.search,
        hash: url2.hash
      };
    },
    push,
    replace,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.28.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
const alreadyWarned = {};
function warnOnce(key, message) {
  if (!alreadyWarned[message]) {
    alreadyWarned[message] = true;
    console.warn(message);
  }
}
const logDeprecation = (flag, msg, link2) => warnOnce(flag, "⚠️ React Router Future Flag Warning: " + msg + ". " + ("You can use the `" + flag + "` future flag to opt-in early. ") + ("For more information, see " + link2 + "."));
function logV6DeprecationWarnings(renderFuture, routerFuture) {
  if (!(renderFuture != null && renderFuture.v7_startTransition)) {
    logDeprecation("v7_startTransition", "React Router will begin wrapping state updates in `React.startTransition` in v7", "https://reactrouter.com/v6/upgrading/future#v7_starttransition");
  }
  if (!(renderFuture != null && renderFuture.v7_relativeSplatPath) && true) {
    logDeprecation("v7_relativeSplatPath", "Relative route resolution within Splat routes is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath");
  }
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search: search2 = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search: search2,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search2, hash, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
new Promise(() => {
});
/**
 * React Router DOM v6.28.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e) {
}
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$1[START_TRANSITION];
function BrowserRouter(_ref4) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref4;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  reactExports.useEffect(() => logV6DeprecationWarnings(future), [future]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future
  });
}
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
var c = React.createContext(defaultStore), o = function(n2) {
  return n2();
};
function a(n2, t2) {
  return function() {
    var r2 = t2.apply(void 0, [].slice.call(arguments));
    r2 && o(function() {
      n2.dispatch(r2);
    });
  };
}
function s$9(n2, o2, i2) {
  var f2 = n2;
  i2 = [];
  var s2 = React.useContext(c);
  i2 = i2.concat([n2, s2]);
  var l2 = React.useState(function() {
    return getState(n2, s2);
  }), v2 = l2[0], m2 = l2[1], p2 = React.useRef(v2);
  p2.current = v2 = getState(n2, s2);
  var b2 = React.useMemo(function() {
    return Object.entries(f2).reduce(function(n3, t2) {
      var r2 = t2[0], u2 = t2[1];
      return isActionCreator(u2) && (n3[r2] = a(s2, u2)), n3;
    }, {});
  }, i2);
  return React.useEffect(function() {
    return s2.subscribe(n2, function(n3) {
      return Object.is(n3, p2.current) || m2(p2.current = n3);
    });
  }, i2), React.useDebugValue(v2), [v2, b2];
}
const currentTooltipAtom = createAtom(
  {
    setCurrentTooltip: (tooltipData) => tooltipData,
    resetCurrentTooltip: () => null,
    turnOffById: (id) => id
  },
  ({ onAction }, state = null) => {
    onAction("setCurrentTooltip", (tooltipData) => state = tooltipData);
    onAction("resetCurrentTooltip", () => state = null);
    onAction("turnOffById", (id) => {
      if ((state == null ? void 0 : state.initiatorId) === id) state = null;
    });
    return state;
  },
  "[Shared state] currentTooltipAtom"
);
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
function addClass(element, className) {
  if (element.classList) element.classList.add(className);
  else if (!hasClass(element, className)) if (typeof element.className === "string") element.className = element.className + " " + className;
  else element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
const config = {
  disabled: false
};
const TransitionGroupContext = React.createContext(null);
var forceReflow = function forceReflow2(node) {
  return node.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context2) {
    var _this;
    _this = _React$Component.call(this, props, context2) || this;
    var parentGroup = context2;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node) forceReflow(node);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active2 = true;
    this.nextCallback = function(event) {
      if (active2) {
        active2 = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active2 = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
    );
  };
  return Transition2;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c2) {
    return addClass(node, c2);
  });
};
var removeClass = function removeClass2(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c2) {
    return removeClass$1(node, c2);
  });
};
var CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass2(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      if (node) forceReflow(node);
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass(node, baseClassName);
    }
    if (activeClassName) {
      removeClass(node, activeClassName);
    }
    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props;
    _this$props.classNames;
    var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return /* @__PURE__ */ React.createElement(Transition, _extends$2({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(React.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = {};
const fadeEnter = "_fadeEnter_1fjeq_1";
const fadeEnterActive = "_fadeEnterActive_1fjeq_5";
const fadeExit = "_fadeExit_1fjeq_10";
const fadeExitActive = "_fadeExitActive_1fjeq_14";
const s$8 = {
  fadeEnter,
  fadeEnterActive,
  fadeExit,
  fadeExitActive
};
const fadeClassNames = {
  enter: s$8.fadeEnter,
  enterActive: s$8.fadeEnterActive,
  exit: s$8.fadeExit,
  exitActive: s$8.fadeExitActive
};
const CSSTransitionWrapper = ({
  children,
  ...props
}) => {
  const nodeRef = reactExports.useRef(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CSSTransition, { ...props, nodeRef, children: children(nodeRef) });
};
function parseLinksAsTags(text2) {
  if (!text2) return "";
  let parsed = text2;
  const regex = /(.?.?https|.?.?http)(:\/\/)([\w_-]+(?:(?:\.[\w_-]+)+))([\w.,@?^=%&:\/~+#-]*[\w@?^=%&\/~+#-])/gm;
  const matchIterable = text2.matchAll(regex);
  let offset2 = 0;
  [...matchIterable].forEach((matchEntity) => {
    const [match, protocol, , domain, path2] = matchEntity;
    const matchIndex = matchEntity.index ?? 0;
    const matchLength = match.length;
    if (match.startsWith("](") || match.indexOf("[http") > -1) return;
    const linkStartIndex = match.indexOf("http");
    const fullLink = match.substring(linkStartIndex);
    const beforeLink = match.substring(0, linkStartIndex);
    const noW3domain = domain.replace("www.", "");
    const mdLinkWithPrefix = `${beforeLink}[${noW3domain}${path2 ?? ""}](${fullLink})`;
    const finalText = spliceString(parsed)(
      matchIndex + offset2,
      matchLength,
      mdLinkWithPrefix
    );
    offset2 += mdLinkWithPrefix.length - matchLength;
    parsed = finalText;
  });
  return parsed;
}
function spliceString(string) {
  return function(index2, count2, add) {
    if (index2 < 0) {
      index2 += string.length;
      if (index2 < 0) index2 = 0;
    }
    return string.slice(0, index2) + (add || "") + string.slice(index2 + count2);
  };
}
const currentLocationAtom = createAtom(
  {
    set: (location) => location
  },
  ({ onAction }, state = globalThis.location) => {
    onAction("set", (location) => state = location);
    return state;
  },
  "currentLocationAtom"
);
const closeOnLocationChangeAtom = createAtom(
  {
    currentLocationAtom
  },
  ({ onChange: onChange2, schedule, getUnlistedState }) => {
    onChange2("currentLocationAtom", (curr, prev) => {
      const tooltip = getUnlistedState(currentTooltipAtom);
      if (curr.pathname !== (prev == null ? void 0 : prev.pathname) && (tooltip == null ? void 0 : tooltip.position)) {
        schedule((dispatch) => {
          dispatch(currentTooltipAtom.resetCurrentTooltip());
        });
      }
    });
  },
  "closeOnLocationChangeAtom"
);
const markdown = "_markdown_4vdv7_1";
const s$7 = {
  markdown
};
function PopupTooltip() {
  const [tooltip, { resetCurrentTooltip }] = s$9(currentTooltipAtom);
  s$9(closeOnLocationChangeAtom);
  const closeHandler = reactExports.useCallback(
    (e) => {
      var _a2;
      resetCurrentTooltip();
      (_a2 = tooltip == null ? void 0 : tooltip.onClose) == null ? void 0 : _a2.call(tooltip, e, resetCurrentTooltip);
    },
    [resetCurrentTooltip, tooltip]
  );
  const outerClickHandler = reactExports.useCallback(
    (e) => {
      var _a2;
      (_a2 = tooltip == null ? void 0 : tooltip.onOuterClick) == null ? void 0 : _a2.call(tooltip, e, resetCurrentTooltip);
    },
    [resetCurrentTooltip, tooltip]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CSSTransitionWrapper, { in: Boolean(tooltip), timeout: 300, classNames: fadeClassNames, children: (transitionRef) => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: tooltip && /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tooltip,
    {
      transitionRef,
      position: tooltip.position,
      hoverBehavior: tooltip.hoverBehavior,
      getPlacement: tooltip.position.predefinedPosition,
      classes: tooltip.popupClasses,
      onClose: closeHandler,
      onOuterClick: outerClickHandler,
      children: typeof tooltip.popup === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Markdown,
        {
          options: { overrides: { a: LinkRenderer } },
          className: s$7.markdown,
          children: parseLinksAsTags(tooltip.popup)
        }
      ) : tooltip.popup
    }
  ) }) });
}
const BIVARIATE_LEGEND_SIZE = 3;
const CORNER_POINTS_INDEXES = [
  0,
  BIVARIATE_LEGEND_SIZE - 1,
  BIVARIATE_LEGEND_SIZE * BIVARIATE_LEGEND_SIZE - BIVARIATE_LEGEND_SIZE,
  BIVARIATE_LEGEND_SIZE * BIVARIATE_LEGEND_SIZE - 1
];
const LOW = `↓${TranslationService.t("bivariate.legend.low")}`;
const HIGH = `↑${TranslationService.t("bivariate.legend.high")}`;
const MEDIUM = TranslationService.t("bivariate.legend.medium");
const isTopSide = (index2) => Array.from(Array(BIVARIATE_LEGEND_SIZE), (_2, i2) => i2).includes(index2);
const isBottomSide = (index2) => {
  const bottomRowStartIndex = BIVARIATE_LEGEND_SIZE * BIVARIATE_LEGEND_SIZE - BIVARIATE_LEGEND_SIZE;
  return Array.from(
    Array(BIVARIATE_LEGEND_SIZE),
    (_2, i2) => bottomRowStartIndex + i2
  ).includes(index2);
};
const isLeftSide = (index2) => Array.from(Array(BIVARIATE_LEGEND_SIZE), (_2, i2) => i2 * BIVARIATE_LEGEND_SIZE).includes(
  index2
);
const isRightSide = (index2) => Array.from(
  Array(BIVARIATE_LEGEND_SIZE),
  (_2, i2) => i2 * BIVARIATE_LEGEND_SIZE + (BIVARIATE_LEGEND_SIZE - 1)
).includes(index2);
function featureProp(name) {
  return ["get", name];
}
function getVariable(name) {
  return ["var", name];
}
function less(first2, second) {
  return ["<", first2, second];
}
function lessOrEqual(first2, second) {
  return ["<=", first2, second];
}
function greaterOrEqual(first2, second) {
  return [">=", first2, second];
}
function notEqual(first2, second) {
  return ["!=", first2, second];
}
function equal(first2, second) {
  return ["==", first2, second];
}
function caseFn(condition, output) {
  return [condition, output];
}
function switchFn(conditions, defaultCase) {
  return ["case", ...conditions.flat(1), defaultCase];
}
function concat(first2, second) {
  return ["concat", first2, second];
}
function addVariable(name, binding, expression) {
  return ["let", name, binding, expression];
}
function allCondition(...conditionInputs) {
  return ["all", ...conditionInputs];
}
function anyCondition(...conditionInputs) {
  return ["any", ...conditionInputs];
}
const AT_CHAR_CODE = 64;
const getCharByIndex = (i2) => String.fromCharCode(AT_CHAR_CODE + i2);
const getConditionFunc = (currentIndex, totalBorders) => currentIndex === totalBorders - 1 ? lessOrEqual : less;
function classResolver(xValue, yValue) {
  return concat(
    switchFn(
      // cases for a, b, c ...
      xValue.borders.map(
        (border, i2, arr) => caseFn(
          getConditionFunc(i2, arr.length)(xValue.propName, border),
          getCharByIndex(i2)
        )
      ),
      // default case required
      getCharByIndex(xValue.borders.length)
    ),
    switchFn(
      // cases for 1, 2, 3 ...
      yValue.borders.map(
        (border, i2, arr) => caseFn(getConditionFunc(i2, arr.length)(yValue.propName, border), i2)
      ),
      // default case required
      yValue.borders.length
    )
  );
}
function colorResolver(variableName, colorMap, fallbackColor) {
  return switchFn(
    Object.entries(colorMap).map(
      ([cls, color]) => (
        // color cases
        caseFn(equal(getVariable(variableName), cls), color)
      )
    ),
    fallbackColor
  );
}
function colorsMap(colors) {
  return Object.fromEntries(colors.map(({ id, color }) => [id, color]));
}
function filterSetup$1(xAxis, yAxis) {
  return anyCondition(
    notEqual(["/", featureProp(xAxis.quotient[0]), featureProp(xAxis.quotient[1])], 0),
    notEqual(["/", featureProp(yAxis.quotient[0]), featureProp(yAxis.quotient[1])], 0)
  );
}
function colorSetup(xAxis, yAxis, colors) {
  const xAxisProp = [
    "/",
    featureProp(xAxis.quotient[0]),
    featureProp(xAxis.quotient[1])
  ];
  const yAxisProp = [
    "/",
    featureProp(yAxis.quotient[0]),
    featureProp(yAxis.quotient[1])
  ];
  return addVariable(
    "class",
    classResolver(
      {
        propName: xAxisProp,
        borders: xAxis.steps.reduce(
          (acc, { value: value2 }) => (acc.push(value2), acc),
          []
        )
      },
      {
        propName: yAxisProp,
        borders: yAxis.steps.reduce(
          (acc, { value: value2 }) => (acc.push(value2), acc),
          []
        )
      }
    ),
    colorResolver("class", colors, "transparent")
  );
}
function generateBivariateStyleForAxis({
  x: x2,
  y: y2,
  colors,
  source,
  sourceLayer,
  id = "bivariate"
}) {
  const style2 = {
    id,
    type: "fill",
    layout: {},
    filter: filterSetup$1(x2, y2),
    paint: {
      "fill-color": colorSetup(x2, y2, colorsMap(colors)),
      "fill-opacity": 1,
      "fill-antialias": false
    }
  };
  if (source) {
    style2.source = source;
  }
  {
    style2["source-layer"] = sourceLayer;
  }
  return style2;
}
function clusterize(arr, key = "id") {
  const clusterMap = arr.reduce(
    (acc, item) => {
      const clusterName = item[key].slice(0, 1);
      if (acc[clusterName]) {
        acc[clusterName].push(item);
      } else {
        acc[clusterName] = [item];
      }
      return acc;
    },
    {}
  );
  return Object.values(clusterMap);
}
function invertClusters(arr, key = "id") {
  const clusters = [...clusterize(arr, key)].reverse();
  return clusters.reduce((acc, cluster) => acc.concat(cluster), []);
}
const formatSentimentDirection = (input) => Array.isArray(input) ? toCapitalizedList(input) : capitalize(input);
const formatCustomBivariateAxisLabel = (customLabel, quotients) => {
  const units = formatBivariateAxisUnit(quotients);
  return units ? `${customLabel} (${units})` : customLabel;
};
const formatBivariateAxisLabel = (quotients) => {
  if (!quotients) return "";
  const [numerator, denominator] = quotients;
  if (!hasUnits(numerator.unit.id)) {
    return `${numerator.label} to ${denominator.label}`;
  }
  if (denominator.name === "one") {
    return `${numerator.label} (${numerator.unit.shortName})`;
  }
  if (!hasUnits(denominator.unit.id)) {
    return `${numerator.label} to ${denominator.label} (${numerator.unit.shortName})`;
  }
  return `${numerator.label} to ${denominator.label} (${numerator.unit.shortName}/${denominator.unit.shortName})`;
};
const formatBivariateAxisUnit = (quotients) => {
  if (!quotients) return null;
  const [numerator, denominator] = quotients;
  if (!hasUnits(numerator.unit.id)) {
    return null;
  }
  if (denominator.name === "one") {
    return numerator.unit.shortName;
  }
  if (!hasUnits(denominator.unit.id)) {
    return numerator.unit.shortName;
  }
  return `${numerator.unit.shortName}/${denominator.unit.shortName}`;
};
const hasUnits = (unitId) => Boolean(unitId && unitId !== "other");
const tooltipContent = "_tooltipContent_1wegb_1";
const arrow = "_arrow_1wegb_12";
const s$6 = {
  tooltipContent,
  arrow
};
function SimpleRefTooltip({
  referenceElement,
  content,
  isOpen,
  placement = "top"
}) {
  const arrowRef = reactExports.useRef(null);
  const { x: x2, y: y2, strategy, refs, context: context2 } = useFloating({
    placement,
    middleware: [offset(8), flip(), shift(), arrow$3({ element: arrowRef })]
  });
  reactExports.useEffect(() => {
    if (referenceElement) {
      refs.setReference(referenceElement);
    }
  }, [referenceElement, refs]);
  if (!isOpen || !referenceElement) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: s$6.tooltipContent,
      ref: refs.setFloating,
      style: {
        position: strategy,
        top: y2 ?? 0,
        left: x2 ?? 0,
        zIndex: "var(--tooltip)"
      },
      children: [
        content,
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FloatingArrow,
          {
            ref: arrowRef,
            context: context2,
            className: s$6.arrow,
            stroke: "transparent",
            strokeWidth: 2,
            height: 8,
            width: 16
          }
        )
      ]
    }
  );
}
const tooltipRoot = "_tooltipRoot_zjmcz_1";
const tooltipRow = "_tooltipRow_zjmcz_11";
const sentimentDirection = "_sentimentDirection_zjmcz_17";
const sentimentLabel = "_sentimentLabel_zjmcz_21";
const sentimentInfo = "_sentimentInfo_zjmcz_25";
const indicator = "_indicator_zjmcz_29";
const s$5 = {
  tooltipRoot,
  tooltipRow,
  sentimentDirection,
  sentimentLabel,
  sentimentInfo,
  indicator
};
function CornerTooltipWrapper({ children, hints }) {
  const [activeCorner, setActiveCorner] = reactExports.useState(null);
  const [referenceEl, setReferenceEl] = reactExports.useState(null);
  const handleShowTooltip = (e, _cell, i2) => {
    var _a2;
    if (hints && CORNER_POINTS_INDEXES.includes(i2)) {
      setActiveCorner(i2);
      const divRef = ((_a2 = e.target) == null ? void 0 : _a2.tagName) == "SPAN" ? e.target.parentElement : e.target;
      setReferenceEl(divRef);
    }
  };
  const handleHideTooltip = () => {
    setActiveCorner(null);
    setReferenceEl(null);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    reactExports.isValidElement(children) ? reactExports.cloneElement(children, {
      // @ts-expect-error - Legend component accepts these props but TS doesn't recognize them
      onCellPointerOver: handleShowTooltip,
      onCellPointerLeave: handleHideTooltip
    }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SimpleRefTooltip,
      {
        referenceElement: referenceEl,
        isOpen: activeCorner !== null && referenceEl !== null && !!hints,
        content: /* @__PURE__ */ jsxRuntimeExports.jsx(
          BivariateLegendCornerTooltip,
          {
            cellIndex: activeCorner,
            hints
          }
        )
      }
    )
  ] });
}
const BivariateLegendCornerTooltip = ({
  hints,
  cellIndex
}) => {
  var _a2, _b, _c, _d, _e2, _f;
  if (!hints) return null;
  const rows = [
    {
      label: (_a2 = hints.x) == null ? void 0 : _a2.label,
      direction: (_c = (_b = hints.x) == null ? void 0 : _b.direction) == null ? void 0 : _c[isBottomSide(cellIndex) ? 0 : 1],
      indicator: isBottomSide(cellIndex) ? LOW : HIGH
    },
    {
      label: (_d = hints.y) == null ? void 0 : _d.label,
      direction: (_f = (_e2 = hints.y) == null ? void 0 : _e2.direction) == null ? void 0 : _f[isLeftSide(cellIndex) ? 0 : 1],
      indicator: isLeftSide(cellIndex) ? LOW : HIGH
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: clsx(s$5.tooltipRoot), children: rows.map(({ label: label2, direction, indicator: indicator2 }, i2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clsx(s$5.tooltipRow), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: clsx(s$5.indicator), children: indicator2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: clsx(s$5.sentimentInfo), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: clsx(s$5.sentimentLabel), children: [
        label2,
        " "
      ] }),
      direction && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: clsx(s$5.sentimentDirection), children: formatSentimentDirection(direction) })
    ] })
  ] }, i2)) });
};
const meta = {
  hints: {
    x: {
      label: "Average NDVI, JUN 2019",
      direction: [["bad"], ["good"]]
    },
    y: {
      label: "Multi-hazard exposure PDC GRVA",
      direction: [["unimportant"], ["bad", "important"]]
    }
  }
};
const axis = {
  x: {
    label: "Multi-hazard exposure PDC GRVA to 1",
    steps: [
      {
        label: "",
        value: 0
      },
      {
        label: "",
        value: 0.48
      },
      {
        label: "",
        value: 0.62
      },
      {
        label: "",
        value: 1
      }
    ],
    quality: 0.997101882904748,
    quotient: ["mhe_index", "one"]
  },
  y: {
    label: "Average NDVI, JUN 2019 to 1",
    steps: [
      {
        label: "",
        value: -1
      },
      {
        label: "",
        value: 0.3625118070036407
      },
      {
        label: "",
        value: 0.6441754083082613
      },
      {
        label: "",
        value: 1
      }
    ],
    quality: 0.9410965072118505,
    quotient: ["avg_ndvi", "one"]
  }
};
const cells = [
  {
    label: "C1",
    color: "rgba(90,200,127,0.5)"
  },
  {
    label: "C2",
    color: "rgba(179,165,130,0.5)"
  },
  {
    label: "C3",
    color: "rgba(153,153,153,0.5)"
  },
  {
    label: "B1",
    color: "rgba(169,218,122,0.5)"
  },
  {
    label: "B2",
    color: "rgba(195,163,111,0.5)"
  },
  {
    label: "B3",
    color: "rgba(204,103,116,0.5)"
  },
  {
    label: "A1",
    color: "rgba(232,232,157,0.5)"
  },
  {
    label: "A2",
    color: "rgba(216,159,88,0.5)"
  },
  {
    label: "A3",
    color: "rgba(228,26,28,0.5)"
  }
];
function BivariateLegendFixture() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(BrowserRouter, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PopupTooltip, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CornerTooltipWrapper, { meta, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Legend,
      {
        showAxisLabels: true,
        size: BIVARIATE_LEGEND_SIZE,
        axis,
        cells
      }
    ) })
  ] });
}
const fixture6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: BivariateLegendFixture
}, Symbol.toStringTag, { value: "Module" }));
const useIsomorphicEffect = "undefined" != typeof document ? React.useLayoutEffect : React.useEffect, { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED } = React, getComponentDebugName = (type) => {
  var _a2, _b;
  let Component = (_b = (_a2 = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED == null ? void 0 : __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) == null ? void 0 : _a2.current) == null ? void 0 : _b.type, name = (Component == null ? void 0 : Component.displayName) ?? (Component == null ? void 0 : Component.name);
  return name ? `Component.${name}.${type}` : `_${type}`;
};
let batch = (cb) => cb();
const reatomContext = React.createContext(null), useCtx = () => {
  let ctx = React.useContext(reatomContext);
  return throwReatomError(!ctx, "ctx is not set, you probably forgot to specify the ctx provider"), ctx;
};
const useAction = (fn, deps = [], name) => {
  throwReatomError("function" != typeof fn, 'invalid "fn"'), deps ?? (deps = []);
  let ctx = useCtx();
  deps.push(ctx), isAction$1(fn) && deps.push(fn);
  let ref = React.useMemo(() => {
    let theAction = isAction$1(fn) ? fn : action(function() {
      return ref.fn(...[].slice.call(arguments));
    }, getComponentDebugName("useAction"));
    return { fn, cb: function() {
      return batch(() => theAction(ctx, ...[].slice.call(arguments)));
    } };
  }, deps);
  return useIsomorphicEffect(() => {
    ref.fn = fn;
  }), ref.cb;
};
class Hsluv {
  constructor() {
    this.hex = "#000000";
    this.rgb_r = 0;
    this.rgb_g = 0;
    this.rgb_b = 0;
    this.xyz_x = 0;
    this.xyz_y = 0;
    this.xyz_z = 0;
    this.luv_l = 0;
    this.luv_u = 0;
    this.luv_v = 0;
    this.lch_l = 0;
    this.lch_c = 0;
    this.lch_h = 0;
    this.hsluv_h = 0;
    this.hsluv_s = 0;
    this.hsluv_l = 0;
    this.hpluv_h = 0;
    this.hpluv_p = 0;
    this.hpluv_l = 0;
    this.r0s = 0;
    this.r0i = 0;
    this.r1s = 0;
    this.r1i = 0;
    this.g0s = 0;
    this.g0i = 0;
    this.g1s = 0;
    this.g1i = 0;
    this.b0s = 0;
    this.b0i = 0;
    this.b1s = 0;
    this.b1i = 0;
  }
  static fromLinear(c2) {
    if (c2 <= 31308e-7) {
      return 12.92 * c2;
    } else {
      return 1.055 * Math.pow(c2, 1 / 2.4) - 0.055;
    }
  }
  static toLinear(c2) {
    if (c2 > 0.04045) {
      return Math.pow((c2 + 0.055) / 1.055, 2.4);
    } else {
      return c2 / 12.92;
    }
  }
  static yToL(Y2) {
    if (Y2 <= Hsluv.epsilon) {
      return Y2 / Hsluv.refY * Hsluv.kappa;
    } else {
      return 116 * Math.pow(Y2 / Hsluv.refY, 1 / 3) - 16;
    }
  }
  static lToY(L2) {
    if (L2 <= 8) {
      return Hsluv.refY * L2 / Hsluv.kappa;
    } else {
      return Hsluv.refY * Math.pow((L2 + 16) / 116, 3);
    }
  }
  static rgbChannelToHex(chan) {
    const c2 = Math.round(chan * 255);
    const digit2 = c2 % 16;
    const digit1 = (c2 - digit2) / 16 | 0;
    return Hsluv.hexChars.charAt(digit1) + Hsluv.hexChars.charAt(digit2);
  }
  static hexToRgbChannel(hex, offset2) {
    const digit1 = Hsluv.hexChars.indexOf(hex.charAt(offset2));
    const digit2 = Hsluv.hexChars.indexOf(hex.charAt(offset2 + 1));
    const n2 = digit1 * 16 + digit2;
    return n2 / 255;
  }
  static distanceFromOriginAngle(slope, intercept, angle) {
    const d2 = intercept / (Math.sin(angle) - slope * Math.cos(angle));
    if (d2 < 0) {
      return Infinity;
    } else {
      return d2;
    }
  }
  static distanceFromOrigin(slope, intercept) {
    return Math.abs(intercept) / Math.sqrt(Math.pow(slope, 2) + 1);
  }
  static min6(f1, f2, f3, f4, f5, f6) {
    return Math.min(f1, Math.min(f2, Math.min(f3, Math.min(f4, Math.min(f5, f6)))));
  }
  rgbToHex() {
    this.hex = "#";
    this.hex += Hsluv.rgbChannelToHex(this.rgb_r);
    this.hex += Hsluv.rgbChannelToHex(this.rgb_g);
    this.hex += Hsluv.rgbChannelToHex(this.rgb_b);
  }
  hexToRgb() {
    this.hex = this.hex.toLowerCase();
    this.rgb_r = Hsluv.hexToRgbChannel(this.hex, 1);
    this.rgb_g = Hsluv.hexToRgbChannel(this.hex, 3);
    this.rgb_b = Hsluv.hexToRgbChannel(this.hex, 5);
  }
  xyzToRgb() {
    this.rgb_r = Hsluv.fromLinear(Hsluv.m_r0 * this.xyz_x + Hsluv.m_r1 * this.xyz_y + Hsluv.m_r2 * this.xyz_z);
    this.rgb_g = Hsluv.fromLinear(Hsluv.m_g0 * this.xyz_x + Hsluv.m_g1 * this.xyz_y + Hsluv.m_g2 * this.xyz_z);
    this.rgb_b = Hsluv.fromLinear(Hsluv.m_b0 * this.xyz_x + Hsluv.m_b1 * this.xyz_y + Hsluv.m_b2 * this.xyz_z);
  }
  rgbToXyz() {
    const lr = Hsluv.toLinear(this.rgb_r);
    const lg = Hsluv.toLinear(this.rgb_g);
    const lb = Hsluv.toLinear(this.rgb_b);
    this.xyz_x = 0.41239079926595 * lr + 0.35758433938387 * lg + 0.18048078840183 * lb;
    this.xyz_y = 0.21263900587151 * lr + 0.71516867876775 * lg + 0.072192315360733 * lb;
    this.xyz_z = 0.019330818715591 * lr + 0.11919477979462 * lg + 0.95053215224966 * lb;
  }
  xyzToLuv() {
    const divider = this.xyz_x + 15 * this.xyz_y + 3 * this.xyz_z;
    let varU = 4 * this.xyz_x;
    let varV = 9 * this.xyz_y;
    if (divider !== 0) {
      varU /= divider;
      varV /= divider;
    } else {
      varU = NaN;
      varV = NaN;
    }
    this.luv_l = Hsluv.yToL(this.xyz_y);
    if (this.luv_l === 0) {
      this.luv_u = 0;
      this.luv_v = 0;
    } else {
      this.luv_u = 13 * this.luv_l * (varU - Hsluv.refU);
      this.luv_v = 13 * this.luv_l * (varV - Hsluv.refV);
    }
  }
  luvToXyz() {
    if (this.luv_l === 0) {
      this.xyz_x = 0;
      this.xyz_y = 0;
      this.xyz_z = 0;
      return;
    }
    const varU = this.luv_u / (13 * this.luv_l) + Hsluv.refU;
    const varV = this.luv_v / (13 * this.luv_l) + Hsluv.refV;
    this.xyz_y = Hsluv.lToY(this.luv_l);
    this.xyz_x = 0 - 9 * this.xyz_y * varU / ((varU - 4) * varV - varU * varV);
    this.xyz_z = (9 * this.xyz_y - 15 * varV * this.xyz_y - varV * this.xyz_x) / (3 * varV);
  }
  luvToLch() {
    this.lch_l = this.luv_l;
    this.lch_c = Math.sqrt(this.luv_u * this.luv_u + this.luv_v * this.luv_v);
    if (this.lch_c < 1e-8) {
      this.lch_h = 0;
    } else {
      const hrad = Math.atan2(this.luv_v, this.luv_u);
      this.lch_h = hrad * 180 / Math.PI;
      if (this.lch_h < 0) {
        this.lch_h = 360 + this.lch_h;
      }
    }
  }
  lchToLuv() {
    const hrad = this.lch_h / 180 * Math.PI;
    this.luv_l = this.lch_l;
    this.luv_u = Math.cos(hrad) * this.lch_c;
    this.luv_v = Math.sin(hrad) * this.lch_c;
  }
  calculateBoundingLines(l2) {
    const sub1 = Math.pow(l2 + 16, 3) / 1560896;
    const sub2 = sub1 > Hsluv.epsilon ? sub1 : l2 / Hsluv.kappa;
    const s1r = sub2 * (284517 * Hsluv.m_r0 - 94839 * Hsluv.m_r2);
    const s2r = sub2 * (838422 * Hsluv.m_r2 + 769860 * Hsluv.m_r1 + 731718 * Hsluv.m_r0);
    const s3r = sub2 * (632260 * Hsluv.m_r2 - 126452 * Hsluv.m_r1);
    const s1g = sub2 * (284517 * Hsluv.m_g0 - 94839 * Hsluv.m_g2);
    const s2g = sub2 * (838422 * Hsluv.m_g2 + 769860 * Hsluv.m_g1 + 731718 * Hsluv.m_g0);
    const s3g = sub2 * (632260 * Hsluv.m_g2 - 126452 * Hsluv.m_g1);
    const s1b = sub2 * (284517 * Hsluv.m_b0 - 94839 * Hsluv.m_b2);
    const s2b = sub2 * (838422 * Hsluv.m_b2 + 769860 * Hsluv.m_b1 + 731718 * Hsluv.m_b0);
    const s3b = sub2 * (632260 * Hsluv.m_b2 - 126452 * Hsluv.m_b1);
    this.r0s = s1r / s3r;
    this.r0i = s2r * l2 / s3r;
    this.r1s = s1r / (s3r + 126452);
    this.r1i = (s2r - 769860) * l2 / (s3r + 126452);
    this.g0s = s1g / s3g;
    this.g0i = s2g * l2 / s3g;
    this.g1s = s1g / (s3g + 126452);
    this.g1i = (s2g - 769860) * l2 / (s3g + 126452);
    this.b0s = s1b / s3b;
    this.b0i = s2b * l2 / s3b;
    this.b1s = s1b / (s3b + 126452);
    this.b1i = (s2b - 769860) * l2 / (s3b + 126452);
  }
  calcMaxChromaHpluv() {
    const r0 = Hsluv.distanceFromOrigin(this.r0s, this.r0i);
    const r1 = Hsluv.distanceFromOrigin(this.r1s, this.r1i);
    const g0 = Hsluv.distanceFromOrigin(this.g0s, this.g0i);
    const g1 = Hsluv.distanceFromOrigin(this.g1s, this.g1i);
    const b0 = Hsluv.distanceFromOrigin(this.b0s, this.b0i);
    const b1 = Hsluv.distanceFromOrigin(this.b1s, this.b1i);
    return Hsluv.min6(r0, r1, g0, g1, b0, b1);
  }
  calcMaxChromaHsluv(h2) {
    const hueRad = h2 / 360 * Math.PI * 2;
    const r0 = Hsluv.distanceFromOriginAngle(this.r0s, this.r0i, hueRad);
    const r1 = Hsluv.distanceFromOriginAngle(this.r1s, this.r1i, hueRad);
    const g0 = Hsluv.distanceFromOriginAngle(this.g0s, this.g0i, hueRad);
    const g1 = Hsluv.distanceFromOriginAngle(this.g1s, this.g1i, hueRad);
    const b0 = Hsluv.distanceFromOriginAngle(this.b0s, this.b0i, hueRad);
    const b1 = Hsluv.distanceFromOriginAngle(this.b1s, this.b1i, hueRad);
    return Hsluv.min6(r0, r1, g0, g1, b0, b1);
  }
  hsluvToLch() {
    if (this.hsluv_l > 99.9999999) {
      this.lch_l = 100;
      this.lch_c = 0;
    } else if (this.hsluv_l < 1e-8) {
      this.lch_l = 0;
      this.lch_c = 0;
    } else {
      this.lch_l = this.hsluv_l;
      this.calculateBoundingLines(this.hsluv_l);
      const max2 = this.calcMaxChromaHsluv(this.hsluv_h);
      this.lch_c = max2 / 100 * this.hsluv_s;
    }
    this.lch_h = this.hsluv_h;
  }
  lchToHsluv() {
    if (this.lch_l > 99.9999999) {
      this.hsluv_s = 0;
      this.hsluv_l = 100;
    } else if (this.lch_l < 1e-8) {
      this.hsluv_s = 0;
      this.hsluv_l = 0;
    } else {
      this.calculateBoundingLines(this.lch_l);
      const max2 = this.calcMaxChromaHsluv(this.lch_h);
      this.hsluv_s = this.lch_c / max2 * 100;
      this.hsluv_l = this.lch_l;
    }
    this.hsluv_h = this.lch_h;
  }
  hpluvToLch() {
    if (this.hpluv_l > 99.9999999) {
      this.lch_l = 100;
      this.lch_c = 0;
    } else if (this.hpluv_l < 1e-8) {
      this.lch_l = 0;
      this.lch_c = 0;
    } else {
      this.lch_l = this.hpluv_l;
      this.calculateBoundingLines(this.hpluv_l);
      const max2 = this.calcMaxChromaHpluv();
      this.lch_c = max2 / 100 * this.hpluv_p;
    }
    this.lch_h = this.hpluv_h;
  }
  lchToHpluv() {
    if (this.lch_l > 99.9999999) {
      this.hpluv_p = 0;
      this.hpluv_l = 100;
    } else if (this.lch_l < 1e-8) {
      this.hpluv_p = 0;
      this.hpluv_l = 0;
    } else {
      this.calculateBoundingLines(this.lch_l);
      const max2 = this.calcMaxChromaHpluv();
      this.hpluv_p = this.lch_c / max2 * 100;
      this.hpluv_l = this.lch_l;
    }
    this.hpluv_h = this.lch_h;
  }
  hsluvToRgb() {
    this.hsluvToLch();
    this.lchToLuv();
    this.luvToXyz();
    this.xyzToRgb();
  }
  hpluvToRgb() {
    this.hpluvToLch();
    this.lchToLuv();
    this.luvToXyz();
    this.xyzToRgb();
  }
  hsluvToHex() {
    this.hsluvToRgb();
    this.rgbToHex();
  }
  hpluvToHex() {
    this.hpluvToRgb();
    this.rgbToHex();
  }
  rgbToHsluv() {
    this.rgbToXyz();
    this.xyzToLuv();
    this.luvToLch();
    this.lchToHpluv();
    this.lchToHsluv();
  }
  rgbToHpluv() {
    this.rgbToXyz();
    this.xyzToLuv();
    this.luvToLch();
    this.lchToHpluv();
    this.lchToHpluv();
  }
  hexToHsluv() {
    this.hexToRgb();
    this.rgbToHsluv();
  }
  hexToHpluv() {
    this.hexToRgb();
    this.rgbToHpluv();
  }
}
Hsluv.hexChars = "0123456789abcdef";
Hsluv.refY = 1;
Hsluv.refU = 0.19783000664283;
Hsluv.refV = 0.46831999493879;
Hsluv.kappa = 903.2962962;
Hsluv.epsilon = 0.0088564516;
Hsluv.m_r0 = 3.240969941904521;
Hsluv.m_r1 = -1.537383177570093;
Hsluv.m_r2 = -0.498610760293;
Hsluv.m_g0 = -0.96924363628087;
Hsluv.m_g1 = 1.87596750150772;
Hsluv.m_g2 = 0.041555057407175;
Hsluv.m_b0 = 0.055630079696993;
Hsluv.m_b1 = -0.20397695888897;
Hsluv.m_b2 = 1.056971514242878;
function getMaxMCDAZoomLevel(config2, fallbackMaxZoom) {
  return getMaxNumeratorZoomLevel(
    config2.layers.map((axis2) => axis2.indicators),
    fallbackMaxZoom
  );
}
function getMaxNumeratorZoomLevel(indicators, fallbackMaxZoom) {
  const maxIndicatorsZoom = Math.max(
    ...indicators.map((indicators2) => {
      var _a2;
      return ((_a2 = indicators2[0]) == null ? void 0 : _a2.maxZoom) ?? -1;
    })
  );
  if (maxIndicatorsZoom === -1) {
    return fallbackMaxZoom;
  }
  return maxIndicatorsZoom;
}
const SOURCE_LAYER_BIVARIATE = "stats";
const FALLBACK_BIVARIATE_MIN_ZOOM = 0;
const FALLBACK_BIVARIATE_MAX_ZOOM = 9;
const FEATURE_STATES = {
  hover: "hover",
  active: "active"
};
const H3_HOVER_LAYER = {
  type: "line",
  layout: {},
  paint: {
    "line-color": [
      "case",
      // prettier-ignore :active
      ["==", ["feature-state", FEATURE_STATES.active], true],
      "rgba(5, 22, 38, 1)",
      // prettier-ignore :hover
      ["==", ["feature-state", FEATURE_STATES.hover], true],
      "rgba(5, 22, 38, 0.4)",
      // not selected
      "rgba(0, 0, 0, 0)"
    ],
    "line-width": 1
  }
};
function adaptTileUrl(url2) {
  const protocolRegexp = /https?:/;
  if (protocolRegexp.test(url2)) {
    url2 = window.location.protocol + url2.replace(protocolRegexp, "");
  } else {
    const baseUrl = configRepo.get().bivariateTilesServer ?? `${window.location.protocol}${window.location.host}${configRepo.get().baseUrl}`;
    url2 = `${baseUrl}${url2}`;
  }
  url2 = url2.replace("{bbox}", "{bbox-epsg-3857}").replace("{proj}", "EPSG:3857").replace("{width}", "256").replace("{height}", "256").replace("{zoom}", "{z}").replace("{-y}", "{y}");
  const domains = (url2.match(/{switch:(.*?)}/) || ["", ""])[1].split(",")[0];
  url2 = url2.replace(/{switch:(.*?)}/, domains);
  return url2;
}
function getDefaultBivariateTilesUrl() {
  return `${adaptTileUrl(
    configRepo.get().bivariateTilesRelativeUrl
  )}{z}/{x}/{y}.mvt?indicatorsClass=${configRepo.get().bivariateTilesIndicatorsClass}`;
}
function interpolate360(start, end) {
  return start + (((end - start) % 360 + 540) % 360 - 180) * 0.5;
}
function interpolateLinear(start, end) {
  return (start + end) / 2;
}
function interpolateHsl(start, end) {
  return [
    interpolate360(start[0], end[0]),
    interpolateLinear(start[1], end[1]),
    interpolateLinear(start[2], end[2])
  ];
}
function convertToRgbaWithOpacity(hexColor) {
  if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hexColor)) {
    let clr = hexColor.substring(1).split("");
    if (clr.length === 3) {
      clr = [clr[0], clr[0], clr[1], clr[1], clr[2], clr[2]];
    }
    const hexNum = parseInt(`0x${clr.join("")}`, 0);
    return `rgba(${[hexNum >> 16 & 255, hexNum >> 8 & 255, hexNum & 255].join(
      ","
    )},0.5)`;
  }
  throw new Error("Bad Hex");
}
function findColors(colors, crn) {
  const corner1 = (Array.isArray(crn[0]) ? [...crn[0]] : [crn[0]]).sort();
  const corner2 = (Array.isArray(crn[1]) ? [...crn[1]] : [crn[1]]).sort();
  const mergedCorner = Array.from(new Set(corner1.concat(corner2)));
  const combination = colors.combinations.find(({ corner: corner3 }) => {
    if (mergedCorner.length !== corner3.length) return false;
    for (let i2 = 0; i2 < mergedCorner.length; i2 += 1) {
      if (mergedCorner[i2] !== corner3[i2]) {
        return false;
      }
    }
    return true;
  });
  return (combination == null ? void 0 : combination.color) ? { color: combination.color } : { color: colors.fallback, isFallbackColor: true };
}
function generateColorThemeAndBivariateStyle(xNumerator, xDenominator, yNumerator, yDenominator, stats, sourceLayer) {
  var _a2, _b;
  const { indicators, colors, axis: axis2 } = stats;
  const xAxis = axis2.find(
    (ax) => ax.quotient[0] === xNumerator && ax.quotient[1] === xDenominator
  );
  const yAxis = axis2.find(
    (ax) => ax.quotient[0] === yNumerator && ax.quotient[1] === yDenominator
  );
  if (!xAxis || !yAxis) return;
  const xAxisDirection = (_a2 = indicators.find((ind) => ind.name === xNumerator)) == null ? void 0 : _a2.direction;
  const yAxisDirection = (_b = indicators.find((ind) => ind.name === yNumerator)) == null ? void 0 : _b.direction;
  if (!xAxisDirection || !yAxisDirection) return;
  const colorTheme = generateColorTheme(
    colors,
    xAxisDirection,
    yAxisDirection
  );
  const maxZoom = getMaxNumeratorZoomLevel(
    [xAxis.quotients ?? [], yAxis.quotients ?? []],
    stats.meta.max_zoom || FALLBACK_BIVARIATE_MAX_ZOOM
  );
  const bivariateStyle = generateBivariateStyle(
    xAxis,
    yAxis,
    colorTheme,
    maxZoom,
    sourceLayer
  );
  return [colorTheme, bivariateStyle];
}
const generateBivariateStyle = (xAxis, yAxis, colorTheme, maxZoomLevel, sourceLayer) => generateBivariateStyleForAxis({
  id: `${xAxis.quotient.join("&")}|${yAxis.quotient.join("&")}`,
  x: xAxis,
  y: yAxis,
  colors: colorTheme,
  sourceLayer,
  source: {
    type: "vector",
    tiles: [getDefaultBivariateTilesUrl()],
    maxzoom: maxZoomLevel,
    minzoom: 0
  }
});
const generateColorTheme = (colors, xAxisDirection, yAxisDirection) => {
  const conv = new Hsluv();
  const corner00 = findColors(colors, [xAxisDirection[0], yAxisDirection[0]]);
  const corner01 = findColors(colors, [xAxisDirection[0], yAxisDirection[1]]);
  const corner10 = findColors(colors, [xAxisDirection[1], yAxisDirection[0]]);
  const corner11 = findColors(colors, [xAxisDirection[1], yAxisDirection[1]]);
  const cornerHsl = [corner00, corner01, corner10, corner11].map((c2) => {
    conv.hex = c2.color;
    conv.hexToHsluv();
    return [conv.hsluv_h, conv.hsluv_s, conv.hsluv_l];
  });
  const midLeftHsl = interpolateHsl(cornerHsl[0], cornerHsl[1]);
  const midBottomHsl = interpolateHsl(cornerHsl[0], cornerHsl[2]);
  const midTopHsl = interpolateHsl(cornerHsl[1], cornerHsl[3]);
  const midRightHsl = interpolateHsl(cornerHsl[2], cornerHsl[3]);
  const midMidHsl = interpolateHsl(midBottomHsl, midTopHsl);
  const [A2, B1, B2, B3, C2] = [
    midLeftHsl,
    midBottomHsl,
    midMidHsl,
    midTopHsl,
    midRightHsl
  ].map(([h2, s2, l2]) => {
    conv.hsluv_h = h2;
    conv.hsluv_s = s2;
    conv.hsluv_l = l2;
    conv.hsluvToHex();
    return convertToRgbaWithOpacity(conv.hex);
  });
  const colorTheme = [
    {
      id: "A1",
      color: convertToRgbaWithOpacity(corner00.color),
      isFallbackColor: corner00.isFallbackColor
    },
    { id: "A2", color: A2 },
    {
      id: "A3",
      color: convertToRgbaWithOpacity(corner01.color),
      isFallbackColor: corner01.isFallbackColor
    },
    { id: "B1", color: B1 },
    { id: "B2", color: B2 },
    { id: "B3", color: B3 },
    {
      id: "C1",
      color: convertToRgbaWithOpacity(corner10.color),
      isFallbackColor: corner10.isFallbackColor
    },
    { id: "C2", color: C2 },
    {
      id: "C3",
      color: convertToRgbaWithOpacity(corner11.color),
      isFallbackColor: corner11.isFallbackColor
    }
  ];
  return colorTheme;
};
function generateLayerStyleFromBivariateLegend(bl, sourceLayer) {
  return generateBivariateStyleForAxis({
    id: `${bl.axis.x.quotient.join("&")}|${bl.axis.y.quotient.join("&")}`,
    x: bl.axis.x,
    y: bl.axis.y,
    colors: [...bl.steps].sort((stp1, stp2) => stp1.label > stp2.label ? 1 : -1).map((stp) => ({ id: stp.label, color: stp.color })),
    sourceLayer
  });
}
function createBivariateLegend(name, colorTheme, xNumerator, xDenominator, yNumerator, yDenominator, stats) {
  const xAxis = stats.axis.find(
    (ax) => ax.quotient[0] === xNumerator && ax.quotient[1] === xDenominator
  );
  const yAxis = stats.axis.find(
    (ax) => ax.quotient[0] === yNumerator && ax.quotient[1] === yDenominator
  );
  if (!xAxis || !yAxis) return;
  return fillBivariateLegend(name, xAxis, yAxis, colorTheme);
}
const fillBivariateLegend = (name, xAxis, yAxis, colorTheme) => ({
  name,
  axis: { x: xAxis, y: yAxis },
  type: "bivariate",
  steps: colorTheme.map(({ id, color, isFallbackColor }) => ({
    label: id,
    color,
    isFallbackColor
  }))
});
function createBivariateMeta(xNumerator, xDenominator, yNumerator, yDenominator, stats) {
  var _a2, _b, _c, _d;
  const xAxisNumeratorIndicator = stats.indicators.find((ind) => ind.name === xNumerator);
  const yAxisNumeratorIndicator = stats.indicators.find((ind) => ind.name === yNumerator);
  const xNumeratorLabel = xAxisNumeratorIndicator == null ? void 0 : xAxisNumeratorIndicator.label;
  const yNumeratorLabel = yAxisNumeratorIndicator == null ? void 0 : yAxisNumeratorIndicator.label;
  const xDenominatorLabel = (_a2 = stats.indicators.find(
    (ind) => ind.name === xDenominator
  )) == null ? void 0 : _a2.label;
  const yDenominatorLabel = (_b = stats.indicators.find(
    (ind) => ind.name === yDenominator
  )) == null ? void 0 : _b.label;
  let copyrights = [];
  if ((_c = xAxisNumeratorIndicator == null ? void 0 : xAxisNumeratorIndicator.copyrights) == null ? void 0 : _c.length) {
    copyrights = copyrights.concat(xAxisNumeratorIndicator.copyrights);
  }
  if ((_d = yAxisNumeratorIndicator == null ? void 0 : yAxisNumeratorIndicator.copyrights) == null ? void 0 : _d.length) {
    copyrights = copyrights.concat(yAxisNumeratorIndicator.copyrights);
  }
  const description = `This map shows relation of ${xNumeratorLabel} (normalized by ${xDenominatorLabel}) to the base of ${yNumeratorLabel} (normalized by ${yDenominatorLabel}).`;
  return {
    description,
    copyrights,
    hints: {
      x: {
        label: xNumeratorLabel,
        direction: xAxisNumeratorIndicator == null ? void 0 : xAxisNumeratorIndicator.direction
      },
      y: {
        label: yNumeratorLabel,
        direction: yAxisNumeratorIndicator == null ? void 0 : yAxisNumeratorIndicator.direction
      }
    }
  };
}
const fitsLegendCriteria = (step, index2, totalSteps, targetValue) => index2 !== 0 && targetValue < step.value || index2 === totalSteps - 1 && targetValue <= step.value;
function getCellLabelByValue(xSteps, ySteps, xValue, yValue) {
  const charIndex = xSteps.findIndex(
    (xStep, i2, arr) => fitsLegendCriteria(xStep, i2, arr.length, xValue)
  );
  const char = getCharByIndex(charIndex);
  const number = ySteps.findIndex(
    (yStep, i2, arr) => fitsLegendCriteria(yStep, i2, arr.length, yValue)
  );
  return char + number;
}
const layersLegendsAtom = createMapAtom(
  /* @__PURE__ */ new Map(),
  "layersLegends"
);
const layersSourcesAtom = createMapAtom(
  /* @__PURE__ */ new Map(),
  "layersSources"
);
const layersMetaAtom = createMapAtom(
  /* @__PURE__ */ new Map(),
  "layersMeta"
);
const layersSettingsAtom$1 = createMapAtom(
  /* @__PURE__ */ new Map(),
  "layersSettings"
);
const layersMenusAtom = createMapAtom(
  /* @__PURE__ */ new Map(),
  "layersMenus"
);
const createBatchedUpdateMap = () => ({
  legend: [],
  source: [],
  meta: [],
  settings: [],
  menu: []
});
const wrapInAsyncState = ([id, data]) => [
  id,
  { data, isLoading: false, error: null }
];
function createUpdateLayerActions(updates) {
  const batchedUpdates = updates.reduce((acc, { id, ...update }) => {
    Object.keys(update).forEach((key) => {
      acc[key].push([id, update[key]]);
    });
    return acc;
  }, createBatchedUpdateMap());
  const updateActions = [];
  const cleanupActions = [];
  if (batchedUpdates.legend.length) {
    const update = batchedUpdates.legend.map(wrapInAsyncState);
    updateActions.push(
      layersLegendsAtom.change((state) => {
        return new Map([...state, ...update]);
      })
    );
  }
  if (batchedUpdates.source.length) {
    const update = batchedUpdates.source.map(wrapInAsyncState);
    updateActions.push(
      layersSourcesAtom.change((state) => {
        return new Map([...state, ...update]);
      })
    );
  }
  if (batchedUpdates.meta.length) {
    const update = batchedUpdates.meta.map(wrapInAsyncState);
    updateActions.push(
      layersMetaAtom.change((state) => {
        return new Map([...state, ...update]);
      })
    );
  }
  if (batchedUpdates.settings.length) {
    const update = batchedUpdates.settings.map(wrapInAsyncState);
    updateActions.push(
      layersSettingsAtom$1.change((state) => {
        return new Map([...state, ...update]);
      })
    );
  }
  if (batchedUpdates.menu.length) {
    const update = batchedUpdates.menu;
    updateActions.push(
      layersMenusAtom.change((state) => {
        return new Map([...state, ...update]);
      })
    );
  }
  return [updateActions, cleanupActions];
}
var maplibreGl$1 = { exports: {} };
var maplibreGl = maplibreGl$1.exports;
var hasRequiredMaplibreGl;
function requireMaplibreGl() {
  if (hasRequiredMaplibreGl) return maplibreGl$1.exports;
  hasRequiredMaplibreGl = 1;
  (function(module, exports) {
    (function(global2, factory2) {
      module.exports = factory2();
    })(maplibreGl, function() {
      var shared, worker, maplibregl;
      function define(_2, chunk) {
        if (!shared) {
          shared = chunk;
        } else if (!worker) {
          worker = chunk;
        } else {
          var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
          var sharedChunk = {};
          shared(sharedChunk);
          maplibregl = chunk(sharedChunk);
          if (typeof window !== "undefined") {
            maplibregl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
          }
        }
      }
      define(["exports"], function(t2) {
        function e(t3, e2, r3, n3) {
          return new (r3 || (r3 = Promise))(function(i3, a3) {
            function s3(t4) {
              try {
                l3(n3.next(t4));
              } catch (t5) {
                a3(t5);
              }
            }
            function o3(t4) {
              try {
                l3(n3.throw(t4));
              } catch (t5) {
                a3(t5);
              }
            }
            function l3(t4) {
              var e3;
              t4.done ? i3(t4.value) : (e3 = t4.value, e3 instanceof r3 ? e3 : new r3(function(t5) {
                t5(e3);
              })).then(s3, o3);
            }
            l3((n3 = n3.apply(t3, e2 || [])).next());
          });
        }
        function r2(t3) {
          return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
        }
        "function" == typeof SuppressedError && SuppressedError;
        var n2 = i2;
        function i2(t3, e2) {
          this.x = t3, this.y = e2;
        }
        i2.prototype = { clone: function() {
          return new i2(this.x, this.y);
        }, add: function(t3) {
          return this.clone()._add(t3);
        }, sub: function(t3) {
          return this.clone()._sub(t3);
        }, multByPoint: function(t3) {
          return this.clone()._multByPoint(t3);
        }, divByPoint: function(t3) {
          return this.clone()._divByPoint(t3);
        }, mult: function(t3) {
          return this.clone()._mult(t3);
        }, div: function(t3) {
          return this.clone()._div(t3);
        }, rotate: function(t3) {
          return this.clone()._rotate(t3);
        }, rotateAround: function(t3, e2) {
          return this.clone()._rotateAround(t3, e2);
        }, matMult: function(t3) {
          return this.clone()._matMult(t3);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t3) {
          return this.x === t3.x && this.y === t3.y;
        }, dist: function(t3) {
          return Math.sqrt(this.distSqr(t3));
        }, distSqr: function(t3) {
          var e2 = t3.x - this.x, r3 = t3.y - this.y;
          return e2 * e2 + r3 * r3;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t3) {
          return Math.atan2(this.y - t3.y, this.x - t3.x);
        }, angleWith: function(t3) {
          return this.angleWithSep(t3.x, t3.y);
        }, angleWithSep: function(t3, e2) {
          return Math.atan2(this.x * e2 - this.y * t3, this.x * t3 + this.y * e2);
        }, _matMult: function(t3) {
          var e2 = t3[2] * this.x + t3[3] * this.y;
          return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e2, this;
        }, _add: function(t3) {
          return this.x += t3.x, this.y += t3.y, this;
        }, _sub: function(t3) {
          return this.x -= t3.x, this.y -= t3.y, this;
        }, _mult: function(t3) {
          return this.x *= t3, this.y *= t3, this;
        }, _div: function(t3) {
          return this.x /= t3, this.y /= t3, this;
        }, _multByPoint: function(t3) {
          return this.x *= t3.x, this.y *= t3.y, this;
        }, _divByPoint: function(t3) {
          return this.x /= t3.x, this.y /= t3.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t3 = this.y;
          return this.y = this.x, this.x = -t3, this;
        }, _rotate: function(t3) {
          var e2 = Math.cos(t3), r3 = Math.sin(t3), n3 = r3 * this.x + e2 * this.y;
          return this.x = e2 * this.x - r3 * this.y, this.y = n3, this;
        }, _rotateAround: function(t3, e2) {
          var r3 = Math.cos(t3), n3 = Math.sin(t3), i3 = e2.y + n3 * (this.x - e2.x) + r3 * (this.y - e2.y);
          return this.x = e2.x + r3 * (this.x - e2.x) - n3 * (this.y - e2.y), this.y = i3, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, i2.convert = function(t3) {
          return t3 instanceof i2 ? t3 : Array.isArray(t3) ? new i2(t3[0], t3[1]) : t3;
        };
        var a2 = r2(n2), s2 = o2;
        function o2(t3, e2, r3, n3) {
          this.cx = 3 * t3, this.bx = 3 * (r3 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n3 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e2, this.p2x = r3, this.p2y = n3;
        }
        o2.prototype = { sampleCurveX: function(t3) {
          return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
        }, sampleCurveY: function(t3) {
          return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
        }, sampleCurveDerivativeX: function(t3) {
          return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
        }, solveCurveX: function(t3, e2) {
          if (void 0 === e2 && (e2 = 1e-6), t3 < 0) return 0;
          if (t3 > 1) return 1;
          for (var r3 = t3, n3 = 0; n3 < 8; n3++) {
            var i3 = this.sampleCurveX(r3) - t3;
            if (Math.abs(i3) < e2) return r3;
            var a3 = this.sampleCurveDerivativeX(r3);
            if (Math.abs(a3) < 1e-6) break;
            r3 -= i3 / a3;
          }
          var s3 = 0, o3 = 1;
          for (r3 = t3, n3 = 0; n3 < 20 && (i3 = this.sampleCurveX(r3), !(Math.abs(i3 - t3) < e2)); n3++) t3 > i3 ? s3 = r3 : o3 = r3, r3 = 0.5 * (o3 - s3) + s3;
          return r3;
        }, solve: function(t3, e2) {
          return this.sampleCurveY(this.solveCurveX(t3, e2));
        } };
        var l2 = r2(s2);
        let u2, c2;
        function h2() {
          return null == u2 && (u2 = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), u2;
        }
        function p2() {
          if (null == c2 && (c2 = false, h2())) {
            const t3 = 5, e2 = new OffscreenCanvas(t3, t3).getContext("2d", { willReadFrequently: true });
            if (e2) {
              for (let r4 = 0; r4 < t3 * t3; r4++) {
                const n3 = 4 * r4;
                e2.fillStyle = `rgb(${n3},${n3 + 1},${n3 + 2})`, e2.fillRect(r4 % t3, Math.floor(r4 / t3), 1, 1);
              }
              const r3 = e2.getImageData(0, 0, t3, t3).data;
              for (let e3 = 0; e3 < t3 * t3 * 4; e3++) if (e3 % 4 != 3 && r3[e3] !== e3) {
                c2 = true;
                break;
              }
            }
          }
          return c2 || false;
        }
        function f2(t3, e2, r3, n3) {
          const i3 = new l2(t3, e2, r3, n3);
          return function(t4) {
            return i3.solve(t4);
          };
        }
        const d2 = f2(0.25, 0.1, 0.25, 1);
        function y2(t3, e2, r3) {
          return Math.min(r3, Math.max(e2, t3));
        }
        function m2(t3, e2, r3) {
          const n3 = r3 - e2, i3 = ((t3 - e2) % n3 + n3) % n3 + e2;
          return i3 === e2 ? r3 : i3;
        }
        function g2(t3, ...e2) {
          for (const r3 of e2) for (const e3 in r3) t3[e3] = r3[e3];
          return t3;
        }
        let x2 = 1;
        function v2(t3, e2, r3) {
          const n3 = {};
          for (const i3 in t3) n3[i3] = e2.call(r3 || this, t3[i3], i3, t3);
          return n3;
        }
        function b2(t3, e2, r3) {
          const n3 = {};
          for (const i3 in t3) e2.call(r3 || this, t3[i3], i3, t3) && (n3[i3] = t3[i3]);
          return n3;
        }
        function w2(t3) {
          return Array.isArray(t3) ? t3.map(w2) : "object" == typeof t3 && t3 ? v2(t3, w2) : t3;
        }
        const _2 = {};
        function A2(t3) {
          _2[t3] || ("undefined" != typeof console && console.warn(t3), _2[t3] = true);
        }
        function S2(t3, e2, r3) {
          return (r3.y - t3.y) * (e2.x - t3.x) > (e2.y - t3.y) * (r3.x - t3.x);
        }
        function k2(t3) {
          let e2 = 0;
          for (let r3, n3, i3 = 0, a3 = t3.length, s3 = a3 - 1; i3 < a3; s3 = i3++) r3 = t3[i3], n3 = t3[s3], e2 += (n3.x - r3.x) * (r3.y + n3.y);
          return e2;
        }
        function I2() {
          return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        let z2 = null;
        function M2(t3) {
          return "undefined" != typeof ImageBitmap && t3 instanceof ImageBitmap;
        }
        const C2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function B2(t3, r3, n3, i3, a3) {
          return e(this, void 0, void 0, function* () {
            if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported");
            const e2 = new VideoFrame(t3, { timestamp: 0 });
            try {
              const s3 = null == e2 ? void 0 : e2.format;
              if (!s3 || !s3.startsWith("BGR") && !s3.startsWith("RGB")) throw new Error(`Unrecognized format ${s3}`);
              const o3 = s3.startsWith("BGR"), l3 = new Uint8ClampedArray(i3 * a3 * 4);
              if (yield e2.copyTo(l3, function(t4, e3, r4, n4, i4) {
                const a4 = 4 * Math.max(-e3, 0), s4 = (Math.max(0, r4) - r4) * n4 * 4 + a4, o4 = 4 * n4, l4 = Math.max(0, e3), u3 = Math.max(0, r4);
                return { rect: { x: l4, y: u3, width: Math.min(t4.width, e3 + n4) - l4, height: Math.min(t4.height, r4 + i4) - u3 }, layout: [{ offset: s4, stride: o4 }] };
              }(t3, r3, n3, i3, a3)), o3) for (let t4 = 0; t4 < l3.length; t4 += 4) {
                const e3 = l3[t4];
                l3[t4] = l3[t4 + 2], l3[t4 + 2] = e3;
              }
              return l3;
            } finally {
              e2.close();
            }
          });
        }
        let P2, V2, E2, F2;
        const T2 = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(t3) {
          const e2 = requestAnimationFrame(t3);
          return { cancel: () => cancelAnimationFrame(e2) };
        }, getImageData(t3, e2 = 0) {
          return this.getImageCanvasContext(t3).getImageData(-e2, -e2, t3.width + 2 * e2, t3.height + 2 * e2);
        }, getImageCanvasContext(t3) {
          const e2 = window.document.createElement("canvas"), r3 = e2.getContext("2d", { willReadFrequently: true });
          if (!r3) throw new Error("failed to create canvas 2d context");
          return e2.width = t3.width, e2.height = t3.height, r3.drawImage(t3, 0, 0, t3.width, t3.height), r3;
        }, resolveURL: (t3) => (E2 || (E2 = document.createElement("a")), E2.href = t3, E2.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (null == F2 && (F2 = matchMedia("(prefers-reduced-motion: reduce)")), F2.matches);
        } }, $2 = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        class L2 extends Error {
          constructor(t3, e2, r3, n3) {
            super(`AJAXError: ${e2} (${t3}): ${r3}`), this.status = t3, this.statusText = e2, this.url = r3, this.body = n3;
          }
        }
        const D2 = I2() ? () => self.worker && self.worker.referrer : () => ("blob:" === window.location.protocol ? window.parent : window).location.href, O2 = (t3) => $2.REGISTERED_PROTOCOLS[t3.substring(0, t3.indexOf("://"))];
        function U2(t3, e2) {
          const r3 = new AbortController(), n3 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, cache: t3.cache, referrer: D2(), signal: r3.signal });
          let i3 = false, a3 = false;
          "json" === t3.type && n3.headers.set("Accept", "application/json");
          return a3 || fetch(n3).then((r4) => r4.ok ? ((r5) => {
            ("arrayBuffer" === t3.type || "image" === t3.type ? r5.arrayBuffer() : "json" === t3.type ? r5.json() : r5.text()).then((t4) => {
              a3 || (i3 = true, e2(null, t4, r5.headers.get("Cache-Control"), r5.headers.get("Expires")));
            }).catch((t4) => {
              a3 || e2(new Error(t4.message));
            });
          })(r4) : r4.blob().then((n4) => e2(new L2(r4.status, r4.statusText, t3.url, n4)))).catch((t4) => {
            20 !== t4.code && e2(new Error(t4.message));
          }), { cancel: () => {
            a3 = true, i3 || r3.abort();
          } };
        }
        const R2 = function(t3, e2) {
          if (/:\/\//.test(t3.url) && !/^https?:|^file:/.test(t3.url)) {
            if (I2() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t3, e2);
            if (!I2()) return (O2(t3.url) || U2)(t3, e2);
          }
          if (!(/^file:/.test(r3 = t3.url) || /^file:/.test(D2()) && !/^\w+:/.test(r3))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return U2(t3, e2);
            if (I2() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t3, e2, void 0, true);
          }
          var r3;
          return function(t4, e3) {
            const r4 = new XMLHttpRequest();
            r4.open(t4.method || "GET", t4.url, true), "arrayBuffer" !== t4.type && "image" !== t4.type || (r4.responseType = "arraybuffer");
            for (const e4 in t4.headers) r4.setRequestHeader(e4, t4.headers[e4]);
            return "json" === t4.type && (r4.responseType = "text", r4.setRequestHeader("Accept", "application/json")), r4.withCredentials = "include" === t4.credentials, r4.onerror = () => {
              e3(new Error(r4.statusText));
            }, r4.onload = () => {
              if ((r4.status >= 200 && r4.status < 300 || 0 === r4.status) && null !== r4.response) {
                let n3 = r4.response;
                if ("json" === t4.type) try {
                  n3 = JSON.parse(r4.response);
                } catch (t5) {
                  return e3(t5);
                }
                e3(null, n3, r4.getResponseHeader("Cache-Control"), r4.getResponseHeader("Expires"));
              } else {
                const n3 = new Blob([r4.response], { type: r4.getResponseHeader("Content-Type") });
                e3(new L2(r4.status, r4.statusText, t4.url, n3));
              }
            }, r4.send(t4.body), { cancel: () => r4.abort() };
          }(t3, e2);
        }, q2 = function(t3, e2) {
          return R2(g2(t3, { type: "arrayBuffer" }), e2);
        };
        function j2(t3) {
          if (!t3 || t3.indexOf("://") <= 0 || 0 === t3.indexOf("data:image/") || 0 === t3.indexOf("blob:")) return true;
          const e2 = new URL(t3), r3 = window.location;
          return e2.protocol === r3.protocol && e2.host === r3.host;
        }
        function N2(t3, e2, r3) {
          r3[t3] && -1 !== r3[t3].indexOf(e2) || (r3[t3] = r3[t3] || [], r3[t3].push(e2));
        }
        function Z2(t3, e2, r3) {
          if (r3 && r3[t3]) {
            const n3 = r3[t3].indexOf(e2);
            -1 !== n3 && r3[t3].splice(n3, 1);
          }
        }
        class K2 {
          constructor(t3, e2 = {}) {
            g2(this, e2), this.type = t3;
          }
        }
        class G2 extends K2 {
          constructor(t3, e2 = {}) {
            super("error", g2({ error: t3 }, e2));
          }
        }
        class J2 {
          on(t3, e2) {
            return this._listeners = this._listeners || {}, N2(t3, e2, this._listeners), this;
          }
          off(t3, e2) {
            return Z2(t3, e2, this._listeners), Z2(t3, e2, this._oneTimeListeners), this;
          }
          once(t3, e2) {
            return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, N2(t3, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t3, e3));
          }
          fire(t3, e2) {
            "string" == typeof t3 && (t3 = new K2(t3, e2 || {}));
            const r3 = t3.type;
            if (this.listens(r3)) {
              t3.target = this;
              const e3 = this._listeners && this._listeners[r3] ? this._listeners[r3].slice() : [];
              for (const r4 of e3) r4.call(this, t3);
              const n3 = this._oneTimeListeners && this._oneTimeListeners[r3] ? this._oneTimeListeners[r3].slice() : [];
              for (const e4 of n3) Z2(r3, e4, this._oneTimeListeners), e4.call(this, t3);
              const i3 = this._eventedParent;
              i3 && (g2(t3, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i3.fire(t3));
            } else t3 instanceof G2 && console.error(t3.error);
            return this;
          }
          listens(t3) {
            return this._listeners && this._listeners[t3] && this._listeners[t3].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t3] && this._oneTimeListeners[t3].length > 0 || this._eventedParent && this._eventedParent.listens(t3);
          }
          setEventedParent(t3, e2) {
            return this._eventedParent = t3, this._eventedParentData = e2, this;
          }
        }
        var X2 = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const Y2 = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function H2(t3, e2) {
          const r3 = {};
          for (const e3 in t3) "ref" !== e3 && (r3[e3] = t3[e3]);
          return Y2.forEach((t4) => {
            t4 in e2 && (r3[t4] = e2[t4]);
          }), r3;
        }
        function W2(t3, e2) {
          if (Array.isArray(t3)) {
            if (!Array.isArray(e2) || t3.length !== e2.length) return false;
            for (let r3 = 0; r3 < t3.length; r3++) if (!W2(t3[r3], e2[r3])) return false;
            return true;
          }
          if ("object" == typeof t3 && null !== t3 && null !== e2) {
            if ("object" != typeof e2) return false;
            if (Object.keys(t3).length !== Object.keys(e2).length) return false;
            for (const r3 in t3) if (!W2(t3[r3], e2[r3])) return false;
            return true;
          }
          return t3 === e2;
        }
        const Q2 = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
        function tt(t3, e2, r3) {
          r3.push({ command: Q2.addSource, args: [t3, e2[t3]] });
        }
        function et(t3, e2, r3) {
          e2.push({ command: Q2.removeSource, args: [t3] }), r3[t3] = true;
        }
        function rt(t3, e2, r3, n3) {
          et(t3, r3, n3), tt(t3, e2, r3);
        }
        function nt(t3, e2, r3) {
          let n3;
          for (n3 in t3[r3]) if (Object.prototype.hasOwnProperty.call(t3[r3], n3) && "data" !== n3 && !W2(t3[r3][n3], e2[r3][n3])) return false;
          for (n3 in e2[r3]) if (Object.prototype.hasOwnProperty.call(e2[r3], n3) && "data" !== n3 && !W2(t3[r3][n3], e2[r3][n3])) return false;
          return true;
        }
        function it(t3, e2, r3, n3, i3, a3) {
          let s3;
          for (s3 in e2 = e2 || {}, t3 = t3 || {}) Object.prototype.hasOwnProperty.call(t3, s3) && (W2(t3[s3], e2[s3]) || r3.push({ command: a3, args: [n3, s3, e2[s3], i3] }));
          for (s3 in e2) Object.prototype.hasOwnProperty.call(e2, s3) && !Object.prototype.hasOwnProperty.call(t3, s3) && (W2(t3[s3], e2[s3]) || r3.push({ command: a3, args: [n3, s3, e2[s3], i3] }));
        }
        function at(t3) {
          return t3.id;
        }
        function st(t3, e2) {
          return t3[e2.id] = e2, t3;
        }
        class ot {
          constructor(t3, e2, r3, n3) {
            this.message = (t3 ? `${t3}: ` : "") + r3, n3 && (this.identifier = n3), null != e2 && e2.__line__ && (this.line = e2.__line__);
          }
        }
        function lt(t3, ...e2) {
          for (const r3 of e2) for (const e3 in r3) t3[e3] = r3[e3];
          return t3;
        }
        class ut extends Error {
          constructor(t3, e2) {
            super(e2), this.message = e2, this.key = t3;
          }
        }
        class ct {
          constructor(t3, e2 = []) {
            this.parent = t3, this.bindings = {};
            for (const [t4, r3] of e2) this.bindings[t4] = r3;
          }
          concat(t3) {
            return new ct(this, t3);
          }
          get(t3) {
            if (this.bindings[t3]) return this.bindings[t3];
            if (this.parent) return this.parent.get(t3);
            throw new Error(`${t3} not found in scope.`);
          }
          has(t3) {
            return !!this.bindings[t3] || !!this.parent && this.parent.has(t3);
          }
        }
        const ht = { kind: "null" }, pt = { kind: "number" }, ft = { kind: "string" }, dt = { kind: "boolean" }, yt = { kind: "color" }, mt = { kind: "object" }, gt = { kind: "value" }, xt = { kind: "collator" }, vt = { kind: "formatted" }, bt = { kind: "padding" }, wt = { kind: "resolvedImage" }, _t = { kind: "variableAnchorOffsetCollection" };
        function At(t3, e2) {
          return { kind: "array", itemType: t3, N: e2 };
        }
        function St(t3) {
          if ("array" === t3.kind) {
            const e2 = St(t3.itemType);
            return "number" == typeof t3.N ? `array<${e2}, ${t3.N}>` : "value" === t3.itemType.kind ? "array" : `array<${e2}>`;
          }
          return t3.kind;
        }
        const kt = [ht, pt, ft, dt, yt, vt, mt, At(gt), bt, wt, _t];
        function It(t3, e2) {
          if ("error" === e2.kind) return null;
          if ("array" === t3.kind) {
            if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !It(t3.itemType, e2.itemType)) && ("number" != typeof t3.N || t3.N === e2.N)) return null;
          } else {
            if (t3.kind === e2.kind) return null;
            if ("value" === t3.kind) {
              for (const t4 of kt) if (!It(t4, e2)) return null;
            }
          }
          return `Expected ${St(t3)} but found ${St(e2)} instead.`;
        }
        function zt(t3, e2) {
          return e2.some((e3) => e3.kind === t3.kind);
        }
        function Mt(t3, e2) {
          return e2.some((e3) => "null" === e3 ? null === t3 : "array" === e3 ? Array.isArray(t3) : "object" === e3 ? t3 && !Array.isArray(t3) && "object" == typeof t3 : e3 === typeof t3);
        }
        function Ct(t3, e2) {
          return "array" === t3.kind && "array" === e2.kind ? t3.itemType.kind === e2.itemType.kind && "number" == typeof t3.N : t3.kind === e2.kind;
        }
        const Bt = 0.96422, Pt = 0.82521, Vt = 4 / 29, Et = 6 / 29, Ft = 3 * Et * Et, Tt = Et * Et * Et, $t = Math.PI / 180, Lt = 180 / Math.PI;
        function Dt(t3) {
          return (t3 %= 360) < 0 && (t3 += 360), t3;
        }
        function Ot([t3, e2, r3, n3]) {
          let i3, a3;
          const s3 = Rt((0.2225045 * (t3 = Ut(t3)) + 0.7168786 * (e2 = Ut(e2)) + 0.0606169 * (r3 = Ut(r3))) / 1);
          t3 === e2 && e2 === r3 ? i3 = a3 = s3 : (i3 = Rt((0.4360747 * t3 + 0.3850649 * e2 + 0.1430804 * r3) / Bt), a3 = Rt((0.0139322 * t3 + 0.0971045 * e2 + 0.7141733 * r3) / Pt));
          const o3 = 116 * s3 - 16;
          return [o3 < 0 ? 0 : o3, 500 * (i3 - s3), 200 * (s3 - a3), n3];
        }
        function Ut(t3) {
          return t3 <= 0.04045 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
        }
        function Rt(t3) {
          return t3 > Tt ? Math.pow(t3, 1 / 3) : t3 / Ft + Vt;
        }
        function qt([t3, e2, r3, n3]) {
          let i3 = (t3 + 16) / 116, a3 = isNaN(e2) ? i3 : i3 + e2 / 500, s3 = isNaN(r3) ? i3 : i3 - r3 / 200;
          return i3 = 1 * Nt(i3), a3 = Bt * Nt(a3), s3 = Pt * Nt(s3), [jt(3.1338561 * a3 - 1.6168667 * i3 - 0.4906146 * s3), jt(-0.9787684 * a3 + 1.9161415 * i3 + 0.033454 * s3), jt(0.0719453 * a3 - 0.2289914 * i3 + 1.4052427 * s3), n3];
        }
        function jt(t3) {
          return (t3 = t3 <= 304e-5 ? 12.92 * t3 : 1.055 * Math.pow(t3, 1 / 2.4) - 0.055) < 0 ? 0 : t3 > 1 ? 1 : t3;
        }
        function Nt(t3) {
          return t3 > Et ? t3 * t3 * t3 : Ft * (t3 - Vt);
        }
        function Zt(t3) {
          return parseInt(t3.padEnd(2, t3), 16) / 255;
        }
        function Kt(t3, e2) {
          return Gt(e2 ? t3 / 100 : t3, 0, 1);
        }
        function Gt(t3, e2, r3) {
          return Math.min(Math.max(e2, t3), r3);
        }
        function Jt(t3) {
          return !t3.some(Number.isNaN);
        }
        const Xt = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        class Yt {
          constructor(t3, e2, r3, n3 = 1, i3 = true) {
            this.r = t3, this.g = e2, this.b = r3, this.a = n3, i3 || (this.r *= n3, this.g *= n3, this.b *= n3, n3 || this.overwriteGetter("rgb", [t3, e2, r3, n3]));
          }
          static parse(t3) {
            if (t3 instanceof Yt) return t3;
            if ("string" != typeof t3) return;
            const e2 = function(t4) {
              if ("transparent" === (t4 = t4.toLowerCase().trim())) return [0, 0, 0, 0];
              const e3 = Xt[t4];
              if (e3) {
                const [t5, r4, n3] = e3;
                return [t5 / 255, r4 / 255, n3 / 255, 1];
              }
              if (t4.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t4)) {
                const e4 = t4.length < 6 ? 1 : 2;
                let r4 = 1;
                return [Zt(t4.slice(r4, r4 += e4)), Zt(t4.slice(r4, r4 += e4)), Zt(t4.slice(r4, r4 += e4)), Zt(t4.slice(r4, r4 + e4) || "ff")];
              }
              if (t4.startsWith("rgb")) {
                const e4 = t4.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (e4) {
                  const [t5, r4, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3] = e4, f3 = [i3 || " ", o3 || " ", c3].join("");
                  if ("  " === f3 || "  /" === f3 || ",," === f3 || ",,," === f3) {
                    const t6 = [n3, s3, u3].join(""), e5 = "%%%" === t6 ? 100 : "" === t6 ? 255 : 0;
                    if (e5) {
                      const t7 = [Gt(+r4 / e5, 0, 1), Gt(+a3 / e5, 0, 1), Gt(+l3 / e5, 0, 1), h3 ? Kt(+h3, p3) : 1];
                      if (Jt(t7)) return t7;
                    }
                  }
                  return;
                }
              }
              const r3 = t4.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (r3) {
                const [t5, e4, n3, i3, a3, s3, o3, l3, u3] = r3, c3 = [n3 || " ", a3 || " ", o3].join("");
                if ("  " === c3 || "  /" === c3 || ",," === c3 || ",,," === c3) {
                  const t6 = [+e4, Gt(+i3, 0, 100), Gt(+s3, 0, 100), l3 ? Kt(+l3, u3) : 1];
                  if (Jt(t6)) return function([t7, e5, r4, n4]) {
                    function i4(n5) {
                      const i5 = (n5 + t7 / 30) % 12, a4 = e5 * Math.min(r4, 1 - r4);
                      return r4 - a4 * Math.max(-1, Math.min(i5 - 3, 9 - i5, 1));
                    }
                    return t7 = Dt(t7), e5 /= 100, r4 /= 100, [i4(0), i4(8), i4(4), n4];
                  }(t6);
                }
              }
            }(t3);
            return e2 ? new Yt(...e2, false) : void 0;
          }
          get rgb() {
            const { r: t3, g: e2, b: r3, a: n3 } = this, i3 = n3 || 1 / 0;
            return this.overwriteGetter("rgb", [t3 / i3, e2 / i3, r3 / i3, n3]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", function(t3) {
              const [e2, r3, n3, i3] = Ot(t3), a3 = Math.sqrt(r3 * r3 + n3 * n3);
              return [Math.round(1e4 * a3) ? Dt(Math.atan2(n3, r3) * Lt) : NaN, a3, e2, i3];
            }(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", Ot(this.rgb));
          }
          overwriteGetter(t3, e2) {
            return Object.defineProperty(this, t3, { value: e2 }), e2;
          }
          toString() {
            const [t3, e2, r3, n3] = this.rgb;
            return `rgba(${[t3, e2, r3].map((t4) => Math.round(255 * t4)).join(",")},${n3})`;
          }
        }
        Yt.black = new Yt(0, 0, 0, 1), Yt.white = new Yt(1, 1, 1, 1), Yt.transparent = new Yt(0, 0, 0, 0), Yt.red = new Yt(1, 0, 0, 1);
        class Ht {
          constructor(t3, e2, r3) {
            this.sensitivity = t3 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r3, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t3, e2) {
            return this.collator.compare(t3, e2);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class Wt {
          constructor(t3, e2, r3, n3, i3) {
            this.text = t3, this.image = e2, this.scale = r3, this.fontStack = n3, this.textColor = i3;
          }
        }
        class Qt {
          constructor(t3) {
            this.sections = t3;
          }
          static fromString(t3) {
            return new Qt([new Wt(t3, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some((t3) => 0 !== t3.text.length || t3.image && 0 !== t3.image.name.length);
          }
          static factory(t3) {
            return t3 instanceof Qt ? t3 : Qt.fromString(t3);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map((t3) => t3.text).join("");
          }
        }
        class te2 {
          constructor(t3) {
            this.values = t3.slice();
          }
          static parse(t3) {
            if (t3 instanceof te2) return t3;
            if ("number" == typeof t3) return new te2([t3, t3, t3, t3]);
            if (Array.isArray(t3) && !(t3.length < 1 || t3.length > 4)) {
              for (const e2 of t3) if ("number" != typeof e2) return;
              switch (t3.length) {
                case 1:
                  t3 = [t3[0], t3[0], t3[0], t3[0]];
                  break;
                case 2:
                  t3 = [t3[0], t3[1], t3[0], t3[1]];
                  break;
                case 3:
                  t3 = [t3[0], t3[1], t3[2], t3[1]];
              }
              return new te2(t3);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
        }
        const ee2 = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class re2 {
          constructor(t3) {
            this.values = t3.slice();
          }
          static parse(t3) {
            if (t3 instanceof re2) return t3;
            if (Array.isArray(t3) && !(t3.length < 1) && t3.length % 2 == 0) {
              for (let e2 = 0; e2 < t3.length; e2 += 2) {
                const r3 = t3[e2], n3 = t3[e2 + 1];
                if ("string" != typeof r3 || !ee2.has(r3)) return;
                if (!Array.isArray(n3) || 2 !== n3.length || "number" != typeof n3[0] || "number" != typeof n3[1]) return;
              }
              return new re2(t3);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
        }
        class ne2 {
          constructor(t3) {
            this.name = t3.name, this.available = t3.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t3) {
            return t3 ? new ne2({ name: t3, available: false }) : null;
          }
        }
        function ie2(t3, e2, r3, n3) {
          return "number" == typeof t3 && t3 >= 0 && t3 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r3 && r3 >= 0 && r3 <= 255 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid rgba value [${[t3, e2, r3, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n3 ? [t3, e2, r3, n3] : [t3, e2, r3]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function ae2(t3) {
          if (null === t3 || "string" == typeof t3 || "boolean" == typeof t3 || "number" == typeof t3 || t3 instanceof Yt || t3 instanceof Ht || t3 instanceof Qt || t3 instanceof te2 || t3 instanceof re2 || t3 instanceof ne2) return true;
          if (Array.isArray(t3)) {
            for (const e2 of t3) if (!ae2(e2)) return false;
            return true;
          }
          if ("object" == typeof t3) {
            for (const e2 in t3) if (!ae2(t3[e2])) return false;
            return true;
          }
          return false;
        }
        function se2(t3) {
          if (null === t3) return ht;
          if ("string" == typeof t3) return ft;
          if ("boolean" == typeof t3) return dt;
          if ("number" == typeof t3) return pt;
          if (t3 instanceof Yt) return yt;
          if (t3 instanceof Ht) return xt;
          if (t3 instanceof Qt) return vt;
          if (t3 instanceof te2) return bt;
          if (t3 instanceof re2) return _t;
          if (t3 instanceof ne2) return wt;
          if (Array.isArray(t3)) {
            const e2 = t3.length;
            let r3;
            for (const e3 of t3) {
              const t4 = se2(e3);
              if (r3) {
                if (r3 === t4) continue;
                r3 = gt;
                break;
              }
              r3 = t4;
            }
            return At(r3 || gt, e2);
          }
          return mt;
        }
        function oe2(t3) {
          const e2 = typeof t3;
          return null === t3 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t3) : t3 instanceof Yt || t3 instanceof Qt || t3 instanceof te2 || t3 instanceof re2 || t3 instanceof ne2 ? t3.toString() : JSON.stringify(t3);
        }
        class le2 {
          constructor(t3, e2) {
            this.type = t3, this.value = e2;
          }
          static parse(t3, e2) {
            if (2 !== t3.length) return e2.error(`'literal' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
            if (!ae2(t3[1])) return e2.error("invalid value");
            const r3 = t3[1];
            let n3 = se2(r3);
            const i3 = e2.expectedType;
            return "array" !== n3.kind || 0 !== n3.N || !i3 || "array" !== i3.kind || "number" == typeof i3.N && 0 !== i3.N || (n3 = i3), new le2(n3, r3);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class ue2 {
          constructor(t3) {
            this.name = "ExpressionEvaluationError", this.message = t3;
          }
          toJSON() {
            return this.message;
          }
        }
        const ce2 = { string: ft, number: pt, boolean: dt, object: mt };
        class he2 {
          constructor(t3, e2) {
            this.type = t3, this.args = e2;
          }
          static parse(t3, e2) {
            if (t3.length < 2) return e2.error("Expected at least one argument.");
            let r3, n3 = 1;
            const i3 = t3[0];
            if ("array" === i3) {
              let i4, a4;
              if (t3.length > 2) {
                const r4 = t3[1];
                if ("string" != typeof r4 || !(r4 in ce2) || "object" === r4) return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i4 = ce2[r4], n3++;
              } else i4 = gt;
              if (t3.length > 3) {
                if (null !== t3[2] && ("number" != typeof t3[2] || t3[2] < 0 || t3[2] !== Math.floor(t3[2]))) return e2.error('The length argument to "array" must be a positive integer literal', 2);
                a4 = t3[2], n3++;
              }
              r3 = At(i4, a4);
            } else {
              if (!ce2[i3]) throw new Error(`Types doesn't contain name = ${i3}`);
              r3 = ce2[i3];
            }
            const a3 = [];
            for (; n3 < t3.length; n3++) {
              const r4 = e2.parse(t3[n3], n3, gt);
              if (!r4) return null;
              a3.push(r4);
            }
            return new he2(r3, a3);
          }
          evaluate(t3) {
            for (let e2 = 0; e2 < this.args.length; e2++) {
              const r3 = this.args[e2].evaluate(t3);
              if (!It(this.type, se2(r3))) return r3;
              if (e2 === this.args.length - 1) throw new ue2(`Expected value to be of type ${St(this.type)}, but found ${St(se2(r3))} instead.`);
            }
            throw new Error();
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
        }
        const pe2 = { "to-boolean": dt, "to-color": yt, "to-number": pt, "to-string": ft };
        class fe2 {
          constructor(t3, e2) {
            this.type = t3, this.args = e2;
          }
          static parse(t3, e2) {
            if (t3.length < 2) return e2.error("Expected at least one argument.");
            const r3 = t3[0];
            if (!pe2[r3]) throw new Error(`Can't parse ${r3} as it is not part of the known types`);
            if (("to-boolean" === r3 || "to-string" === r3) && 2 !== t3.length) return e2.error("Expected one argument.");
            const n3 = pe2[r3], i3 = [];
            for (let r4 = 1; r4 < t3.length; r4++) {
              const n4 = e2.parse(t3[r4], r4, gt);
              if (!n4) return null;
              i3.push(n4);
            }
            return new fe2(n3, i3);
          }
          evaluate(t3) {
            switch (this.type.kind) {
              case "boolean":
                return Boolean(this.args[0].evaluate(t3));
              case "color": {
                let e2, r3;
                for (const n3 of this.args) {
                  if (e2 = n3.evaluate(t3), r3 = null, e2 instanceof Yt) return e2;
                  if ("string" == typeof e2) {
                    const r4 = t3.parseColor(e2);
                    if (r4) return r4;
                  } else if (Array.isArray(e2) && (r3 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : ie2(e2[0], e2[1], e2[2], e2[3]), !r3)) return new Yt(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
                }
                throw new ue2(r3 || `Could not parse color from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "padding": {
                let e2;
                for (const r3 of this.args) {
                  e2 = r3.evaluate(t3);
                  const n3 = te2.parse(e2);
                  if (n3) return n3;
                }
                throw new ue2(`Could not parse padding from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let e2;
                for (const r3 of this.args) {
                  e2 = r3.evaluate(t3);
                  const n3 = re2.parse(e2);
                  if (n3) return n3;
                }
                throw new ue2(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "number": {
                let e2 = null;
                for (const r3 of this.args) {
                  if (e2 = r3.evaluate(t3), null === e2) return 0;
                  const n3 = Number(e2);
                  if (!isNaN(n3)) return n3;
                }
                throw new ue2(`Could not convert ${JSON.stringify(e2)} to number.`);
              }
              case "formatted":
                return Qt.fromString(oe2(this.args[0].evaluate(t3)));
              case "resolvedImage":
                return ne2.fromString(oe2(this.args[0].evaluate(t3)));
              default:
                return oe2(this.args[0].evaluate(t3));
            }
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
        }
        const de2 = ["Unknown", "Point", "LineString", "Polygon"];
        class ye2 {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? de2[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t3) {
            let e2 = this._parseColorCache[t3];
            return e2 || (e2 = this._parseColorCache[t3] = Yt.parse(t3)), e2;
          }
        }
        class me2 {
          constructor(t3, e2, r3 = [], n3, i3 = new ct(), a3 = []) {
            this.registry = t3, this.path = r3, this.key = r3.map((t4) => `[${t4}]`).join(""), this.scope = i3, this.errors = a3, this.expectedType = n3, this._isConstant = e2;
          }
          parse(t3, e2, r3, n3, i3 = {}) {
            return e2 ? this.concat(e2, r3, n3)._parse(t3, i3) : this._parse(t3, i3);
          }
          _parse(t3, e2) {
            function r3(t4, e3, r4) {
              return "assert" === r4 ? new he2(e3, [t4]) : "coerce" === r4 ? new fe2(e3, [t4]) : t4;
            }
            if (null !== t3 && "string" != typeof t3 && "boolean" != typeof t3 && "number" != typeof t3 || (t3 = ["literal", t3]), Array.isArray(t3)) {
              if (0 === t3.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n3 = t3[0];
              if ("string" != typeof n3) return this.error(`Expression name must be a string, but found ${typeof n3} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const i3 = this.registry[n3];
              if (i3) {
                let n4 = i3.parse(t3, this);
                if (!n4) return null;
                if (this.expectedType) {
                  const t4 = this.expectedType, i4 = n4.type;
                  if ("string" !== t4.kind && "number" !== t4.kind && "boolean" !== t4.kind && "object" !== t4.kind && "array" !== t4.kind || "value" !== i4.kind) if ("color" !== t4.kind && "formatted" !== t4.kind && "resolvedImage" !== t4.kind || "value" !== i4.kind && "string" !== i4.kind) if ("padding" !== t4.kind || "value" !== i4.kind && "number" !== i4.kind && "array" !== i4.kind) if ("variableAnchorOffsetCollection" !== t4.kind || "value" !== i4.kind && "array" !== i4.kind) {
                    if (this.checkSubtype(t4, i4)) return null;
                  } else n4 = r3(n4, t4, e2.typeAnnotation || "coerce");
                  else n4 = r3(n4, t4, e2.typeAnnotation || "coerce");
                  else n4 = r3(n4, t4, e2.typeAnnotation || "coerce");
                  else n4 = r3(n4, t4, e2.typeAnnotation || "assert");
                }
                if (!(n4 instanceof le2) && "resolvedImage" !== n4.type.kind && this._isConstant(n4)) {
                  const t4 = new ye2();
                  try {
                    n4 = new le2(n4.type, n4.evaluate(t4));
                  } catch (t5) {
                    return this.error(t5.message), null;
                  }
                }
                return n4;
              }
              return this.error(`Unknown expression "${n3}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(void 0 === t3 ? "'undefined' value invalid. Use null instead." : "object" == typeof t3 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t3} instead.`);
          }
          concat(t3, e2, r3) {
            const n3 = "number" == typeof t3 ? this.path.concat(t3) : this.path, i3 = r3 ? this.scope.concat(r3) : this.scope;
            return new me2(this.registry, this._isConstant, n3, e2 || null, i3, this.errors);
          }
          error(t3, ...e2) {
            const r3 = `${this.key}${e2.map((t4) => `[${t4}]`).join("")}`;
            this.errors.push(new ut(r3, t3));
          }
          checkSubtype(t3, e2) {
            const r3 = It(t3, e2);
            return r3 && this.error(r3), r3;
          }
        }
        class ge2 {
          constructor(t3, e2, r3) {
            this.type = xt, this.locale = r3, this.caseSensitive = t3, this.diacriticSensitive = e2;
          }
          static parse(t3, e2) {
            if (2 !== t3.length) return e2.error("Expected one argument.");
            const r3 = t3[1];
            if ("object" != typeof r3 || Array.isArray(r3)) return e2.error("Collator options argument must be an object.");
            const n3 = e2.parse(void 0 !== r3["case-sensitive"] && r3["case-sensitive"], 1, dt);
            if (!n3) return null;
            const i3 = e2.parse(void 0 !== r3["diacritic-sensitive"] && r3["diacritic-sensitive"], 1, dt);
            if (!i3) return null;
            let a3 = null;
            return r3.locale && (a3 = e2.parse(r3.locale, 1, ft), !a3) ? null : new ge2(n3, i3, a3);
          }
          evaluate(t3) {
            return new Ht(this.caseSensitive.evaluate(t3), this.diacriticSensitive.evaluate(t3), this.locale ? this.locale.evaluate(t3) : null);
          }
          eachChild(t3) {
            t3(this.caseSensitive), t3(this.diacriticSensitive), this.locale && t3(this.locale);
          }
          outputDefined() {
            return false;
          }
        }
        const xe2 = 8192;
        function ve2(t3, e2) {
          t3[0] = Math.min(t3[0], e2[0]), t3[1] = Math.min(t3[1], e2[1]), t3[2] = Math.max(t3[2], e2[0]), t3[3] = Math.max(t3[3], e2[1]);
        }
        function be2(t3, e2) {
          return !(t3[0] <= e2[0] || t3[2] >= e2[2] || t3[1] <= e2[1] || t3[3] >= e2[3]);
        }
        function we2(t3, e2) {
          const r3 = (180 + t3[0]) / 360, n3 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3[1] * Math.PI / 360))) / 360, i3 = Math.pow(2, e2.z);
          return [Math.round(r3 * i3 * xe2), Math.round(n3 * i3 * xe2)];
        }
        function _e2(t3, e2, r3) {
          const n3 = t3[0] - e2[0], i3 = t3[1] - e2[1], a3 = t3[0] - r3[0], s3 = t3[1] - r3[1];
          return n3 * s3 - a3 * i3 == 0 && n3 * a3 <= 0 && i3 * s3 <= 0;
        }
        function Ae2(t3, e2) {
          let r3 = false;
          for (let s3 = 0, o3 = e2.length; s3 < o3; s3++) {
            const o4 = e2[s3];
            for (let e3 = 0, s4 = o4.length; e3 < s4 - 1; e3++) {
              if (_e2(t3, o4[e3], o4[e3 + 1])) return false;
              (i3 = o4[e3])[1] > (n3 = t3)[1] != (a3 = o4[e3 + 1])[1] > n3[1] && n3[0] < (a3[0] - i3[0]) * (n3[1] - i3[1]) / (a3[1] - i3[1]) + i3[0] && (r3 = !r3);
            }
          }
          var n3, i3, a3;
          return r3;
        }
        function Se2(t3, e2) {
          for (let r3 = 0; r3 < e2.length; r3++) if (Ae2(t3, e2[r3])) return true;
          return false;
        }
        function ke2(t3, e2, r3, n3) {
          const i3 = n3[0] - r3[0], a3 = n3[1] - r3[1], s3 = (t3[0] - r3[0]) * a3 - i3 * (t3[1] - r3[1]), o3 = (e2[0] - r3[0]) * a3 - i3 * (e2[1] - r3[1]);
          return s3 > 0 && o3 < 0 || s3 < 0 && o3 > 0;
        }
        function Ie2(t3, e2, r3) {
          for (const u3 of r3) for (let r4 = 0; r4 < u3.length - 1; ++r4) if (0 != (o3 = [(s3 = u3[r4 + 1])[0] - (a3 = u3[r4])[0], s3[1] - a3[1]])[0] * (l3 = [(i3 = e2)[0] - (n3 = t3)[0], i3[1] - n3[1]])[1] - o3[1] * l3[0] && ke2(n3, i3, a3, s3) && ke2(a3, s3, n3, i3)) return true;
          var n3, i3, a3, s3, o3, l3;
          return false;
        }
        function ze2(t3, e2) {
          for (let r3 = 0; r3 < t3.length; ++r3) if (!Ae2(t3[r3], e2)) return false;
          for (let r3 = 0; r3 < t3.length - 1; ++r3) if (Ie2(t3[r3], t3[r3 + 1], e2)) return false;
          return true;
        }
        function Me2(t3, e2) {
          for (let r3 = 0; r3 < e2.length; r3++) if (ze2(t3, e2[r3])) return true;
          return false;
        }
        function Ce2(t3, e2, r3) {
          const n3 = [];
          for (let i3 = 0; i3 < t3.length; i3++) {
            const a3 = [];
            for (let n4 = 0; n4 < t3[i3].length; n4++) {
              const s3 = we2(t3[i3][n4], r3);
              ve2(e2, s3), a3.push(s3);
            }
            n3.push(a3);
          }
          return n3;
        }
        function Be2(t3, e2, r3) {
          const n3 = [];
          for (let i3 = 0; i3 < t3.length; i3++) {
            const a3 = Ce2(t3[i3], e2, r3);
            n3.push(a3);
          }
          return n3;
        }
        function Pe2(t3, e2, r3, n3) {
          if (t3[0] < r3[0] || t3[0] > r3[2]) {
            const e3 = 0.5 * n3;
            let i3 = t3[0] - r3[0] > e3 ? -n3 : r3[0] - t3[0] > e3 ? n3 : 0;
            0 === i3 && (i3 = t3[0] - r3[2] > e3 ? -n3 : r3[2] - t3[0] > e3 ? n3 : 0), t3[0] += i3;
          }
          ve2(e2, t3);
        }
        function Ve2(t3, e2, r3, n3) {
          const i3 = Math.pow(2, n3.z) * xe2, a3 = [n3.x * xe2, n3.y * xe2], s3 = [];
          for (const n4 of t3) for (const t4 of n4) {
            const n5 = [t4.x + a3[0], t4.y + a3[1]];
            Pe2(n5, e2, r3, i3), s3.push(n5);
          }
          return s3;
        }
        function Ee2(t3, e2, r3, n3) {
          const i3 = Math.pow(2, n3.z) * xe2, a3 = [n3.x * xe2, n3.y * xe2], s3 = [];
          for (const r4 of t3) {
            const t4 = [];
            for (const n4 of r4) {
              const r5 = [n4.x + a3[0], n4.y + a3[1]];
              ve2(e2, r5), t4.push(r5);
            }
            s3.push(t4);
          }
          if (e2[2] - e2[0] <= i3 / 2) {
            (o3 = e2)[0] = o3[1] = 1 / 0, o3[2] = o3[3] = -1 / 0;
            for (const t4 of s3) for (const n4 of t4) Pe2(n4, e2, r3, i3);
          }
          var o3;
          return s3;
        }
        class Fe2 {
          constructor(t3, e2) {
            this.type = dt, this.geojson = t3, this.geometries = e2;
          }
          static parse(t3, e2) {
            if (2 !== t3.length) return e2.error(`'within' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
            if (ae2(t3[1])) {
              const e3 = t3[1];
              if ("FeatureCollection" === e3.type) for (let t4 = 0; t4 < e3.features.length; ++t4) {
                const r3 = e3.features[t4].geometry.type;
                if ("Polygon" === r3 || "MultiPolygon" === r3) return new Fe2(e3, e3.features[t4].geometry);
              }
              else if ("Feature" === e3.type) {
                const t4 = e3.geometry.type;
                if ("Polygon" === t4 || "MultiPolygon" === t4) return new Fe2(e3, e3.geometry);
              } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type) return new Fe2(e3, e3);
            }
            return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t3) {
            if (null != t3.geometry() && null != t3.canonicalID()) {
              if ("Point" === t3.geometryType()) return function(t4, e2) {
                const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t4.canonicalID();
                if ("Polygon" === e2.type) {
                  const a3 = Ce2(e2.coordinates, n3, i3), s3 = Ve2(t4.geometry(), r3, n3, i3);
                  if (!be2(r3, n3)) return false;
                  for (const t5 of s3) if (!Ae2(t5, a3)) return false;
                }
                if ("MultiPolygon" === e2.type) {
                  const a3 = Be2(e2.coordinates, n3, i3), s3 = Ve2(t4.geometry(), r3, n3, i3);
                  if (!be2(r3, n3)) return false;
                  for (const t5 of s3) if (!Se2(t5, a3)) return false;
                }
                return true;
              }(t3, this.geometries);
              if ("LineString" === t3.geometryType()) return function(t4, e2) {
                const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t4.canonicalID();
                if ("Polygon" === e2.type) {
                  const a3 = Ce2(e2.coordinates, n3, i3), s3 = Ee2(t4.geometry(), r3, n3, i3);
                  if (!be2(r3, n3)) return false;
                  for (const t5 of s3) if (!ze2(t5, a3)) return false;
                }
                if ("MultiPolygon" === e2.type) {
                  const a3 = Be2(e2.coordinates, n3, i3), s3 = Ee2(t4.geometry(), r3, n3, i3);
                  if (!be2(r3, n3)) return false;
                  for (const t5 of s3) if (!Me2(t5, a3)) return false;
                }
                return true;
              }(t3, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class Te2 {
          constructor(t3, e2) {
            this.type = e2.type, this.name = t3, this.boundExpression = e2;
          }
          static parse(t3, e2) {
            if (2 !== t3.length || "string" != typeof t3[1]) return e2.error("'var' expression requires exactly one string literal argument.");
            const r3 = t3[1];
            return e2.scope.has(r3) ? new Te2(r3, e2.scope.get(r3)) : e2.error(`Unknown variable "${r3}". Make sure "${r3}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t3) {
            return this.boundExpression.evaluate(t3);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        class $e2 {
          constructor(t3, e2, r3, n3) {
            this.name = t3, this.type = e2, this._evaluate = r3, this.args = n3;
          }
          evaluate(t3) {
            return this._evaluate(t3, this.args);
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return false;
          }
          static parse(t3, e2) {
            const r3 = t3[0], n3 = $e2.definitions[r3];
            if (!n3) return e2.error(`Unknown expression "${r3}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i3 = Array.isArray(n3) ? n3[0] : n3.type, a3 = Array.isArray(n3) ? [[n3[1], n3[2]]] : n3.overloads, s3 = a3.filter(([e3]) => !Array.isArray(e3) || e3.length === t3.length - 1);
            let o3 = null;
            for (const [n4, a4] of s3) {
              o3 = new me2(e2.registry, Le2, e2.path, null, e2.scope);
              const s4 = [];
              let l3 = false;
              for (let e3 = 1; e3 < t3.length; e3++) {
                const r4 = t3[e3], i4 = Array.isArray(n4) ? n4[e3 - 1] : n4.type, a5 = o3.parse(r4, 1 + s4.length, i4);
                if (!a5) {
                  l3 = true;
                  break;
                }
                s4.push(a5);
              }
              if (!l3) if (Array.isArray(n4) && n4.length !== s4.length) o3.error(`Expected ${n4.length} arguments, but found ${s4.length} instead.`);
              else {
                for (let t4 = 0; t4 < s4.length; t4++) {
                  const e3 = Array.isArray(n4) ? n4[t4] : n4.type, r4 = s4[t4];
                  o3.concat(t4 + 1).checkSubtype(e3, r4.type);
                }
                if (0 === o3.errors.length) return new $e2(r3, i3, a4, s4);
              }
            }
            if (1 === s3.length) e2.errors.push(...o3.errors);
            else {
              const r4 = (s3.length ? s3 : a3).map(([t4]) => {
                return e3 = t4, Array.isArray(e3) ? `(${e3.map(St).join(", ")})` : `(${St(e3.type)}...)`;
                var e3;
              }).join(" | "), n4 = [];
              for (let r5 = 1; r5 < t3.length; r5++) {
                const i4 = e2.parse(t3[r5], 1 + n4.length);
                if (!i4) return null;
                n4.push(St(i4.type));
              }
              e2.error(`Expected arguments of type ${r4}, but found (${n4.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t3, e2) {
            $e2.definitions = e2;
            for (const r3 in e2) t3[r3] = $e2;
          }
        }
        function Le2(t3) {
          if (t3 instanceof Te2) return Le2(t3.boundExpression);
          if (t3 instanceof $e2 && "error" === t3.name) return false;
          if (t3 instanceof ge2) return false;
          if (t3 instanceof Fe2) return false;
          const e2 = t3 instanceof fe2 || t3 instanceof he2;
          let r3 = true;
          return t3.eachChild((t4) => {
            r3 = e2 ? r3 && Le2(t4) : r3 && t4 instanceof le2;
          }), !!r3 && De2(t3) && Ue2(t3, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
        }
        function De2(t3) {
          if (t3 instanceof $e2) {
            if ("get" === t3.name && 1 === t3.args.length) return false;
            if ("feature-state" === t3.name) return false;
            if ("has" === t3.name && 1 === t3.args.length) return false;
            if ("properties" === t3.name || "geometry-type" === t3.name || "id" === t3.name) return false;
            if (/^filter-/.test(t3.name)) return false;
          }
          if (t3 instanceof Fe2) return false;
          let e2 = true;
          return t3.eachChild((t4) => {
            e2 && !De2(t4) && (e2 = false);
          }), e2;
        }
        function Oe2(t3) {
          if (t3 instanceof $e2 && "feature-state" === t3.name) return false;
          let e2 = true;
          return t3.eachChild((t4) => {
            e2 && !Oe2(t4) && (e2 = false);
          }), e2;
        }
        function Ue2(t3, e2) {
          if (t3 instanceof $e2 && e2.indexOf(t3.name) >= 0) return false;
          let r3 = true;
          return t3.eachChild((t4) => {
            r3 && !Ue2(t4, e2) && (r3 = false);
          }), r3;
        }
        function Re2(t3, e2) {
          const r3 = t3.length - 1;
          let n3, i3, a3 = 0, s3 = r3, o3 = 0;
          for (; a3 <= s3; ) if (o3 = Math.floor((a3 + s3) / 2), n3 = t3[o3], i3 = t3[o3 + 1], n3 <= e2) {
            if (o3 === r3 || e2 < i3) return o3;
            a3 = o3 + 1;
          } else {
            if (!(n3 > e2)) throw new ue2("Input is not a number.");
            s3 = o3 - 1;
          }
          return 0;
        }
        class qe2 {
          constructor(t3, e2, r3) {
            this.type = t3, this.input = e2, this.labels = [], this.outputs = [];
            for (const [t4, e3] of r3) this.labels.push(t4), this.outputs.push(e3);
          }
          static parse(t3, e2) {
            if (t3.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if ((t3.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
            const r3 = e2.parse(t3[1], 1, pt);
            if (!r3) return null;
            const n3 = [];
            let i3 = null;
            e2.expectedType && "value" !== e2.expectedType.kind && (i3 = e2.expectedType);
            for (let r4 = 1; r4 < t3.length; r4 += 2) {
              const a3 = 1 === r4 ? -1 / 0 : t3[r4], s3 = t3[r4 + 1], o3 = r4, l3 = r4 + 1;
              if ("number" != typeof a3) return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o3);
              if (n3.length && n3[n3.length - 1][0] >= a3) return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o3);
              const u3 = e2.parse(s3, l3, i3);
              if (!u3) return null;
              i3 = i3 || u3.type, n3.push([a3, u3]);
            }
            return new qe2(i3, r3, n3);
          }
          evaluate(t3) {
            const e2 = this.labels, r3 = this.outputs;
            if (1 === e2.length) return r3[0].evaluate(t3);
            const n3 = this.input.evaluate(t3);
            if (n3 <= e2[0]) return r3[0].evaluate(t3);
            const i3 = e2.length;
            return n3 >= e2[i3 - 1] ? r3[i3 - 1].evaluate(t3) : r3[Re2(e2, n3)].evaluate(t3);
          }
          eachChild(t3) {
            t3(this.input);
            for (const e2 of this.outputs) t3(e2);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined());
          }
        }
        function je2(t3, e2, r3) {
          return t3 + r3 * (e2 - t3);
        }
        function Ne2(t3, e2, r3) {
          return t3.map((t4, n3) => je2(t4, e2[n3], r3));
        }
        const Ze2 = { number: je2, color: function(t3, e2, r3, n3 = "rgb") {
          switch (n3) {
            case "rgb": {
              const [n4, i3, a3, s3] = Ne2(t3.rgb, e2.rgb, r3);
              return new Yt(n4, i3, a3, s3, false);
            }
            case "hcl": {
              const [n4, i3, a3, s3] = t3.hcl, [o3, l3, u3, c3] = e2.hcl;
              let h3, p3;
              if (isNaN(n4) || isNaN(o3)) isNaN(n4) ? isNaN(o3) ? h3 = NaN : (h3 = o3, 1 !== a3 && 0 !== a3 || (p3 = l3)) : (h3 = n4, 1 !== u3 && 0 !== u3 || (p3 = i3));
              else {
                let t4 = o3 - n4;
                o3 > n4 && t4 > 180 ? t4 -= 360 : o3 < n4 && n4 - o3 > 180 && (t4 += 360), h3 = n4 + r3 * t4;
              }
              const [f3, d3, y3, m3] = function([t4, e3, r4, n5]) {
                return t4 = isNaN(t4) ? 0 : t4 * $t, qt([r4, Math.cos(t4) * e3, Math.sin(t4) * e3, n5]);
              }([h3, null != p3 ? p3 : je2(i3, l3, r3), je2(a3, u3, r3), je2(s3, c3, r3)]);
              return new Yt(f3, d3, y3, m3, false);
            }
            case "lab": {
              const [n4, i3, a3, s3] = qt(Ne2(t3.lab, e2.lab, r3));
              return new Yt(n4, i3, a3, s3, false);
            }
          }
        }, array: Ne2, padding: function(t3, e2, r3) {
          return new te2(Ne2(t3.values, e2.values, r3));
        }, variableAnchorOffsetCollection: function(t3, e2, r3) {
          const n3 = t3.values, i3 = e2.values;
          if (n3.length !== i3.length) throw new ue2(`Cannot interpolate values of different length. from: ${t3.toString()}, to: ${e2.toString()}`);
          const a3 = [];
          for (let t4 = 0; t4 < n3.length; t4 += 2) {
            if (n3[t4] !== i3[t4]) throw new ue2(`Cannot interpolate values containing mismatched anchors. from[${t4}]: ${n3[t4]}, to[${t4}]: ${i3[t4]}`);
            a3.push(n3[t4]);
            const [e3, s3] = n3[t4 + 1], [o3, l3] = i3[t4 + 1];
            a3.push([je2(e3, o3, r3), je2(s3, l3, r3)]);
          }
          return new re2(a3);
        } };
        class Ke {
          constructor(t3, e2, r3, n3, i3) {
            this.type = t3, this.operator = e2, this.interpolation = r3, this.input = n3, this.labels = [], this.outputs = [];
            for (const [t4, e3] of i3) this.labels.push(t4), this.outputs.push(e3);
          }
          static interpolationFactor(t3, e2, r3, n3) {
            let i3 = 0;
            if ("exponential" === t3.name) i3 = Ge2(e2, t3.base, r3, n3);
            else if ("linear" === t3.name) i3 = Ge2(e2, 1, r3, n3);
            else if ("cubic-bezier" === t3.name) {
              const a3 = t3.controlPoints;
              i3 = new l2(a3[0], a3[1], a3[2], a3[3]).solve(Ge2(e2, 1, r3, n3));
            }
            return i3;
          }
          static parse(t3, e2) {
            let [r3, n3, i3, ...a3] = t3;
            if (!Array.isArray(n3) || 0 === n3.length) return e2.error("Expected an interpolation type expression.", 1);
            if ("linear" === n3[0]) n3 = { name: "linear" };
            else if ("exponential" === n3[0]) {
              const t4 = n3[1];
              if ("number" != typeof t4) return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
              n3 = { name: "exponential", base: t4 };
            } else {
              if ("cubic-bezier" !== n3[0]) return e2.error(`Unknown interpolation type ${String(n3[0])}`, 1, 0);
              {
                const t4 = n3.slice(1);
                if (4 !== t4.length || t4.some((t5) => "number" != typeof t5 || t5 < 0 || t5 > 1)) return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n3 = { name: "cubic-bezier", controlPoints: t4 };
              }
            }
            if (t3.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if ((t3.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
            if (i3 = e2.parse(i3, 2, pt), !i3) return null;
            const s3 = [];
            let o3 = null;
            "interpolate-hcl" === r3 || "interpolate-lab" === r3 ? o3 = yt : e2.expectedType && "value" !== e2.expectedType.kind && (o3 = e2.expectedType);
            for (let t4 = 0; t4 < a3.length; t4 += 2) {
              const r4 = a3[t4], n4 = a3[t4 + 1], i4 = t4 + 3, l3 = t4 + 4;
              if ("number" != typeof r4) return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i4);
              if (s3.length && s3[s3.length - 1][0] >= r4) return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i4);
              const u3 = e2.parse(n4, l3, o3);
              if (!u3) return null;
              o3 = o3 || u3.type, s3.push([r4, u3]);
            }
            return Ct(o3, pt) || Ct(o3, yt) || Ct(o3, bt) || Ct(o3, _t) || Ct(o3, At(pt)) ? new Ke(o3, r3, n3, i3, s3) : e2.error(`Type ${St(o3)} is not interpolatable.`);
          }
          evaluate(t3) {
            const e2 = this.labels, r3 = this.outputs;
            if (1 === e2.length) return r3[0].evaluate(t3);
            const n3 = this.input.evaluate(t3);
            if (n3 <= e2[0]) return r3[0].evaluate(t3);
            const i3 = e2.length;
            if (n3 >= e2[i3 - 1]) return r3[i3 - 1].evaluate(t3);
            const a3 = Re2(e2, n3), s3 = Ke.interpolationFactor(this.interpolation, n3, e2[a3], e2[a3 + 1]), o3 = r3[a3].evaluate(t3), l3 = r3[a3 + 1].evaluate(t3);
            switch (this.operator) {
              case "interpolate":
                return Ze2[this.type.kind](o3, l3, s3);
              case "interpolate-hcl":
                return Ze2.color(o3, l3, s3, "hcl");
              case "interpolate-lab":
                return Ze2.color(o3, l3, s3, "lab");
            }
          }
          eachChild(t3) {
            t3(this.input);
            for (const e2 of this.outputs) t3(e2);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined());
          }
        }
        function Ge2(t3, e2, r3, n3) {
          const i3 = n3 - r3, a3 = t3 - r3;
          return 0 === i3 ? 0 : 1 === e2 ? a3 / i3 : (Math.pow(e2, a3) - 1) / (Math.pow(e2, i3) - 1);
        }
        class Je {
          constructor(t3, e2) {
            this.type = t3, this.args = e2;
          }
          static parse(t3, e2) {
            if (t3.length < 2) return e2.error("Expectected at least one argument.");
            let r3 = null;
            const n3 = e2.expectedType;
            n3 && "value" !== n3.kind && (r3 = n3);
            const i3 = [];
            for (const n4 of t3.slice(1)) {
              const t4 = e2.parse(n4, 1 + i3.length, r3, void 0, { typeAnnotation: "omit" });
              if (!t4) return null;
              r3 = r3 || t4.type, i3.push(t4);
            }
            if (!r3) throw new Error("No output type");
            const a3 = n3 && i3.some((t4) => It(n3, t4.type));
            return new Je(a3 ? gt : r3, i3);
          }
          evaluate(t3) {
            let e2, r3 = null, n3 = 0;
            for (const i3 of this.args) if (n3++, r3 = i3.evaluate(t3), r3 && r3 instanceof ne2 && !r3.available && (e2 || (e2 = r3.name), r3 = null, n3 === this.args.length && (r3 = e2)), null !== r3) break;
            return r3;
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
        }
        class Xe2 {
          constructor(t3, e2) {
            this.type = e2.type, this.bindings = [].concat(t3), this.result = e2;
          }
          evaluate(t3) {
            return this.result.evaluate(t3);
          }
          eachChild(t3) {
            for (const e2 of this.bindings) t3(e2[1]);
            t3(this.result);
          }
          static parse(t3, e2) {
            if (t3.length < 4) return e2.error(`Expected at least 3 arguments, but found ${t3.length - 1} instead.`);
            const r3 = [];
            for (let n4 = 1; n4 < t3.length - 1; n4 += 2) {
              const i3 = t3[n4];
              if ("string" != typeof i3) return e2.error(`Expected string, but found ${typeof i3} instead.`, n4);
              if (/[^a-zA-Z0-9_]/.test(i3)) return e2.error("Variable names must contain only alphanumeric characters or '_'.", n4);
              const a3 = e2.parse(t3[n4 + 1], n4 + 1);
              if (!a3) return null;
              r3.push([i3, a3]);
            }
            const n3 = e2.parse(t3[t3.length - 1], t3.length - 1, e2.expectedType, r3);
            return n3 ? new Xe2(r3, n3) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Ye {
          constructor(t3, e2, r3) {
            this.type = t3, this.index = e2, this.input = r3;
          }
          static parse(t3, e2) {
            if (3 !== t3.length) return e2.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
            const r3 = e2.parse(t3[1], 1, pt), n3 = e2.parse(t3[2], 2, At(e2.expectedType || gt));
            return r3 && n3 ? new Ye(n3.type.itemType, r3, n3) : null;
          }
          evaluate(t3) {
            const e2 = this.index.evaluate(t3), r3 = this.input.evaluate(t3);
            if (e2 < 0) throw new ue2(`Array index out of bounds: ${e2} < 0.`);
            if (e2 >= r3.length) throw new ue2(`Array index out of bounds: ${e2} > ${r3.length - 1}.`);
            if (e2 !== Math.floor(e2)) throw new ue2(`Array index must be an integer, but found ${e2} instead.`);
            return r3[e2];
          }
          eachChild(t3) {
            t3(this.index), t3(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class He2 {
          constructor(t3, e2) {
            this.type = dt, this.needle = t3, this.haystack = e2;
          }
          static parse(t3, e2) {
            if (3 !== t3.length) return e2.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
            const r3 = e2.parse(t3[1], 1, gt), n3 = e2.parse(t3[2], 2, gt);
            return r3 && n3 ? zt(r3.type, [dt, ft, pt, ht, gt]) ? new He2(r3, n3) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${St(r3.type)} instead`) : null;
          }
          evaluate(t3) {
            const e2 = this.needle.evaluate(t3), r3 = this.haystack.evaluate(t3);
            if (!r3) return false;
            if (!Mt(e2, ["boolean", "string", "number", "null"])) throw new ue2(`Expected first argument to be of type boolean, string, number or null, but found ${St(se2(e2))} instead.`);
            if (!Mt(r3, ["string", "array"])) throw new ue2(`Expected second argument to be of type array or string, but found ${St(se2(r3))} instead.`);
            return r3.indexOf(e2) >= 0;
          }
          eachChild(t3) {
            t3(this.needle), t3(this.haystack);
          }
          outputDefined() {
            return true;
          }
        }
        class We2 {
          constructor(t3, e2, r3) {
            this.type = pt, this.needle = t3, this.haystack = e2, this.fromIndex = r3;
          }
          static parse(t3, e2) {
            if (t3.length <= 2 || t3.length >= 5) return e2.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
            const r3 = e2.parse(t3[1], 1, gt), n3 = e2.parse(t3[2], 2, gt);
            if (!r3 || !n3) return null;
            if (!zt(r3.type, [dt, ft, pt, ht, gt])) return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${St(r3.type)} instead`);
            if (4 === t3.length) {
              const i3 = e2.parse(t3[3], 3, pt);
              return i3 ? new We2(r3, n3, i3) : null;
            }
            return new We2(r3, n3);
          }
          evaluate(t3) {
            const e2 = this.needle.evaluate(t3), r3 = this.haystack.evaluate(t3);
            if (!Mt(e2, ["boolean", "string", "number", "null"])) throw new ue2(`Expected first argument to be of type boolean, string, number or null, but found ${St(se2(e2))} instead.`);
            if (!Mt(r3, ["string", "array"])) throw new ue2(`Expected second argument to be of type array or string, but found ${St(se2(r3))} instead.`);
            if (this.fromIndex) {
              const n3 = this.fromIndex.evaluate(t3);
              return r3.indexOf(e2, n3);
            }
            return r3.indexOf(e2);
          }
          eachChild(t3) {
            t3(this.needle), t3(this.haystack), this.fromIndex && t3(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
        }
        class Qe2 {
          constructor(t3, e2, r3, n3, i3, a3) {
            this.inputType = t3, this.type = e2, this.input = r3, this.cases = n3, this.outputs = i3, this.otherwise = a3;
          }
          static parse(t3, e2) {
            if (t3.length < 5) return e2.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if (t3.length % 2 != 1) return e2.error("Expected an even number of arguments.");
            let r3, n3;
            e2.expectedType && "value" !== e2.expectedType.kind && (n3 = e2.expectedType);
            const i3 = {}, a3 = [];
            for (let s4 = 2; s4 < t3.length - 1; s4 += 2) {
              let o4 = t3[s4];
              const l3 = t3[s4 + 1];
              Array.isArray(o4) || (o4 = [o4]);
              const u3 = e2.concat(s4);
              if (0 === o4.length) return u3.error("Expected at least one branch label.");
              for (const t4 of o4) {
                if ("number" != typeof t4 && "string" != typeof t4) return u3.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t4 && Math.abs(t4) > Number.MAX_SAFE_INTEGER) return u3.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if ("number" == typeof t4 && Math.floor(t4) !== t4) return u3.error("Numeric branch labels must be integer values.");
                if (r3) {
                  if (u3.checkSubtype(r3, se2(t4))) return null;
                } else r3 = se2(t4);
                if (void 0 !== i3[String(t4)]) return u3.error("Branch labels must be unique.");
                i3[String(t4)] = a3.length;
              }
              const c3 = e2.parse(l3, s4, n3);
              if (!c3) return null;
              n3 = n3 || c3.type, a3.push(c3);
            }
            const s3 = e2.parse(t3[1], 1, gt);
            if (!s3) return null;
            const o3 = e2.parse(t3[t3.length - 1], t3.length - 1, n3);
            return o3 ? "value" !== s3.type.kind && e2.concat(1).checkSubtype(r3, s3.type) ? null : new Qe2(r3, n3, s3, i3, a3, o3) : null;
          }
          evaluate(t3) {
            const e2 = this.input.evaluate(t3);
            return (se2(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t3);
          }
          eachChild(t3) {
            t3(this.input), this.outputs.forEach(t3), t3(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class tr {
          constructor(t3, e2, r3) {
            this.type = t3, this.branches = e2, this.otherwise = r3;
          }
          static parse(t3, e2) {
            if (t3.length < 4) return e2.error(`Expected at least 3 arguments, but found only ${t3.length - 1}.`);
            if (t3.length % 2 != 0) return e2.error("Expected an odd number of arguments.");
            let r3;
            e2.expectedType && "value" !== e2.expectedType.kind && (r3 = e2.expectedType);
            const n3 = [];
            for (let i4 = 1; i4 < t3.length - 1; i4 += 2) {
              const a3 = e2.parse(t3[i4], i4, dt);
              if (!a3) return null;
              const s3 = e2.parse(t3[i4 + 1], i4 + 1, r3);
              if (!s3) return null;
              n3.push([a3, s3]), r3 = r3 || s3.type;
            }
            const i3 = e2.parse(t3[t3.length - 1], t3.length - 1, r3);
            if (!i3) return null;
            if (!r3) throw new Error("Can't infer output type");
            return new tr(r3, n3, i3);
          }
          evaluate(t3) {
            for (const [e2, r3] of this.branches) if (e2.evaluate(t3)) return r3.evaluate(t3);
            return this.otherwise.evaluate(t3);
          }
          eachChild(t3) {
            for (const [e2, r3] of this.branches) t3(e2), t3(r3);
            t3(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t3, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class er {
          constructor(t3, e2, r3, n3) {
            this.type = t3, this.input = e2, this.beginIndex = r3, this.endIndex = n3;
          }
          static parse(t3, e2) {
            if (t3.length <= 2 || t3.length >= 5) return e2.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
            const r3 = e2.parse(t3[1], 1, gt), n3 = e2.parse(t3[2], 2, pt);
            if (!r3 || !n3) return null;
            if (!zt(r3.type, [At(gt), ft, gt])) return e2.error(`Expected first argument to be of type array or string, but found ${St(r3.type)} instead`);
            if (4 === t3.length) {
              const i3 = e2.parse(t3[3], 3, pt);
              return i3 ? new er(r3.type, r3, n3, i3) : null;
            }
            return new er(r3.type, r3, n3);
          }
          evaluate(t3) {
            const e2 = this.input.evaluate(t3), r3 = this.beginIndex.evaluate(t3);
            if (!Mt(e2, ["string", "array"])) throw new ue2(`Expected first argument to be of type array or string, but found ${St(se2(e2))} instead.`);
            if (this.endIndex) {
              const n3 = this.endIndex.evaluate(t3);
              return e2.slice(r3, n3);
            }
            return e2.slice(r3);
          }
          eachChild(t3) {
            t3(this.input), t3(this.beginIndex), this.endIndex && t3(this.endIndex);
          }
          outputDefined() {
            return false;
          }
        }
        function rr(t3, e2) {
          return "==" === t3 || "!=" === t3 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
        }
        function nr(t3, e2, r3, n3) {
          return 0 === n3.compare(e2, r3);
        }
        function ir(t3, e2, r3) {
          const n3 = "==" !== t3 && "!=" !== t3;
          return class i3 {
            constructor(t4, e3, r4) {
              this.type = dt, this.lhs = t4, this.rhs = e3, this.collator = r4, this.hasUntypedArgument = "value" === t4.type.kind || "value" === e3.type.kind;
            }
            static parse(t4, e3) {
              if (3 !== t4.length && 4 !== t4.length) return e3.error("Expected two or three arguments.");
              const r4 = t4[0];
              let a3 = e3.parse(t4[1], 1, gt);
              if (!a3) return null;
              if (!rr(r4, a3.type)) return e3.concat(1).error(`"${r4}" comparisons are not supported for type '${St(a3.type)}'.`);
              let s3 = e3.parse(t4[2], 2, gt);
              if (!s3) return null;
              if (!rr(r4, s3.type)) return e3.concat(2).error(`"${r4}" comparisons are not supported for type '${St(s3.type)}'.`);
              if (a3.type.kind !== s3.type.kind && "value" !== a3.type.kind && "value" !== s3.type.kind) return e3.error(`Cannot compare types '${St(a3.type)}' and '${St(s3.type)}'.`);
              n3 && ("value" === a3.type.kind && "value" !== s3.type.kind ? a3 = new he2(s3.type, [a3]) : "value" !== a3.type.kind && "value" === s3.type.kind && (s3 = new he2(a3.type, [s3])));
              let o3 = null;
              if (4 === t4.length) {
                if ("string" !== a3.type.kind && "string" !== s3.type.kind && "value" !== a3.type.kind && "value" !== s3.type.kind) return e3.error("Cannot use collator to compare non-string types.");
                if (o3 = e3.parse(t4[3], 3, xt), !o3) return null;
              }
              return new i3(a3, s3, o3);
            }
            evaluate(i4) {
              const a3 = this.lhs.evaluate(i4), s3 = this.rhs.evaluate(i4);
              if (n3 && this.hasUntypedArgument) {
                const e3 = se2(a3), r4 = se2(s3);
                if (e3.kind !== r4.kind || "string" !== e3.kind && "number" !== e3.kind) throw new ue2(`Expected arguments for "${t3}" to be (string, string) or (number, number), but found (${e3.kind}, ${r4.kind}) instead.`);
              }
              if (this.collator && !n3 && this.hasUntypedArgument) {
                const t4 = se2(a3), r4 = se2(s3);
                if ("string" !== t4.kind || "string" !== r4.kind) return e2(i4, a3, s3);
              }
              return this.collator ? r3(i4, a3, s3, this.collator.evaluate(i4)) : e2(i4, a3, s3);
            }
            eachChild(t4) {
              t4(this.lhs), t4(this.rhs), this.collator && t4(this.collator);
            }
            outputDefined() {
              return true;
            }
          };
        }
        const ar = ir("==", function(t3, e2, r3) {
          return e2 === r3;
        }, nr), sr = ir("!=", function(t3, e2, r3) {
          return e2 !== r3;
        }, function(t3, e2, r3, n3) {
          return !nr(0, e2, r3, n3);
        }), or2 = ir("<", function(t3, e2, r3) {
          return e2 < r3;
        }, function(t3, e2, r3, n3) {
          return n3.compare(e2, r3) < 0;
        }), lr = ir(">", function(t3, e2, r3) {
          return e2 > r3;
        }, function(t3, e2, r3, n3) {
          return n3.compare(e2, r3) > 0;
        }), ur = ir("<=", function(t3, e2, r3) {
          return e2 <= r3;
        }, function(t3, e2, r3, n3) {
          return n3.compare(e2, r3) <= 0;
        }), cr = ir(">=", function(t3, e2, r3) {
          return e2 >= r3;
        }, function(t3, e2, r3, n3) {
          return n3.compare(e2, r3) >= 0;
        });
        class hr {
          constructor(t3, e2, r3, n3, i3) {
            this.type = ft, this.number = t3, this.locale = e2, this.currency = r3, this.minFractionDigits = n3, this.maxFractionDigits = i3;
          }
          static parse(t3, e2) {
            if (3 !== t3.length) return e2.error("Expected two arguments.");
            const r3 = e2.parse(t3[1], 1, pt);
            if (!r3) return null;
            const n3 = t3[2];
            if ("object" != typeof n3 || Array.isArray(n3)) return e2.error("NumberFormat options argument must be an object.");
            let i3 = null;
            if (n3.locale && (i3 = e2.parse(n3.locale, 1, ft), !i3)) return null;
            let a3 = null;
            if (n3.currency && (a3 = e2.parse(n3.currency, 1, ft), !a3)) return null;
            let s3 = null;
            if (n3["min-fraction-digits"] && (s3 = e2.parse(n3["min-fraction-digits"], 1, pt), !s3)) return null;
            let o3 = null;
            return n3["max-fraction-digits"] && (o3 = e2.parse(n3["max-fraction-digits"], 1, pt), !o3) ? null : new hr(r3, i3, a3, s3, o3);
          }
          evaluate(t3) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t3) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t3) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t3) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t3) : void 0 }).format(this.number.evaluate(t3));
          }
          eachChild(t3) {
            t3(this.number), this.locale && t3(this.locale), this.currency && t3(this.currency), this.minFractionDigits && t3(this.minFractionDigits), this.maxFractionDigits && t3(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
        }
        class pr {
          constructor(t3) {
            this.type = vt, this.sections = t3;
          }
          static parse(t3, e2) {
            if (t3.length < 2) return e2.error("Expected at least one argument.");
            const r3 = t3[1];
            if (!Array.isArray(r3) && "object" == typeof r3) return e2.error("First argument must be an image or text section.");
            const n3 = [];
            let i3 = false;
            for (let r4 = 1; r4 <= t3.length - 1; ++r4) {
              const a3 = t3[r4];
              if (i3 && "object" == typeof a3 && !Array.isArray(a3)) {
                i3 = false;
                let t4 = null;
                if (a3["font-scale"] && (t4 = e2.parse(a3["font-scale"], 1, pt), !t4)) return null;
                let r5 = null;
                if (a3["text-font"] && (r5 = e2.parse(a3["text-font"], 1, At(ft)), !r5)) return null;
                let s3 = null;
                if (a3["text-color"] && (s3 = e2.parse(a3["text-color"], 1, yt), !s3)) return null;
                const o3 = n3[n3.length - 1];
                o3.scale = t4, o3.font = r5, o3.textColor = s3;
              } else {
                const a4 = e2.parse(t3[r4], 1, gt);
                if (!a4) return null;
                const s3 = a4.type.kind;
                if ("string" !== s3 && "value" !== s3 && "null" !== s3 && "resolvedImage" !== s3) return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i3 = true, n3.push({ content: a4, scale: null, font: null, textColor: null });
              }
            }
            return new pr(n3);
          }
          evaluate(t3) {
            return new Qt(this.sections.map((e2) => {
              const r3 = e2.content.evaluate(t3);
              return se2(r3) === wt ? new Wt("", r3, null, null, null) : new Wt(oe2(r3), null, e2.scale ? e2.scale.evaluate(t3) : null, e2.font ? e2.font.evaluate(t3).join(",") : null, e2.textColor ? e2.textColor.evaluate(t3) : null);
            }));
          }
          eachChild(t3) {
            for (const e2 of this.sections) t3(e2.content), e2.scale && t3(e2.scale), e2.font && t3(e2.font), e2.textColor && t3(e2.textColor);
          }
          outputDefined() {
            return false;
          }
        }
        class fr {
          constructor(t3) {
            this.type = wt, this.input = t3;
          }
          static parse(t3, e2) {
            if (2 !== t3.length) return e2.error("Expected two arguments.");
            const r3 = e2.parse(t3[1], 1, ft);
            return r3 ? new fr(r3) : e2.error("No image name provided.");
          }
          evaluate(t3) {
            const e2 = this.input.evaluate(t3), r3 = ne2.fromString(e2);
            return r3 && t3.availableImages && (r3.available = t3.availableImages.indexOf(e2) > -1), r3;
          }
          eachChild(t3) {
            t3(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class dr {
          constructor(t3) {
            this.type = pt, this.input = t3;
          }
          static parse(t3, e2) {
            if (2 !== t3.length) return e2.error(`Expected 1 argument, but found ${t3.length - 1} instead.`);
            const r3 = e2.parse(t3[1], 1);
            return r3 ? "array" !== r3.type.kind && "string" !== r3.type.kind && "value" !== r3.type.kind ? e2.error(`Expected argument of type string or array, but found ${St(r3.type)} instead.`) : new dr(r3) : null;
          }
          evaluate(t3) {
            const e2 = this.input.evaluate(t3);
            if ("string" == typeof e2) return e2.length;
            if (Array.isArray(e2)) return e2.length;
            throw new ue2(`Expected value to be of type string or array, but found ${St(se2(e2))} instead.`);
          }
          eachChild(t3) {
            t3(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        const yr = { "==": ar, "!=": sr, ">": lr, "<": or2, ">=": cr, "<=": ur, array: he2, at: Ye, boolean: he2, case: tr, coalesce: Je, collator: ge2, format: pr, image: fr, in: He2, "index-of": We2, interpolate: Ke, "interpolate-hcl": Ke, "interpolate-lab": Ke, length: dr, let: Xe2, literal: le2, match: Qe2, number: he2, "number-format": hr, object: he2, slice: er, step: qe2, string: he2, "to-boolean": fe2, "to-color": fe2, "to-number": fe2, "to-string": fe2, var: Te2, within: Fe2 };
        function mr(t3, [e2, r3, n3, i3]) {
          e2 = e2.evaluate(t3), r3 = r3.evaluate(t3), n3 = n3.evaluate(t3);
          const a3 = i3 ? i3.evaluate(t3) : 1, s3 = ie2(e2, r3, n3, a3);
          if (s3) throw new ue2(s3);
          return new Yt(e2 / 255, r3 / 255, n3 / 255, a3, false);
        }
        function gr(t3, e2) {
          return t3 in e2;
        }
        function xr(t3, e2) {
          const r3 = e2[t3];
          return void 0 === r3 ? null : r3;
        }
        function vr(t3) {
          return { type: t3 };
        }
        function br(t3) {
          return { result: "success", value: t3 };
        }
        function wr(t3) {
          return { result: "error", value: t3 };
        }
        function _r(t3) {
          return "data-driven" === t3["property-type"] || "cross-faded-data-driven" === t3["property-type"];
        }
        function Ar(t3) {
          return !!t3.expression && t3.expression.parameters.indexOf("zoom") > -1;
        }
        function Sr(t3) {
          return !!t3.expression && t3.expression.interpolated;
        }
        function kr(t3) {
          return t3 instanceof Number ? "number" : t3 instanceof String ? "string" : t3 instanceof Boolean ? "boolean" : Array.isArray(t3) ? "array" : null === t3 ? "null" : typeof t3;
        }
        function Ir(t3) {
          return "object" == typeof t3 && null !== t3 && !Array.isArray(t3);
        }
        function zr(t3) {
          return t3;
        }
        function Mr(t3, e2) {
          const r3 = "color" === e2.type, n3 = t3.stops && "object" == typeof t3.stops[0][0], i3 = n3 || !(n3 || void 0 !== t3.property), a3 = t3.type || (Sr(e2) ? "exponential" : "interval");
          if (r3 || "padding" === e2.type) {
            const n4 = r3 ? Yt.parse : te2.parse;
            (t3 = lt({}, t3)).stops && (t3.stops = t3.stops.map((t4) => [t4[0], n4(t4[1])])), t3.default = n4(t3.default ? t3.default : e2.default);
          }
          if (t3.colorSpace && "rgb" !== (s3 = t3.colorSpace) && "hcl" !== s3 && "lab" !== s3) throw new Error(`Unknown color space: "${t3.colorSpace}"`);
          var s3;
          let o3, l3, u3;
          if ("exponential" === a3) o3 = Vr;
          else if ("interval" === a3) o3 = Pr;
          else if ("categorical" === a3) {
            o3 = Br, l3 = /* @__PURE__ */ Object.create(null);
            for (const e3 of t3.stops) l3[e3[0]] = e3[1];
            u3 = typeof t3.stops[0][0];
          } else {
            if ("identity" !== a3) throw new Error(`Unknown function type "${a3}"`);
            o3 = Er;
          }
          if (n3) {
            const r4 = {}, n4 = [];
            for (let e3 = 0; e3 < t3.stops.length; e3++) {
              const i5 = t3.stops[e3], a5 = i5[0].zoom;
              void 0 === r4[a5] && (r4[a5] = { zoom: a5, type: t3.type, property: t3.property, default: t3.default, stops: [] }, n4.push(a5)), r4[a5].stops.push([i5[0].value, i5[1]]);
            }
            const i4 = [];
            for (const t4 of n4) i4.push([r4[t4].zoom, Mr(r4[t4], e2)]);
            const a4 = { name: "linear" };
            return { kind: "composite", interpolationType: a4, interpolationFactor: Ke.interpolationFactor.bind(void 0, a4), zoomStops: i4.map((t4) => t4[0]), evaluate: ({ zoom: r5 }, n5) => Vr({ stops: i4, base: t3.base }, e2, r5).evaluate(r5, n5) };
          }
          if (i3) {
            const r4 = "exponential" === a3 ? { name: "exponential", base: void 0 !== t3.base ? t3.base : 1 } : null;
            return { kind: "camera", interpolationType: r4, interpolationFactor: Ke.interpolationFactor.bind(void 0, r4), zoomStops: t3.stops.map((t4) => t4[0]), evaluate: ({ zoom: r5 }) => o3(t3, e2, r5, l3, u3) };
          }
          return { kind: "source", evaluate(r4, n4) {
            const i4 = n4 && n4.properties ? n4.properties[t3.property] : void 0;
            return void 0 === i4 ? Cr(t3.default, e2.default) : o3(t3, e2, i4, l3, u3);
          } };
        }
        function Cr(t3, e2, r3) {
          return void 0 !== t3 ? t3 : void 0 !== e2 ? e2 : void 0 !== r3 ? r3 : void 0;
        }
        function Br(t3, e2, r3, n3, i3) {
          return Cr(typeof r3 === i3 ? n3[r3] : void 0, t3.default, e2.default);
        }
        function Pr(t3, e2, r3) {
          if ("number" !== kr(r3)) return Cr(t3.default, e2.default);
          const n3 = t3.stops.length;
          if (1 === n3) return t3.stops[0][1];
          if (r3 <= t3.stops[0][0]) return t3.stops[0][1];
          if (r3 >= t3.stops[n3 - 1][0]) return t3.stops[n3 - 1][1];
          const i3 = Re2(t3.stops.map((t4) => t4[0]), r3);
          return t3.stops[i3][1];
        }
        function Vr(t3, e2, r3) {
          const n3 = void 0 !== t3.base ? t3.base : 1;
          if ("number" !== kr(r3)) return Cr(t3.default, e2.default);
          const i3 = t3.stops.length;
          if (1 === i3) return t3.stops[0][1];
          if (r3 <= t3.stops[0][0]) return t3.stops[0][1];
          if (r3 >= t3.stops[i3 - 1][0]) return t3.stops[i3 - 1][1];
          const a3 = Re2(t3.stops.map((t4) => t4[0]), r3), s3 = function(t4, e3, r4, n4) {
            const i4 = n4 - r4, a4 = t4 - r4;
            return 0 === i4 ? 0 : 1 === e3 ? a4 / i4 : (Math.pow(e3, a4) - 1) / (Math.pow(e3, i4) - 1);
          }(r3, n3, t3.stops[a3][0], t3.stops[a3 + 1][0]), o3 = t3.stops[a3][1], l3 = t3.stops[a3 + 1][1], u3 = Ze2[e2.type] || zr;
          return "function" == typeof o3.evaluate ? { evaluate(...e3) {
            const r4 = o3.evaluate.apply(void 0, e3), n4 = l3.evaluate.apply(void 0, e3);
            if (void 0 !== r4 && void 0 !== n4) return u3(r4, n4, s3, t3.colorSpace);
          } } : u3(o3, l3, s3, t3.colorSpace);
        }
        function Er(t3, e2, r3) {
          switch (e2.type) {
            case "color":
              r3 = Yt.parse(r3);
              break;
            case "formatted":
              r3 = Qt.fromString(r3.toString());
              break;
            case "resolvedImage":
              r3 = ne2.fromString(r3.toString());
              break;
            case "padding":
              r3 = te2.parse(r3);
              break;
            default:
              kr(r3) === e2.type || "enum" === e2.type && e2.values[r3] || (r3 = void 0);
          }
          return Cr(r3, t3.default, e2.default);
        }
        $e2.register(yr, { error: [{ kind: "error" }, [ft], (t3, [e2]) => {
          throw new ue2(e2.evaluate(t3));
        }], typeof: [ft, [gt], (t3, [e2]) => St(se2(e2.evaluate(t3)))], "to-rgba": [At(pt, 4), [yt], (t3, [e2]) => {
          const [r3, n3, i3, a3] = e2.evaluate(t3).rgb;
          return [255 * r3, 255 * n3, 255 * i3, a3];
        }], rgb: [yt, [pt, pt, pt], mr], rgba: [yt, [pt, pt, pt, pt], mr], has: { type: dt, overloads: [[[ft], (t3, [e2]) => gr(e2.evaluate(t3), t3.properties())], [[ft, mt], (t3, [e2, r3]) => gr(e2.evaluate(t3), r3.evaluate(t3))]] }, get: { type: gt, overloads: [[[ft], (t3, [e2]) => xr(e2.evaluate(t3), t3.properties())], [[ft, mt], (t3, [e2, r3]) => xr(e2.evaluate(t3), r3.evaluate(t3))]] }, "feature-state": [gt, [ft], (t3, [e2]) => xr(e2.evaluate(t3), t3.featureState || {})], properties: [mt, [], (t3) => t3.properties()], "geometry-type": [ft, [], (t3) => t3.geometryType()], id: [gt, [], (t3) => t3.id()], zoom: [pt, [], (t3) => t3.globals.zoom], "heatmap-density": [pt, [], (t3) => t3.globals.heatmapDensity || 0], "line-progress": [pt, [], (t3) => t3.globals.lineProgress || 0], accumulated: [gt, [], (t3) => void 0 === t3.globals.accumulated ? null : t3.globals.accumulated], "+": [pt, vr(pt), (t3, e2) => {
          let r3 = 0;
          for (const n3 of e2) r3 += n3.evaluate(t3);
          return r3;
        }], "*": [pt, vr(pt), (t3, e2) => {
          let r3 = 1;
          for (const n3 of e2) r3 *= n3.evaluate(t3);
          return r3;
        }], "-": { type: pt, overloads: [[[pt, pt], (t3, [e2, r3]) => e2.evaluate(t3) - r3.evaluate(t3)], [[pt], (t3, [e2]) => -e2.evaluate(t3)]] }, "/": [pt, [pt, pt], (t3, [e2, r3]) => e2.evaluate(t3) / r3.evaluate(t3)], "%": [pt, [pt, pt], (t3, [e2, r3]) => e2.evaluate(t3) % r3.evaluate(t3)], ln2: [pt, [], () => Math.LN2], pi: [pt, [], () => Math.PI], e: [pt, [], () => Math.E], "^": [pt, [pt, pt], (t3, [e2, r3]) => Math.pow(e2.evaluate(t3), r3.evaluate(t3))], sqrt: [pt, [pt], (t3, [e2]) => Math.sqrt(e2.evaluate(t3))], log10: [pt, [pt], (t3, [e2]) => Math.log(e2.evaluate(t3)) / Math.LN10], ln: [pt, [pt], (t3, [e2]) => Math.log(e2.evaluate(t3))], log2: [pt, [pt], (t3, [e2]) => Math.log(e2.evaluate(t3)) / Math.LN2], sin: [pt, [pt], (t3, [e2]) => Math.sin(e2.evaluate(t3))], cos: [pt, [pt], (t3, [e2]) => Math.cos(e2.evaluate(t3))], tan: [pt, [pt], (t3, [e2]) => Math.tan(e2.evaluate(t3))], asin: [pt, [pt], (t3, [e2]) => Math.asin(e2.evaluate(t3))], acos: [pt, [pt], (t3, [e2]) => Math.acos(e2.evaluate(t3))], atan: [pt, [pt], (t3, [e2]) => Math.atan(e2.evaluate(t3))], min: [pt, vr(pt), (t3, e2) => Math.min(...e2.map((e3) => e3.evaluate(t3)))], max: [pt, vr(pt), (t3, e2) => Math.max(...e2.map((e3) => e3.evaluate(t3)))], abs: [pt, [pt], (t3, [e2]) => Math.abs(e2.evaluate(t3))], round: [pt, [pt], (t3, [e2]) => {
          const r3 = e2.evaluate(t3);
          return r3 < 0 ? -Math.round(-r3) : Math.round(r3);
        }], floor: [pt, [pt], (t3, [e2]) => Math.floor(e2.evaluate(t3))], ceil: [pt, [pt], (t3, [e2]) => Math.ceil(e2.evaluate(t3))], "filter-==": [dt, [ft, gt], (t3, [e2, r3]) => t3.properties()[e2.value] === r3.value], "filter-id-==": [dt, [gt], (t3, [e2]) => t3.id() === e2.value], "filter-type-==": [dt, [ft], (t3, [e2]) => t3.geometryType() === e2.value], "filter-<": [dt, [ft, gt], (t3, [e2, r3]) => {
          const n3 = t3.properties()[e2.value], i3 = r3.value;
          return typeof n3 == typeof i3 && n3 < i3;
        }], "filter-id-<": [dt, [gt], (t3, [e2]) => {
          const r3 = t3.id(), n3 = e2.value;
          return typeof r3 == typeof n3 && r3 < n3;
        }], "filter->": [dt, [ft, gt], (t3, [e2, r3]) => {
          const n3 = t3.properties()[e2.value], i3 = r3.value;
          return typeof n3 == typeof i3 && n3 > i3;
        }], "filter-id->": [dt, [gt], (t3, [e2]) => {
          const r3 = t3.id(), n3 = e2.value;
          return typeof r3 == typeof n3 && r3 > n3;
        }], "filter-<=": [dt, [ft, gt], (t3, [e2, r3]) => {
          const n3 = t3.properties()[e2.value], i3 = r3.value;
          return typeof n3 == typeof i3 && n3 <= i3;
        }], "filter-id-<=": [dt, [gt], (t3, [e2]) => {
          const r3 = t3.id(), n3 = e2.value;
          return typeof r3 == typeof n3 && r3 <= n3;
        }], "filter->=": [dt, [ft, gt], (t3, [e2, r3]) => {
          const n3 = t3.properties()[e2.value], i3 = r3.value;
          return typeof n3 == typeof i3 && n3 >= i3;
        }], "filter-id->=": [dt, [gt], (t3, [e2]) => {
          const r3 = t3.id(), n3 = e2.value;
          return typeof r3 == typeof n3 && r3 >= n3;
        }], "filter-has": [dt, [gt], (t3, [e2]) => e2.value in t3.properties()], "filter-has-id": [dt, [], (t3) => null !== t3.id() && void 0 !== t3.id()], "filter-type-in": [dt, [At(ft)], (t3, [e2]) => e2.value.indexOf(t3.geometryType()) >= 0], "filter-id-in": [dt, [At(gt)], (t3, [e2]) => e2.value.indexOf(t3.id()) >= 0], "filter-in-small": [dt, [ft, At(gt)], (t3, [e2, r3]) => r3.value.indexOf(t3.properties()[e2.value]) >= 0], "filter-in-large": [dt, [ft, At(gt)], (t3, [e2, r3]) => function(t4, e3, r4, n3) {
          for (; r4 <= n3; ) {
            const i3 = r4 + n3 >> 1;
            if (e3[i3] === t4) return true;
            e3[i3] > t4 ? n3 = i3 - 1 : r4 = i3 + 1;
          }
          return false;
        }(t3.properties()[e2.value], r3.value, 0, r3.value.length - 1)], all: { type: dt, overloads: [[[dt, dt], (t3, [e2, r3]) => e2.evaluate(t3) && r3.evaluate(t3)], [vr(dt), (t3, e2) => {
          for (const r3 of e2) if (!r3.evaluate(t3)) return false;
          return true;
        }]] }, any: { type: dt, overloads: [[[dt, dt], (t3, [e2, r3]) => e2.evaluate(t3) || r3.evaluate(t3)], [vr(dt), (t3, e2) => {
          for (const r3 of e2) if (r3.evaluate(t3)) return true;
          return false;
        }]] }, "!": [dt, [dt], (t3, [e2]) => !e2.evaluate(t3)], "is-supported-script": [dt, [ft], (t3, [e2]) => {
          const r3 = t3.globals && t3.globals.isSupportedScript;
          return !r3 || r3(e2.evaluate(t3));
        }], upcase: [ft, [ft], (t3, [e2]) => e2.evaluate(t3).toUpperCase()], downcase: [ft, [ft], (t3, [e2]) => e2.evaluate(t3).toLowerCase()], concat: [ft, vr(gt), (t3, e2) => e2.map((e3) => oe2(e3.evaluate(t3))).join("")], "resolved-locale": [ft, [xt], (t3, [e2]) => e2.evaluate(t3).resolvedLocale()] });
        class Fr {
          constructor(t3, e2) {
            var r3;
            this.expression = t3, this._warningHistory = {}, this._evaluator = new ye2(), this._defaultValue = e2 ? "color" === (r3 = e2).type && Ir(r3.default) ? new Yt(0, 0, 0, 0) : "color" === r3.type ? Yt.parse(r3.default) || null : "padding" === r3.type ? te2.parse(r3.default) || null : "variableAnchorOffsetCollection" === r3.type ? re2.parse(r3.default) || null : void 0 === r3.default ? null : r3.default : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
          }
          evaluateWithoutErrorHandling(t3, e2, r3, n3, i3, a3) {
            return this._evaluator.globals = t3, this._evaluator.feature = e2, this._evaluator.featureState = r3, this._evaluator.canonical = n3, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = a3, this.expression.evaluate(this._evaluator);
          }
          evaluate(t3, e2, r3, n3, i3, a3) {
            this._evaluator.globals = t3, this._evaluator.feature = e2 || null, this._evaluator.featureState = r3 || null, this._evaluator.canonical = n3, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = a3 || null;
            try {
              const t4 = this.expression.evaluate(this._evaluator);
              if (null == t4 || "number" == typeof t4 && t4 != t4) return this._defaultValue;
              if (this._enumValues && !(t4 in this._enumValues)) throw new ue2(`Expected value to be one of ${Object.keys(this._enumValues).map((t5) => JSON.stringify(t5)).join(", ")}, but found ${JSON.stringify(t4)} instead.`);
              return t4;
            } catch (t4) {
              return this._warningHistory[t4.message] || (this._warningHistory[t4.message] = true, "undefined" != typeof console && console.warn(t4.message)), this._defaultValue;
            }
          }
        }
        function Tr(t3) {
          return Array.isArray(t3) && t3.length > 0 && "string" == typeof t3[0] && t3[0] in yr;
        }
        function $r(t3, e2) {
          const r3 = new me2(yr, Le2, [], e2 ? function(t4) {
            const e3 = { color: yt, string: ft, number: pt, enum: ft, boolean: dt, formatted: vt, padding: bt, resolvedImage: wt, variableAnchorOffsetCollection: _t };
            return "array" === t4.type ? At(e3[t4.value] || gt, t4.length) : e3[t4.type];
          }(e2) : void 0), n3 = r3.parse(t3, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
          return n3 ? br(new Fr(n3, e2)) : wr(r3.errors);
        }
        class Lr {
          constructor(t3, e2) {
            this.kind = t3, this._styleExpression = e2, this.isStateDependent = "constant" !== t3 && !Oe2(e2.expression);
          }
          evaluateWithoutErrorHandling(t3, e2, r3, n3, i3, a3) {
            return this._styleExpression.evaluateWithoutErrorHandling(t3, e2, r3, n3, i3, a3);
          }
          evaluate(t3, e2, r3, n3, i3, a3) {
            return this._styleExpression.evaluate(t3, e2, r3, n3, i3, a3);
          }
        }
        class Dr {
          constructor(t3, e2, r3, n3) {
            this.kind = t3, this.zoomStops = r3, this._styleExpression = e2, this.isStateDependent = "camera" !== t3 && !Oe2(e2.expression), this.interpolationType = n3;
          }
          evaluateWithoutErrorHandling(t3, e2, r3, n3, i3, a3) {
            return this._styleExpression.evaluateWithoutErrorHandling(t3, e2, r3, n3, i3, a3);
          }
          evaluate(t3, e2, r3, n3, i3, a3) {
            return this._styleExpression.evaluate(t3, e2, r3, n3, i3, a3);
          }
          interpolationFactor(t3, e2, r3) {
            return this.interpolationType ? Ke.interpolationFactor(this.interpolationType, t3, e2, r3) : 0;
          }
        }
        function Or(t3, e2) {
          const r3 = $r(t3, e2);
          if ("error" === r3.result) return r3;
          const n3 = r3.value.expression, i3 = De2(n3);
          if (!i3 && !_r(e2)) return wr([new ut("", "data expressions not supported")]);
          const a3 = Ue2(n3, ["zoom"]);
          if (!a3 && !Ar(e2)) return wr([new ut("", "zoom expressions not supported")]);
          const s3 = Rr(n3);
          return s3 || a3 ? s3 instanceof ut ? wr([s3]) : s3 instanceof Ke && !Sr(e2) ? wr([new ut("", '"interpolate" expressions cannot be used with this property')]) : br(s3 ? new Dr(i3 ? "camera" : "composite", r3.value, s3.labels, s3 instanceof Ke ? s3.interpolation : void 0) : new Lr(i3 ? "constant" : "source", r3.value)) : wr([new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Ur {
          constructor(t3, e2) {
            this._parameters = t3, this._specification = e2, lt(this, Mr(this._parameters, this._specification));
          }
          static deserialize(t3) {
            return new Ur(t3._parameters, t3._specification);
          }
          static serialize(t3) {
            return { _parameters: t3._parameters, _specification: t3._specification };
          }
        }
        function Rr(t3) {
          let e2 = null;
          if (t3 instanceof Xe2) e2 = Rr(t3.result);
          else if (t3 instanceof Je) {
            for (const r3 of t3.args) if (e2 = Rr(r3), e2) break;
          } else (t3 instanceof qe2 || t3 instanceof Ke) && t3.input instanceof $e2 && "zoom" === t3.input.name && (e2 = t3);
          return e2 instanceof ut || t3.eachChild((t4) => {
            const r3 = Rr(t4);
            r3 instanceof ut ? e2 = r3 : !e2 && r3 ? e2 = new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r3 && e2 !== r3 && (e2 = new ut("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e2;
        }
        function qr(t3) {
          if (true === t3 || false === t3) return true;
          if (!Array.isArray(t3) || 0 === t3.length) return false;
          switch (t3[0]) {
            case "has":
              return t3.length >= 2 && "$id" !== t3[1] && "$type" !== t3[1];
            case "in":
              return t3.length >= 3 && ("string" != typeof t3[1] || Array.isArray(t3[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t3.length || Array.isArray(t3[1]) || Array.isArray(t3[2]);
            case "any":
            case "all":
              for (const e2 of t3.slice(1)) if (!qr(e2) && "boolean" != typeof e2) return false;
              return true;
            default:
              return true;
          }
        }
        const jr = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function Nr(t3) {
          if (null == t3) return { filter: () => true, needGeometry: false };
          qr(t3) || (t3 = Gr(t3));
          const e2 = $r(t3, jr);
          if ("error" === e2.result) throw new Error(e2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
          return { filter: (t4, r3, n3) => e2.value.evaluate(t4, r3, {}, n3), needGeometry: Kr(t3) };
        }
        function Zr(t3, e2) {
          return t3 < e2 ? -1 : t3 > e2 ? 1 : 0;
        }
        function Kr(t3) {
          if (!Array.isArray(t3)) return false;
          if ("within" === t3[0]) return true;
          for (let e2 = 1; e2 < t3.length; e2++) if (Kr(t3[e2])) return true;
          return false;
        }
        function Gr(t3) {
          if (!t3) return true;
          const e2 = t3[0];
          return t3.length <= 1 ? "any" !== e2 : "==" === e2 ? Jr(t3[1], t3[2], "==") : "!=" === e2 ? Hr(Jr(t3[1], t3[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? Jr(t3[1], t3[2], e2) : "any" === e2 ? (r3 = t3.slice(1), ["any"].concat(r3.map(Gr))) : "all" === e2 ? ["all"].concat(t3.slice(1).map(Gr)) : "none" === e2 ? ["all"].concat(t3.slice(1).map(Gr).map(Hr)) : "in" === e2 ? Xr(t3[1], t3.slice(2)) : "!in" === e2 ? Hr(Xr(t3[1], t3.slice(2))) : "has" === e2 ? Yr(t3[1]) : "!has" === e2 ? Hr(Yr(t3[1])) : "within" !== e2 || t3;
          var r3;
        }
        function Jr(t3, e2, r3) {
          switch (t3) {
            case "$type":
              return [`filter-type-${r3}`, e2];
            case "$id":
              return [`filter-id-${r3}`, e2];
            default:
              return [`filter-${r3}`, t3, e2];
          }
        }
        function Xr(t3, e2) {
          if (0 === e2.length) return false;
          switch (t3) {
            case "$type":
              return ["filter-type-in", ["literal", e2]];
            case "$id":
              return ["filter-id-in", ["literal", e2]];
            default:
              return e2.length > 200 && !e2.some((t4) => typeof t4 != typeof e2[0]) ? ["filter-in-large", t3, ["literal", e2.sort(Zr)]] : ["filter-in-small", t3, ["literal", e2]];
          }
        }
        function Yr(t3) {
          switch (t3) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t3];
          }
        }
        function Hr(t3) {
          return ["!", t3];
        }
        function Wr(t3) {
          const e2 = typeof t3;
          if ("number" === e2 || "boolean" === e2 || "string" === e2 || null == t3) return JSON.stringify(t3);
          if (Array.isArray(t3)) {
            let e3 = "[";
            for (const r4 of t3) e3 += `${Wr(r4)},`;
            return `${e3}]`;
          }
          const r3 = Object.keys(t3).sort();
          let n3 = "{";
          for (let e3 = 0; e3 < r3.length; e3++) n3 += `${JSON.stringify(r3[e3])}:${Wr(t3[r3[e3]])},`;
          return `${n3}}`;
        }
        function Qr(t3) {
          let e2 = "";
          for (const r3 of Y2) e2 += `/${Wr(t3[r3])}`;
          return e2;
        }
        function tn(t3) {
          const e2 = t3.value;
          return e2 ? [new ot(t3.key, e2, "constants have been deprecated as of v8")] : [];
        }
        function en(t3) {
          return t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean ? t3.valueOf() : t3;
        }
        function rn(t3) {
          if (Array.isArray(t3)) return t3.map(rn);
          if (t3 instanceof Object && !(t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean)) {
            const e2 = {};
            for (const r3 in t3) e2[r3] = rn(t3[r3]);
            return e2;
          }
          return en(t3);
        }
        function nn(t3) {
          const e2 = t3.key, r3 = t3.value, n3 = t3.valueSpec || {}, i3 = t3.objectElementValidators || {}, a3 = t3.style, s3 = t3.styleSpec, o3 = t3.validateSpec;
          let l3 = [];
          const u3 = kr(r3);
          if ("object" !== u3) return [new ot(e2, r3, `object expected, ${u3} found`)];
          for (const t4 in r3) {
            const u4 = t4.split(".")[0], c3 = n3[u4] || n3["*"];
            let h3;
            if (i3[u4]) h3 = i3[u4];
            else if (n3[u4]) h3 = o3;
            else if (i3["*"]) h3 = i3["*"];
            else {
              if (!n3["*"]) {
                l3.push(new ot(e2, r3[t4], `unknown property "${t4}"`));
                continue;
              }
              h3 = o3;
            }
            l3 = l3.concat(h3({ key: (e2 ? `${e2}.` : e2) + t4, value: r3[t4], valueSpec: c3, style: a3, styleSpec: s3, object: r3, objectKey: t4, validateSpec: o3 }, r3));
          }
          for (const t4 in n3) i3[t4] || n3[t4].required && void 0 === n3[t4].default && void 0 === r3[t4] && l3.push(new ot(e2, r3, `missing required property "${t4}"`));
          return l3;
        }
        function an(t3) {
          const e2 = t3.value, r3 = t3.valueSpec, n3 = t3.style, i3 = t3.styleSpec, a3 = t3.key, s3 = t3.arrayElementValidator || t3.validateSpec;
          if ("array" !== kr(e2)) return [new ot(a3, e2, `array expected, ${kr(e2)} found`)];
          if (r3.length && e2.length !== r3.length) return [new ot(a3, e2, `array length ${r3.length} expected, length ${e2.length} found`)];
          if (r3["min-length"] && e2.length < r3["min-length"]) return [new ot(a3, e2, `array length at least ${r3["min-length"]} expected, length ${e2.length} found`)];
          let o3 = { type: r3.value, values: r3.values };
          i3.$version < 7 && (o3.function = r3.function), "object" === kr(r3.value) && (o3 = r3.value);
          let l3 = [];
          for (let r4 = 0; r4 < e2.length; r4++) l3 = l3.concat(s3({ array: e2, arrayIndex: r4, value: e2[r4], valueSpec: o3, validateSpec: t3.validateSpec, style: n3, styleSpec: i3, key: `${a3}[${r4}]` }));
          return l3;
        }
        function sn(t3) {
          const e2 = t3.key, r3 = t3.value, n3 = t3.valueSpec;
          let i3 = kr(r3);
          return "number" === i3 && r3 != r3 && (i3 = "NaN"), "number" !== i3 ? [new ot(e2, r3, `number expected, ${i3} found`)] : "minimum" in n3 && r3 < n3.minimum ? [new ot(e2, r3, `${r3} is less than the minimum value ${n3.minimum}`)] : "maximum" in n3 && r3 > n3.maximum ? [new ot(e2, r3, `${r3} is greater than the maximum value ${n3.maximum}`)] : [];
        }
        function on(t3) {
          const e2 = t3.valueSpec, r3 = en(t3.value.type);
          let n3, i3, a3, s3 = {};
          const o3 = "categorical" !== r3 && void 0 === t3.value.property, l3 = !o3, u3 = "array" === kr(t3.value.stops) && "array" === kr(t3.value.stops[0]) && "object" === kr(t3.value.stops[0][0]), c3 = nn({ key: t3.key, value: t3.value, valueSpec: t3.styleSpec.function, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { stops: function(t4) {
            if ("identity" === r3) return [new ot(t4.key, t4.value, 'identity function may not have a "stops" property')];
            let e3 = [];
            const n4 = t4.value;
            return e3 = e3.concat(an({ key: t4.key, value: n4, valueSpec: t4.valueSpec, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec, arrayElementValidator: h3 })), "array" === kr(n4) && 0 === n4.length && e3.push(new ot(t4.key, n4, "array must have at least one stop")), e3;
          }, default: function(t4) {
            return t4.validateSpec({ key: t4.key, value: t4.value, valueSpec: e2, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec });
          } } });
          return "identity" === r3 && o3 && c3.push(new ot(t3.key, t3.value, 'missing required property "property"')), "identity" === r3 || t3.value.stops || c3.push(new ot(t3.key, t3.value, 'missing required property "stops"')), "exponential" === r3 && t3.valueSpec.expression && !Sr(t3.valueSpec) && c3.push(new ot(t3.key, t3.value, "exponential functions not supported")), t3.styleSpec.$version >= 8 && (l3 && !_r(t3.valueSpec) ? c3.push(new ot(t3.key, t3.value, "property functions not supported")) : o3 && !Ar(t3.valueSpec) && c3.push(new ot(t3.key, t3.value, "zoom functions not supported"))), "categorical" !== r3 && !u3 || void 0 !== t3.value.property || c3.push(new ot(t3.key, t3.value, '"property" property is required')), c3;
          function h3(t4) {
            let r4 = [];
            const n4 = t4.value, o4 = t4.key;
            if ("array" !== kr(n4)) return [new ot(o4, n4, `array expected, ${kr(n4)} found`)];
            if (2 !== n4.length) return [new ot(o4, n4, `array length 2 expected, length ${n4.length} found`)];
            if (u3) {
              if ("object" !== kr(n4[0])) return [new ot(o4, n4, `object expected, ${kr(n4[0])} found`)];
              if (void 0 === n4[0].zoom) return [new ot(o4, n4, "object stop key must have zoom")];
              if (void 0 === n4[0].value) return [new ot(o4, n4, "object stop key must have value")];
              if (a3 && a3 > en(n4[0].zoom)) return [new ot(o4, n4[0].zoom, "stop zoom values must appear in ascending order")];
              en(n4[0].zoom) !== a3 && (a3 = en(n4[0].zoom), i3 = void 0, s3 = {}), r4 = r4.concat(nn({ key: `${o4}[0]`, value: n4[0], valueSpec: { zoom: {} }, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { zoom: sn, value: p3 } }));
            } else r4 = r4.concat(p3({ key: `${o4}[0]`, value: n4[0], validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec }, n4));
            return Tr(rn(n4[1])) ? r4.concat([new ot(`${o4}[1]`, n4[1], "expressions are not allowed in function stops.")]) : r4.concat(t4.validateSpec({ key: `${o4}[1]`, value: n4[1], valueSpec: e2, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec }));
          }
          function p3(t4, a4) {
            const o4 = kr(t4.value), l4 = en(t4.value), u4 = null !== t4.value ? t4.value : a4;
            if (n3) {
              if (o4 !== n3) return [new ot(t4.key, u4, `${o4} stop domain type must match previous stop domain type ${n3}`)];
            } else n3 = o4;
            if ("number" !== o4 && "string" !== o4 && "boolean" !== o4) return [new ot(t4.key, u4, "stop domain value must be a number, string, or boolean")];
            if ("number" !== o4 && "categorical" !== r3) {
              let n4 = `number expected, ${o4} found`;
              return _r(e2) && void 0 === r3 && (n4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ot(t4.key, u4, n4)];
            }
            return "categorical" !== r3 || "number" !== o4 || isFinite(l4) && Math.floor(l4) === l4 ? "categorical" !== r3 && "number" === o4 && void 0 !== i3 && l4 < i3 ? [new ot(t4.key, u4, "stop domain values must appear in ascending order")] : (i3 = l4, "categorical" === r3 && l4 in s3 ? [new ot(t4.key, u4, "stop domain values must be unique")] : (s3[l4] = true, [])) : [new ot(t4.key, u4, `integer expected, found ${l4}`)];
          }
        }
        function ln(t3) {
          const e2 = ("property" === t3.expressionContext ? Or : $r)(rn(t3.value), t3.valueSpec);
          if ("error" === e2.result) return e2.value.map((e3) => new ot(`${t3.key}${e3.key}`, t3.value, e3.message));
          const r3 = e2.value.expression || e2.value._styleExpression.expression;
          if ("property" === t3.expressionContext && "text-font" === t3.propertyKey && !r3.outputDefined()) return [new ot(t3.key, t3.value, `Invalid data expression for "${t3.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t3.expressionContext && "layout" === t3.propertyType && !Oe2(r3)) return [new ot(t3.key, t3.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t3.expressionContext && !Oe2(r3)) return [new ot(t3.key, t3.value, '"feature-state" data expressions are not supported with filters.')];
          if (t3.expressionContext && 0 === t3.expressionContext.indexOf("cluster")) {
            if (!Ue2(r3, ["zoom", "feature-state"])) return [new ot(t3.key, t3.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t3.expressionContext && !De2(r3)) return [new ot(t3.key, t3.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function un(t3) {
          const e2 = t3.key, r3 = t3.value, n3 = t3.valueSpec, i3 = [];
          return Array.isArray(n3.values) ? -1 === n3.values.indexOf(en(r3)) && i3.push(new ot(e2, r3, `expected one of [${n3.values.join(", ")}], ${JSON.stringify(r3)} found`)) : -1 === Object.keys(n3.values).indexOf(en(r3)) && i3.push(new ot(e2, r3, `expected one of [${Object.keys(n3.values).join(", ")}], ${JSON.stringify(r3)} found`)), i3;
        }
        function cn(t3) {
          return qr(rn(t3.value)) ? ln(lt({}, t3, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : hn(t3);
        }
        function hn(t3) {
          const e2 = t3.value, r3 = t3.key;
          if ("array" !== kr(e2)) return [new ot(r3, e2, `array expected, ${kr(e2)} found`)];
          const n3 = t3.styleSpec;
          let i3, a3 = [];
          if (e2.length < 1) return [new ot(r3, e2, "filter array must have at least 1 element")];
          switch (a3 = a3.concat(un({ key: `${r3}[0]`, value: e2[0], valueSpec: n3.filter_operator, style: t3.style, styleSpec: t3.styleSpec })), en(e2[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e2.length >= 2 && "$type" === en(e2[1]) && a3.push(new ot(r3, e2, `"$type" cannot be use with operator "${e2[0]}"`));
            case "==":
            case "!=":
              3 !== e2.length && a3.push(new ot(r3, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e2.length >= 2 && (i3 = kr(e2[1]), "string" !== i3 && a3.push(new ot(`${r3}[1]`, e2[1], `string expected, ${i3} found`)));
              for (let s3 = 2; s3 < e2.length; s3++) i3 = kr(e2[s3]), "$type" === en(e2[1]) ? a3 = a3.concat(un({ key: `${r3}[${s3}]`, value: e2[s3], valueSpec: n3.geometry_type, style: t3.style, styleSpec: t3.styleSpec })) : "string" !== i3 && "number" !== i3 && "boolean" !== i3 && a3.push(new ot(`${r3}[${s3}]`, e2[s3], `string, number, or boolean expected, ${i3} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let n4 = 1; n4 < e2.length; n4++) a3 = a3.concat(hn({ key: `${r3}[${n4}]`, value: e2[n4], style: t3.style, styleSpec: t3.styleSpec }));
              break;
            case "has":
            case "!has":
              i3 = kr(e2[1]), 2 !== e2.length ? a3.push(new ot(r3, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "string" !== i3 && a3.push(new ot(`${r3}[1]`, e2[1], `string expected, ${i3} found`));
              break;
            case "within":
              i3 = kr(e2[1]), 2 !== e2.length ? a3.push(new ot(r3, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "object" !== i3 && a3.push(new ot(`${r3}[1]`, e2[1], `object expected, ${i3} found`));
          }
          return a3;
        }
        function pn(t3, e2) {
          const r3 = t3.key, n3 = t3.validateSpec, i3 = t3.style, a3 = t3.styleSpec, s3 = t3.value, o3 = t3.objectKey, l3 = a3[`${e2}_${t3.layerType}`];
          if (!l3) return [];
          const u3 = o3.match(/^(.*)-transition$/);
          if ("paint" === e2 && u3 && l3[u3[1]] && l3[u3[1]].transition) return n3({ key: r3, value: s3, valueSpec: a3.transition, style: i3, styleSpec: a3 });
          const c3 = t3.valueSpec || l3[o3];
          if (!c3) return [new ot(r3, s3, `unknown property "${o3}"`)];
          let h3;
          if ("string" === kr(s3) && _r(c3) && !c3.tokens && (h3 = /^{([^}]+)}$/.exec(s3))) return [new ot(r3, s3, `"${o3}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h3[1])} }\`.`)];
          const p3 = [];
          return "symbol" === t3.layerType && ("text-field" === o3 && i3 && !i3.glyphs && p3.push(new ot(r3, s3, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o3 && Ir(rn(s3)) && "identity" === en(s3.type) && p3.push(new ot(r3, s3, '"text-font" does not support identity functions'))), p3.concat(n3({ key: t3.key, value: s3, valueSpec: c3, style: i3, styleSpec: a3, expressionContext: "property", propertyType: e2, propertyKey: o3 }));
        }
        function fn(t3) {
          return pn(t3, "paint");
        }
        function dn(t3) {
          return pn(t3, "layout");
        }
        function yn(t3) {
          let e2 = [];
          const r3 = t3.value, n3 = t3.key, i3 = t3.style, a3 = t3.styleSpec;
          r3.type || r3.ref || e2.push(new ot(n3, r3, 'either "type" or "ref" is required'));
          let s3 = en(r3.type);
          const o3 = en(r3.ref);
          if (r3.id) {
            const a4 = en(r3.id);
            for (let s4 = 0; s4 < t3.arrayIndex; s4++) {
              const t4 = i3.layers[s4];
              en(t4.id) === a4 && e2.push(new ot(n3, r3.id, `duplicate layer id "${r3.id}", previously used at line ${t4.id.__line__}`));
            }
          }
          if ("ref" in r3) {
            let t4;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t5) => {
              t5 in r3 && e2.push(new ot(n3, r3[t5], `"${t5}" is prohibited for ref layers`));
            }), i3.layers.forEach((e3) => {
              en(e3.id) === o3 && (t4 = e3);
            }), t4 ? t4.ref ? e2.push(new ot(n3, r3.ref, "ref cannot reference another ref layer")) : s3 = en(t4.type) : e2.push(new ot(n3, r3.ref, `ref layer "${o3}" not found`));
          } else if ("background" !== s3) if (r3.source) {
            const t4 = i3.sources && i3.sources[r3.source], a4 = t4 && en(t4.type);
            t4 ? "vector" === a4 && "raster" === s3 ? e2.push(new ot(n3, r3.source, `layer "${r3.id}" requires a raster source`)) : "raster-dem" !== a4 && "hillshade" === s3 ? e2.push(new ot(n3, r3.source, `layer "${r3.id}" requires a raster-dem source`)) : "raster" === a4 && "raster" !== s3 ? e2.push(new ot(n3, r3.source, `layer "${r3.id}" requires a vector source`)) : "vector" !== a4 || r3["source-layer"] ? "raster-dem" === a4 && "hillshade" !== s3 ? e2.push(new ot(n3, r3.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s3 || !r3.paint || !r3.paint["line-gradient"] || "geojson" === a4 && t4.lineMetrics || e2.push(new ot(n3, r3, `layer "${r3.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new ot(n3, r3, `layer "${r3.id}" must specify a "source-layer"`)) : e2.push(new ot(n3, r3.source, `source "${r3.source}" not found`));
          } else e2.push(new ot(n3, r3, 'missing required property "source"'));
          return e2 = e2.concat(nn({ key: n3, value: r3, valueSpec: a3.layer, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": () => [], type: () => t3.validateSpec({ key: `${n3}.type`, value: r3.type, valueSpec: a3.layer.type, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, object: r3, objectKey: "type" }), filter: cn, layout: (t4) => nn({ layer: r3, key: t4.key, value: t4.value, style: t4.style, styleSpec: t4.styleSpec, validateSpec: t4.validateSpec, objectElementValidators: { "*": (t5) => dn(lt({ layerType: s3 }, t5)) } }), paint: (t4) => nn({ layer: r3, key: t4.key, value: t4.value, style: t4.style, styleSpec: t4.styleSpec, validateSpec: t4.validateSpec, objectElementValidators: { "*": (t5) => fn(lt({ layerType: s3 }, t5)) } }) } })), e2;
        }
        function mn(t3) {
          const e2 = t3.value, r3 = t3.key, n3 = kr(e2);
          return "string" !== n3 ? [new ot(r3, e2, `string expected, ${n3} found`)] : [];
        }
        const gn = { promoteId: function({ key: t3, value: e2 }) {
          if ("string" === kr(e2)) return mn({ key: t3, value: e2 });
          {
            const r3 = [];
            for (const n3 in e2) r3.push(...mn({ key: `${t3}.${n3}`, value: e2[n3] }));
            return r3;
          }
        } };
        function xn(t3) {
          const e2 = t3.value, r3 = t3.key, n3 = t3.styleSpec, i3 = t3.style, a3 = t3.validateSpec;
          if (!e2.type) return [new ot(r3, e2, '"type" is required')];
          const s3 = en(e2.type);
          let o3;
          switch (s3) {
            case "vector":
            case "raster":
              return o3 = nn({ key: r3, value: e2, valueSpec: n3[`source_${s3.replace("-", "_")}`], style: t3.style, styleSpec: n3, objectElementValidators: gn, validateSpec: a3 }), o3;
            case "raster-dem":
              return o3 = function(t4) {
                var e3;
                const r4 = null !== (e3 = t4.sourceName) && void 0 !== e3 ? e3 : "", n4 = t4.value, i4 = t4.styleSpec, a4 = i4.source_raster_dem, s4 = t4.style;
                let o4 = [];
                const l3 = kr(n4);
                if (void 0 === n4) return o4;
                if ("object" !== l3) return o4.push(new ot("source_raster_dem", n4, `object expected, ${l3} found`)), o4;
                const u3 = "custom" === en(n4.encoding), c3 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h3 = t4.value.encoding ? `"${t4.value.encoding}"` : "Default";
                for (const e4 in n4) !u3 && c3.includes(e4) ? o4.push(new ot(e4, n4[e4], `In "${r4}": "${e4}" is only valid when "encoding" is set to "custom". ${h3} encoding found`)) : a4[e4] ? o4 = o4.concat(t4.validateSpec({ key: e4, value: n4[e4], valueSpec: a4[e4], validateSpec: t4.validateSpec, style: s4, styleSpec: i4 })) : o4.push(new ot(e4, n4[e4], `unknown property "${e4}"`));
                return o4;
              }({ sourceName: r3, value: e2, style: t3.style, styleSpec: n3, validateSpec: a3 }), o3;
            case "geojson":
              if (o3 = nn({ key: r3, value: e2, valueSpec: n3.source_geojson, style: i3, styleSpec: n3, validateSpec: a3, objectElementValidators: gn }), e2.cluster) for (const t4 in e2.clusterProperties) {
                const [n4, i4] = e2.clusterProperties[t4], s4 = "string" == typeof n4 ? [n4, ["accumulated"], ["get", t4]] : n4;
                o3.push(...ln({ key: `${r3}.${t4}.map`, value: i4, expressionContext: "cluster-map" })), o3.push(...ln({ key: `${r3}.${t4}.reduce`, value: s4, expressionContext: "cluster-reduce" }));
              }
              return o3;
            case "video":
              return nn({ key: r3, value: e2, valueSpec: n3.source_video, style: i3, validateSpec: a3, styleSpec: n3 });
            case "image":
              return nn({ key: r3, value: e2, valueSpec: n3.source_image, style: i3, validateSpec: a3, styleSpec: n3 });
            case "canvas":
              return [new ot(r3, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return un({ key: `${r3}.type`, value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function vn(t3) {
          const e2 = t3.value, r3 = t3.styleSpec, n3 = r3.light, i3 = t3.style;
          let a3 = [];
          const s3 = kr(e2);
          if (void 0 === e2) return a3;
          if ("object" !== s3) return a3 = a3.concat([new ot("light", e2, `object expected, ${s3} found`)]), a3;
          for (const s4 in e2) {
            const o3 = s4.match(/^(.*)-transition$/);
            a3 = a3.concat(o3 && n3[o3[1]] && n3[o3[1]].transition ? t3.validateSpec({ key: s4, value: e2[s4], valueSpec: r3.transition, validateSpec: t3.validateSpec, style: i3, styleSpec: r3 }) : n3[s4] ? t3.validateSpec({ key: s4, value: e2[s4], valueSpec: n3[s4], validateSpec: t3.validateSpec, style: i3, styleSpec: r3 }) : [new ot(s4, e2[s4], `unknown property "${s4}"`)]);
          }
          return a3;
        }
        function bn(t3) {
          const e2 = t3.value, r3 = t3.styleSpec, n3 = r3.terrain, i3 = t3.style;
          let a3 = [];
          const s3 = kr(e2);
          if (void 0 === e2) return a3;
          if ("object" !== s3) return a3 = a3.concat([new ot("terrain", e2, `object expected, ${s3} found`)]), a3;
          for (const s4 in e2) a3 = a3.concat(n3[s4] ? t3.validateSpec({ key: s4, value: e2[s4], valueSpec: n3[s4], validateSpec: t3.validateSpec, style: i3, styleSpec: r3 }) : [new ot(s4, e2[s4], `unknown property "${s4}"`)]);
          return a3;
        }
        function wn(t3) {
          let e2 = [];
          const r3 = t3.value, n3 = t3.key;
          if (Array.isArray(r3)) {
            const i3 = [], a3 = [];
            for (const s3 in r3) r3[s3].id && i3.includes(r3[s3].id) && e2.push(new ot(n3, r3, `all the sprites' ids must be unique, but ${r3[s3].id} is duplicated`)), i3.push(r3[s3].id), r3[s3].url && a3.includes(r3[s3].url) && e2.push(new ot(n3, r3, `all the sprites' URLs must be unique, but ${r3[s3].url} is duplicated`)), a3.push(r3[s3].url), e2 = e2.concat(nn({ key: `${n3}[${s3}]`, value: r3[s3], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t3.validateSpec }));
            return e2;
          }
          return mn({ key: n3, value: r3 });
        }
        const _n = { "*": () => [], array: an, boolean: function(t3) {
          const e2 = t3.value, r3 = t3.key, n3 = kr(e2);
          return "boolean" !== n3 ? [new ot(r3, e2, `boolean expected, ${n3} found`)] : [];
        }, number: sn, color: function(t3) {
          const e2 = t3.key, r3 = t3.value, n3 = kr(r3);
          return "string" !== n3 ? [new ot(e2, r3, `color expected, ${n3} found`)] : Yt.parse(String(r3)) ? [] : [new ot(e2, r3, `color expected, "${r3}" found`)];
        }, constants: tn, enum: un, filter: cn, function: on, layer: yn, object: nn, source: xn, light: vn, terrain: bn, string: mn, formatted: function(t3) {
          return 0 === mn(t3).length ? [] : ln(t3);
        }, resolvedImage: function(t3) {
          return 0 === mn(t3).length ? [] : ln(t3);
        }, padding: function(t3) {
          const e2 = t3.key, r3 = t3.value;
          if ("array" === kr(r3)) {
            if (r3.length < 1 || r3.length > 4) return [new ot(e2, r3, `padding requires 1 to 4 values; ${r3.length} values found`)];
            const n3 = { type: "number" };
            let i3 = [];
            for (let a3 = 0; a3 < r3.length; a3++) i3 = i3.concat(t3.validateSpec({ key: `${e2}[${a3}]`, value: r3[a3], validateSpec: t3.validateSpec, valueSpec: n3 }));
            return i3;
          }
          return sn({ key: e2, value: r3, valueSpec: {} });
        }, variableAnchorOffsetCollection: function(t3) {
          const e2 = t3.key, r3 = t3.value, n3 = kr(r3), i3 = t3.styleSpec;
          if ("array" !== n3 || r3.length < 1 || r3.length % 2 != 0) return [new ot(e2, r3, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let a3 = [];
          for (let n4 = 0; n4 < r3.length; n4 += 2) a3 = a3.concat(un({ key: `${e2}[${n4}]`, value: r3[n4], valueSpec: i3.layout_symbol["text-anchor"] })), a3 = a3.concat(an({ key: `${e2}[${n4 + 1}]`, value: r3[n4 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t3.validateSpec, style: t3.style, styleSpec: i3 }));
          return a3;
        }, sprite: wn };
        function An(t3) {
          const e2 = t3.value, r3 = t3.valueSpec, n3 = t3.styleSpec;
          return t3.validateSpec = An, r3.expression && Ir(en(e2)) ? on(t3) : r3.expression && Tr(rn(e2)) ? ln(t3) : r3.type && _n[r3.type] ? _n[r3.type](t3) : nn(lt({}, t3, { valueSpec: r3.type ? n3[r3.type] : r3 }));
        }
        function Sn(t3) {
          const e2 = t3.value, r3 = t3.key, n3 = mn(t3);
          return n3.length || (-1 === e2.indexOf("{fontstack}") && n3.push(new ot(r3, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n3.push(new ot(r3, e2, '"glyphs" url must include a "{range}" token'))), n3;
        }
        function kn(t3, e2 = X2) {
          let r3 = [];
          return r3 = r3.concat(An({ key: "", value: t3, valueSpec: e2.$root, styleSpec: e2, style: t3, validateSpec: An, objectElementValidators: { glyphs: Sn, "*": () => [] } })), t3.constants && (r3 = r3.concat(tn({ key: "constants", value: t3.constants }))), zn(r3);
        }
        function In(t3) {
          return function(e2) {
            return t3({ ...e2, validateSpec: An });
          };
        }
        function zn(t3) {
          return [].concat(t3).sort((t4, e2) => t4.line - e2.line);
        }
        function Mn(t3) {
          return function(...e2) {
            return zn(t3.apply(this, e2));
          };
        }
        kn.source = Mn(In(xn)), kn.sprite = Mn(In(wn)), kn.glyphs = Mn(In(Sn)), kn.light = Mn(In(vn)), kn.terrain = Mn(In(bn)), kn.layer = Mn(In(yn)), kn.filter = Mn(In(cn)), kn.paintProperty = Mn(In(fn)), kn.layoutProperty = Mn(In(dn));
        const Cn = kn, Bn = Cn.light, Pn = Cn.paintProperty, Vn = Cn.layoutProperty;
        function En(t3, e2) {
          let r3 = false;
          if (e2 && e2.length) for (const n3 of e2) t3.fire(new G2(new Error(n3.message))), r3 = true;
          return r3;
        }
        class Fn {
          constructor(t3, e2, r3) {
            const n3 = this.cells = [];
            if (t3 instanceof ArrayBuffer) {
              this.arrayBuffer = t3;
              const i4 = new Int32Array(this.arrayBuffer);
              t3 = i4[0], this.d = (e2 = i4[1]) + 2 * (r3 = i4[2]);
              for (let t4 = 0; t4 < this.d * this.d; t4++) {
                const e3 = i4[3 + t4], r4 = i4[3 + t4 + 1];
                n3.push(e3 === r4 ? null : i4.subarray(e3, r4));
              }
              const a3 = i4[3 + n3.length + 1];
              this.keys = i4.subarray(i4[3 + n3.length], a3), this.bboxes = i4.subarray(a3), this.insert = this._insertReadonly;
            } else {
              this.d = e2 + 2 * r3;
              for (let t4 = 0; t4 < this.d * this.d; t4++) n3.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = e2, this.extent = t3, this.padding = r3, this.scale = e2 / t3, this.uid = 0;
            const i3 = r3 / e2 * t3;
            this.min = -i3, this.max = t3 + i3;
          }
          insert(t3, e2, r3, n3, i3) {
            this._forEachCell(e2, r3, n3, i3, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t3), this.bboxes.push(e2), this.bboxes.push(r3), this.bboxes.push(n3), this.bboxes.push(i3);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t3, e2, r3, n3, i3, a3) {
            this.cells[i3].push(a3);
          }
          query(t3, e2, r3, n3, i3) {
            const a3 = this.min, s3 = this.max;
            if (t3 <= a3 && e2 <= a3 && s3 <= r3 && s3 <= n3 && !i3) return Array.prototype.slice.call(this.keys);
            {
              const a4 = [];
              return this._forEachCell(t3, e2, r3, n3, this._queryCell, a4, {}, i3), a4;
            }
          }
          _queryCell(t3, e2, r3, n3, i3, a3, s3, o3) {
            const l3 = this.cells[i3];
            if (null !== l3) {
              const i4 = this.keys, u3 = this.bboxes;
              for (let c3 = 0; c3 < l3.length; c3++) {
                const h3 = l3[c3];
                if (void 0 === s3[h3]) {
                  const l4 = 4 * h3;
                  (o3 ? o3(u3[l4 + 0], u3[l4 + 1], u3[l4 + 2], u3[l4 + 3]) : t3 <= u3[l4 + 2] && e2 <= u3[l4 + 3] && r3 >= u3[l4 + 0] && n3 >= u3[l4 + 1]) ? (s3[h3] = true, a3.push(i4[h3])) : s3[h3] = false;
                }
              }
            }
          }
          _forEachCell(t3, e2, r3, n3, i3, a3, s3, o3) {
            const l3 = this._convertToCellCoord(t3), u3 = this._convertToCellCoord(e2), c3 = this._convertToCellCoord(r3), h3 = this._convertToCellCoord(n3);
            for (let p3 = l3; p3 <= c3; p3++) for (let l4 = u3; l4 <= h3; l4++) {
              const u4 = this.d * l4 + p3;
              if ((!o3 || o3(this._convertFromCellCoord(p3), this._convertFromCellCoord(l4), this._convertFromCellCoord(p3 + 1), this._convertFromCellCoord(l4 + 1))) && i3.call(this, t3, e2, r3, n3, u4, a3, s3, o3)) return;
            }
          }
          _convertFromCellCoord(t3) {
            return (t3 - this.padding) / this.scale;
          }
          _convertToCellCoord(t3) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t3 * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t3 = this.cells, e2 = 3 + this.cells.length + 1 + 1;
            let r3 = 0;
            for (let t4 = 0; t4 < this.cells.length; t4++) r3 += this.cells[t4].length;
            const n3 = new Int32Array(e2 + r3 + this.keys.length + this.bboxes.length);
            n3[0] = this.extent, n3[1] = this.n, n3[2] = this.padding;
            let i3 = e2;
            for (let e3 = 0; e3 < t3.length; e3++) {
              const r4 = t3[e3];
              n3[3 + e3] = i3, n3.set(r4, i3), i3 += r4.length;
            }
            return n3[3 + t3.length] = i3, n3.set(this.keys, i3), i3 += this.keys.length, n3[3 + t3.length + 1] = i3, n3.set(this.bboxes, i3), i3 += this.bboxes.length, n3.buffer;
          }
          static serialize(t3, e2) {
            const r3 = t3.toArrayBuffer();
            return e2 && e2.push(r3), { buffer: r3 };
          }
          static deserialize(t3) {
            return new Fn(t3.buffer);
          }
        }
        const Tn = {};
        function $n(t3, e2, r3 = {}) {
          if (Tn[t3]) throw new Error(`${t3} is already registered.`);
          Object.defineProperty(e2, "_classRegistryKey", { value: t3, writeable: false }), Tn[t3] = { klass: e2, omit: r3.omit || [], shallow: r3.shallow || [] };
        }
        $n("Object", Object), $n("TransferableGridIndex", Fn), $n("Color", Yt), $n("Error", Error), $n("AJAXError", L2), $n("ResolvedImage", ne2), $n("StylePropertyFunction", Ur), $n("StyleExpression", Fr, { omit: ["_evaluator"] }), $n("ZoomDependentExpression", Dr), $n("ZoomConstantExpression", Lr), $n("CompoundExpression", $e2, { omit: ["_evaluate"] });
        for (const t3 in yr) yr[t3]._classRegistryKey || $n(`Expression_${t3}`, yr[t3]);
        function Ln(t3) {
          return t3 && "undefined" != typeof ArrayBuffer && (t3 instanceof ArrayBuffer || t3.constructor && "ArrayBuffer" === t3.constructor.name);
        }
        function Dn(t3, e2) {
          if (null == t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp || t3 instanceof Blob) return t3;
          if (Ln(t3)) return e2 && e2.push(t3), t3;
          if (M2(t3)) return e2 && e2.push(t3), t3;
          if (ArrayBuffer.isView(t3)) {
            const r3 = t3;
            return e2 && e2.push(r3.buffer), r3;
          }
          if (t3 instanceof ImageData) return e2 && e2.push(t3.data.buffer), t3;
          if (Array.isArray(t3)) {
            const r3 = [];
            for (const n3 of t3) r3.push(Dn(n3, e2));
            return r3;
          }
          if ("object" == typeof t3) {
            const r3 = t3.constructor, n3 = r3._classRegistryKey;
            if (!n3) throw new Error("can't serialize object of unregistered class");
            if (!Tn[n3]) throw new Error(`${n3} is not registered.`);
            const i3 = r3.serialize ? r3.serialize(t3, e2) : {};
            if (r3.serialize) {
              if (e2 && i3 === e2[e2.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
            } else {
              for (const r4 in t3) {
                if (!t3.hasOwnProperty(r4)) continue;
                if (Tn[n3].omit.indexOf(r4) >= 0) continue;
                const a3 = t3[r4];
                i3[r4] = Tn[n3].shallow.indexOf(r4) >= 0 ? a3 : Dn(a3, e2);
              }
              t3 instanceof Error && (i3.message = t3.message);
            }
            if (i3.$name) throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== n3 && (i3.$name = n3), i3;
          }
          throw new Error("can't serialize object of type " + typeof t3);
        }
        function On(t3) {
          if (null == t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp || t3 instanceof Blob || Ln(t3) || M2(t3) || ArrayBuffer.isView(t3) || t3 instanceof ImageData) return t3;
          if (Array.isArray(t3)) return t3.map(On);
          if ("object" == typeof t3) {
            const e2 = t3.$name || "Object";
            if (!Tn[e2]) throw new Error(`can't deserialize unregistered class ${e2}`);
            const { klass: r3 } = Tn[e2];
            if (!r3) throw new Error(`can't deserialize unregistered class ${e2}`);
            if (r3.deserialize) return r3.deserialize(t3);
            const n3 = Object.create(r3.prototype);
            for (const r4 of Object.keys(t3)) {
              if ("$name" === r4) continue;
              const i3 = t3[r4];
              n3[r4] = Tn[e2].shallow.indexOf(r4) >= 0 ? i3 : On(i3);
            }
            return n3;
          }
          throw new Error("can't deserialize object of type " + typeof t3);
        }
        class Un {
          constructor() {
            this.first = true;
          }
          update(t3, e2) {
            const r3 = Math.floor(t3);
            return this.first ? (this.first = false, this.lastIntegerZoom = r3, this.lastIntegerZoomTime = 0, this.lastZoom = t3, this.lastFloorZoom = r3, true) : (this.lastFloorZoom > r3 ? (this.lastIntegerZoom = r3 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r3 && (this.lastIntegerZoom = r3, this.lastIntegerZoomTime = e2), t3 !== this.lastZoom && (this.lastZoom = t3, this.lastFloorZoom = r3, true));
          }
        }
        const Rn = { "Latin-1 Supplement": (t3) => t3 >= 128 && t3 <= 255, Arabic: (t3) => t3 >= 1536 && t3 <= 1791, "Arabic Supplement": (t3) => t3 >= 1872 && t3 <= 1919, "Arabic Extended-A": (t3) => t3 >= 2208 && t3 <= 2303, "Hangul Jamo": (t3) => t3 >= 4352 && t3 <= 4607, "Unified Canadian Aboriginal Syllabics": (t3) => t3 >= 5120 && t3 <= 5759, Khmer: (t3) => t3 >= 6016 && t3 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t3) => t3 >= 6320 && t3 <= 6399, "General Punctuation": (t3) => t3 >= 8192 && t3 <= 8303, "Letterlike Symbols": (t3) => t3 >= 8448 && t3 <= 8527, "Number Forms": (t3) => t3 >= 8528 && t3 <= 8591, "Miscellaneous Technical": (t3) => t3 >= 8960 && t3 <= 9215, "Control Pictures": (t3) => t3 >= 9216 && t3 <= 9279, "Optical Character Recognition": (t3) => t3 >= 9280 && t3 <= 9311, "Enclosed Alphanumerics": (t3) => t3 >= 9312 && t3 <= 9471, "Geometric Shapes": (t3) => t3 >= 9632 && t3 <= 9727, "Miscellaneous Symbols": (t3) => t3 >= 9728 && t3 <= 9983, "Miscellaneous Symbols and Arrows": (t3) => t3 >= 11008 && t3 <= 11263, "CJK Radicals Supplement": (t3) => t3 >= 11904 && t3 <= 12031, "Kangxi Radicals": (t3) => t3 >= 12032 && t3 <= 12255, "Ideographic Description Characters": (t3) => t3 >= 12272 && t3 <= 12287, "CJK Symbols and Punctuation": (t3) => t3 >= 12288 && t3 <= 12351, Hiragana: (t3) => t3 >= 12352 && t3 <= 12447, Katakana: (t3) => t3 >= 12448 && t3 <= 12543, Bopomofo: (t3) => t3 >= 12544 && t3 <= 12591, "Hangul Compatibility Jamo": (t3) => t3 >= 12592 && t3 <= 12687, Kanbun: (t3) => t3 >= 12688 && t3 <= 12703, "Bopomofo Extended": (t3) => t3 >= 12704 && t3 <= 12735, "CJK Strokes": (t3) => t3 >= 12736 && t3 <= 12783, "Katakana Phonetic Extensions": (t3) => t3 >= 12784 && t3 <= 12799, "Enclosed CJK Letters and Months": (t3) => t3 >= 12800 && t3 <= 13055, "CJK Compatibility": (t3) => t3 >= 13056 && t3 <= 13311, "CJK Unified Ideographs Extension A": (t3) => t3 >= 13312 && t3 <= 19903, "Yijing Hexagram Symbols": (t3) => t3 >= 19904 && t3 <= 19967, "CJK Unified Ideographs": (t3) => t3 >= 19968 && t3 <= 40959, "Yi Syllables": (t3) => t3 >= 40960 && t3 <= 42127, "Yi Radicals": (t3) => t3 >= 42128 && t3 <= 42191, "Hangul Jamo Extended-A": (t3) => t3 >= 43360 && t3 <= 43391, "Hangul Syllables": (t3) => t3 >= 44032 && t3 <= 55215, "Hangul Jamo Extended-B": (t3) => t3 >= 55216 && t3 <= 55295, "Private Use Area": (t3) => t3 >= 57344 && t3 <= 63743, "CJK Compatibility Ideographs": (t3) => t3 >= 63744 && t3 <= 64255, "Arabic Presentation Forms-A": (t3) => t3 >= 64336 && t3 <= 65023, "Vertical Forms": (t3) => t3 >= 65040 && t3 <= 65055, "CJK Compatibility Forms": (t3) => t3 >= 65072 && t3 <= 65103, "Small Form Variants": (t3) => t3 >= 65104 && t3 <= 65135, "Arabic Presentation Forms-B": (t3) => t3 >= 65136 && t3 <= 65279, "Halfwidth and Fullwidth Forms": (t3) => t3 >= 65280 && t3 <= 65519 };
        function qn(t3) {
          for (const e2 of t3) if (Zn(e2.charCodeAt(0))) return true;
          return false;
        }
        function jn(t3) {
          for (const e2 of t3) if (!Nn(e2.charCodeAt(0))) return false;
          return true;
        }
        function Nn(t3) {
          return !(Rn.Arabic(t3) || Rn["Arabic Supplement"](t3) || Rn["Arabic Extended-A"](t3) || Rn["Arabic Presentation Forms-A"](t3) || Rn["Arabic Presentation Forms-B"](t3));
        }
        function Zn(t3) {
          return !(746 !== t3 && 747 !== t3 && (t3 < 4352 || !(Rn["Bopomofo Extended"](t3) || Rn.Bopomofo(t3) || Rn["CJK Compatibility Forms"](t3) && !(t3 >= 65097 && t3 <= 65103) || Rn["CJK Compatibility Ideographs"](t3) || Rn["CJK Compatibility"](t3) || Rn["CJK Radicals Supplement"](t3) || Rn["CJK Strokes"](t3) || !(!Rn["CJK Symbols and Punctuation"](t3) || t3 >= 12296 && t3 <= 12305 || t3 >= 12308 && t3 <= 12319 || 12336 === t3) || Rn["CJK Unified Ideographs Extension A"](t3) || Rn["CJK Unified Ideographs"](t3) || Rn["Enclosed CJK Letters and Months"](t3) || Rn["Hangul Compatibility Jamo"](t3) || Rn["Hangul Jamo Extended-A"](t3) || Rn["Hangul Jamo Extended-B"](t3) || Rn["Hangul Jamo"](t3) || Rn["Hangul Syllables"](t3) || Rn.Hiragana(t3) || Rn["Ideographic Description Characters"](t3) || Rn.Kanbun(t3) || Rn["Kangxi Radicals"](t3) || Rn["Katakana Phonetic Extensions"](t3) || Rn.Katakana(t3) && 12540 !== t3 || !(!Rn["Halfwidth and Fullwidth Forms"](t3) || 65288 === t3 || 65289 === t3 || 65293 === t3 || t3 >= 65306 && t3 <= 65310 || 65339 === t3 || 65341 === t3 || 65343 === t3 || t3 >= 65371 && t3 <= 65503 || 65507 === t3 || t3 >= 65512 && t3 <= 65519) || !(!Rn["Small Form Variants"](t3) || t3 >= 65112 && t3 <= 65118 || t3 >= 65123 && t3 <= 65126) || Rn["Unified Canadian Aboriginal Syllabics"](t3) || Rn["Unified Canadian Aboriginal Syllabics Extended"](t3) || Rn["Vertical Forms"](t3) || Rn["Yijing Hexagram Symbols"](t3) || Rn["Yi Syllables"](t3) || Rn["Yi Radicals"](t3))));
        }
        function Kn(t3) {
          return !(Zn(t3) || function(t4) {
            return !!(Rn["Latin-1 Supplement"](t4) && (167 === t4 || 169 === t4 || 174 === t4 || 177 === t4 || 188 === t4 || 189 === t4 || 190 === t4 || 215 === t4 || 247 === t4) || Rn["General Punctuation"](t4) && (8214 === t4 || 8224 === t4 || 8225 === t4 || 8240 === t4 || 8241 === t4 || 8251 === t4 || 8252 === t4 || 8258 === t4 || 8263 === t4 || 8264 === t4 || 8265 === t4 || 8273 === t4) || Rn["Letterlike Symbols"](t4) || Rn["Number Forms"](t4) || Rn["Miscellaneous Technical"](t4) && (t4 >= 8960 && t4 <= 8967 || t4 >= 8972 && t4 <= 8991 || t4 >= 8996 && t4 <= 9e3 || 9003 === t4 || t4 >= 9085 && t4 <= 9114 || t4 >= 9150 && t4 <= 9165 || 9167 === t4 || t4 >= 9169 && t4 <= 9179 || t4 >= 9186 && t4 <= 9215) || Rn["Control Pictures"](t4) && 9251 !== t4 || Rn["Optical Character Recognition"](t4) || Rn["Enclosed Alphanumerics"](t4) || Rn["Geometric Shapes"](t4) || Rn["Miscellaneous Symbols"](t4) && !(t4 >= 9754 && t4 <= 9759) || Rn["Miscellaneous Symbols and Arrows"](t4) && (t4 >= 11026 && t4 <= 11055 || t4 >= 11088 && t4 <= 11097 || t4 >= 11192 && t4 <= 11243) || Rn["CJK Symbols and Punctuation"](t4) || Rn.Katakana(t4) || Rn["Private Use Area"](t4) || Rn["CJK Compatibility Forms"](t4) || Rn["Small Form Variants"](t4) || Rn["Halfwidth and Fullwidth Forms"](t4) || 8734 === t4 || 8756 === t4 || 8757 === t4 || t4 >= 9984 && t4 <= 10087 || t4 >= 10102 && t4 <= 10131 || 65532 === t4 || 65533 === t4);
          }(t3));
        }
        function Gn(t3) {
          return t3 >= 1424 && t3 <= 2303 || Rn["Arabic Presentation Forms-A"](t3) || Rn["Arabic Presentation Forms-B"](t3);
        }
        function Jn(t3, e2) {
          return !(!e2 && Gn(t3) || t3 >= 2304 && t3 <= 3583 || t3 >= 3840 && t3 <= 4255 || Rn.Khmer(t3));
        }
        function Xn(t3) {
          for (const e2 of t3) if (Gn(e2.charCodeAt(0))) return true;
          return false;
        }
        const Yn = "deferred", Hn = "loading", Wn = "loaded";
        let Qn = null, ti = "unavailable", ei = null;
        const ri = function(t3) {
          t3 && "string" == typeof t3 && t3.indexOf("NetworkError") > -1 && (ti = "error"), Qn && Qn(t3);
        };
        function ni() {
          ii.fire(new K2("pluginStateChange", { pluginStatus: ti, pluginURL: ei }));
        }
        const ii = new J2(), ai = function() {
          return ti;
        }, si = function() {
          if (ti !== Yn || !ei) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          ti = Hn, ni(), ei && q2({ url: ei }, (t3) => {
            t3 ? ri(t3) : (ti = Wn, ni());
          });
        }, oi = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => ti === Wn || null != oi.applyArabicShaping, isLoading: () => ti === Hn, setState(t3) {
          if (!I2()) throw new Error("Cannot set the state of the rtl-text-plugin when not in the web-worker context");
          ti = t3.pluginStatus, ei = t3.pluginURL;
        }, isParsed() {
          if (!I2()) throw new Error("rtl-text-plugin is only parsed on the worker-threads");
          return null != oi.applyArabicShaping && null != oi.processBidirectionalText && null != oi.processStyledBidirectionalText;
        }, getPluginURL() {
          if (!I2()) throw new Error("rtl-text-plugin url can only be queried from the worker threads");
          return ei;
        } };
        class li {
          constructor(t3, e2) {
            this.zoom = t3, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Un(), this.transition = {});
          }
          isSupportedScript(t3) {
            return function(t4, e2) {
              for (const r3 of t4) if (!Jn(r3.charCodeAt(0), e2)) return false;
              return true;
            }(t3, oi.isLoaded());
          }
          crossFadingFactor() {
            return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t3 = this.zoom, e2 = t3 - Math.floor(t3), r3 = this.crossFadingFactor();
            return t3 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r3 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r3) * e2 };
          }
        }
        class ui {
          constructor(t3, e2) {
            this.property = t3, this.value = e2, this.expression = function(t4, e3) {
              if (Ir(t4)) return new Ur(t4, e3);
              if (Tr(t4)) {
                const r3 = Or(t4, e3);
                if ("error" === r3.result) throw new Error(r3.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
                return r3.value;
              }
              {
                let r3 = t4;
                return "color" === e3.type && "string" == typeof t4 ? r3 = Yt.parse(t4) : "padding" !== e3.type || "number" != typeof t4 && !Array.isArray(t4) ? "variableAnchorOffsetCollection" === e3.type && Array.isArray(t4) && (r3 = re2.parse(t4)) : r3 = te2.parse(t4), { kind: "constant", evaluate: () => r3 };
              }
            }(void 0 === e2 ? t3.specification.default : e2, t3.specification);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(t3, e2, r3) {
            return this.property.possiblyEvaluate(this, t3, e2, r3);
          }
        }
        class ci {
          constructor(t3) {
            this.property = t3, this.value = new ui(t3, void 0);
          }
          transitioned(t3, e2) {
            return new pi(this.property, this.value, e2, g2({}, t3.transition, this.transition), t3.now);
          }
          untransitioned() {
            return new pi(this.property, this.value, null, {}, 0);
          }
        }
        class hi {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultTransitionablePropertyValues);
          }
          getValue(t3) {
            return w2(this._values[t3].value.value);
          }
          setValue(t3, e2) {
            Object.prototype.hasOwnProperty.call(this._values, t3) || (this._values[t3] = new ci(this._values[t3].property)), this._values[t3].value = new ui(this._values[t3].property, null === e2 ? void 0 : w2(e2));
          }
          getTransition(t3) {
            return w2(this._values[t3].transition);
          }
          setTransition(t3, e2) {
            Object.prototype.hasOwnProperty.call(this._values, t3) || (this._values[t3] = new ci(this._values[t3].property)), this._values[t3].transition = w2(e2) || void 0;
          }
          serialize() {
            const t3 = {};
            for (const e2 of Object.keys(this._values)) {
              const r3 = this.getValue(e2);
              void 0 !== r3 && (t3[e2] = r3);
              const n3 = this.getTransition(e2);
              void 0 !== n3 && (t3[`${e2}-transition`] = n3);
            }
            return t3;
          }
          transitioned(t3, e2) {
            const r3 = new fi(this._properties);
            for (const n3 of Object.keys(this._values)) r3._values[n3] = this._values[n3].transitioned(t3, e2._values[n3]);
            return r3;
          }
          untransitioned() {
            const t3 = new fi(this._properties);
            for (const e2 of Object.keys(this._values)) t3._values[e2] = this._values[e2].untransitioned();
            return t3;
          }
        }
        class pi {
          constructor(t3, e2, r3, n3, i3) {
            this.property = t3, this.value = e2, this.begin = i3 + n3.delay || 0, this.end = this.begin + n3.duration || 0, t3.specification.transition && (n3.delay || n3.duration) && (this.prior = r3);
          }
          possiblyEvaluate(t3, e2, r3) {
            const n3 = t3.now || 0, i3 = this.value.possiblyEvaluate(t3, e2, r3), a3 = this.prior;
            if (a3) {
              if (n3 > this.end) return this.prior = null, i3;
              if (this.value.isDataDriven()) return this.prior = null, i3;
              if (n3 < this.begin) return a3.possiblyEvaluate(t3, e2, r3);
              {
                const s3 = (n3 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(a3.possiblyEvaluate(t3, e2, r3), i3, function(t4) {
                  if (t4 <= 0) return 0;
                  if (t4 >= 1) return 1;
                  const e3 = t4 * t4, r4 = e3 * t4;
                  return 4 * (t4 < 0.5 ? r4 : 3 * (t4 - e3) + r4 - 0.75);
                }(s3));
              }
            }
            return i3;
          }
        }
        class fi {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t3, e2, r3) {
            const n3 = new mi(this._properties);
            for (const i3 of Object.keys(this._values)) n3._values[i3] = this._values[i3].possiblyEvaluate(t3, e2, r3);
            return n3;
          }
          hasTransition() {
            for (const t3 of Object.keys(this._values)) if (this._values[t3].prior) return true;
            return false;
          }
        }
        class di {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultPropertyValues);
          }
          hasValue(t3) {
            return void 0 !== this._values[t3].value;
          }
          getValue(t3) {
            return w2(this._values[t3].value);
          }
          setValue(t3, e2) {
            this._values[t3] = new ui(this._values[t3].property, null === e2 ? void 0 : w2(e2));
          }
          serialize() {
            const t3 = {};
            for (const e2 of Object.keys(this._values)) {
              const r3 = this.getValue(e2);
              void 0 !== r3 && (t3[e2] = r3);
            }
            return t3;
          }
          possiblyEvaluate(t3, e2, r3) {
            const n3 = new mi(this._properties);
            for (const i3 of Object.keys(this._values)) n3._values[i3] = this._values[i3].possiblyEvaluate(t3, e2, r3);
            return n3;
          }
        }
        class yi {
          constructor(t3, e2, r3) {
            this.property = t3, this.value = e2, this.parameters = r3;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t3) {
            return "constant" === this.value.kind ? this.value.value : t3;
          }
          evaluate(t3, e2, r3, n3) {
            return this.property.evaluate(this.value, this.parameters, t3, e2, r3, n3);
          }
        }
        class mi {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultPossiblyEvaluatedValues);
          }
          get(t3) {
            return this._values[t3];
          }
        }
        class gi {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e2) {
            if (t3.isDataDriven()) throw new Error("Value should not be data driven");
            return t3.expression.evaluate(e2);
          }
          interpolate(t3, e2, r3) {
            const n3 = Ze2[this.specification.type];
            return n3 ? n3(t3, e2, r3) : t3;
          }
        }
        class xi {
          constructor(t3, e2) {
            this.specification = t3, this.overrides = e2;
          }
          possiblyEvaluate(t3, e2, r3, n3) {
            return new yi(this, "constant" === t3.expression.kind || "camera" === t3.expression.kind ? { kind: "constant", value: t3.expression.evaluate(e2, null, {}, r3, n3) } : t3.expression, e2);
          }
          interpolate(t3, e2, r3) {
            if ("constant" !== t3.value.kind || "constant" !== e2.value.kind) return t3;
            if (void 0 === t3.value.value || void 0 === e2.value.value) return new yi(this, { kind: "constant", value: void 0 }, t3.parameters);
            const n3 = Ze2[this.specification.type];
            if (n3) {
              const i3 = n3(t3.value.value, e2.value.value, r3);
              return new yi(this, { kind: "constant", value: i3 }, t3.parameters);
            }
            return t3;
          }
          evaluate(t3, e2, r3, n3, i3, a3) {
            return "constant" === t3.kind ? t3.value : t3.evaluate(e2, r3, n3, i3, a3);
          }
        }
        class vi extends xi {
          possiblyEvaluate(t3, e2, r3, n3) {
            if (void 0 === t3.value) return new yi(this, { kind: "constant", value: void 0 }, e2);
            if ("constant" === t3.expression.kind) {
              const i3 = t3.expression.evaluate(e2, null, {}, r3, n3), a3 = "resolvedImage" === t3.property.specification.type && "string" != typeof i3 ? i3.name : i3, s3 = this._calculate(a3, a3, a3, e2);
              return new yi(this, { kind: "constant", value: s3 }, e2);
            }
            if ("camera" === t3.expression.kind) {
              const r4 = this._calculate(t3.expression.evaluate({ zoom: e2.zoom - 1 }), t3.expression.evaluate({ zoom: e2.zoom }), t3.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
              return new yi(this, { kind: "constant", value: r4 }, e2);
            }
            return new yi(this, t3.expression, e2);
          }
          evaluate(t3, e2, r3, n3, i3, a3) {
            if ("source" === t3.kind) {
              const s3 = t3.evaluate(e2, r3, n3, i3, a3);
              return this._calculate(s3, s3, s3, e2);
            }
            return "composite" === t3.kind ? this._calculate(t3.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r3, n3), t3.evaluate({ zoom: Math.floor(e2.zoom) }, r3, n3), t3.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r3, n3), e2) : t3.value;
          }
          _calculate(t3, e2, r3, n3) {
            return n3.zoom > n3.zoomHistory.lastIntegerZoom ? { from: t3, to: e2 } : { from: r3, to: e2 };
          }
          interpolate(t3) {
            return t3;
          }
        }
        class bi {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e2, r3, n3) {
            if (void 0 !== t3.value) {
              if ("constant" === t3.expression.kind) {
                const i3 = t3.expression.evaluate(e2, null, {}, r3, n3);
                return this._calculate(i3, i3, i3, e2);
              }
              return this._calculate(t3.expression.evaluate(new li(Math.floor(e2.zoom - 1), e2)), t3.expression.evaluate(new li(Math.floor(e2.zoom), e2)), t3.expression.evaluate(new li(Math.floor(e2.zoom + 1), e2)), e2);
            }
          }
          _calculate(t3, e2, r3, n3) {
            return n3.zoom > n3.zoomHistory.lastIntegerZoom ? { from: t3, to: e2 } : { from: r3, to: e2 };
          }
          interpolate(t3) {
            return t3;
          }
        }
        class wi {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e2, r3, n3) {
            return !!t3.expression.evaluate(e2, null, {}, r3, n3);
          }
          interpolate() {
            return false;
          }
        }
        class _i {
          constructor(t3) {
            this.properties = t3, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const e2 in t3) {
              const r3 = t3[e2];
              r3.specification.overridable && this.overridableProperties.push(e2);
              const n3 = this.defaultPropertyValues[e2] = new ui(r3, void 0), i3 = this.defaultTransitionablePropertyValues[e2] = new ci(r3);
              this.defaultTransitioningPropertyValues[e2] = i3.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n3.possiblyEvaluate({});
            }
          }
        }
        $n("DataDrivenProperty", xi), $n("DataConstantProperty", gi), $n("CrossFadedDataDrivenProperty", vi), $n("CrossFadedProperty", bi), $n("ColorRampProperty", wi);
        const Ai = "-transition";
        class Si extends J2 {
          constructor(t3, e2) {
            if (super(), this.id = t3.id, this.type = t3.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t3.type && (this.metadata = t3.metadata, this.minzoom = t3.minzoom, this.maxzoom = t3.maxzoom, "background" !== t3.type && (this.source = t3.source, this.sourceLayer = t3["source-layer"], this.filter = t3.filter), e2.layout && (this._unevaluatedLayout = new di(e2.layout)), e2.paint)) {
              this._transitionablePaint = new hi(e2.paint);
              for (const e3 in t3.paint) this.setPaintProperty(e3, t3.paint[e3], { validate: false });
              for (const e3 in t3.layout) this.setLayoutProperty(e3, t3.layout[e3], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new mi(e2.paint);
            }
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t3) {
            return "visibility" === t3 ? this.visibility : this._unevaluatedLayout.getValue(t3);
          }
          setLayoutProperty(t3, e2, r3 = {}) {
            null != e2 && this._validate(Vn, `layers.${this.id}.layout.${t3}`, t3, e2, r3) || ("visibility" !== t3 ? this._unevaluatedLayout.setValue(t3, e2) : this.visibility = e2);
          }
          getPaintProperty(t3) {
            return t3.endsWith(Ai) ? this._transitionablePaint.getTransition(t3.slice(0, -11)) : this._transitionablePaint.getValue(t3);
          }
          setPaintProperty(t3, e2, r3 = {}) {
            if (null != e2 && this._validate(Pn, `layers.${this.id}.paint.${t3}`, t3, e2, r3)) return false;
            if (t3.endsWith(Ai)) return this._transitionablePaint.setTransition(t3.slice(0, -11), e2 || void 0), false;
            {
              const r4 = this._transitionablePaint._values[t3], n3 = "cross-faded-data-driven" === r4.property.specification["property-type"], i3 = r4.value.isDataDriven(), a3 = r4.value;
              this._transitionablePaint.setValue(t3, e2), this._handleSpecialPaintPropertyUpdate(t3);
              const s3 = this._transitionablePaint._values[t3].value;
              return s3.isDataDriven() || i3 || n3 || this._handleOverridablePaintPropertyUpdate(t3, a3, s3);
            }
          }
          _handleSpecialPaintPropertyUpdate(t3) {
          }
          _handleOverridablePaintPropertyUpdate(t3, e2, r3) {
            return false;
          }
          isHidden(t3) {
            return !!(this.minzoom && t3 < this.minzoom) || !!(this.maxzoom && t3 >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(t3) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t3, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t3, e2) {
            t3.getCrossfadeParameters && (this._crossfadeParameters = t3.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t3, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t3, void 0, e2);
          }
          serialize() {
            const t3 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t3.layout = t3.layout || {}, t3.layout.visibility = this.visibility), b2(t3, (t4, e2) => !(void 0 === t4 || "layout" === e2 && !Object.keys(t4).length || "paint" === e2 && !Object.keys(t4).length));
          }
          _validate(t3, e2, r3, n3, i3 = {}) {
            return (!i3 || false !== i3.validate) && En(this, t3.call(Cn, { key: e2, layerType: this.type, objectKey: r3, value: n3, styleSpec: X2, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t3 in this.paint._values) {
              const e2 = this.paint.get(t3);
              if (e2 instanceof yi && _r(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent) return true;
            }
            return false;
          }
        }
        const ki = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Ii {
          constructor(t3, e2) {
            this._structArray = t3, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class zi {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t3, e2) {
            return t3._trim(), e2 && (t3.isTransferred = true, e2.push(t3.arrayBuffer)), { length: t3.length, arrayBuffer: t3.arrayBuffer };
          }
          static deserialize(t3) {
            const e2 = Object.create(this.prototype);
            return e2.arrayBuffer = t3.arrayBuffer, e2.length = t3.length, e2.capacity = t3.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t3) {
            this.reserve(t3), this.length = t3;
          }
          reserve(t3) {
            if (t3 > this.capacity) {
              this.capacity = Math.max(t3, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e2 = this.uint8;
              this._refreshViews(), e2 && this.uint8.set(e2);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function Mi(t3, e2 = 1) {
          let r3 = 0, n3 = 0;
          return { members: t3.map((t4) => {
            const i3 = ki[t4.type].BYTES_PER_ELEMENT, a3 = r3 = Ci(r3, Math.max(e2, i3)), s3 = t4.components || 1;
            return n3 = Math.max(n3, i3), r3 += i3 * s3, { name: t4.name, type: t4.type, components: s3, offset: a3 };
          }), size: Ci(r3, Math.max(n3, e2)), alignment: e2 };
        }
        function Ci(t3, e2) {
          return Math.ceil(t3 / e2) * e2;
        }
        class Bi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2) {
            const r3 = this.length;
            return this.resize(r3 + 1), this.emplace(r3, t3, e2);
          }
          emplace(t3, e2, r3) {
            const n3 = 2 * t3;
            return this.int16[n3 + 0] = e2, this.int16[n3 + 1] = r3, t3;
          }
        }
        Bi.prototype.bytesPerElement = 4, $n("StructArrayLayout2i4", Bi);
        class Pi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e2, r3);
          }
          emplace(t3, e2, r3, n3) {
            const i3 = 3 * t3;
            return this.int16[i3 + 0] = e2, this.int16[i3 + 1] = r3, this.int16[i3 + 2] = n3, t3;
          }
        }
        Pi.prototype.bytesPerElement = 6, $n("StructArrayLayout3i6", Pi);
        class Vi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3, n3) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e2, r3, n3);
          }
          emplace(t3, e2, r3, n3, i3) {
            const a3 = 4 * t3;
            return this.int16[a3 + 0] = e2, this.int16[a3 + 1] = r3, this.int16[a3 + 2] = n3, this.int16[a3 + 3] = i3, t3;
          }
        }
        Vi.prototype.bytesPerElement = 8, $n("StructArrayLayout4i8", Vi);
        class Ei extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3, n3, i3, a3) {
            const s3 = this.length;
            return this.resize(s3 + 1), this.emplace(s3, t3, e2, r3, n3, i3, a3);
          }
          emplace(t3, e2, r3, n3, i3, a3, s3) {
            const o3 = 6 * t3;
            return this.int16[o3 + 0] = e2, this.int16[o3 + 1] = r3, this.int16[o3 + 2] = n3, this.int16[o3 + 3] = i3, this.int16[o3 + 4] = a3, this.int16[o3 + 5] = s3, t3;
          }
        }
        Ei.prototype.bytesPerElement = 12, $n("StructArrayLayout2i4i12", Ei);
        class Fi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3, n3, i3, a3) {
            const s3 = this.length;
            return this.resize(s3 + 1), this.emplace(s3, t3, e2, r3, n3, i3, a3);
          }
          emplace(t3, e2, r3, n3, i3, a3, s3) {
            const o3 = 4 * t3, l3 = 8 * t3;
            return this.int16[o3 + 0] = e2, this.int16[o3 + 1] = r3, this.uint8[l3 + 4] = n3, this.uint8[l3 + 5] = i3, this.uint8[l3 + 6] = a3, this.uint8[l3 + 7] = s3, t3;
          }
        }
        Fi.prototype.bytesPerElement = 8, $n("StructArrayLayout2i4ub8", Fi);
        class Ti extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2) {
            const r3 = this.length;
            return this.resize(r3 + 1), this.emplace(r3, t3, e2);
          }
          emplace(t3, e2, r3) {
            const n3 = 2 * t3;
            return this.float32[n3 + 0] = e2, this.float32[n3 + 1] = r3, t3;
          }
        }
        Ti.prototype.bytesPerElement = 8, $n("StructArrayLayout2f8", Ti);
        class $i extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3) {
            const c3 = this.length;
            return this.resize(c3 + 1), this.emplace(c3, t3, e2, r3, n3, i3, a3, s3, o3, l3, u3);
          }
          emplace(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3) {
            const h3 = 10 * t3;
            return this.uint16[h3 + 0] = e2, this.uint16[h3 + 1] = r3, this.uint16[h3 + 2] = n3, this.uint16[h3 + 3] = i3, this.uint16[h3 + 4] = a3, this.uint16[h3 + 5] = s3, this.uint16[h3 + 6] = o3, this.uint16[h3 + 7] = l3, this.uint16[h3 + 8] = u3, this.uint16[h3 + 9] = c3, t3;
          }
        }
        $i.prototype.bytesPerElement = 20, $n("StructArrayLayout10ui20", $i);
        class Li extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3) {
            const p3 = this.length;
            return this.resize(p3 + 1), this.emplace(p3, t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3);
          }
          emplace(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3) {
            const f3 = 12 * t3;
            return this.int16[f3 + 0] = e2, this.int16[f3 + 1] = r3, this.int16[f3 + 2] = n3, this.int16[f3 + 3] = i3, this.uint16[f3 + 4] = a3, this.uint16[f3 + 5] = s3, this.uint16[f3 + 6] = o3, this.uint16[f3 + 7] = l3, this.int16[f3 + 8] = u3, this.int16[f3 + 9] = c3, this.int16[f3 + 10] = h3, this.int16[f3 + 11] = p3, t3;
          }
        }
        Li.prototype.bytesPerElement = 24, $n("StructArrayLayout4i4ui4i24", Li);
        class Di extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e2, r3);
          }
          emplace(t3, e2, r3, n3) {
            const i3 = 3 * t3;
            return this.float32[i3 + 0] = e2, this.float32[i3 + 1] = r3, this.float32[i3 + 2] = n3, t3;
          }
        }
        Di.prototype.bytesPerElement = 12, $n("StructArrayLayout3f12", Di);
        class Oi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t3);
          }
          emplace(t3, e2) {
            return this.uint32[1 * t3 + 0] = e2, t3;
          }
        }
        Oi.prototype.bytesPerElement = 4, $n("StructArrayLayout1ul4", Oi);
        class Ui extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3, n3, i3, a3, s3, o3, l3) {
            const u3 = this.length;
            return this.resize(u3 + 1), this.emplace(u3, t3, e2, r3, n3, i3, a3, s3, o3, l3);
          }
          emplace(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3) {
            const c3 = 10 * t3, h3 = 5 * t3;
            return this.int16[c3 + 0] = e2, this.int16[c3 + 1] = r3, this.int16[c3 + 2] = n3, this.int16[c3 + 3] = i3, this.int16[c3 + 4] = a3, this.int16[c3 + 5] = s3, this.uint32[h3 + 3] = o3, this.uint16[c3 + 8] = l3, this.uint16[c3 + 9] = u3, t3;
          }
        }
        Ui.prototype.bytesPerElement = 20, $n("StructArrayLayout6i1ul2ui20", Ui);
        class Ri extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3, n3, i3, a3) {
            const s3 = this.length;
            return this.resize(s3 + 1), this.emplace(s3, t3, e2, r3, n3, i3, a3);
          }
          emplace(t3, e2, r3, n3, i3, a3, s3) {
            const o3 = 6 * t3;
            return this.int16[o3 + 0] = e2, this.int16[o3 + 1] = r3, this.int16[o3 + 2] = n3, this.int16[o3 + 3] = i3, this.int16[o3 + 4] = a3, this.int16[o3 + 5] = s3, t3;
          }
        }
        Ri.prototype.bytesPerElement = 12, $n("StructArrayLayout2i2i2i12", Ri);
        class qi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3, n3, i3) {
            const a3 = this.length;
            return this.resize(a3 + 1), this.emplace(a3, t3, e2, r3, n3, i3);
          }
          emplace(t3, e2, r3, n3, i3, a3) {
            const s3 = 4 * t3, o3 = 8 * t3;
            return this.float32[s3 + 0] = e2, this.float32[s3 + 1] = r3, this.float32[s3 + 2] = n3, this.int16[o3 + 6] = i3, this.int16[o3 + 7] = a3, t3;
          }
        }
        qi.prototype.bytesPerElement = 16, $n("StructArrayLayout2f1f2i16", qi);
        class ji extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3, n3) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e2, r3, n3);
          }
          emplace(t3, e2, r3, n3, i3) {
            const a3 = 12 * t3, s3 = 3 * t3;
            return this.uint8[a3 + 0] = e2, this.uint8[a3 + 1] = r3, this.float32[s3 + 1] = n3, this.float32[s3 + 2] = i3, t3;
          }
        }
        ji.prototype.bytesPerElement = 12, $n("StructArrayLayout2ub2f12", ji);
        class Ni extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e2, r3);
          }
          emplace(t3, e2, r3, n3) {
            const i3 = 3 * t3;
            return this.uint16[i3 + 0] = e2, this.uint16[i3 + 1] = r3, this.uint16[i3 + 2] = n3, t3;
          }
        }
        Ni.prototype.bytesPerElement = 6, $n("StructArrayLayout3ui6", Ni);
        class Zi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3) {
            const g3 = this.length;
            return this.resize(g3 + 1), this.emplace(g3, t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3);
          }
          emplace(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3, g3) {
            const x3 = 24 * t3, v3 = 12 * t3, b3 = 48 * t3;
            return this.int16[x3 + 0] = e2, this.int16[x3 + 1] = r3, this.uint16[x3 + 2] = n3, this.uint16[x3 + 3] = i3, this.uint32[v3 + 2] = a3, this.uint32[v3 + 3] = s3, this.uint32[v3 + 4] = o3, this.uint16[x3 + 10] = l3, this.uint16[x3 + 11] = u3, this.uint16[x3 + 12] = c3, this.float32[v3 + 7] = h3, this.float32[v3 + 8] = p3, this.uint8[b3 + 36] = f3, this.uint8[b3 + 37] = d3, this.uint8[b3 + 38] = y3, this.uint32[v3 + 10] = m3, this.int16[x3 + 22] = g3, t3;
          }
        }
        Zi.prototype.bytesPerElement = 48, $n("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Zi);
        class Ki extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3, g3, x3, v3, b3, w3, _3, A3, S3, k3, I3, z3) {
            const M3 = this.length;
            return this.resize(M3 + 1), this.emplace(M3, t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3, g3, x3, v3, b3, w3, _3, A3, S3, k3, I3, z3);
          }
          emplace(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3, g3, x3, v3, b3, w3, _3, A3, S3, k3, I3, z3, M3) {
            const C3 = 32 * t3, B3 = 16 * t3;
            return this.int16[C3 + 0] = e2, this.int16[C3 + 1] = r3, this.int16[C3 + 2] = n3, this.int16[C3 + 3] = i3, this.int16[C3 + 4] = a3, this.int16[C3 + 5] = s3, this.int16[C3 + 6] = o3, this.int16[C3 + 7] = l3, this.uint16[C3 + 8] = u3, this.uint16[C3 + 9] = c3, this.uint16[C3 + 10] = h3, this.uint16[C3 + 11] = p3, this.uint16[C3 + 12] = f3, this.uint16[C3 + 13] = d3, this.uint16[C3 + 14] = y3, this.uint16[C3 + 15] = m3, this.uint16[C3 + 16] = g3, this.uint16[C3 + 17] = x3, this.uint16[C3 + 18] = v3, this.uint16[C3 + 19] = b3, this.uint16[C3 + 20] = w3, this.uint16[C3 + 21] = _3, this.uint16[C3 + 22] = A3, this.uint32[B3 + 12] = S3, this.float32[B3 + 13] = k3, this.float32[B3 + 14] = I3, this.uint16[C3 + 30] = z3, this.uint16[C3 + 31] = M3, t3;
          }
        }
        Ki.prototype.bytesPerElement = 64, $n("StructArrayLayout8i15ui1ul2f2ui64", Ki);
        class Gi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t3);
          }
          emplace(t3, e2) {
            return this.float32[1 * t3 + 0] = e2, t3;
          }
        }
        Gi.prototype.bytesPerElement = 4, $n("StructArrayLayout1f4", Gi);
        class Ji extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e2, r3);
          }
          emplace(t3, e2, r3, n3) {
            const i3 = 3 * t3;
            return this.uint16[6 * t3 + 0] = e2, this.float32[i3 + 1] = r3, this.float32[i3 + 2] = n3, t3;
          }
        }
        Ji.prototype.bytesPerElement = 12, $n("StructArrayLayout1ui2f12", Ji);
        class Xi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e2, r3);
          }
          emplace(t3, e2, r3, n3) {
            const i3 = 4 * t3;
            return this.uint32[2 * t3 + 0] = e2, this.uint16[i3 + 2] = r3, this.uint16[i3 + 3] = n3, t3;
          }
        }
        Xi.prototype.bytesPerElement = 8, $n("StructArrayLayout1ul2ui8", Xi);
        class Yi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2) {
            const r3 = this.length;
            return this.resize(r3 + 1), this.emplace(r3, t3, e2);
          }
          emplace(t3, e2, r3) {
            const n3 = 2 * t3;
            return this.uint16[n3 + 0] = e2, this.uint16[n3 + 1] = r3, t3;
          }
        }
        Yi.prototype.bytesPerElement = 4, $n("StructArrayLayout2ui4", Yi);
        class Hi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t3);
          }
          emplace(t3, e2) {
            return this.uint16[1 * t3 + 0] = e2, t3;
          }
        }
        Hi.prototype.bytesPerElement = 2, $n("StructArrayLayout1ui2", Hi);
        class Wi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e2, r3, n3) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e2, r3, n3);
          }
          emplace(t3, e2, r3, n3, i3) {
            const a3 = 4 * t3;
            return this.float32[a3 + 0] = e2, this.float32[a3 + 1] = r3, this.float32[a3 + 2] = n3, this.float32[a3 + 3] = i3, t3;
          }
        }
        Wi.prototype.bytesPerElement = 16, $n("StructArrayLayout4f16", Wi);
        class Qi extends Ii {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new a2(this.anchorPointX, this.anchorPointY);
          }
        }
        Qi.prototype.size = 20;
        class ta extends Ui {
          get(t3) {
            return new Qi(this, t3);
          }
        }
        $n("CollisionBoxArray", ta);
        class ea extends Ii {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t3) {
            this._structArray.uint8[this._pos1 + 37] = t3;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t3) {
            this._structArray.uint8[this._pos1 + 38] = t3;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t3) {
            this._structArray.uint32[this._pos4 + 10] = t3;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        ea.prototype.size = 48;
        class ra extends Zi {
          get(t3) {
            return new ea(this, t3);
          }
        }
        $n("PlacedSymbolArray", ra);
        class na extends Ii {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t3) {
            this._structArray.uint32[this._pos4 + 12] = t3;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        na.prototype.size = 64;
        class ia extends Ki {
          get(t3) {
            return new na(this, t3);
          }
        }
        $n("SymbolInstanceArray", ia);
        class aa extends Gi {
          getoffsetX(t3) {
            return this.float32[1 * t3 + 0];
          }
        }
        $n("GlyphOffsetArray", aa);
        class sa extends Pi {
          getx(t3) {
            return this.int16[3 * t3 + 0];
          }
          gety(t3) {
            return this.int16[3 * t3 + 1];
          }
          gettileUnitDistanceFromAnchor(t3) {
            return this.int16[3 * t3 + 2];
          }
        }
        $n("SymbolLineVertexArray", sa);
        class oa extends Ii {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        oa.prototype.size = 12;
        class la extends Ji {
          get(t3) {
            return new oa(this, t3);
          }
        }
        $n("TextAnchorOffsetArray", la);
        class ua extends Ii {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        ua.prototype.size = 8;
        class ca extends Xi {
          get(t3) {
            return new ua(this, t3);
          }
        }
        $n("FeatureIndexArray", ca);
        class ha extends Bi {
        }
        class pa extends Bi {
        }
        class fa extends Bi {
        }
        class da extends Ei {
        }
        class ya extends Fi {
        }
        class ma extends Ti {
        }
        class ga extends $i {
        }
        class xa extends Li {
        }
        class va extends Di {
        }
        class ba extends Oi {
        }
        class wa extends Ri {
        }
        class _a2 extends ji {
        }
        class Aa extends Ni {
        }
        class Sa extends Yi {
        }
        const ka = Mi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ia } = ka;
        class za {
          constructor(t3 = []) {
            this.segments = t3;
          }
          prepareSegment(t3, e2, r3, n3) {
            let i3 = this.segments[this.segments.length - 1];
            return t3 > za.MAX_VERTEX_ARRAY_LENGTH && A2(`Max vertices per segment is ${za.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t3}`), (!i3 || i3.vertexLength + t3 > za.MAX_VERTEX_ARRAY_LENGTH || i3.sortKey !== n3) && (i3 = { vertexOffset: e2.length, primitiveOffset: r3.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n3 && (i3.sortKey = n3), this.segments.push(i3)), i3;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t3 of this.segments) for (const e2 in t3.vaos) t3.vaos[e2].destroy();
          }
          static simpleSegment(t3, e2, r3, n3) {
            return new za([{ vertexOffset: t3, primitiveOffset: e2, vertexLength: r3, primitiveLength: n3, vaos: {}, sortKey: 0 }]);
          }
        }
        function Ma(t3, e2) {
          return 256 * (t3 = y2(Math.floor(t3), 0, 255)) + y2(Math.floor(e2), 0, 255);
        }
        za.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, $n("SegmentVector", za);
        const Ca = Mi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var Ba = { exports: {} }, Pa = { exports: {} };
        Pa.exports = function(t3, e2) {
          var r3, n3, i3, a3, s3, o3, l3, u3;
          for (n3 = t3.length - (r3 = 3 & t3.length), i3 = e2, s3 = 3432918353, o3 = 461845907, u3 = 0; u3 < n3; ) l3 = 255 & t3.charCodeAt(u3) | (255 & t3.charCodeAt(++u3)) << 8 | (255 & t3.charCodeAt(++u3)) << 16 | (255 & t3.charCodeAt(++u3)) << 24, ++u3, i3 = 27492 + (65535 & (a3 = 5 * (65535 & (i3 = (i3 ^= l3 = (65535 & (l3 = (l3 = (65535 & l3) * s3 + (((l3 >>> 16) * s3 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o3 + (((l3 >>> 16) * o3 & 65535) << 16) & 4294967295) << 13 | i3 >>> 19)) + ((5 * (i3 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a3 >>> 16) & 65535) << 16);
          switch (l3 = 0, r3) {
            case 3:
              l3 ^= (255 & t3.charCodeAt(u3 + 2)) << 16;
            case 2:
              l3 ^= (255 & t3.charCodeAt(u3 + 1)) << 8;
            case 1:
              i3 ^= l3 = (65535 & (l3 = (l3 = (65535 & (l3 ^= 255 & t3.charCodeAt(u3))) * s3 + (((l3 >>> 16) * s3 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o3 + (((l3 >>> 16) * o3 & 65535) << 16) & 4294967295;
          }
          return i3 ^= t3.length, i3 = 2246822507 * (65535 & (i3 ^= i3 >>> 16)) + ((2246822507 * (i3 >>> 16) & 65535) << 16) & 4294967295, i3 = 3266489909 * (65535 & (i3 ^= i3 >>> 13)) + ((3266489909 * (i3 >>> 16) & 65535) << 16) & 4294967295, (i3 ^= i3 >>> 16) >>> 0;
        };
        var Va = Pa.exports, Ea = { exports: {} };
        Ea.exports = function(t3, e2) {
          for (var r3, n3 = t3.length, i3 = e2 ^ n3, a3 = 0; n3 >= 4; ) r3 = 1540483477 * (65535 & (r3 = 255 & t3.charCodeAt(a3) | (255 & t3.charCodeAt(++a3)) << 8 | (255 & t3.charCodeAt(++a3)) << 16 | (255 & t3.charCodeAt(++a3)) << 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16), i3 = 1540483477 * (65535 & i3) + ((1540483477 * (i3 >>> 16) & 65535) << 16) ^ (r3 = 1540483477 * (65535 & (r3 ^= r3 >>> 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16)), n3 -= 4, ++a3;
          switch (n3) {
            case 3:
              i3 ^= (255 & t3.charCodeAt(a3 + 2)) << 16;
            case 2:
              i3 ^= (255 & t3.charCodeAt(a3 + 1)) << 8;
            case 1:
              i3 = 1540483477 * (65535 & (i3 ^= 255 & t3.charCodeAt(a3))) + ((1540483477 * (i3 >>> 16) & 65535) << 16);
          }
          return i3 = 1540483477 * (65535 & (i3 ^= i3 >>> 13)) + ((1540483477 * (i3 >>> 16) & 65535) << 16), (i3 ^= i3 >>> 15) >>> 0;
        };
        var Fa = Va, Ta = Ea.exports;
        Ba.exports = Fa, Ba.exports.murmur3 = Fa, Ba.exports.murmur2 = Ta;
        var $a = r2(Ba.exports);
        class La {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t3, e2, r3, n3) {
            this.ids.push(Da(t3)), this.positions.push(e2, r3, n3);
          }
          getPositions(t3) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const e2 = Da(t3);
            let r3 = 0, n3 = this.ids.length - 1;
            for (; r3 < n3; ) {
              const t4 = r3 + n3 >> 1;
              this.ids[t4] >= e2 ? n3 = t4 : r3 = t4 + 1;
            }
            const i3 = [];
            for (; this.ids[r3] === e2; ) i3.push({ index: this.positions[3 * r3], start: this.positions[3 * r3 + 1], end: this.positions[3 * r3 + 2] }), r3++;
            return i3;
          }
          static serialize(t3, e2) {
            const r3 = new Float64Array(t3.ids), n3 = new Uint32Array(t3.positions);
            return Oa(r3, n3, 0, r3.length - 1), e2 && e2.push(r3.buffer, n3.buffer), { ids: r3, positions: n3 };
          }
          static deserialize(t3) {
            const e2 = new La();
            return e2.ids = t3.ids, e2.positions = t3.positions, e2.indexed = true, e2;
          }
        }
        function Da(t3) {
          const e2 = +t3;
          return !isNaN(e2) && e2 <= Number.MAX_SAFE_INTEGER ? e2 : $a(String(t3));
        }
        function Oa(t3, e2, r3, n3) {
          for (; r3 < n3; ) {
            const i3 = t3[r3 + n3 >> 1];
            let a3 = r3 - 1, s3 = n3 + 1;
            for (; ; ) {
              do {
                a3++;
              } while (t3[a3] < i3);
              do {
                s3--;
              } while (t3[s3] > i3);
              if (a3 >= s3) break;
              Ua(t3, a3, s3), Ua(e2, 3 * a3, 3 * s3), Ua(e2, 3 * a3 + 1, 3 * s3 + 1), Ua(e2, 3 * a3 + 2, 3 * s3 + 2);
            }
            s3 - r3 < n3 - s3 ? (Oa(t3, e2, r3, s3), r3 = s3 + 1) : (Oa(t3, e2, s3 + 1, n3), n3 = s3);
          }
        }
        function Ua(t3, e2, r3) {
          const n3 = t3[e2];
          t3[e2] = t3[r3], t3[r3] = n3;
        }
        $n("FeaturePositionMap", La);
        class Ra {
          constructor(t3, e2) {
            this.gl = t3.gl, this.location = e2;
          }
        }
        class qa extends Ra {
          constructor(t3, e2) {
            super(t3, e2), this.current = 0;
          }
          set(t3) {
            this.current !== t3 && (this.current = t3, this.gl.uniform1f(this.location, t3));
          }
        }
        class ja extends Ra {
          constructor(t3, e2) {
            super(t3, e2), this.current = [0, 0, 0, 0];
          }
          set(t3) {
            t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] && t3[3] === this.current[3] || (this.current = t3, this.gl.uniform4f(this.location, t3[0], t3[1], t3[2], t3[3]));
          }
        }
        class Na extends Ra {
          constructor(t3, e2) {
            super(t3, e2), this.current = Yt.transparent;
          }
          set(t3) {
            t3.r === this.current.r && t3.g === this.current.g && t3.b === this.current.b && t3.a === this.current.a || (this.current = t3, this.gl.uniform4f(this.location, t3.r, t3.g, t3.b, t3.a));
          }
        }
        const Za = new Float32Array(16);
        function Ka(t3) {
          return [Ma(255 * t3.r, 255 * t3.g), Ma(255 * t3.b, 255 * t3.a)];
        }
        class Ga {
          constructor(t3, e2, r3) {
            this.value = t3, this.uniformNames = e2.map((t4) => `u_${t4}`), this.type = r3;
          }
          setUniform(t3, e2, r3) {
            t3.set(r3.constantOr(this.value));
          }
          getBinding(t3, e2, r3) {
            return "color" === this.type ? new Na(t3, e2) : new qa(t3, e2);
          }
        }
        class Ja {
          constructor(t3, e2) {
            this.uniformNames = e2.map((t4) => `u_${t4}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t3, e2) {
            this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t3.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t3.tlbr;
          }
          setUniform(t3, e2, r3, n3) {
            const i3 = "u_pattern_to" === n3 ? this.patternTo : "u_pattern_from" === n3 ? this.patternFrom : "u_pixel_ratio_to" === n3 ? this.pixelRatioTo : "u_pixel_ratio_from" === n3 ? this.pixelRatioFrom : null;
            i3 && t3.set(i3);
          }
          getBinding(t3, e2, r3) {
            return "u_pattern" === r3.substr(0, 9) ? new ja(t3, e2) : new qa(t3, e2);
          }
        }
        class Xa {
          constructor(t3, e2, r3, n3) {
            this.expression = t3, this.type = r3, this.maxValue = 0, this.paintVertexAttributes = e2.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: "color" === r3 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n3();
          }
          populatePaintArray(t3, e2, r3, n3, i3) {
            const a3 = this.paintVertexArray.length, s3 = this.expression.evaluate(new li(0), e2, {}, n3, [], i3);
            this.paintVertexArray.resize(t3), this._setPaintValue(a3, t3, s3);
          }
          updatePaintArray(t3, e2, r3, n3) {
            const i3 = this.expression.evaluate({ zoom: 0 }, r3, n3);
            this._setPaintValue(t3, e2, i3);
          }
          _setPaintValue(t3, e2, r3) {
            if ("color" === this.type) {
              const n3 = Ka(r3);
              for (let r4 = t3; r4 < e2; r4++) this.paintVertexArray.emplace(r4, n3[0], n3[1]);
            } else {
              for (let n3 = t3; n3 < e2; n3++) this.paintVertexArray.emplace(n3, r3);
              this.maxValue = Math.max(this.maxValue, Math.abs(r3));
            }
          }
          upload(t3) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Ya {
          constructor(t3, e2, r3, n3, i3, a3) {
            this.expression = t3, this.uniformNames = e2.map((t4) => `u_${t4}_t`), this.type = r3, this.useIntegerZoom = n3, this.zoom = i3, this.maxValue = 0, this.paintVertexAttributes = e2.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: "color" === r3 ? 4 : 2, offset: 0 })), this.paintVertexArray = new a3();
          }
          populatePaintArray(t3, e2, r3, n3, i3) {
            const a3 = this.expression.evaluate(new li(this.zoom), e2, {}, n3, [], i3), s3 = this.expression.evaluate(new li(this.zoom + 1), e2, {}, n3, [], i3), o3 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t3), this._setPaintValue(o3, t3, a3, s3);
          }
          updatePaintArray(t3, e2, r3, n3) {
            const i3 = this.expression.evaluate({ zoom: this.zoom }, r3, n3), a3 = this.expression.evaluate({ zoom: this.zoom + 1 }, r3, n3);
            this._setPaintValue(t3, e2, i3, a3);
          }
          _setPaintValue(t3, e2, r3, n3) {
            if ("color" === this.type) {
              const i3 = Ka(r3), a3 = Ka(n3);
              for (let r4 = t3; r4 < e2; r4++) this.paintVertexArray.emplace(r4, i3[0], i3[1], a3[0], a3[1]);
            } else {
              for (let i3 = t3; i3 < e2; i3++) this.paintVertexArray.emplace(i3, r3, n3);
              this.maxValue = Math.max(this.maxValue, Math.abs(r3), Math.abs(n3));
            }
          }
          upload(t3) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t3, e2) {
            const r3 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n3 = y2(this.expression.interpolationFactor(r3, this.zoom, this.zoom + 1), 0, 1);
            t3.set(n3);
          }
          getBinding(t3, e2, r3) {
            return new qa(t3, e2);
          }
        }
        class Ha {
          constructor(t3, e2, r3, n3, i3, a3) {
            this.expression = t3, this.type = e2, this.useIntegerZoom = r3, this.zoom = n3, this.layerId = a3, this.zoomInPaintVertexArray = new i3(), this.zoomOutPaintVertexArray = new i3();
          }
          populatePaintArray(t3, e2, r3) {
            const n3 = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t3), this.zoomOutPaintVertexArray.resize(t3), this._setPaintValues(n3, t3, e2.patterns && e2.patterns[this.layerId], r3);
          }
          updatePaintArray(t3, e2, r3, n3, i3) {
            this._setPaintValues(t3, e2, r3.patterns && r3.patterns[this.layerId], i3);
          }
          _setPaintValues(t3, e2, r3, n3) {
            if (!n3 || !r3) return;
            const { min: i3, mid: a3, max: s3 } = r3, o3 = n3[i3], l3 = n3[a3], u3 = n3[s3];
            if (o3 && l3 && u3) for (let r4 = t3; r4 < e2; r4++) this.zoomInPaintVertexArray.emplace(r4, l3.tl[0], l3.tl[1], l3.br[0], l3.br[1], o3.tl[0], o3.tl[1], o3.br[0], o3.br[1], l3.pixelRatio, o3.pixelRatio), this.zoomOutPaintVertexArray.emplace(r4, l3.tl[0], l3.tl[1], l3.br[0], l3.br[1], u3.tl[0], u3.tl[1], u3.br[0], u3.br[1], l3.pixelRatio, u3.pixelRatio);
          }
          upload(t3) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t3.createVertexBuffer(this.zoomInPaintVertexArray, Ca.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t3.createVertexBuffer(this.zoomOutPaintVertexArray, Ca.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Wa {
          constructor(t3, e2, r3) {
            this.binders = {}, this._buffers = [];
            const n3 = [];
            for (const i3 in t3.paint._values) {
              if (!r3(i3)) continue;
              const a3 = t3.paint.get(i3);
              if (!(a3 instanceof yi && _r(a3.property.specification))) continue;
              const s3 = ts(i3, t3.type), o3 = a3.value, l3 = a3.property.specification.type, u3 = a3.property.useIntegerZoom, c3 = a3.property.specification["property-type"], h3 = "cross-faded" === c3 || "cross-faded-data-driven" === c3;
              if ("constant" === o3.kind) this.binders[i3] = h3 ? new Ja(o3.value, s3) : new Ga(o3.value, s3, l3), n3.push(`/u_${i3}`);
              else if ("source" === o3.kind || h3) {
                const r4 = es(i3, l3, "source");
                this.binders[i3] = h3 ? new Ha(o3, l3, u3, e2, r4, t3.id) : new Xa(o3, s3, l3, r4), n3.push(`/a_${i3}`);
              } else {
                const t4 = es(i3, l3, "composite");
                this.binders[i3] = new Ya(o3, s3, l3, u3, e2, t4), n3.push(`/z_${i3}`);
              }
            }
            this.cacheKey = n3.sort().join("");
          }
          getMaxValue(t3) {
            const e2 = this.binders[t3];
            return e2 instanceof Xa || e2 instanceof Ya ? e2.maxValue : 0;
          }
          populatePaintArrays(t3, e2, r3, n3, i3) {
            for (const a3 in this.binders) {
              const s3 = this.binders[a3];
              (s3 instanceof Xa || s3 instanceof Ya || s3 instanceof Ha) && s3.populatePaintArray(t3, e2, r3, n3, i3);
            }
          }
          setConstantPatternPositions(t3, e2) {
            for (const r3 in this.binders) {
              const n3 = this.binders[r3];
              n3 instanceof Ja && n3.setConstantPatternPositions(t3, e2);
            }
          }
          updatePaintArrays(t3, e2, r3, n3, i3) {
            let a3 = false;
            for (const s3 in t3) {
              const o3 = e2.getPositions(s3);
              for (const e3 of o3) {
                const o4 = r3.feature(e3.index);
                for (const r4 in this.binders) {
                  const l3 = this.binders[r4];
                  if ((l3 instanceof Xa || l3 instanceof Ya || l3 instanceof Ha) && true === l3.expression.isStateDependent) {
                    const u3 = n3.paint.get(r4);
                    l3.expression = u3.value, l3.updatePaintArray(e3.start, e3.end, o4, t3[s3], i3), a3 = true;
                  }
                }
              }
            }
            return a3;
          }
          defines() {
            const t3 = [];
            for (const e2 in this.binders) {
              const r3 = this.binders[e2];
              (r3 instanceof Ga || r3 instanceof Ja) && t3.push(...r3.uniformNames.map((t4) => `#define HAS_UNIFORM_${t4}`));
            }
            return t3;
          }
          getBinderAttributes() {
            const t3 = [];
            for (const e2 in this.binders) {
              const r3 = this.binders[e2];
              if (r3 instanceof Xa || r3 instanceof Ya) for (let e3 = 0; e3 < r3.paintVertexAttributes.length; e3++) t3.push(r3.paintVertexAttributes[e3].name);
              else if (r3 instanceof Ha) for (let e3 = 0; e3 < Ca.members.length; e3++) t3.push(Ca.members[e3].name);
            }
            return t3;
          }
          getBinderUniforms() {
            const t3 = [];
            for (const e2 in this.binders) {
              const r3 = this.binders[e2];
              if (r3 instanceof Ga || r3 instanceof Ja || r3 instanceof Ya) for (const e3 of r3.uniformNames) t3.push(e3);
            }
            return t3;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t3, e2) {
            const r3 = [];
            for (const n3 in this.binders) {
              const i3 = this.binders[n3];
              if (i3 instanceof Ga || i3 instanceof Ja || i3 instanceof Ya) {
                for (const a3 of i3.uniformNames) if (e2[a3]) {
                  const s3 = i3.getBinding(t3, e2[a3], a3);
                  r3.push({ name: a3, property: n3, binding: s3 });
                }
              }
            }
            return r3;
          }
          setUniforms(t3, e2, r3, n3) {
            for (const { name: t4, property: i3, binding: a3 } of e2) this.binders[i3].setUniform(a3, n3, r3.get(i3), t4);
          }
          updatePaintBuffers(t3) {
            this._buffers = [];
            for (const e2 in this.binders) {
              const r3 = this.binders[e2];
              if (t3 && r3 instanceof Ha) {
                const e3 = 2 === t3.fromScale ? r3.zoomInPaintVertexBuffer : r3.zoomOutPaintVertexBuffer;
                e3 && this._buffers.push(e3);
              } else (r3 instanceof Xa || r3 instanceof Ya) && r3.paintVertexBuffer && this._buffers.push(r3.paintVertexBuffer);
            }
          }
          upload(t3) {
            for (const e2 in this.binders) {
              const r3 = this.binders[e2];
              (r3 instanceof Xa || r3 instanceof Ya || r3 instanceof Ha) && r3.upload(t3);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t3 in this.binders) {
              const e2 = this.binders[t3];
              (e2 instanceof Xa || e2 instanceof Ya || e2 instanceof Ha) && e2.destroy();
            }
          }
        }
        class Qa {
          constructor(t3, e2, r3 = () => true) {
            this.programConfigurations = {};
            for (const n3 of t3) this.programConfigurations[n3.id] = new Wa(n3, e2, r3);
            this.needsUpload = false, this._featureMap = new La(), this._bufferOffset = 0;
          }
          populatePaintArrays(t3, e2, r3, n3, i3, a3) {
            for (const r4 in this.programConfigurations) this.programConfigurations[r4].populatePaintArrays(t3, e2, n3, i3, a3);
            void 0 !== e2.id && this._featureMap.add(e2.id, r3, this._bufferOffset, t3), this._bufferOffset = t3, this.needsUpload = true;
          }
          updatePaintArrays(t3, e2, r3, n3) {
            for (const i3 of r3) this.needsUpload = this.programConfigurations[i3.id].updatePaintArrays(t3, this._featureMap, e2, i3, n3) || this.needsUpload;
          }
          get(t3) {
            return this.programConfigurations[t3];
          }
          upload(t3) {
            if (this.needsUpload) {
              for (const e2 in this.programConfigurations) this.programConfigurations[e2].upload(t3);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t3 in this.programConfigurations) this.programConfigurations[t3].destroy();
          }
        }
        function ts(t3, e2) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t3] || [t3.replace(`${e2}-`, "").replace(/-/g, "_")];
        }
        function es(t3, e2, r3) {
          const n3 = { color: { source: Ti, composite: Wi }, number: { source: Gi, composite: Ti } }, i3 = function(t4) {
            return { "line-pattern": { source: ga, composite: ga }, "fill-pattern": { source: ga, composite: ga }, "fill-extrusion-pattern": { source: ga, composite: ga } }[t4];
          }(t3);
          return i3 && i3[r3] || n3[e2][r3];
        }
        $n("ConstantBinder", Ga), $n("CrossFadedConstantBinder", Ja), $n("SourceExpressionBinder", Xa), $n("CrossFadedCompositeBinder", Ha), $n("CompositeExpressionBinder", Ya), $n("ProgramConfiguration", Wa, { omit: ["_buffers"] }), $n("ProgramConfigurationSet", Qa);
        const rs = 8192, ns = Math.pow(2, 14) - 1, is = -ns - 1;
        function as(t3) {
          const e2 = rs / t3.extent, r3 = t3.loadGeometry();
          for (let t4 = 0; t4 < r3.length; t4++) {
            const n3 = r3[t4];
            for (let t5 = 0; t5 < n3.length; t5++) {
              const r4 = n3[t5], i3 = Math.round(r4.x * e2), a3 = Math.round(r4.y * e2);
              r4.x = y2(i3, is, ns), r4.y = y2(a3, is, ns), (i3 < r4.x || i3 > r4.x + 1 || a3 < r4.y || a3 > r4.y + 1) && A2("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return r3;
        }
        function ss2(t3, e2) {
          return { type: t3.type, id: t3.id, properties: t3.properties, geometry: e2 ? as(t3) : [] };
        }
        function os(t3, e2, r3, n3, i3) {
          t3.emplaceBack(2 * e2 + (n3 + 1) / 2, 2 * r3 + (i3 + 1) / 2);
        }
        class ls {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.layoutVertexArray = new pa(), this.indexArray = new Aa(), this.segments = new za(), this.programConfigurations = new Qa(t3.layers, t3.zoom), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e2, r3) {
            const n3 = this.layers[0], i3 = [];
            let a3 = null, s3 = false;
            "circle" === n3.type && (a3 = n3.layout.get("circle-sort-key"), s3 = !a3.isConstant());
            for (const { feature: e3, id: n4, index: o3, sourceLayerIndex: l3 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, u3 = ss2(e3, t4);
              if (!this.layers[0]._featureFilter.filter(new li(this.zoom), u3, r3)) continue;
              const c3 = s3 ? a3.evaluate(u3, {}, r3) : void 0, h3 = { id: n4, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t4 ? u3.geometry : as(e3), patterns: {}, sortKey: c3 };
              i3.push(h3);
            }
            s3 && i3.sort((t4, e3) => t4.sortKey - e3.sortKey);
            for (const n4 of i3) {
              const { geometry: i4, index: a4, sourceLayerIndex: s4 } = n4, o3 = t3[a4].feature;
              this.addFeature(n4, i4, a4, r3), e2.featureIndex.insert(o3, i4, a4, s4, this.index);
            }
          }
          update(t3, e2, r3) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e2, this.stateDependentLayers, r3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Ia), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t3, e2, r3, n3) {
            for (const r4 of e2) for (const e3 of r4) {
              const r5 = e3.x, n4 = e3.y;
              if (r5 < 0 || r5 >= rs || n4 < 0 || n4 >= rs) continue;
              const i3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t3.sortKey), a3 = i3.vertexLength;
              os(this.layoutVertexArray, r5, n4, -1, -1), os(this.layoutVertexArray, r5, n4, 1, -1), os(this.layoutVertexArray, r5, n4, 1, 1), os(this.layoutVertexArray, r5, n4, -1, 1), this.indexArray.emplaceBack(a3, a3 + 1, a3 + 2), this.indexArray.emplaceBack(a3, a3 + 3, a3 + 2), i3.vertexLength += 4, i3.primitiveLength += 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, {}, n3);
          }
        }
        function us(t3, e2) {
          for (let r3 = 0; r3 < t3.length; r3++) if (xs(e2, t3[r3])) return true;
          for (let r3 = 0; r3 < e2.length; r3++) if (xs(t3, e2[r3])) return true;
          return !!fs(t3, e2);
        }
        function cs(t3, e2, r3) {
          return !!xs(t3, e2) || !!ys(e2, t3, r3);
        }
        function hs(t3, e2) {
          if (1 === t3.length) return gs(e2, t3[0]);
          for (let r3 = 0; r3 < e2.length; r3++) {
            const n3 = e2[r3];
            for (let e3 = 0; e3 < n3.length; e3++) if (xs(t3, n3[e3])) return true;
          }
          for (let r3 = 0; r3 < t3.length; r3++) if (gs(e2, t3[r3])) return true;
          for (let r3 = 0; r3 < e2.length; r3++) if (fs(t3, e2[r3])) return true;
          return false;
        }
        function ps(t3, e2, r3) {
          if (t3.length > 1) {
            if (fs(t3, e2)) return true;
            for (let n3 = 0; n3 < e2.length; n3++) if (ys(e2[n3], t3, r3)) return true;
          }
          for (let n3 = 0; n3 < t3.length; n3++) if (ys(t3[n3], e2, r3)) return true;
          return false;
        }
        function fs(t3, e2) {
          if (0 === t3.length || 0 === e2.length) return false;
          for (let r3 = 0; r3 < t3.length - 1; r3++) {
            const n3 = t3[r3], i3 = t3[r3 + 1];
            for (let t4 = 0; t4 < e2.length - 1; t4++) if (ds(n3, i3, e2[t4], e2[t4 + 1])) return true;
          }
          return false;
        }
        function ds(t3, e2, r3, n3) {
          return S2(t3, r3, n3) !== S2(e2, r3, n3) && S2(t3, e2, r3) !== S2(t3, e2, n3);
        }
        function ys(t3, e2, r3) {
          const n3 = r3 * r3;
          if (1 === e2.length) return t3.distSqr(e2[0]) < n3;
          for (let r4 = 1; r4 < e2.length; r4++) if (ms(t3, e2[r4 - 1], e2[r4]) < n3) return true;
          return false;
        }
        function ms(t3, e2, r3) {
          const n3 = e2.distSqr(r3);
          if (0 === n3) return t3.distSqr(e2);
          const i3 = ((t3.x - e2.x) * (r3.x - e2.x) + (t3.y - e2.y) * (r3.y - e2.y)) / n3;
          return t3.distSqr(i3 < 0 ? e2 : i3 > 1 ? r3 : r3.sub(e2)._mult(i3)._add(e2));
        }
        function gs(t3, e2) {
          let r3, n3, i3, a3 = false;
          for (let s3 = 0; s3 < t3.length; s3++) {
            r3 = t3[s3];
            for (let t4 = 0, s4 = r3.length - 1; t4 < r3.length; s4 = t4++) n3 = r3[t4], i3 = r3[s4], n3.y > e2.y != i3.y > e2.y && e2.x < (i3.x - n3.x) * (e2.y - n3.y) / (i3.y - n3.y) + n3.x && (a3 = !a3);
          }
          return a3;
        }
        function xs(t3, e2) {
          let r3 = false;
          for (let n3 = 0, i3 = t3.length - 1; n3 < t3.length; i3 = n3++) {
            const a3 = t3[n3], s3 = t3[i3];
            a3.y > e2.y != s3.y > e2.y && e2.x < (s3.x - a3.x) * (e2.y - a3.y) / (s3.y - a3.y) + a3.x && (r3 = !r3);
          }
          return r3;
        }
        function vs(t3, e2, r3) {
          const n3 = r3[0], i3 = r3[2];
          if (t3.x < n3.x && e2.x < n3.x || t3.x > i3.x && e2.x > i3.x || t3.y < n3.y && e2.y < n3.y || t3.y > i3.y && e2.y > i3.y) return false;
          const a3 = S2(t3, e2, r3[0]);
          return a3 !== S2(t3, e2, r3[1]) || a3 !== S2(t3, e2, r3[2]) || a3 !== S2(t3, e2, r3[3]);
        }
        function bs(t3, e2, r3) {
          const n3 = e2.paint.get(t3).value;
          return "constant" === n3.kind ? n3.value : r3.programConfigurations.get(e2.id).getMaxValue(t3);
        }
        function ws(t3) {
          return Math.sqrt(t3[0] * t3[0] + t3[1] * t3[1]);
        }
        function _s(t3, e2, r3, n3, i3) {
          if (!e2[0] && !e2[1]) return t3;
          const s3 = a2.convert(e2)._mult(i3);
          "viewport" === r3 && s3._rotate(-n3);
          const o3 = [];
          for (let e3 = 0; e3 < t3.length; e3++) o3.push(t3[e3].sub(s3));
          return o3;
        }
        let As, Ss;
        $n("CircleBucket", ls, { omit: ["layers"] });
        var ks = { get paint() {
          return Ss = Ss || new _i({ "circle-radius": new xi(X2.paint_circle["circle-radius"]), "circle-color": new xi(X2.paint_circle["circle-color"]), "circle-blur": new xi(X2.paint_circle["circle-blur"]), "circle-opacity": new xi(X2.paint_circle["circle-opacity"]), "circle-translate": new gi(X2.paint_circle["circle-translate"]), "circle-translate-anchor": new gi(X2.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new gi(X2.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new gi(X2.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new xi(X2.paint_circle["circle-stroke-width"]), "circle-stroke-color": new xi(X2.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new xi(X2.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return As = As || new _i({ "circle-sort-key": new xi(X2.layout_circle["circle-sort-key"]) });
        } }, Is = 1e-6, zs = "undefined" != typeof Float32Array ? Float32Array : Array;
        function Ms(t3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }
        function Cs(t3, e2, r3) {
          var n3 = e2[0], i3 = e2[1], a3 = e2[2], s3 = e2[3], o3 = e2[4], l3 = e2[5], u3 = e2[6], c3 = e2[7], h3 = e2[8], p3 = e2[9], f3 = e2[10], d3 = e2[11], y3 = e2[12], m3 = e2[13], g3 = e2[14], x3 = e2[15], v3 = r3[0], b3 = r3[1], w3 = r3[2], _3 = r3[3];
          return t3[0] = v3 * n3 + b3 * o3 + w3 * h3 + _3 * y3, t3[1] = v3 * i3 + b3 * l3 + w3 * p3 + _3 * m3, t3[2] = v3 * a3 + b3 * u3 + w3 * f3 + _3 * g3, t3[3] = v3 * s3 + b3 * c3 + w3 * d3 + _3 * x3, t3[4] = (v3 = r3[4]) * n3 + (b3 = r3[5]) * o3 + (w3 = r3[6]) * h3 + (_3 = r3[7]) * y3, t3[5] = v3 * i3 + b3 * l3 + w3 * p3 + _3 * m3, t3[6] = v3 * a3 + b3 * u3 + w3 * f3 + _3 * g3, t3[7] = v3 * s3 + b3 * c3 + w3 * d3 + _3 * x3, t3[8] = (v3 = r3[8]) * n3 + (b3 = r3[9]) * o3 + (w3 = r3[10]) * h3 + (_3 = r3[11]) * y3, t3[9] = v3 * i3 + b3 * l3 + w3 * p3 + _3 * m3, t3[10] = v3 * a3 + b3 * u3 + w3 * f3 + _3 * g3, t3[11] = v3 * s3 + b3 * c3 + w3 * d3 + _3 * x3, t3[12] = (v3 = r3[12]) * n3 + (b3 = r3[13]) * o3 + (w3 = r3[14]) * h3 + (_3 = r3[15]) * y3, t3[13] = v3 * i3 + b3 * l3 + w3 * p3 + _3 * m3, t3[14] = v3 * a3 + b3 * u3 + w3 * f3 + _3 * g3, t3[15] = v3 * s3 + b3 * c3 + w3 * d3 + _3 * x3, t3;
        }
        Math.hypot || (Math.hypot = function() {
          for (var t3 = 0, e2 = arguments.length; e2--; ) t3 += arguments[e2] * arguments[e2];
          return Math.sqrt(t3);
        });
        var Bs, Ps = Cs;
        function Vs(t3, e2, r3) {
          var n3 = e2[0], i3 = e2[1], a3 = e2[2], s3 = e2[3];
          return t3[0] = r3[0] * n3 + r3[4] * i3 + r3[8] * a3 + r3[12] * s3, t3[1] = r3[1] * n3 + r3[5] * i3 + r3[9] * a3 + r3[13] * s3, t3[2] = r3[2] * n3 + r3[6] * i3 + r3[10] * a3 + r3[14] * s3, t3[3] = r3[3] * n3 + r3[7] * i3 + r3[11] * a3 + r3[15] * s3, t3;
        }
        Bs = new zs(4), zs != Float32Array && (Bs[0] = 0, Bs[1] = 0, Bs[2] = 0, Bs[3] = 0);
        class Es extends Si {
          constructor(t3) {
            super(t3, ks);
          }
          createBucket(t3) {
            return new ls(t3);
          }
          queryRadius(t3) {
            const e2 = t3;
            return bs("circle-radius", this, e2) + bs("circle-stroke-width", this, e2) + ws(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t3, e2, r3, n3, i3, a3, s3, o3) {
            const l3 = _s(t3, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a3.angle, s3), u3 = this.paint.get("circle-radius").evaluate(e2, r3) + this.paint.get("circle-stroke-width").evaluate(e2, r3), c3 = "map" === this.paint.get("circle-pitch-alignment"), h3 = c3 ? l3 : function(t4, e3) {
              return t4.map((t5) => Fs(t5, e3));
            }(l3, o3), p3 = c3 ? u3 * s3 : u3;
            for (const t4 of n3) for (const e3 of t4) {
              const t5 = c3 ? e3 : Fs(e3, o3);
              let r4 = p3;
              const n4 = Vs([], [e3.x, e3.y, 0, 1], o3);
              if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r4 *= n4[3] / a3.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r4 *= a3.cameraToCenterDistance / n4[3]), cs(h3, t5, r4)) return true;
            }
            return false;
          }
        }
        function Fs(t3, e2) {
          const r3 = Vs([], [t3.x, t3.y, 0, 1], e2);
          return new a2(r3[0] / r3[3], r3[1] / r3[3]);
        }
        class Ts extends ls {
        }
        let $s;
        $n("HeatmapBucket", Ts, { omit: ["layers"] });
        var Ls = { get paint() {
          return $s = $s || new _i({ "heatmap-radius": new xi(X2.paint_heatmap["heatmap-radius"]), "heatmap-weight": new xi(X2.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new gi(X2.paint_heatmap["heatmap-intensity"]), "heatmap-color": new wi(X2.paint_heatmap["heatmap-color"]), "heatmap-opacity": new gi(X2.paint_heatmap["heatmap-opacity"]) });
        } };
        function Ds(t3, { width: e2, height: r3 }, n3, i3) {
          if (i3) {
            if (i3 instanceof Uint8ClampedArray) i3 = new Uint8Array(i3.buffer);
            else if (i3.length !== e2 * r3 * n3) throw new RangeError(`mismatched image size. expected: ${i3.length} but got: ${e2 * r3 * n3}`);
          } else i3 = new Uint8Array(e2 * r3 * n3);
          return t3.width = e2, t3.height = r3, t3.data = i3, t3;
        }
        function Os(t3, { width: e2, height: r3 }, n3) {
          if (e2 === t3.width && r3 === t3.height) return;
          const i3 = Ds({}, { width: e2, height: r3 }, n3);
          Us(t3, i3, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t3.width, e2), height: Math.min(t3.height, r3) }, n3), t3.width = e2, t3.height = r3, t3.data = i3.data;
        }
        function Us(t3, e2, r3, n3, i3, a3) {
          if (0 === i3.width || 0 === i3.height) return e2;
          if (i3.width > t3.width || i3.height > t3.height || r3.x > t3.width - i3.width || r3.y > t3.height - i3.height) throw new RangeError("out of range source coordinates for image copy");
          if (i3.width > e2.width || i3.height > e2.height || n3.x > e2.width - i3.width || n3.y > e2.height - i3.height) throw new RangeError("out of range destination coordinates for image copy");
          const s3 = t3.data, o3 = e2.data;
          if (s3 === o3) throw new Error("srcData equals dstData, so image is already copied");
          for (let l3 = 0; l3 < i3.height; l3++) {
            const u3 = ((r3.y + l3) * t3.width + r3.x) * a3, c3 = ((n3.y + l3) * e2.width + n3.x) * a3;
            for (let t4 = 0; t4 < i3.width * a3; t4++) o3[c3 + t4] = s3[u3 + t4];
          }
          return e2;
        }
        class Rs {
          constructor(t3, e2) {
            Ds(this, t3, 1, e2);
          }
          resize(t3) {
            Os(this, t3, 1);
          }
          clone() {
            return new Rs({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t3, e2, r3, n3, i3) {
            Us(t3, e2, r3, n3, i3, 1);
          }
        }
        class qs {
          constructor(t3, e2) {
            Ds(this, t3, 4, e2);
          }
          resize(t3) {
            Os(this, t3, 4);
          }
          replace(t3, e2) {
            e2 ? this.data.set(t3) : this.data = t3 instanceof Uint8ClampedArray ? new Uint8Array(t3.buffer) : t3;
          }
          clone() {
            return new qs({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t3, e2, r3, n3, i3) {
            Us(t3, e2, r3, n3, i3, 4);
          }
        }
        function js(t3) {
          const e2 = {}, r3 = t3.resolution || 256, n3 = t3.clips ? t3.clips.length : 1, i3 = t3.image || new qs({ width: r3, height: n3 });
          if (Math.log(r3) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r3}`);
          const a3 = (r4, n4, a4) => {
            e2[t3.evaluationKey] = a4;
            const s3 = t3.expression.evaluate(e2);
            i3.data[r4 + n4 + 0] = Math.floor(255 * s3.r / s3.a), i3.data[r4 + n4 + 1] = Math.floor(255 * s3.g / s3.a), i3.data[r4 + n4 + 2] = Math.floor(255 * s3.b / s3.a), i3.data[r4 + n4 + 3] = Math.floor(255 * s3.a);
          };
          if (t3.clips) for (let e3 = 0, i4 = 0; e3 < n3; ++e3, i4 += 4 * r3) for (let n4 = 0, s3 = 0; n4 < r3; n4++, s3 += 4) {
            const o3 = n4 / (r3 - 1), { start: l3, end: u3 } = t3.clips[e3];
            a3(i4, s3, l3 * (1 - o3) + u3 * o3);
          }
          else for (let t4 = 0, e3 = 0; t4 < r3; t4++, e3 += 4) a3(0, e3, t4 / (r3 - 1));
          return i3;
        }
        $n("AlphaImage", Rs), $n("RGBAImage", qs);
        class Ns extends Si {
          createBucket(t3) {
            return new Ts(t3);
          }
          constructor(t3) {
            super(t3, Ls), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            "heatmap-color" === t3 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = js({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
        }
        let Zs;
        var Ks = { get paint() {
          return Zs = Zs || new _i({ "hillshade-illumination-direction": new gi(X2.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new gi(X2.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new gi(X2.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new gi(X2.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new gi(X2.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new gi(X2.paint_hillshade["hillshade-accent-color"]) });
        } };
        class Gs extends Si {
          constructor(t3) {
            super(t3, Ks);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
        }
        const Js = Mi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Xs } = Js;
        var Ys = { exports: {} };
        function Hs(t3, e2, r3) {
          r3 = r3 || 2;
          var n3, i3, a3, s3, o3, l3, u3, c3 = e2 && e2.length, h3 = c3 ? e2[0] * r3 : t3.length, p3 = Ws(t3, 0, h3, r3, true), f3 = [];
          if (!p3 || p3.next === p3.prev) return f3;
          if (c3 && (p3 = function(t4, e3, r4, n4) {
            var i4, a4, s4, o4 = [];
            for (i4 = 0, a4 = e3.length; i4 < a4; i4++) (s4 = Ws(t4, e3[i4] * n4, i4 < a4 - 1 ? e3[i4 + 1] * n4 : t4.length, n4, false)) === s4.next && (s4.steiner = true), o4.push(uo(s4));
            for (o4.sort(ao), i4 = 0; i4 < o4.length; i4++) r4 = so(o4[i4], r4);
            return r4;
          }(t3, e2, p3, r3)), t3.length > 80 * r3) {
            n3 = a3 = t3[0], i3 = s3 = t3[1];
            for (var d3 = r3; d3 < h3; d3 += r3) (o3 = t3[d3]) < n3 && (n3 = o3), (l3 = t3[d3 + 1]) < i3 && (i3 = l3), o3 > a3 && (a3 = o3), l3 > s3 && (s3 = l3);
            u3 = 0 !== (u3 = Math.max(a3 - n3, s3 - i3)) ? 32767 / u3 : 0;
          }
          return to2(p3, f3, r3, n3, i3, u3, 0), f3;
        }
        function Ws(t3, e2, r3, n3, i3) {
          var a3, s3;
          if (i3 === Ao(t3, e2, r3, n3) > 0) for (a3 = e2; a3 < r3; a3 += n3) s3 = bo(a3, t3[a3], t3[a3 + 1], s3);
          else for (a3 = r3 - n3; a3 >= e2; a3 -= n3) s3 = bo(a3, t3[a3], t3[a3 + 1], s3);
          return s3 && fo(s3, s3.next) && (wo(s3), s3 = s3.next), s3;
        }
        function Qs(t3, e2) {
          if (!t3) return t3;
          e2 || (e2 = t3);
          var r3, n3 = t3;
          do {
            if (r3 = false, n3.steiner || !fo(n3, n3.next) && 0 !== po(n3.prev, n3, n3.next)) n3 = n3.next;
            else {
              if (wo(n3), (n3 = e2 = n3.prev) === n3.next) break;
              r3 = true;
            }
          } while (r3 || n3 !== e2);
          return e2;
        }
        function to2(t3, e2, r3, n3, i3, a3, s3) {
          if (t3) {
            !s3 && a3 && function(t4, e3, r4, n4) {
              var i4 = t4;
              do {
                0 === i4.z && (i4.z = lo(i4.x, i4.y, e3, r4, n4)), i4.prevZ = i4.prev, i4.nextZ = i4.next, i4 = i4.next;
              } while (i4 !== t4);
              i4.prevZ.nextZ = null, i4.prevZ = null, function(t5) {
                var e4, r5, n5, i5, a4, s4, o4, l4, u4 = 1;
                do {
                  for (r5 = t5, t5 = null, a4 = null, s4 = 0; r5; ) {
                    for (s4++, n5 = r5, o4 = 0, e4 = 0; e4 < u4 && (o4++, n5 = n5.nextZ); e4++) ;
                    for (l4 = u4; o4 > 0 || l4 > 0 && n5; ) 0 !== o4 && (0 === l4 || !n5 || r5.z <= n5.z) ? (i5 = r5, r5 = r5.nextZ, o4--) : (i5 = n5, n5 = n5.nextZ, l4--), a4 ? a4.nextZ = i5 : t5 = i5, i5.prevZ = a4, a4 = i5;
                    r5 = n5;
                  }
                  a4.nextZ = null, u4 *= 2;
                } while (s4 > 1);
              }(i4);
            }(t3, n3, i3, a3);
            for (var o3, l3, u3 = t3; t3.prev !== t3.next; ) if (o3 = t3.prev, l3 = t3.next, a3 ? ro(t3, n3, i3, a3) : eo(t3)) e2.push(o3.i / r3 | 0), e2.push(t3.i / r3 | 0), e2.push(l3.i / r3 | 0), wo(t3), t3 = l3.next, u3 = l3.next;
            else if ((t3 = l3) === u3) {
              s3 ? 1 === s3 ? to2(t3 = no(Qs(t3), e2, r3), e2, r3, n3, i3, a3, 2) : 2 === s3 && io(t3, e2, r3, n3, i3, a3) : to2(Qs(t3), e2, r3, n3, i3, a3, 1);
              break;
            }
          }
        }
        function eo(t3) {
          var e2 = t3.prev, r3 = t3, n3 = t3.next;
          if (po(e2, r3, n3) >= 0) return false;
          for (var i3 = e2.x, a3 = r3.x, s3 = n3.x, o3 = e2.y, l3 = r3.y, u3 = n3.y, c3 = i3 < a3 ? i3 < s3 ? i3 : s3 : a3 < s3 ? a3 : s3, h3 = o3 < l3 ? o3 < u3 ? o3 : u3 : l3 < u3 ? l3 : u3, p3 = i3 > a3 ? i3 > s3 ? i3 : s3 : a3 > s3 ? a3 : s3, f3 = o3 > l3 ? o3 > u3 ? o3 : u3 : l3 > u3 ? l3 : u3, d3 = n3.next; d3 !== e2; ) {
            if (d3.x >= c3 && d3.x <= p3 && d3.y >= h3 && d3.y <= f3 && co(i3, o3, a3, l3, s3, u3, d3.x, d3.y) && po(d3.prev, d3, d3.next) >= 0) return false;
            d3 = d3.next;
          }
          return true;
        }
        function ro(t3, e2, r3, n3) {
          var i3 = t3.prev, a3 = t3, s3 = t3.next;
          if (po(i3, a3, s3) >= 0) return false;
          for (var o3 = i3.x, l3 = a3.x, u3 = s3.x, c3 = i3.y, h3 = a3.y, p3 = s3.y, f3 = o3 < l3 ? o3 < u3 ? o3 : u3 : l3 < u3 ? l3 : u3, d3 = c3 < h3 ? c3 < p3 ? c3 : p3 : h3 < p3 ? h3 : p3, y3 = o3 > l3 ? o3 > u3 ? o3 : u3 : l3 > u3 ? l3 : u3, m3 = c3 > h3 ? c3 > p3 ? c3 : p3 : h3 > p3 ? h3 : p3, g3 = lo(f3, d3, e2, r3, n3), x3 = lo(y3, m3, e2, r3, n3), v3 = t3.prevZ, b3 = t3.nextZ; v3 && v3.z >= g3 && b3 && b3.z <= x3; ) {
            if (v3.x >= f3 && v3.x <= y3 && v3.y >= d3 && v3.y <= m3 && v3 !== i3 && v3 !== s3 && co(o3, c3, l3, h3, u3, p3, v3.x, v3.y) && po(v3.prev, v3, v3.next) >= 0) return false;
            if (v3 = v3.prevZ, b3.x >= f3 && b3.x <= y3 && b3.y >= d3 && b3.y <= m3 && b3 !== i3 && b3 !== s3 && co(o3, c3, l3, h3, u3, p3, b3.x, b3.y) && po(b3.prev, b3, b3.next) >= 0) return false;
            b3 = b3.nextZ;
          }
          for (; v3 && v3.z >= g3; ) {
            if (v3.x >= f3 && v3.x <= y3 && v3.y >= d3 && v3.y <= m3 && v3 !== i3 && v3 !== s3 && co(o3, c3, l3, h3, u3, p3, v3.x, v3.y) && po(v3.prev, v3, v3.next) >= 0) return false;
            v3 = v3.prevZ;
          }
          for (; b3 && b3.z <= x3; ) {
            if (b3.x >= f3 && b3.x <= y3 && b3.y >= d3 && b3.y <= m3 && b3 !== i3 && b3 !== s3 && co(o3, c3, l3, h3, u3, p3, b3.x, b3.y) && po(b3.prev, b3, b3.next) >= 0) return false;
            b3 = b3.nextZ;
          }
          return true;
        }
        function no(t3, e2, r3) {
          var n3 = t3;
          do {
            var i3 = n3.prev, a3 = n3.next.next;
            !fo(i3, a3) && yo(i3, n3, n3.next, a3) && xo(i3, a3) && xo(a3, i3) && (e2.push(i3.i / r3 | 0), e2.push(n3.i / r3 | 0), e2.push(a3.i / r3 | 0), wo(n3), wo(n3.next), n3 = t3 = a3), n3 = n3.next;
          } while (n3 !== t3);
          return Qs(n3);
        }
        function io(t3, e2, r3, n3, i3, a3) {
          var s3 = t3;
          do {
            for (var o3 = s3.next.next; o3 !== s3.prev; ) {
              if (s3.i !== o3.i && ho(s3, o3)) {
                var l3 = vo(s3, o3);
                return s3 = Qs(s3, s3.next), l3 = Qs(l3, l3.next), to2(s3, e2, r3, n3, i3, a3, 0), void to2(l3, e2, r3, n3, i3, a3, 0);
              }
              o3 = o3.next;
            }
            s3 = s3.next;
          } while (s3 !== t3);
        }
        function ao(t3, e2) {
          return t3.x - e2.x;
        }
        function so(t3, e2) {
          var r3 = function(t4, e3) {
            var r4, n4 = e3, i3 = t4.x, a3 = t4.y, s3 = -1 / 0;
            do {
              if (a3 <= n4.y && a3 >= n4.next.y && n4.next.y !== n4.y) {
                var o3 = n4.x + (a3 - n4.y) * (n4.next.x - n4.x) / (n4.next.y - n4.y);
                if (o3 <= i3 && o3 > s3 && (s3 = o3, r4 = n4.x < n4.next.x ? n4 : n4.next, o3 === i3)) return r4;
              }
              n4 = n4.next;
            } while (n4 !== e3);
            if (!r4) return null;
            var l3, u3 = r4, c3 = r4.x, h3 = r4.y, p3 = 1 / 0;
            n4 = r4;
            do {
              i3 >= n4.x && n4.x >= c3 && i3 !== n4.x && co(a3 < h3 ? i3 : s3, a3, c3, h3, a3 < h3 ? s3 : i3, a3, n4.x, n4.y) && (l3 = Math.abs(a3 - n4.y) / (i3 - n4.x), xo(n4, t4) && (l3 < p3 || l3 === p3 && (n4.x > r4.x || n4.x === r4.x && oo(r4, n4))) && (r4 = n4, p3 = l3)), n4 = n4.next;
            } while (n4 !== u3);
            return r4;
          }(t3, e2);
          if (!r3) return e2;
          var n3 = vo(r3, t3);
          return Qs(n3, n3.next), Qs(r3, r3.next);
        }
        function oo(t3, e2) {
          return po(t3.prev, t3, e2.prev) < 0 && po(e2.next, t3, t3.next) < 0;
        }
        function lo(t3, e2, r3, n3, i3) {
          return (t3 = 1431655765 & ((t3 = 858993459 & ((t3 = 252645135 & ((t3 = 16711935 & ((t3 = (t3 - r3) * i3 | 0) | t3 << 8)) | t3 << 4)) | t3 << 2)) | t3 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n3) * i3 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
        }
        function uo(t3) {
          var e2 = t3, r3 = t3;
          do {
            (e2.x < r3.x || e2.x === r3.x && e2.y < r3.y) && (r3 = e2), e2 = e2.next;
          } while (e2 !== t3);
          return r3;
        }
        function co(t3, e2, r3, n3, i3, a3, s3, o3) {
          return (i3 - s3) * (e2 - o3) >= (t3 - s3) * (a3 - o3) && (t3 - s3) * (n3 - o3) >= (r3 - s3) * (e2 - o3) && (r3 - s3) * (a3 - o3) >= (i3 - s3) * (n3 - o3);
        }
        function ho(t3, e2) {
          return t3.next.i !== e2.i && t3.prev.i !== e2.i && !function(t4, e3) {
            var r3 = t4;
            do {
              if (r3.i !== t4.i && r3.next.i !== t4.i && r3.i !== e3.i && r3.next.i !== e3.i && yo(r3, r3.next, t4, e3)) return true;
              r3 = r3.next;
            } while (r3 !== t4);
            return false;
          }(t3, e2) && (xo(t3, e2) && xo(e2, t3) && function(t4, e3) {
            var r3 = t4, n3 = false, i3 = (t4.x + e3.x) / 2, a3 = (t4.y + e3.y) / 2;
            do {
              r3.y > a3 != r3.next.y > a3 && r3.next.y !== r3.y && i3 < (r3.next.x - r3.x) * (a3 - r3.y) / (r3.next.y - r3.y) + r3.x && (n3 = !n3), r3 = r3.next;
            } while (r3 !== t4);
            return n3;
          }(t3, e2) && (po(t3.prev, t3, e2.prev) || po(t3, e2.prev, e2)) || fo(t3, e2) && po(t3.prev, t3, t3.next) > 0 && po(e2.prev, e2, e2.next) > 0);
        }
        function po(t3, e2, r3) {
          return (e2.y - t3.y) * (r3.x - e2.x) - (e2.x - t3.x) * (r3.y - e2.y);
        }
        function fo(t3, e2) {
          return t3.x === e2.x && t3.y === e2.y;
        }
        function yo(t3, e2, r3, n3) {
          var i3 = go(po(t3, e2, r3)), a3 = go(po(t3, e2, n3)), s3 = go(po(r3, n3, t3)), o3 = go(po(r3, n3, e2));
          return i3 !== a3 && s3 !== o3 || !(0 !== i3 || !mo(t3, r3, e2)) || !(0 !== a3 || !mo(t3, n3, e2)) || !(0 !== s3 || !mo(r3, t3, n3)) || !(0 !== o3 || !mo(r3, e2, n3));
        }
        function mo(t3, e2, r3) {
          return e2.x <= Math.max(t3.x, r3.x) && e2.x >= Math.min(t3.x, r3.x) && e2.y <= Math.max(t3.y, r3.y) && e2.y >= Math.min(t3.y, r3.y);
        }
        function go(t3) {
          return t3 > 0 ? 1 : t3 < 0 ? -1 : 0;
        }
        function xo(t3, e2) {
          return po(t3.prev, t3, t3.next) < 0 ? po(t3, e2, t3.next) >= 0 && po(t3, t3.prev, e2) >= 0 : po(t3, e2, t3.prev) < 0 || po(t3, t3.next, e2) < 0;
        }
        function vo(t3, e2) {
          var r3 = new _o(t3.i, t3.x, t3.y), n3 = new _o(e2.i, e2.x, e2.y), i3 = t3.next, a3 = e2.prev;
          return t3.next = e2, e2.prev = t3, r3.next = i3, i3.prev = r3, n3.next = r3, r3.prev = n3, a3.next = n3, n3.prev = a3, n3;
        }
        function bo(t3, e2, r3, n3) {
          var i3 = new _o(t3, e2, r3);
          return n3 ? (i3.next = n3.next, i3.prev = n3, n3.next.prev = i3, n3.next = i3) : (i3.prev = i3, i3.next = i3), i3;
        }
        function wo(t3) {
          t3.next.prev = t3.prev, t3.prev.next = t3.next, t3.prevZ && (t3.prevZ.nextZ = t3.nextZ), t3.nextZ && (t3.nextZ.prevZ = t3.prevZ);
        }
        function _o(t3, e2, r3) {
          this.i = t3, this.x = e2, this.y = r3, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        function Ao(t3, e2, r3, n3) {
          for (var i3 = 0, a3 = e2, s3 = r3 - n3; a3 < r3; a3 += n3) i3 += (t3[s3] - t3[a3]) * (t3[a3 + 1] + t3[s3 + 1]), s3 = a3;
          return i3;
        }
        Ys.exports = Hs, Ys.exports.default = Hs, Hs.deviation = function(t3, e2, r3, n3) {
          var i3 = e2 && e2.length, a3 = Math.abs(Ao(t3, 0, i3 ? e2[0] * r3 : t3.length, r3));
          if (i3) for (var s3 = 0, o3 = e2.length; s3 < o3; s3++) a3 -= Math.abs(Ao(t3, e2[s3] * r3, s3 < o3 - 1 ? e2[s3 + 1] * r3 : t3.length, r3));
          var l3 = 0;
          for (s3 = 0; s3 < n3.length; s3 += 3) {
            var u3 = n3[s3] * r3, c3 = n3[s3 + 1] * r3, h3 = n3[s3 + 2] * r3;
            l3 += Math.abs((t3[u3] - t3[h3]) * (t3[c3 + 1] - t3[u3 + 1]) - (t3[u3] - t3[c3]) * (t3[h3 + 1] - t3[u3 + 1]));
          }
          return 0 === a3 && 0 === l3 ? 0 : Math.abs((l3 - a3) / a3);
        }, Hs.flatten = function(t3) {
          for (var e2 = t3[0][0].length, r3 = { vertices: [], holes: [], dimensions: e2 }, n3 = 0, i3 = 0; i3 < t3.length; i3++) {
            for (var a3 = 0; a3 < t3[i3].length; a3++) for (var s3 = 0; s3 < e2; s3++) r3.vertices.push(t3[i3][a3][s3]);
            i3 > 0 && r3.holes.push(n3 += t3[i3 - 1].length);
          }
          return r3;
        };
        var So = r2(Ys.exports);
        function ko(t3, e2, r3, n3, i3) {
          Io(t3, e2, r3, n3 || t3.length - 1, i3 || Mo);
        }
        function Io(t3, e2, r3, n3, i3) {
          for (; n3 > r3; ) {
            if (n3 - r3 > 600) {
              var a3 = n3 - r3 + 1, s3 = e2 - r3 + 1, o3 = Math.log(a3), l3 = 0.5 * Math.exp(2 * o3 / 3), u3 = 0.5 * Math.sqrt(o3 * l3 * (a3 - l3) / a3) * (s3 - a3 / 2 < 0 ? -1 : 1);
              Io(t3, e2, Math.max(r3, Math.floor(e2 - s3 * l3 / a3 + u3)), Math.min(n3, Math.floor(e2 + (a3 - s3) * l3 / a3 + u3)), i3);
            }
            var c3 = t3[e2], h3 = r3, p3 = n3;
            for (zo(t3, r3, e2), i3(t3[n3], c3) > 0 && zo(t3, r3, n3); h3 < p3; ) {
              for (zo(t3, h3, p3), h3++, p3--; i3(t3[h3], c3) < 0; ) h3++;
              for (; i3(t3[p3], c3) > 0; ) p3--;
            }
            0 === i3(t3[r3], c3) ? zo(t3, r3, p3) : zo(t3, ++p3, n3), p3 <= e2 && (r3 = p3 + 1), e2 <= p3 && (n3 = p3 - 1);
          }
        }
        function zo(t3, e2, r3) {
          var n3 = t3[e2];
          t3[e2] = t3[r3], t3[r3] = n3;
        }
        function Mo(t3, e2) {
          return t3 < e2 ? -1 : t3 > e2 ? 1 : 0;
        }
        function Co(t3, e2) {
          const r3 = t3.length;
          if (r3 <= 1) return [t3];
          const n3 = [];
          let i3, a3;
          for (let e3 = 0; e3 < r3; e3++) {
            const r4 = k2(t3[e3]);
            0 !== r4 && (t3[e3].area = Math.abs(r4), void 0 === a3 && (a3 = r4 < 0), a3 === r4 < 0 ? (i3 && n3.push(i3), i3 = [t3[e3]]) : i3.push(t3[e3]));
          }
          if (i3 && n3.push(i3), e2 > 1) for (let t4 = 0; t4 < n3.length; t4++) n3[t4].length <= e2 || (ko(n3[t4], e2, 1, n3[t4].length - 1, Bo), n3[t4] = n3[t4].slice(0, e2));
          return n3;
        }
        function Bo(t3, e2) {
          return e2.area - t3.area;
        }
        function Po(t3, e2, r3) {
          const n3 = r3.patternDependencies;
          let i3 = false;
          for (const r4 of e2) {
            const e3 = r4.paint.get(`${t3}-pattern`);
            e3.isConstant() || (i3 = true);
            const a3 = e3.constantOr(null);
            a3 && (i3 = true, n3[a3.to] = true, n3[a3.from] = true);
          }
          return i3;
        }
        function Vo(t3, e2, r3, n3, i3) {
          const a3 = i3.patternDependencies;
          for (const s3 of e2) {
            const e3 = s3.paint.get(`${t3}-pattern`).value;
            if ("constant" !== e3.kind) {
              let t4 = e3.evaluate({ zoom: n3 - 1 }, r3, {}, i3.availableImages), o3 = e3.evaluate({ zoom: n3 }, r3, {}, i3.availableImages), l3 = e3.evaluate({ zoom: n3 + 1 }, r3, {}, i3.availableImages);
              t4 = t4 && t4.name ? t4.name : t4, o3 = o3 && o3.name ? o3.name : o3, l3 = l3 && l3.name ? l3.name : l3, a3[t4] = true, a3[o3] = true, a3[l3] = true, r3.patterns[s3.id] = { min: t4, mid: o3, max: l3 };
            }
          }
          return r3;
        }
        class Eo {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new fa(), this.indexArray = new Aa(), this.indexArray2 = new Sa(), this.programConfigurations = new Qa(t3.layers, t3.zoom), this.segments = new za(), this.segments2 = new za(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e2, r3) {
            this.hasPattern = Po("fill", this.layers, e2);
            const n3 = this.layers[0].layout.get("fill-sort-key"), i3 = !n3.isConstant(), a3 = [];
            for (const { feature: s3, id: o3, index: l3, sourceLayerIndex: u3 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, c3 = ss2(s3, t4);
              if (!this.layers[0]._featureFilter.filter(new li(this.zoom), c3, r3)) continue;
              const h3 = i3 ? n3.evaluate(c3, {}, r3, e2.availableImages) : void 0, p3 = { id: o3, properties: s3.properties, type: s3.type, sourceLayerIndex: u3, index: l3, geometry: t4 ? c3.geometry : as(s3), patterns: {}, sortKey: h3 };
              a3.push(p3);
            }
            i3 && a3.sort((t4, e3) => t4.sortKey - e3.sortKey);
            for (const n4 of a3) {
              const { geometry: i4, index: a4, sourceLayerIndex: s3 } = n4;
              if (this.hasPattern) {
                const t4 = Vo("fill", this.layers, n4, this.zoom, e2);
                this.patternFeatures.push(t4);
              } else this.addFeature(n4, i4, a4, r3, {});
              e2.featureIndex.insert(t3[a4].feature, i4, a4, s3, this.index);
            }
          }
          update(t3, e2, r3) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e2, this.stateDependentLayers, r3);
          }
          addFeatures(t3, e2, r3) {
            for (const t4 of this.patternFeatures) this.addFeature(t4, t4.geometry, t4.index, e2, r3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Xs), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.indexBuffer2 = t3.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t3, e2, r3, n3, i3) {
            for (const t4 of Co(e2, 500)) {
              let e3 = 0;
              for (const r5 of t4) e3 += r5.length;
              const r4 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n4 = r4.vertexLength, i4 = [], a3 = [];
              for (const e4 of t4) {
                if (0 === e4.length) continue;
                e4 !== t4[0] && a3.push(i4.length / 2);
                const r5 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n5 = r5.vertexLength;
                this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n5 + e4.length - 1, n5), i4.push(e4[0].x), i4.push(e4[0].y);
                for (let t5 = 1; t5 < e4.length; t5++) this.layoutVertexArray.emplaceBack(e4[t5].x, e4[t5].y), this.indexArray2.emplaceBack(n5 + t5 - 1, n5 + t5), i4.push(e4[t5].x), i4.push(e4[t5].y);
                r5.vertexLength += e4.length, r5.primitiveLength += e4.length;
              }
              const s3 = So(i4, a3);
              for (let t5 = 0; t5 < s3.length; t5 += 3) this.indexArray.emplaceBack(n4 + s3[t5], n4 + s3[t5 + 1], n4 + s3[t5 + 2]);
              r4.vertexLength += e3, r4.primitiveLength += s3.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i3, n3);
          }
        }
        let Fo, To;
        $n("FillBucket", Eo, { omit: ["layers", "patternFeatures"] });
        var $o = { get paint() {
          return To = To || new _i({ "fill-antialias": new gi(X2.paint_fill["fill-antialias"]), "fill-opacity": new xi(X2.paint_fill["fill-opacity"]), "fill-color": new xi(X2.paint_fill["fill-color"]), "fill-outline-color": new xi(X2.paint_fill["fill-outline-color"]), "fill-translate": new gi(X2.paint_fill["fill-translate"]), "fill-translate-anchor": new gi(X2.paint_fill["fill-translate-anchor"]), "fill-pattern": new vi(X2.paint_fill["fill-pattern"]) });
        }, get layout() {
          return Fo = Fo || new _i({ "fill-sort-key": new xi(X2.layout_fill["fill-sort-key"]) });
        } };
        class Lo extends Si {
          constructor(t3) {
            super(t3, $o);
          }
          recalculate(t3, e2) {
            super.recalculate(t3, e2);
            const r3 = this.paint._values["fill-outline-color"];
            "constant" === r3.value.kind && void 0 === r3.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t3) {
            return new Eo(t3);
          }
          queryRadius() {
            return ws(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t3, e2, r3, n3, i3, a3, s3) {
            return hs(_s(t3, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a3.angle, s3), n3);
          }
          isTileClipped() {
            return true;
          }
        }
        const Do = Mi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Oo = Mi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Uo } = Do;
        var Ro = {}, qo = n2, jo = No;
        function No(t3, e2, r3, n3, i3) {
          this.properties = {}, this.extent = r3, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = n3, this._values = i3, t3.readFields(Zo, this, e2);
        }
        function Zo(t3, e2, r3) {
          1 == t3 ? e2.id = r3.readVarint() : 2 == t3 ? function(t4, e3) {
            for (var r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
              var n3 = e3._keys[t4.readVarint()], i3 = e3._values[t4.readVarint()];
              e3.properties[n3] = i3;
            }
          }(r3, e2) : 3 == t3 ? e2.type = r3.readVarint() : 4 == t3 && (e2._geometry = r3.pos);
        }
        function Ko(t3) {
          for (var e2, r3, n3 = 0, i3 = 0, a3 = t3.length, s3 = a3 - 1; i3 < a3; s3 = i3++) n3 += ((r3 = t3[s3]).x - (e2 = t3[i3]).x) * (e2.y + r3.y);
          return n3;
        }
        No.types = ["Unknown", "Point", "LineString", "Polygon"], No.prototype.loadGeometry = function() {
          var t3 = this._pbf;
          t3.pos = this._geometry;
          for (var e2, r3 = t3.readVarint() + t3.pos, n3 = 1, i3 = 0, a3 = 0, s3 = 0, o3 = []; t3.pos < r3; ) {
            if (i3 <= 0) {
              var l3 = t3.readVarint();
              n3 = 7 & l3, i3 = l3 >> 3;
            }
            if (i3--, 1 === n3 || 2 === n3) a3 += t3.readSVarint(), s3 += t3.readSVarint(), 1 === n3 && (e2 && o3.push(e2), e2 = []), e2.push(new qo(a3, s3));
            else {
              if (7 !== n3) throw new Error("unknown command " + n3);
              e2 && e2.push(e2[0].clone());
            }
          }
          return e2 && o3.push(e2), o3;
        }, No.prototype.bbox = function() {
          var t3 = this._pbf;
          t3.pos = this._geometry;
          for (var e2 = t3.readVarint() + t3.pos, r3 = 1, n3 = 0, i3 = 0, a3 = 0, s3 = 1 / 0, o3 = -1 / 0, l3 = 1 / 0, u3 = -1 / 0; t3.pos < e2; ) {
            if (n3 <= 0) {
              var c3 = t3.readVarint();
              r3 = 7 & c3, n3 = c3 >> 3;
            }
            if (n3--, 1 === r3 || 2 === r3) (i3 += t3.readSVarint()) < s3 && (s3 = i3), i3 > o3 && (o3 = i3), (a3 += t3.readSVarint()) < l3 && (l3 = a3), a3 > u3 && (u3 = a3);
            else if (7 !== r3) throw new Error("unknown command " + r3);
          }
          return [s3, l3, o3, u3];
        }, No.prototype.toGeoJSON = function(t3, e2, r3) {
          var n3, i3, a3 = this.extent * Math.pow(2, r3), s3 = this.extent * t3, o3 = this.extent * e2, l3 = this.loadGeometry(), u3 = No.types[this.type];
          function c3(t4) {
            for (var e3 = 0; e3 < t4.length; e3++) {
              var r4 = t4[e3];
              t4[e3] = [360 * (r4.x + s3) / a3 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r4.y + o3) / a3) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h3 = [];
              for (n3 = 0; n3 < l3.length; n3++) h3[n3] = l3[n3][0];
              c3(l3 = h3);
              break;
            case 2:
              for (n3 = 0; n3 < l3.length; n3++) c3(l3[n3]);
              break;
            case 3:
              for (l3 = function(t4) {
                var e3 = t4.length;
                if (e3 <= 1) return [t4];
                for (var r4, n4, i4 = [], a4 = 0; a4 < e3; a4++) {
                  var s4 = Ko(t4[a4]);
                  0 !== s4 && (void 0 === n4 && (n4 = s4 < 0), n4 === s4 < 0 ? (r4 && i4.push(r4), r4 = [t4[a4]]) : r4.push(t4[a4]));
                }
                return r4 && i4.push(r4), i4;
              }(l3), n3 = 0; n3 < l3.length; n3++) for (i3 = 0; i3 < l3[n3].length; i3++) c3(l3[n3][i3]);
          }
          1 === l3.length ? l3 = l3[0] : u3 = "Multi" + u3;
          var p3 = { type: "Feature", geometry: { type: u3, coordinates: l3 }, properties: this.properties };
          return "id" in this && (p3.id = this.id), p3;
        };
        var Go = jo, Jo = Xo;
        function Xo(t3, e2) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields(Yo, this, e2), this.length = this._features.length;
        }
        function Yo(t3, e2, r3) {
          15 === t3 ? e2.version = r3.readVarint() : 1 === t3 ? e2.name = r3.readString() : 5 === t3 ? e2.extent = r3.readVarint() : 2 === t3 ? e2._features.push(r3.pos) : 3 === t3 ? e2._keys.push(r3.readString()) : 4 === t3 && e2._values.push(function(t4) {
            for (var e3 = null, r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
              var n3 = t4.readVarint() >> 3;
              e3 = 1 === n3 ? t4.readString() : 2 === n3 ? t4.readFloat() : 3 === n3 ? t4.readDouble() : 4 === n3 ? t4.readVarint64() : 5 === n3 ? t4.readVarint() : 6 === n3 ? t4.readSVarint() : 7 === n3 ? t4.readBoolean() : null;
            }
            return e3;
          }(r3));
        }
        Xo.prototype.feature = function(t3) {
          if (t3 < 0 || t3 >= this._features.length) throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t3];
          var e2 = this._pbf.readVarint() + this._pbf.pos;
          return new Go(this._pbf, e2, this.extent, this._keys, this._values);
        };
        var Ho = Jo;
        function Wo(t3, e2, r3) {
          if (3 === t3) {
            var n3 = new Ho(r3, r3.readVarint() + r3.pos);
            n3.length && (e2[n3.name] = n3);
          }
        }
        Ro.VectorTile = function(t3, e2) {
          this.layers = t3.readFields(Wo, {}, e2);
        }, Ro.VectorTileFeature = jo, Ro.VectorTileLayer = Jo;
        const Qo = Ro.VectorTileFeature.types, tl = Math.pow(2, 13);
        function el(t3, e2, r3, n3, i3, a3, s3, o3) {
          t3.emplaceBack(e2, r3, 2 * Math.floor(n3 * tl) + s3, i3 * tl * 2, a3 * tl * 2, Math.round(o3));
        }
        class rl {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.layoutVertexArray = new da(), this.centroidVertexArray = new ha(), this.indexArray = new Aa(), this.programConfigurations = new Qa(t3.layers, t3.zoom), this.segments = new za(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e2, r3) {
            this.features = [], this.hasPattern = Po("fill-extrusion", this.layers, e2);
            for (const { feature: n3, id: i3, index: a3, sourceLayerIndex: s3 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, o3 = ss2(n3, t4);
              if (!this.layers[0]._featureFilter.filter(new li(this.zoom), o3, r3)) continue;
              const l3 = { id: i3, sourceLayerIndex: s3, index: a3, geometry: t4 ? o3.geometry : as(n3), properties: n3.properties, type: n3.type, patterns: {} };
              this.hasPattern ? this.features.push(Vo("fill-extrusion", this.layers, l3, this.zoom, e2)) : this.addFeature(l3, l3.geometry, a3, r3, {}), e2.featureIndex.insert(n3, l3.geometry, a3, s3, this.index, true);
            }
          }
          addFeatures(t3, e2, r3) {
            for (const t4 of this.features) {
              const { geometry: n3 } = t4;
              this.addFeature(t4, n3, t4.index, e2, r3);
            }
          }
          update(t3, e2, r3) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e2, this.stateDependentLayers, r3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Uo), this.centroidVertexBuffer = t3.createVertexBuffer(this.centroidVertexArray, Oo.members, true), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t3, e2, r3, n3, i3) {
            const a3 = { x: 0, y: 0, vertexCount: 0 };
            for (const r4 of Co(e2, 500)) {
              let e3 = 0;
              for (const t4 of r4) e3 += t4.length;
              let n4 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
              for (const t4 of r4) {
                if (0 === t4.length) continue;
                if (il(t4)) continue;
                let e4 = 0;
                for (let r5 = 0; r5 < t4.length; r5++) {
                  const i5 = t4[r5];
                  if (r5 >= 1) {
                    const s4 = t4[r5 - 1];
                    if (!nl(i5, s4)) {
                      n4.vertexLength + 4 > za.MAX_VERTEX_ARRAY_LENGTH && (n4 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                      const t5 = i5.sub(s4)._perp()._unit(), r6 = s4.dist(i5);
                      e4 + r6 > 32768 && (e4 = 0), el(this.layoutVertexArray, i5.x, i5.y, t5.x, t5.y, 0, 0, e4), el(this.layoutVertexArray, i5.x, i5.y, t5.x, t5.y, 0, 1, e4), a3.x += 2 * i5.x, a3.y += 2 * i5.y, a3.vertexCount += 2, e4 += r6, el(this.layoutVertexArray, s4.x, s4.y, t5.x, t5.y, 0, 0, e4), el(this.layoutVertexArray, s4.x, s4.y, t5.x, t5.y, 0, 1, e4), a3.x += 2 * s4.x, a3.y += 2 * s4.y, a3.vertexCount += 2;
                      const o4 = n4.vertexLength;
                      this.indexArray.emplaceBack(o4, o4 + 2, o4 + 1), this.indexArray.emplaceBack(o4 + 1, o4 + 2, o4 + 3), n4.vertexLength += 4, n4.primitiveLength += 2;
                    }
                  }
                }
              }
              if (n4.vertexLength + e3 > za.MAX_VERTEX_ARRAY_LENGTH && (n4 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray)), "Polygon" !== Qo[t3.type]) continue;
              const i4 = [], s3 = [], o3 = n4.vertexLength;
              for (const t4 of r4) if (0 !== t4.length) {
                t4 !== r4[0] && s3.push(i4.length / 2);
                for (let e4 = 0; e4 < t4.length; e4++) {
                  const r5 = t4[e4];
                  el(this.layoutVertexArray, r5.x, r5.y, 0, 0, 1, 1, 0), a3.x += r5.x, a3.y += r5.y, a3.vertexCount += 1, i4.push(r5.x), i4.push(r5.y);
                }
              }
              const l3 = So(i4, s3);
              for (let t4 = 0; t4 < l3.length; t4 += 3) this.indexArray.emplaceBack(o3 + l3[t4], o3 + l3[t4 + 2], o3 + l3[t4 + 1]);
              n4.primitiveLength += l3.length / 3, n4.vertexLength += e3;
            }
            for (let t4 = 0; t4 < a3.vertexCount; t4++) this.centroidVertexArray.emplaceBack(Math.floor(a3.x / a3.vertexCount), Math.floor(a3.y / a3.vertexCount));
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i3, n3);
          }
        }
        function nl(t3, e2) {
          return t3.x === e2.x && (t3.x < 0 || t3.x > rs) || t3.y === e2.y && (t3.y < 0 || t3.y > rs);
        }
        function il(t3) {
          return t3.every((t4) => t4.x < 0) || t3.every((t4) => t4.x > rs) || t3.every((t4) => t4.y < 0) || t3.every((t4) => t4.y > rs);
        }
        let al;
        $n("FillExtrusionBucket", rl, { omit: ["layers", "features"] });
        var sl = { get paint() {
          return al = al || new _i({ "fill-extrusion-opacity": new gi(X2["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new xi(X2["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new gi(X2["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new gi(X2["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new vi(X2["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new xi(X2["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new xi(X2["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new gi(X2["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class ol extends Si {
          constructor(t3) {
            super(t3, sl);
          }
          createBucket(t3) {
            return new rl(t3);
          }
          queryRadius() {
            return ws(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature(t3, e2, r3, n3, i3, s3, o3, l3) {
            const u3 = _s(t3, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s3.angle, o3), c3 = this.paint.get("fill-extrusion-height").evaluate(e2, r3), h3 = this.paint.get("fill-extrusion-base").evaluate(e2, r3), p3 = function(t4, e3, r4, n4) {
              const i4 = [];
              for (const r5 of t4) {
                const t5 = [r5.x, r5.y, 0, 1];
                Vs(t5, t5, e3), i4.push(new a2(t5[0] / t5[3], t5[1] / t5[3]));
              }
              return i4;
            }(u3, l3), f3 = function(t4, e3, r4, n4) {
              const i4 = [], s4 = [], o4 = n4[8] * e3, l4 = n4[9] * e3, u4 = n4[10] * e3, c4 = n4[11] * e3, h4 = n4[8] * r4, p4 = n4[9] * r4, f4 = n4[10] * r4, d3 = n4[11] * r4;
              for (const e4 of t4) {
                const t5 = [], r5 = [];
                for (const i5 of e4) {
                  const e5 = i5.x, s5 = i5.y, y3 = n4[0] * e5 + n4[4] * s5 + n4[12], m3 = n4[1] * e5 + n4[5] * s5 + n4[13], g3 = n4[2] * e5 + n4[6] * s5 + n4[14], x3 = n4[3] * e5 + n4[7] * s5 + n4[15], v3 = g3 + u4, b3 = x3 + c4, w3 = y3 + h4, _3 = m3 + p4, A3 = g3 + f4, S3 = x3 + d3, k3 = new a2((y3 + o4) / b3, (m3 + l4) / b3);
                  k3.z = v3 / b3, t5.push(k3);
                  const I3 = new a2(w3 / S3, _3 / S3);
                  I3.z = A3 / S3, r5.push(I3);
                }
                i4.push(t5), s4.push(r5);
              }
              return [i4, s4];
            }(n3, h3, c3, l3);
            return function(t4, e3, r4) {
              let n4 = 1 / 0;
              hs(r4, e3) && (n4 = ul(r4, e3[0]));
              for (let i4 = 0; i4 < e3.length; i4++) {
                const a3 = e3[i4], s4 = t4[i4];
                for (let t5 = 0; t5 < a3.length - 1; t5++) {
                  const e4 = a3[t5], i5 = [e4, a3[t5 + 1], s4[t5 + 1], s4[t5], e4];
                  us(r4, i5) && (n4 = Math.min(n4, ul(r4, i5)));
                }
              }
              return n4 !== 1 / 0 && n4;
            }(f3[0], f3[1], p3);
          }
        }
        function ll(t3, e2) {
          return t3.x * e2.x + t3.y * e2.y;
        }
        function ul(t3, e2) {
          if (1 === t3.length) {
            let r3 = 0;
            const n3 = e2[r3++];
            let i3;
            for (; !i3 || n3.equals(i3); ) if (i3 = e2[r3++], !i3) return 1 / 0;
            for (; r3 < e2.length; r3++) {
              const a3 = e2[r3], s3 = t3[0], o3 = i3.sub(n3), l3 = a3.sub(n3), u3 = s3.sub(n3), c3 = ll(o3, o3), h3 = ll(o3, l3), p3 = ll(l3, l3), f3 = ll(u3, o3), d3 = ll(u3, l3), y3 = c3 * p3 - h3 * h3, m3 = (p3 * f3 - h3 * d3) / y3, g3 = (c3 * d3 - h3 * f3) / y3, x3 = n3.z * (1 - m3 - g3) + i3.z * m3 + a3.z * g3;
              if (isFinite(x3)) return x3;
            }
            return 1 / 0;
          }
          {
            let t4 = 1 / 0;
            for (const r3 of e2) t4 = Math.min(t4, r3.z);
            return t4;
          }
        }
        const cl = Mi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: hl } = cl, pl = Mi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: fl } = pl, dl = Ro.VectorTileFeature.types, yl = Math.cos(Math.PI / 180 * 37.5), ml = Math.pow(2, 14) / 0.5;
        class gl {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t4) => {
              this.gradients[t4.id] = {};
            }), this.layoutVertexArray = new ya(), this.layoutVertexArray2 = new ma(), this.indexArray = new Aa(), this.programConfigurations = new Qa(t3.layers, t3.zoom), this.segments = new za(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e2, r3) {
            this.hasPattern = Po("line", this.layers, e2);
            const n3 = this.layers[0].layout.get("line-sort-key"), i3 = !n3.isConstant(), a3 = [];
            for (const { feature: e3, id: s3, index: o3, sourceLayerIndex: l3 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, u3 = ss2(e3, t4);
              if (!this.layers[0]._featureFilter.filter(new li(this.zoom), u3, r3)) continue;
              const c3 = i3 ? n3.evaluate(u3, {}, r3) : void 0, h3 = { id: s3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t4 ? u3.geometry : as(e3), patterns: {}, sortKey: c3 };
              a3.push(h3);
            }
            i3 && a3.sort((t4, e3) => t4.sortKey - e3.sortKey);
            for (const n4 of a3) {
              const { geometry: i4, index: a4, sourceLayerIndex: s3 } = n4;
              if (this.hasPattern) {
                const t4 = Vo("line", this.layers, n4, this.zoom, e2);
                this.patternFeatures.push(t4);
              } else this.addFeature(n4, i4, a4, r3, {});
              e2.featureIndex.insert(t3[a4].feature, i4, a4, s3, this.index);
            }
          }
          update(t3, e2, r3) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e2, this.stateDependentLayers, r3);
          }
          addFeatures(t3, e2, r3) {
            for (const t4 of this.patternFeatures) this.addFeature(t4, t4.geometry, t4.index, e2, r3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t3.createVertexBuffer(this.layoutVertexArray2, fl)), this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, hl), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t3) {
            if (t3.properties && Object.prototype.hasOwnProperty.call(t3.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t3.properties, "mapbox_clip_end")) return { start: +t3.properties.mapbox_clip_start, end: +t3.properties.mapbox_clip_end };
          }
          addFeature(t3, e2, r3, n3, i3) {
            const a3 = this.layers[0].layout, s3 = a3.get("line-join").evaluate(t3, {}), o3 = a3.get("line-cap"), l3 = a3.get("line-miter-limit"), u3 = a3.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t3);
            for (const r4 of e2) this.addLine(r4, t3, s3, o3, l3, u3);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i3, n3);
          }
          addLine(t3, e2, r3, n3, i3, a3) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e3 = 0; e3 < t3.length - 1; e3++) this.totalDistance += t3[e3].dist(t3[e3 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const s3 = "Polygon" === dl[e2.type];
            let o3 = t3.length;
            for (; o3 >= 2 && t3[o3 - 1].equals(t3[o3 - 2]); ) o3--;
            let l3 = 0;
            for (; l3 < o3 - 1 && t3[l3].equals(t3[l3 + 1]); ) l3++;
            if (o3 < (s3 ? 3 : 2)) return;
            "bevel" === r3 && (i3 = 1.05);
            const u3 = this.overscaling <= 16 ? 15 * rs / (512 * this.overscaling) : 0, c3 = this.segments.prepareSegment(10 * o3, this.layoutVertexArray, this.indexArray);
            let h3, p3, f3, d3, y3;
            this.e1 = this.e2 = -1, s3 && (h3 = t3[o3 - 2], y3 = t3[l3].sub(h3)._unit()._perp());
            for (let e3 = l3; e3 < o3; e3++) {
              if (f3 = e3 === o3 - 1 ? s3 ? t3[l3 + 1] : void 0 : t3[e3 + 1], f3 && t3[e3].equals(f3)) continue;
              y3 && (d3 = y3), h3 && (p3 = h3), h3 = t3[e3], y3 = f3 ? f3.sub(h3)._unit()._perp() : d3, d3 = d3 || y3;
              let m3 = d3.add(y3);
              0 === m3.x && 0 === m3.y || m3._unit();
              const g3 = d3.x * y3.x + d3.y * y3.y, x3 = m3.x * y3.x + m3.y * y3.y, v3 = 0 !== x3 ? 1 / x3 : 1 / 0, b3 = 2 * Math.sqrt(2 - 2 * x3), w3 = x3 < yl && p3 && f3, _3 = d3.x * y3.y - d3.y * y3.x > 0;
              if (w3 && e3 > l3) {
                const t4 = h3.dist(p3);
                if (t4 > 2 * u3) {
                  const e4 = h3.sub(h3.sub(p3)._mult(u3 / t4)._round());
                  this.updateDistance(p3, e4), this.addCurrentVertex(e4, d3, 0, 0, c3), p3 = e4;
                }
              }
              const A3 = p3 && f3;
              let S3 = A3 ? r3 : s3 ? "butt" : n3;
              if (A3 && "round" === S3 && (v3 < a3 ? S3 = "miter" : v3 <= 2 && (S3 = "fakeround")), "miter" === S3 && v3 > i3 && (S3 = "bevel"), "bevel" === S3 && (v3 > 2 && (S3 = "flipbevel"), v3 < i3 && (S3 = "miter")), p3 && this.updateDistance(p3, h3), "miter" === S3) m3._mult(v3), this.addCurrentVertex(h3, m3, 0, 0, c3);
              else if ("flipbevel" === S3) {
                if (v3 > 100) m3 = y3.mult(-1);
                else {
                  const t4 = v3 * d3.add(y3).mag() / d3.sub(y3).mag();
                  m3._perp()._mult(t4 * (_3 ? -1 : 1));
                }
                this.addCurrentVertex(h3, m3, 0, 0, c3), this.addCurrentVertex(h3, m3.mult(-1), 0, 0, c3);
              } else if ("bevel" === S3 || "fakeround" === S3) {
                const t4 = -Math.sqrt(v3 * v3 - 1), e4 = _3 ? t4 : 0, r4 = _3 ? 0 : t4;
                if (p3 && this.addCurrentVertex(h3, d3, e4, r4, c3), "fakeround" === S3) {
                  const t5 = Math.round(180 * b3 / Math.PI / 20);
                  for (let e5 = 1; e5 < t5; e5++) {
                    let r5 = e5 / t5;
                    if (0.5 !== r5) {
                      const t6 = r5 - 0.5;
                      r5 += r5 * t6 * (r5 - 1) * ((1.0904 + g3 * (g3 * (3.55645 - 1.43519 * g3) - 3.2452)) * t6 * t6 + (0.848013 + g3 * (0.215638 * g3 - 1.06021)));
                    }
                    const n4 = y3.sub(d3)._mult(r5)._add(d3)._unit()._mult(_3 ? -1 : 1);
                    this.addHalfVertex(h3, n4.x, n4.y, false, _3, 0, c3);
                  }
                }
                f3 && this.addCurrentVertex(h3, y3, -e4, -r4, c3);
              } else if ("butt" === S3) this.addCurrentVertex(h3, m3, 0, 0, c3);
              else if ("square" === S3) {
                const t4 = p3 ? 1 : -1;
                this.addCurrentVertex(h3, m3, t4, t4, c3);
              } else "round" === S3 && (p3 && (this.addCurrentVertex(h3, d3, 0, 0, c3), this.addCurrentVertex(h3, d3, 1, 1, c3, true)), f3 && (this.addCurrentVertex(h3, y3, -1, -1, c3, true), this.addCurrentVertex(h3, y3, 0, 0, c3)));
              if (w3 && e3 < o3 - 1) {
                const t4 = h3.dist(f3);
                if (t4 > 2 * u3) {
                  const e4 = h3.add(f3.sub(h3)._mult(u3 / t4)._round());
                  this.updateDistance(h3, e4), this.addCurrentVertex(e4, y3, 0, 0, c3), h3 = e4;
                }
              }
            }
          }
          addCurrentVertex(t3, e2, r3, n3, i3, a3 = false) {
            const s3 = e2.y * n3 - e2.x, o3 = -e2.y - e2.x * n3;
            this.addHalfVertex(t3, e2.x + e2.y * r3, e2.y - e2.x * r3, a3, false, r3, i3), this.addHalfVertex(t3, s3, o3, a3, true, -n3, i3), this.distance > ml / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t3, e2, r3, n3, i3, a3));
          }
          addHalfVertex({ x: t3, y: e2 }, r3, n3, i3, a3, s3, o3) {
            const l3 = 0.5 * (this.lineClips ? this.scaledDistance * (ml - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t3 << 1) + (i3 ? 1 : 0), (e2 << 1) + (a3 ? 1 : 0), Math.round(63 * r3) + 128, Math.round(63 * n3) + 128, 1 + (0 === s3 ? 0 : s3 < 0 ? -1 : 1) | (63 & l3) << 2, l3 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const u3 = o3.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u3), o3.primitiveLength++), a3 ? this.e2 = u3 : this.e1 = u3;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t3, e2) {
            this.distance += t3.dist(e2), this.updateScaledDistance();
          }
        }
        let xl, vl;
        $n("LineBucket", gl, { omit: ["layers", "patternFeatures"] });
        var bl = { get paint() {
          return vl = vl || new _i({ "line-opacity": new xi(X2.paint_line["line-opacity"]), "line-color": new xi(X2.paint_line["line-color"]), "line-translate": new gi(X2.paint_line["line-translate"]), "line-translate-anchor": new gi(X2.paint_line["line-translate-anchor"]), "line-width": new xi(X2.paint_line["line-width"]), "line-gap-width": new xi(X2.paint_line["line-gap-width"]), "line-offset": new xi(X2.paint_line["line-offset"]), "line-blur": new xi(X2.paint_line["line-blur"]), "line-dasharray": new bi(X2.paint_line["line-dasharray"]), "line-pattern": new vi(X2.paint_line["line-pattern"]), "line-gradient": new wi(X2.paint_line["line-gradient"]) });
        }, get layout() {
          return xl = xl || new _i({ "line-cap": new gi(X2.layout_line["line-cap"]), "line-join": new xi(X2.layout_line["line-join"]), "line-miter-limit": new gi(X2.layout_line["line-miter-limit"]), "line-round-limit": new gi(X2.layout_line["line-round-limit"]), "line-sort-key": new xi(X2.layout_line["line-sort-key"]) });
        } };
        class wl extends xi {
          possiblyEvaluate(t3, e2) {
            return e2 = new li(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t3, e2);
          }
          evaluate(t3, e2, r3, n3) {
            return e2 = g2({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t3, e2, r3, n3);
          }
        }
        let _l;
        class Al extends Si {
          constructor(t3) {
            super(t3, bl), this.gradientVersion = 0, _l || (_l = new wl(bl.paint.properties["line-width"].specification), _l.useIntegerZoom = true);
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            if ("line-gradient" === t3) {
              const t4 = this.gradientExpression();
              this.stepInterpolant = !!function(t5) {
                return void 0 !== t5._styleExpression;
              }(t4) && t4._styleExpression.expression instanceof qe2, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t3, e2) {
            super.recalculate(t3, e2), this.paint._values["line-floorwidth"] = _l.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t3);
          }
          createBucket(t3) {
            return new gl(t3);
          }
          queryRadius(t3) {
            const e2 = t3, r3 = Sl(bs("line-width", this, e2), bs("line-gap-width", this, e2)), n3 = bs("line-offset", this, e2);
            return r3 / 2 + Math.abs(n3) + ws(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t3, e2, r3, n3, i3, s3, o3) {
            const l3 = _s(t3, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s3.angle, o3), u3 = o3 / 2 * Sl(this.paint.get("line-width").evaluate(e2, r3), this.paint.get("line-gap-width").evaluate(e2, r3)), c3 = this.paint.get("line-offset").evaluate(e2, r3);
            return c3 && (n3 = function(t4, e3) {
              const r4 = [];
              for (let n4 = 0; n4 < t4.length; n4++) {
                const i4 = t4[n4], s4 = [];
                for (let t5 = 0; t5 < i4.length; t5++) {
                  const r5 = i4[t5 - 1], n5 = i4[t5], o4 = i4[t5 + 1], l4 = 0 === t5 ? new a2(0, 0) : n5.sub(r5)._unit()._perp(), u4 = t5 === i4.length - 1 ? new a2(0, 0) : o4.sub(n5)._unit()._perp(), c4 = l4._add(u4)._unit(), h3 = c4.x * u4.x + c4.y * u4.y;
                  0 !== h3 && c4._mult(1 / h3), s4.push(c4._mult(e3)._add(n5));
                }
                r4.push(s4);
              }
              return r4;
            }(n3, c3 * o3)), function(t4, e3, r4) {
              for (let n4 = 0; n4 < e3.length; n4++) {
                const i4 = e3[n4];
                if (t4.length >= 3) {
                  for (let e4 = 0; e4 < i4.length; e4++) if (xs(t4, i4[e4])) return true;
                }
                if (ps(t4, i4, r4)) return true;
              }
              return false;
            }(l3, n3, u3);
          }
          isTileClipped() {
            return true;
          }
        }
        function Sl(t3, e2) {
          return e2 > 0 ? e2 + 2 * t3 : t3;
        }
        const kl = Mi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Il = Mi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        Mi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const zl = Mi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
        Mi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Ml = Mi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Cl = Mi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function Bl(t3, e2, r3) {
          return t3.sections.forEach((t4) => {
            t4.text = function(t5, e3, r4) {
              const n3 = e3.layout.get("text-transform").evaluate(r4, {});
              return "uppercase" === n3 ? t5 = t5.toLocaleUpperCase() : "lowercase" === n3 && (t5 = t5.toLocaleLowerCase()), oi.applyArabicShaping && (t5 = oi.applyArabicShaping(t5)), t5;
            }(t4.text, e2, r3);
          }), t3;
        }
        Mi([{ name: "triangle", components: 3, type: "Uint16" }]), Mi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Mi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Mi([{ type: "Float32", name: "offsetX" }]), Mi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Mi([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const Pl = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
        var Vl = 24, El = $l, Fl = function(t3, e2, r3, n3, i3) {
          var a3, s3, o3 = 8 * i3 - n3 - 1, l3 = (1 << o3) - 1, u3 = l3 >> 1, c3 = -7, h3 = i3 - 1, p3 = -1, f3 = t3[e2 + h3];
          for (h3 += p3, a3 = f3 & (1 << -c3) - 1, f3 >>= -c3, c3 += o3; c3 > 0; a3 = 256 * a3 + t3[e2 + h3], h3 += p3, c3 -= 8) ;
          for (s3 = a3 & (1 << -c3) - 1, a3 >>= -c3, c3 += n3; c3 > 0; s3 = 256 * s3 + t3[e2 + h3], h3 += p3, c3 -= 8) ;
          if (0 === a3) a3 = 1 - u3;
          else {
            if (a3 === l3) return s3 ? NaN : 1 / 0 * (f3 ? -1 : 1);
            s3 += Math.pow(2, n3), a3 -= u3;
          }
          return (f3 ? -1 : 1) * s3 * Math.pow(2, a3 - n3);
        }, Tl = function(t3, e2, r3, n3, i3, a3) {
          var s3, o3, l3, u3 = 8 * a3 - i3 - 1, c3 = (1 << u3) - 1, h3 = c3 >> 1, p3 = 23 === i3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f3 = 0, d3 = 1, y3 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
          for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o3 = isNaN(e2) ? 1 : 0, s3 = c3) : (s3 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l3 = Math.pow(2, -s3)) < 1 && (s3--, l3 *= 2), (e2 += s3 + h3 >= 1 ? p3 / l3 : p3 * Math.pow(2, 1 - h3)) * l3 >= 2 && (s3++, l3 /= 2), s3 + h3 >= c3 ? (o3 = 0, s3 = c3) : s3 + h3 >= 1 ? (o3 = (e2 * l3 - 1) * Math.pow(2, i3), s3 += h3) : (o3 = e2 * Math.pow(2, h3 - 1) * Math.pow(2, i3), s3 = 0)); i3 >= 8; t3[r3 + f3] = 255 & o3, f3 += d3, o3 /= 256, i3 -= 8) ;
          for (s3 = s3 << i3 | o3, u3 += i3; u3 > 0; t3[r3 + f3] = 255 & s3, f3 += d3, s3 /= 256, u3 -= 8) ;
          t3[r3 + f3 - d3] |= 128 * y3;
        };
        function $l(t3) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        $l.Varint = 0, $l.Fixed64 = 1, $l.Bytes = 2, $l.Fixed32 = 5;
        var Ll = 4294967296, Dl = 1 / Ll, Ol = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function Ul(t3) {
          return t3.type === $l.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
        }
        function Rl(t3, e2, r3) {
          return r3 ? 4294967296 * e2 + (t3 >>> 0) : 4294967296 * (e2 >>> 0) + (t3 >>> 0);
        }
        function ql(t3, e2, r3) {
          var n3 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
          r3.realloc(n3);
          for (var i3 = r3.pos - 1; i3 >= t3; i3--) r3.buf[i3 + n3] = r3.buf[i3];
        }
        function jl(t3, e2) {
          for (var r3 = 0; r3 < t3.length; r3++) e2.writeVarint(t3[r3]);
        }
        function Nl(t3, e2) {
          for (var r3 = 0; r3 < t3.length; r3++) e2.writeSVarint(t3[r3]);
        }
        function Zl(t3, e2) {
          for (var r3 = 0; r3 < t3.length; r3++) e2.writeFloat(t3[r3]);
        }
        function Kl(t3, e2) {
          for (var r3 = 0; r3 < t3.length; r3++) e2.writeDouble(t3[r3]);
        }
        function Gl(t3, e2) {
          for (var r3 = 0; r3 < t3.length; r3++) e2.writeBoolean(t3[r3]);
        }
        function Jl(t3, e2) {
          for (var r3 = 0; r3 < t3.length; r3++) e2.writeFixed32(t3[r3]);
        }
        function Xl(t3, e2) {
          for (var r3 = 0; r3 < t3.length; r3++) e2.writeSFixed32(t3[r3]);
        }
        function Yl(t3, e2) {
          for (var r3 = 0; r3 < t3.length; r3++) e2.writeFixed64(t3[r3]);
        }
        function Hl(t3, e2) {
          for (var r3 = 0; r3 < t3.length; r3++) e2.writeSFixed64(t3[r3]);
        }
        function Wl(t3, e2) {
          return (t3[e2] | t3[e2 + 1] << 8 | t3[e2 + 2] << 16) + 16777216 * t3[e2 + 3];
        }
        function Ql(t3, e2, r3) {
          t3[r3] = e2, t3[r3 + 1] = e2 >>> 8, t3[r3 + 2] = e2 >>> 16, t3[r3 + 3] = e2 >>> 24;
        }
        function tu(t3, e2) {
          return (t3[e2] | t3[e2 + 1] << 8 | t3[e2 + 2] << 16) + (t3[e2 + 3] << 24);
        }
        $l.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t3, e2, r3) {
          for (r3 = r3 || this.length; this.pos < r3; ) {
            var n3 = this.readVarint(), i3 = n3 >> 3, a3 = this.pos;
            this.type = 7 & n3, t3(i3, e2, this), this.pos === a3 && this.skip(n3);
          }
          return e2;
        }, readMessage: function(t3, e2) {
          return this.readFields(t3, e2, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t3 = Wl(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readSFixed32: function() {
          var t3 = tu(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readFixed64: function() {
          var t3 = Wl(this.buf, this.pos) + Wl(this.buf, this.pos + 4) * Ll;
          return this.pos += 8, t3;
        }, readSFixed64: function() {
          var t3 = Wl(this.buf, this.pos) + tu(this.buf, this.pos + 4) * Ll;
          return this.pos += 8, t3;
        }, readFloat: function() {
          var t3 = Fl(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t3;
        }, readDouble: function() {
          var t3 = Fl(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t3;
        }, readVarint: function(t3) {
          var e2, r3, n3 = this.buf;
          return e2 = 127 & (r3 = n3[this.pos++]), r3 < 128 ? e2 : (e2 |= (127 & (r3 = n3[this.pos++])) << 7, r3 < 128 ? e2 : (e2 |= (127 & (r3 = n3[this.pos++])) << 14, r3 < 128 ? e2 : (e2 |= (127 & (r3 = n3[this.pos++])) << 21, r3 < 128 ? e2 : function(t4, e3, r4) {
            var n4, i3, a3 = r4.buf;
            if (n4 = (112 & (i3 = a3[r4.pos++])) >> 4, i3 < 128) return Rl(t4, n4, e3);
            if (n4 |= (127 & (i3 = a3[r4.pos++])) << 3, i3 < 128) return Rl(t4, n4, e3);
            if (n4 |= (127 & (i3 = a3[r4.pos++])) << 10, i3 < 128) return Rl(t4, n4, e3);
            if (n4 |= (127 & (i3 = a3[r4.pos++])) << 17, i3 < 128) return Rl(t4, n4, e3);
            if (n4 |= (127 & (i3 = a3[r4.pos++])) << 24, i3 < 128) return Rl(t4, n4, e3);
            if (n4 |= (1 & (i3 = a3[r4.pos++])) << 31, i3 < 128) return Rl(t4, n4, e3);
            throw new Error("Expected varint not more than 10 bytes");
          }(e2 |= (15 & (r3 = n3[this.pos])) << 28, t3, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t3 = this.readVarint();
          return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t3 = this.readVarint() + this.pos, e2 = this.pos;
          return this.pos = t3, t3 - e2 >= 12 && Ol ? function(t4, e3, r3) {
            return Ol.decode(t4.subarray(e3, r3));
          }(this.buf, e2, t3) : function(t4, e3, r3) {
            for (var n3 = "", i3 = e3; i3 < r3; ) {
              var a3, s3, o3, l3 = t4[i3], u3 = null, c3 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
              if (i3 + c3 > r3) break;
              1 === c3 ? l3 < 128 && (u3 = l3) : 2 === c3 ? 128 == (192 & (a3 = t4[i3 + 1])) && (u3 = (31 & l3) << 6 | 63 & a3) <= 127 && (u3 = null) : 3 === c3 ? (s3 = t4[i3 + 2], 128 == (192 & (a3 = t4[i3 + 1])) && 128 == (192 & s3) && ((u3 = (15 & l3) << 12 | (63 & a3) << 6 | 63 & s3) <= 2047 || u3 >= 55296 && u3 <= 57343) && (u3 = null)) : 4 === c3 && (s3 = t4[i3 + 2], o3 = t4[i3 + 3], 128 == (192 & (a3 = t4[i3 + 1])) && 128 == (192 & s3) && 128 == (192 & o3) && ((u3 = (15 & l3) << 18 | (63 & a3) << 12 | (63 & s3) << 6 | 63 & o3) <= 65535 || u3 >= 1114112) && (u3 = null)), null === u3 ? (u3 = 65533, c3 = 1) : u3 > 65535 && (u3 -= 65536, n3 += String.fromCharCode(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), n3 += String.fromCharCode(u3), i3 += c3;
            }
            return n3;
          }(this.buf, e2, t3);
        }, readBytes: function() {
          var t3 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t3);
          return this.pos = t3, e2;
        }, readPackedVarint: function(t3, e2) {
          if (this.type !== $l.Bytes) return t3.push(this.readVarint(e2));
          var r3 = Ul(this);
          for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readVarint(e2));
          return t3;
        }, readPackedSVarint: function(t3) {
          if (this.type !== $l.Bytes) return t3.push(this.readSVarint());
          var e2 = Ul(this);
          for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readSVarint());
          return t3;
        }, readPackedBoolean: function(t3) {
          if (this.type !== $l.Bytes) return t3.push(this.readBoolean());
          var e2 = Ul(this);
          for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readBoolean());
          return t3;
        }, readPackedFloat: function(t3) {
          if (this.type !== $l.Bytes) return t3.push(this.readFloat());
          var e2 = Ul(this);
          for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readFloat());
          return t3;
        }, readPackedDouble: function(t3) {
          if (this.type !== $l.Bytes) return t3.push(this.readDouble());
          var e2 = Ul(this);
          for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readDouble());
          return t3;
        }, readPackedFixed32: function(t3) {
          if (this.type !== $l.Bytes) return t3.push(this.readFixed32());
          var e2 = Ul(this);
          for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readFixed32());
          return t3;
        }, readPackedSFixed32: function(t3) {
          if (this.type !== $l.Bytes) return t3.push(this.readSFixed32());
          var e2 = Ul(this);
          for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readSFixed32());
          return t3;
        }, readPackedFixed64: function(t3) {
          if (this.type !== $l.Bytes) return t3.push(this.readFixed64());
          var e2 = Ul(this);
          for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readFixed64());
          return t3;
        }, readPackedSFixed64: function(t3) {
          if (this.type !== $l.Bytes) return t3.push(this.readSFixed64());
          var e2 = Ul(this);
          for (t3 = t3 || []; this.pos < e2; ) t3.push(this.readSFixed64());
          return t3;
        }, skip: function(t3) {
          var e2 = 7 & t3;
          if (e2 === $l.Varint) for (; this.buf[this.pos++] > 127; ) ;
          else if (e2 === $l.Bytes) this.pos = this.readVarint() + this.pos;
          else if (e2 === $l.Fixed32) this.pos += 4;
          else {
            if (e2 !== $l.Fixed64) throw new Error("Unimplemented type: " + e2);
            this.pos += 8;
          }
        }, writeTag: function(t3, e2) {
          this.writeVarint(t3 << 3 | e2);
        }, realloc: function(t3) {
          for (var e2 = this.length || 16; e2 < this.pos + t3; ) e2 *= 2;
          if (e2 !== this.length) {
            var r3 = new Uint8Array(e2);
            r3.set(this.buf), this.buf = r3, this.length = e2;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t3) {
          this.realloc(4), Ql(this.buf, t3, this.pos), this.pos += 4;
        }, writeSFixed32: function(t3) {
          this.realloc(4), Ql(this.buf, t3, this.pos), this.pos += 4;
        }, writeFixed64: function(t3) {
          this.realloc(8), Ql(this.buf, -1 & t3, this.pos), Ql(this.buf, Math.floor(t3 * Dl), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t3) {
          this.realloc(8), Ql(this.buf, -1 & t3, this.pos), Ql(this.buf, Math.floor(t3 * Dl), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t3) {
          (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e2) {
            var r3, n3;
            if (t4 >= 0 ? (r3 = t4 % 4294967296 | 0, n3 = t4 / 4294967296 | 0) : (n3 = ~(-t4 / 4294967296), 4294967295 ^ (r3 = ~(-t4 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, n3 = n3 + 1 | 0)), t4 >= 18446744073709552e3 || t4 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
            e2.realloc(10), function(t5, e3, r4) {
              r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, r4.buf[r4.pos] = 127 & (t5 >>>= 7);
            }(r3, 0, e2), function(t5, e3) {
              var r4 = (7 & t5) << 4;
              e3.buf[e3.pos++] |= r4 | ((t5 >>>= 3) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5)))));
            }(n3, e2);
          }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
        }, writeSVarint: function(t3) {
          this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
        }, writeBoolean: function(t3) {
          this.writeVarint(Boolean(t3));
        }, writeString: function(t3) {
          t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
          var e2 = this.pos;
          this.pos = function(t4, e3, r4) {
            for (var n3, i3, a3 = 0; a3 < e3.length; a3++) {
              if ((n3 = e3.charCodeAt(a3)) > 55295 && n3 < 57344) {
                if (!i3) {
                  n3 > 56319 || a3 + 1 === e3.length ? (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189) : i3 = n3;
                  continue;
                }
                if (n3 < 56320) {
                  t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = n3;
                  continue;
                }
                n3 = i3 - 55296 << 10 | n3 - 56320 | 65536, i3 = null;
              } else i3 && (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = null);
              n3 < 128 ? t4[r4++] = n3 : (n3 < 2048 ? t4[r4++] = n3 >> 6 | 192 : (n3 < 65536 ? t4[r4++] = n3 >> 12 | 224 : (t4[r4++] = n3 >> 18 | 240, t4[r4++] = n3 >> 12 & 63 | 128), t4[r4++] = n3 >> 6 & 63 | 128), t4[r4++] = 63 & n3 | 128);
            }
            return r4;
          }(this.buf, t3, this.pos);
          var r3 = this.pos - e2;
          r3 >= 128 && ql(e2, r3, this), this.pos = e2 - 1, this.writeVarint(r3), this.pos += r3;
        }, writeFloat: function(t3) {
          this.realloc(4), Tl(this.buf, t3, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t3) {
          this.realloc(8), Tl(this.buf, t3, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t3) {
          var e2 = t3.length;
          this.writeVarint(e2), this.realloc(e2);
          for (var r3 = 0; r3 < e2; r3++) this.buf[this.pos++] = t3[r3];
        }, writeRawMessage: function(t3, e2) {
          this.pos++;
          var r3 = this.pos;
          t3(e2, this);
          var n3 = this.pos - r3;
          n3 >= 128 && ql(r3, n3, this), this.pos = r3 - 1, this.writeVarint(n3), this.pos += n3;
        }, writeMessage: function(t3, e2, r3) {
          this.writeTag(t3, $l.Bytes), this.writeRawMessage(e2, r3);
        }, writePackedVarint: function(t3, e2) {
          e2.length && this.writeMessage(t3, jl, e2);
        }, writePackedSVarint: function(t3, e2) {
          e2.length && this.writeMessage(t3, Nl, e2);
        }, writePackedBoolean: function(t3, e2) {
          e2.length && this.writeMessage(t3, Gl, e2);
        }, writePackedFloat: function(t3, e2) {
          e2.length && this.writeMessage(t3, Zl, e2);
        }, writePackedDouble: function(t3, e2) {
          e2.length && this.writeMessage(t3, Kl, e2);
        }, writePackedFixed32: function(t3, e2) {
          e2.length && this.writeMessage(t3, Jl, e2);
        }, writePackedSFixed32: function(t3, e2) {
          e2.length && this.writeMessage(t3, Xl, e2);
        }, writePackedFixed64: function(t3, e2) {
          e2.length && this.writeMessage(t3, Yl, e2);
        }, writePackedSFixed64: function(t3, e2) {
          e2.length && this.writeMessage(t3, Hl, e2);
        }, writeBytesField: function(t3, e2) {
          this.writeTag(t3, $l.Bytes), this.writeBytes(e2);
        }, writeFixed32Field: function(t3, e2) {
          this.writeTag(t3, $l.Fixed32), this.writeFixed32(e2);
        }, writeSFixed32Field: function(t3, e2) {
          this.writeTag(t3, $l.Fixed32), this.writeSFixed32(e2);
        }, writeFixed64Field: function(t3, e2) {
          this.writeTag(t3, $l.Fixed64), this.writeFixed64(e2);
        }, writeSFixed64Field: function(t3, e2) {
          this.writeTag(t3, $l.Fixed64), this.writeSFixed64(e2);
        }, writeVarintField: function(t3, e2) {
          this.writeTag(t3, $l.Varint), this.writeVarint(e2);
        }, writeSVarintField: function(t3, e2) {
          this.writeTag(t3, $l.Varint), this.writeSVarint(e2);
        }, writeStringField: function(t3, e2) {
          this.writeTag(t3, $l.Bytes), this.writeString(e2);
        }, writeFloatField: function(t3, e2) {
          this.writeTag(t3, $l.Fixed32), this.writeFloat(e2);
        }, writeDoubleField: function(t3, e2) {
          this.writeTag(t3, $l.Fixed64), this.writeDouble(e2);
        }, writeBooleanField: function(t3, e2) {
          this.writeVarintField(t3, Boolean(e2));
        } };
        var eu = r2(El);
        const ru = 3;
        function nu(t3, e2, r3) {
          1 === t3 && r3.readMessage(iu, e2);
        }
        function iu(t3, e2, r3) {
          if (3 === t3) {
            const { id: t4, bitmap: n3, width: i3, height: a3, left: s3, top: o3, advance: l3 } = r3.readMessage(au, {});
            e2.push({ id: t4, bitmap: new Rs({ width: i3 + 2 * ru, height: a3 + 2 * ru }, n3), metrics: { width: i3, height: a3, left: s3, top: o3, advance: l3 } });
          }
        }
        function au(t3, e2, r3) {
          1 === t3 ? e2.id = r3.readVarint() : 2 === t3 ? e2.bitmap = r3.readBytes() : 3 === t3 ? e2.width = r3.readVarint() : 4 === t3 ? e2.height = r3.readVarint() : 5 === t3 ? e2.left = r3.readSVarint() : 6 === t3 ? e2.top = r3.readSVarint() : 7 === t3 && (e2.advance = r3.readVarint());
        }
        const su = ru;
        function ou(t3) {
          let e2 = 0, r3 = 0;
          for (const n4 of t3) e2 += n4.w * n4.h, r3 = Math.max(r3, n4.w);
          t3.sort((t4, e3) => e3.h - t4.h);
          const n3 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r3), h: 1 / 0 }];
          let i3 = 0, a3 = 0;
          for (const e3 of t3) for (let t4 = n3.length - 1; t4 >= 0; t4--) {
            const r4 = n3[t4];
            if (!(e3.w > r4.w || e3.h > r4.h)) {
              if (e3.x = r4.x, e3.y = r4.y, a3 = Math.max(a3, e3.y + e3.h), i3 = Math.max(i3, e3.x + e3.w), e3.w === r4.w && e3.h === r4.h) {
                const e4 = n3.pop();
                t4 < n3.length && (n3[t4] = e4);
              } else e3.h === r4.h ? (r4.x += e3.w, r4.w -= e3.w) : e3.w === r4.w ? (r4.y += e3.h, r4.h -= e3.h) : (n3.push({ x: r4.x + e3.w, y: r4.y, w: r4.w - e3.w, h: e3.h }), r4.y += e3.h, r4.h -= e3.h);
              break;
            }
          }
          return { w: i3, h: a3, fill: e2 / (i3 * a3) || 0 };
        }
        const lu = 1;
        class uu {
          constructor(t3, { pixelRatio: e2, version: r3, stretchX: n3, stretchY: i3, content: a3 }) {
            this.paddedRect = t3, this.pixelRatio = e2, this.stretchX = n3, this.stretchY = i3, this.content = a3, this.version = r3;
          }
          get tl() {
            return [this.paddedRect.x + lu, this.paddedRect.y + lu];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - lu, this.paddedRect.y + this.paddedRect.h - lu];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * lu) / this.pixelRatio, (this.paddedRect.h - 2 * lu) / this.pixelRatio];
          }
        }
        class cu {
          constructor(t3, e2) {
            const r3 = {}, n3 = {};
            this.haveRenderCallbacks = [];
            const i3 = [];
            this.addImages(t3, r3, i3), this.addImages(e2, n3, i3);
            const { w: a3, h: s3 } = ou(i3), o3 = new qs({ width: a3 || 1, height: s3 || 1 });
            for (const e3 in t3) {
              const n4 = t3[e3], i4 = r3[e3].paddedRect;
              qs.copy(n4.data, o3, { x: 0, y: 0 }, { x: i4.x + lu, y: i4.y + lu }, n4.data);
            }
            for (const t4 in e2) {
              const r4 = e2[t4], i4 = n3[t4].paddedRect, a4 = i4.x + lu, s4 = i4.y + lu, l3 = r4.data.width, u3 = r4.data.height;
              qs.copy(r4.data, o3, { x: 0, y: 0 }, { x: a4, y: s4 }, r4.data), qs.copy(r4.data, o3, { x: 0, y: u3 - 1 }, { x: a4, y: s4 - 1 }, { width: l3, height: 1 }), qs.copy(r4.data, o3, { x: 0, y: 0 }, { x: a4, y: s4 + u3 }, { width: l3, height: 1 }), qs.copy(r4.data, o3, { x: l3 - 1, y: 0 }, { x: a4 - 1, y: s4 }, { width: 1, height: u3 }), qs.copy(r4.data, o3, { x: 0, y: 0 }, { x: a4 + l3, y: s4 }, { width: 1, height: u3 });
            }
            this.image = o3, this.iconPositions = r3, this.patternPositions = n3;
          }
          addImages(t3, e2, r3) {
            for (const n3 in t3) {
              const i3 = t3[n3], a3 = { x: 0, y: 0, w: i3.data.width + 2 * lu, h: i3.data.height + 2 * lu };
              r3.push(a3), e2[n3] = new uu(a3, i3), i3.hasRenderCallback && this.haveRenderCallbacks.push(n3);
            }
          }
          patchUpdatedImages(t3, e2) {
            t3.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const r3 in t3.updatedImages) this.patchUpdatedImage(this.iconPositions[r3], t3.getImage(r3), e2), this.patchUpdatedImage(this.patternPositions[r3], t3.getImage(r3), e2);
          }
          patchUpdatedImage(t3, e2, r3) {
            if (!t3 || !e2) return;
            if (t3.version === e2.version) return;
            t3.version = e2.version;
            const [n3, i3] = t3.tl;
            r3.update(e2.data, void 0, { x: n3, y: i3 });
          }
        }
        var hu;
        $n("ImagePosition", uu), $n("ImageAtlas", cu), t2.ai = void 0, (hu = t2.ai || (t2.ai = {}))[hu.none = 0] = "none", hu[hu.horizontal = 1] = "horizontal", hu[hu.vertical = 2] = "vertical", hu[hu.horizontalOnly = 3] = "horizontalOnly";
        const pu = -17;
        class fu {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(t3, e2) {
            const r3 = new fu();
            return r3.scale = t3 || 1, r3.fontStack = e2, r3;
          }
          static forImage(t3) {
            const e2 = new fu();
            return e2.imageName = t3, e2;
          }
        }
        class du {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t3, e2) {
            const r3 = new du();
            for (let n3 = 0; n3 < t3.sections.length; n3++) {
              const i3 = t3.sections[n3];
              i3.image ? r3.addImageSection(i3) : r3.addTextSection(i3, e2);
            }
            return r3;
          }
          length() {
            return this.text.length;
          }
          getSection(t3) {
            return this.sections[this.sectionIndex[t3]];
          }
          getSectionIndex(t3) {
            return this.sectionIndex[t3];
          }
          getCharCode(t3) {
            return this.text.charCodeAt(t3);
          }
          verticalizePunctuation() {
            this.text = function(t3) {
              let e2 = "";
              for (let r3 = 0; r3 < t3.length; r3++) {
                const n3 = t3.charCodeAt(r3 + 1) || null, i3 = t3.charCodeAt(r3 - 1) || null;
                e2 += n3 && Kn(n3) && !Pl[t3[r3 + 1]] || i3 && Kn(i3) && !Pl[t3[r3 - 1]] || !Pl[t3[r3]] ? t3[r3] : Pl[t3[r3]];
              }
              return e2;
            }(this.text);
          }
          trim() {
            let t3 = 0;
            for (let e3 = 0; e3 < this.text.length && mu[this.text.charCodeAt(e3)]; e3++) t3++;
            let e2 = this.text.length;
            for (let r3 = this.text.length - 1; r3 >= 0 && r3 >= t3 && mu[this.text.charCodeAt(r3)]; r3--) e2--;
            this.text = this.text.substring(t3, e2), this.sectionIndex = this.sectionIndex.slice(t3, e2);
          }
          substring(t3, e2) {
            const r3 = new du();
            return r3.text = this.text.substring(t3, e2), r3.sectionIndex = this.sectionIndex.slice(t3, e2), r3.sections = this.sections, r3;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t3, e2) => Math.max(t3, this.sections[e2].scale), 0);
          }
          addTextSection(t3, e2) {
            this.text += t3.text, this.sections.push(fu.forText(t3.scale, t3.fontStack || e2));
            const r3 = this.sections.length - 1;
            for (let e3 = 0; e3 < t3.text.length; ++e3) this.sectionIndex.push(r3);
          }
          addImageSection(t3) {
            const e2 = t3.image ? t3.image.name : "";
            if (0 === e2.length) return void A2("Can't add FormattedSection with an empty image.");
            const r3 = this.getNextImageSectionCharCode();
            r3 ? (this.text += String.fromCharCode(r3), this.sections.push(fu.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : A2("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function yu(e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3, m3) {
          const g3 = du.fromFeature(e2, a3);
          let x3;
          p3 === t2.ai.vertical && g3.verticalizePunctuation();
          const { processBidirectionalText: v3, processStyledBidirectionalText: b3 } = oi;
          if (v3 && 1 === g3.sections.length) {
            x3 = [];
            const t3 = v3(g3.toString(), Au(g3, c3, s3, r3, i3, d3, y3));
            for (const e3 of t3) {
              const t4 = new du();
              t4.text = e3, t4.sections = g3.sections;
              for (let r4 = 0; r4 < e3.length; r4++) t4.sectionIndex.push(0);
              x3.push(t4);
            }
          } else if (b3) {
            x3 = [];
            const t3 = b3(g3.text, g3.sectionIndex, Au(g3, c3, s3, r3, i3, d3, y3));
            for (const e3 of t3) {
              const t4 = new du();
              t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = g3.sections, x3.push(t4);
            }
          } else x3 = function(t3, e3) {
            const r4 = [], n4 = t3.text;
            let i4 = 0;
            for (const n5 of e3) r4.push(t3.substring(i4, n5)), i4 = n5;
            return i4 < n4.length && r4.push(t3.substring(i4, n4.length)), r4;
          }(g3, Au(g3, c3, s3, r3, i3, d3, y3));
          const w3 = [], _3 = { positionedLines: w3, text: g3.toString(), top: h3[1], bottom: h3[1], left: h3[0], right: h3[0], writingMode: p3, iconsInText: false, verticalizable: false };
          return function(e3, r4, n4, i4, a4, s4, o4, l4, u4, c4, h4, p4) {
            let f4 = 0, d4 = pu, y4 = 0, m4 = 0;
            const g4 = "right" === l4 ? 1 : "left" === l4 ? 0 : 0.5;
            let x4 = 0;
            for (const o5 of a4) {
              o5.trim();
              const a5 = o5.getMaxScale(), l5 = (a5 - 1) * Vl, b5 = { positionedGlyphs: [], lineOffset: 0 };
              e3.positionedLines[x4] = b5;
              const w5 = b5.positionedGlyphs;
              let _5 = 0;
              if (!o5.length()) {
                d4 += s4, ++x4;
                continue;
              }
              for (let s5 = 0; s5 < o5.length(); s5++) {
                const y5 = o5.getSection(s5), m5 = o5.getSectionIndex(s5), g5 = o5.getCharCode(s5);
                let x5 = 0, b6 = null, A4 = null, S3 = null, k3 = Vl;
                const I3 = !(u4 === t2.ai.horizontal || !h4 && !Zn(g5) || h4 && (mu[g5] || (v4 = g5, Rn.Arabic(v4) || Rn["Arabic Supplement"](v4) || Rn["Arabic Extended-A"](v4) || Rn["Arabic Presentation Forms-A"](v4) || Rn["Arabic Presentation Forms-B"](v4))));
                if (y5.imageName) {
                  const t3 = i4[y5.imageName];
                  if (!t3) continue;
                  S3 = y5.imageName, e3.iconsInText = e3.iconsInText || true, A4 = t3.paddedRect;
                  const r5 = t3.displaySize;
                  y5.scale = y5.scale * Vl / p4, b6 = { width: r5[0], height: r5[1], left: lu, top: -3, advance: I3 ? r5[1] : r5[0] }, x5 = l5 + (Vl - r5[1] * y5.scale), k3 = b6.advance;
                  const n5 = I3 ? r5[0] * y5.scale - Vl * a5 : r5[1] * y5.scale - Vl * a5;
                  n5 > 0 && n5 > _5 && (_5 = n5);
                } else {
                  const t3 = n4[y5.fontStack], e4 = t3 && t3[g5];
                  if (e4 && e4.rect) A4 = e4.rect, b6 = e4.metrics;
                  else {
                    const t4 = r4[y5.fontStack], e5 = t4 && t4[g5];
                    if (!e5) continue;
                    b6 = e5.metrics;
                  }
                  x5 = (a5 - y5.scale) * Vl;
                }
                I3 ? (e3.verticalizable = true, w5.push({ glyph: g5, imageName: S3, x: f4, y: d4 + x5, vertical: I3, scale: y5.scale, fontStack: y5.fontStack, sectionIndex: m5, metrics: b6, rect: A4 }), f4 += k3 * y5.scale + c4) : (w5.push({ glyph: g5, imageName: S3, x: f4, y: d4 + x5, vertical: I3, scale: y5.scale, fontStack: y5.fontStack, sectionIndex: m5, metrics: b6, rect: A4 }), f4 += b6.advance * y5.scale + c4);
              }
              0 !== w5.length && (y4 = Math.max(f4 - c4, y4), ku(w5, 0, w5.length - 1, g4, _5)), f4 = 0;
              const A3 = s4 * a5 + _5;
              b5.lineOffset = Math.max(_5, l5), d4 += A3, m4 = Math.max(A3, m4), ++x4;
            }
            var v4;
            const b4 = d4 - pu, { horizontalAlign: w4, verticalAlign: _4 } = Su(o4);
            (function(t3, e4, r5, n5, i5, a5, s5, o5, l5) {
              const u5 = (e4 - r5) * i5;
              let c5 = 0;
              c5 = a5 !== s5 ? -o5 * n5 - pu : (-n5 * l5 + 0.5) * s5;
              for (const e5 of t3) for (const t4 of e5.positionedGlyphs) t4.x += u5, t4.y += c5;
            })(e3.positionedLines, g4, w4, _4, y4, m4, s4, b4, a4.length), e3.top += -_4 * b4, e3.bottom = e3.top + b4, e3.left += -w4 * y4, e3.right = e3.left + y4;
          }(_3, r3, n3, i3, x3, o3, l3, u3, p3, c3, f3, m3), !function(t3) {
            for (const e3 of t3) if (0 !== e3.positionedGlyphs.length) return false;
            return true;
          }(w3) && _3;
        }
        const mu = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, gu = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
        function xu(t3, e2, r3, n3, i3, a3) {
          if (e2.imageName) {
            const t4 = n3[e2.imageName];
            return t4 ? t4.displaySize[0] * e2.scale * Vl / a3 + i3 : 0;
          }
          {
            const n4 = r3[e2.fontStack], a4 = n4 && n4[t3];
            return a4 ? a4.metrics.advance * e2.scale + i3 : 0;
          }
        }
        function vu(t3, e2, r3, n3) {
          const i3 = Math.pow(t3 - e2, 2);
          return n3 ? t3 < e2 ? i3 / 2 : 2 * i3 : i3 + Math.abs(r3) * r3;
        }
        function bu(t3, e2, r3) {
          let n3 = 0;
          return 10 === t3 && (n3 -= 1e4), r3 && (n3 += 150), 40 !== t3 && 65288 !== t3 || (n3 += 50), 41 !== e2 && 65289 !== e2 || (n3 += 50), n3;
        }
        function wu(t3, e2, r3, n3, i3, a3) {
          let s3 = null, o3 = vu(e2, r3, i3, a3);
          for (const t4 of n3) {
            const n4 = vu(e2 - t4.x, r3, i3, a3) + t4.badness;
            n4 <= o3 && (s3 = t4, o3 = n4);
          }
          return { index: t3, x: e2, priorBreak: s3, badness: o3 };
        }
        function _u(t3) {
          return t3 ? _u(t3.priorBreak).concat(t3.index) : [];
        }
        function Au(t3, e2, r3, n3, i3, a3, s3) {
          if ("point" !== a3) return [];
          if (!t3) return [];
          const o3 = [], l3 = function(t4, e3, r4, n4, i4, a4) {
            let s4 = 0;
            for (let r5 = 0; r5 < t4.length(); r5++) {
              const o4 = t4.getSection(r5);
              s4 += xu(t4.getCharCode(r5), o4, n4, i4, e3, a4);
            }
            return s4 / Math.max(1, Math.ceil(s4 / r4));
          }(t3, e2, r3, n3, i3, s3), u3 = t3.text.indexOf("​") >= 0;
          let c3 = 0;
          for (let r4 = 0; r4 < t3.length(); r4++) {
            const a4 = t3.getSection(r4), p3 = t3.getCharCode(r4);
            if (mu[p3] || (c3 += xu(p3, a4, n3, i3, e2, s3)), r4 < t3.length() - 1) {
              const e3 = !((h3 = p3) < 11904 || !(Rn["Bopomofo Extended"](h3) || Rn.Bopomofo(h3) || Rn["CJK Compatibility Forms"](h3) || Rn["CJK Compatibility Ideographs"](h3) || Rn["CJK Compatibility"](h3) || Rn["CJK Radicals Supplement"](h3) || Rn["CJK Strokes"](h3) || Rn["CJK Symbols and Punctuation"](h3) || Rn["CJK Unified Ideographs Extension A"](h3) || Rn["CJK Unified Ideographs"](h3) || Rn["Enclosed CJK Letters and Months"](h3) || Rn["Halfwidth and Fullwidth Forms"](h3) || Rn.Hiragana(h3) || Rn["Ideographic Description Characters"](h3) || Rn["Kangxi Radicals"](h3) || Rn["Katakana Phonetic Extensions"](h3) || Rn.Katakana(h3) || Rn["Vertical Forms"](h3) || Rn["Yi Radicals"](h3) || Rn["Yi Syllables"](h3)));
              (gu[p3] || e3 || a4.imageName) && o3.push(wu(r4 + 1, c3, l3, o3, bu(p3, t3.getCharCode(r4 + 1), e3 && u3), false));
            }
          }
          var h3;
          return _u(wu(t3.length(), c3, l3, o3, 0, true));
        }
        function Su(t3) {
          let e2 = 0.5, r3 = 0.5;
          switch (t3) {
            case "right":
            case "top-right":
            case "bottom-right":
              e2 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e2 = 0;
          }
          switch (t3) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r3 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r3 = 0;
          }
          return { horizontalAlign: e2, verticalAlign: r3 };
        }
        function ku(t3, e2, r3, n3, i3) {
          if (!n3 && !i3) return;
          const a3 = t3[r3], s3 = (t3[r3].x + a3.metrics.advance * a3.scale) * n3;
          for (let n4 = e2; n4 <= r3; n4++) t3[n4].x -= s3, t3[n4].y += i3;
        }
        function Iu(t3, e2, r3) {
          const { horizontalAlign: n3, verticalAlign: i3 } = Su(r3), a3 = e2[0] - t3.displaySize[0] * n3, s3 = e2[1] - t3.displaySize[1] * i3;
          return { image: t3, top: s3, bottom: s3 + t3.displaySize[1], left: a3, right: a3 + t3.displaySize[0] };
        }
        function zu(t3, e2, r3, n3, i3, a3) {
          const s3 = t3.image;
          let o3;
          if (s3.content) {
            const t4 = s3.content, e3 = s3.pixelRatio || 1;
            o3 = [t4[0] / e3, t4[1] / e3, s3.displaySize[0] - t4[2] / e3, s3.displaySize[1] - t4[3] / e3];
          }
          const l3 = e2.left * a3, u3 = e2.right * a3;
          let c3, h3, p3, f3;
          "width" === r3 || "both" === r3 ? (f3 = i3[0] + l3 - n3[3], h3 = i3[0] + u3 + n3[1]) : (f3 = i3[0] + (l3 + u3 - s3.displaySize[0]) / 2, h3 = f3 + s3.displaySize[0]);
          const d3 = e2.top * a3, y3 = e2.bottom * a3;
          return "height" === r3 || "both" === r3 ? (c3 = i3[1] + d3 - n3[0], p3 = i3[1] + y3 + n3[2]) : (c3 = i3[1] + (d3 + y3 - s3.displaySize[1]) / 2, p3 = c3 + s3.displaySize[1]), { image: s3, top: c3, right: h3, bottom: p3, left: f3, collisionPadding: o3 };
        }
        const Mu = 255, Cu = 128, Bu = Mu * Cu;
        function Pu(t3, e2) {
          const { expression: r3 } = e2;
          if ("constant" === r3.kind) return { kind: "constant", layoutSize: r3.evaluate(new li(t3 + 1)) };
          if ("source" === r3.kind) return { kind: "source" };
          {
            const { zoomStops: e3, interpolationType: n3 } = r3;
            let i3 = 0;
            for (; i3 < e3.length && e3[i3] <= t3; ) i3++;
            i3 = Math.max(0, i3 - 1);
            let a3 = i3;
            for (; a3 < e3.length && e3[a3] < t3 + 1; ) a3++;
            a3 = Math.min(e3.length - 1, a3);
            const s3 = e3[i3], o3 = e3[a3];
            return "composite" === r3.kind ? { kind: "composite", minZoom: s3, maxZoom: o3, interpolationType: n3 } : { kind: "camera", minZoom: s3, maxZoom: o3, minSize: r3.evaluate(new li(s3)), maxSize: r3.evaluate(new li(o3)), interpolationType: n3 };
          }
        }
        function Vu(t3, e2, r3) {
          let n3 = "never";
          const i3 = t3.get(e2);
          return i3 ? n3 = i3 : t3.get(r3) && (n3 = "always"), n3;
        }
        const Eu = Ro.VectorTileFeature.types, Fu = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Tu(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3) {
          const f3 = o3 ? Math.min(Bu, Math.round(o3[0])) : 0, d3 = o3 ? Math.min(Bu, Math.round(o3[1])) : 0;
          t3.emplaceBack(e2, r3, Math.round(32 * n3), Math.round(32 * i3), a3, s3, (f3 << 1) + (l3 ? 1 : 0), d3, 16 * u3, 16 * c3, 256 * h3, 256 * p3);
        }
        function $u(t3, e2, r3) {
          t3.emplaceBack(e2.x, e2.y, r3), t3.emplaceBack(e2.x, e2.y, r3), t3.emplaceBack(e2.x, e2.y, r3), t3.emplaceBack(e2.x, e2.y, r3);
        }
        function Lu(t3) {
          for (const e2 of t3.sections) if (Xn(e2.text)) return true;
          return false;
        }
        class Du {
          constructor(t3) {
            this.layoutVertexArray = new xa(), this.indexArray = new Aa(), this.programConfigurations = t3, this.segments = new za(), this.dynamicLayoutVertexArray = new va(), this.opacityVertexArray = new ba(), this.hasVisibleVertices = false, this.placedSymbolArray = new ra();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
          }
          upload(t3, e2, r3, n3) {
            this.isEmpty() || (r3 && (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, kl.members), this.indexBuffer = t3.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t3.createVertexBuffer(this.dynamicLayoutVertexArray, Il.members, true), this.opacityVertexBuffer = t3.createVertexBuffer(this.opacityVertexArray, Fu, true), this.opacityVertexBuffer.itemSize = 1), (r3 || n3) && this.programConfigurations.upload(t3));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        $n("SymbolBuffers", Du);
        class Ou {
          constructor(t3, e2, r3) {
            this.layoutVertexArray = new t3(), this.layoutAttributes = e2, this.indexArray = new r3(), this.segments = new za(), this.collisionVertexArray = new _a2();
          }
          upload(t3) {
            this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t3.createVertexBuffer(this.collisionVertexArray, zl.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        $n("CollisionBuffers", Ou);
        class Uu {
          constructor(e2) {
            this.collisionBoxArray = e2.collisionBoxArray, this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = e2.index, this.pixelRatio = e2.pixelRatio, this.sourceLayerIndex = e2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Ms([]), this.placementViewportMatrix = Ms([]);
            const r3 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Pu(this.zoom, r3["text-size"]), this.iconSizeData = Pu(this.zoom, r3["icon-size"]);
            const n3 = this.layers[0].layout, i3 = n3.get("symbol-sort-key"), a3 = n3.get("symbol-z-order");
            this.canOverlap = "never" !== Vu(n3, "text-overlap", "text-allow-overlap") || "never" !== Vu(n3, "icon-overlap", "icon-allow-overlap") || n3.get("text-ignore-placement") || n3.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== a3 && !i3.isConstant(), this.sortFeaturesByY = ("viewport-y" === a3 || "auto" === a3 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n3.get("symbol-placement") && (this.writingModes = n3.get("text-writing-mode").map((e3) => t2.ai[e3])), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = e2.sourceID;
          }
          createArrays() {
            this.text = new Du(new Qa(this.layers, this.zoom, (t3) => /^text/.test(t3))), this.icon = new Du(new Qa(this.layers, this.zoom, (t3) => /^icon/.test(t3))), this.glyphOffsetArray = new aa(), this.lineVertexArray = new sa(), this.symbolInstances = new ia(), this.textAnchorOffsets = new la();
          }
          calculateGlyphDependencies(t3, e2, r3, n3, i3) {
            for (let a3 = 0; a3 < t3.length; a3++) if (e2[t3.charCodeAt(a3)] = true, (r3 || n3) && i3) {
              const r4 = Pl[t3.charAt(a3)];
              r4 && (e2[r4.charCodeAt(0)] = true);
            }
          }
          populate(e2, r3, n3) {
            const i3 = this.layers[0], a3 = i3.layout, s3 = a3.get("text-font"), o3 = a3.get("text-field"), l3 = a3.get("icon-image"), u3 = ("constant" !== o3.value.kind || o3.value.value instanceof Qt && !o3.value.value.isEmpty() || o3.value.value.toString().length > 0) && ("constant" !== s3.value.kind || s3.value.value.length > 0), c3 = "constant" !== l3.value.kind || !!l3.value.value || Object.keys(l3.parameters).length > 0, h3 = a3.get("symbol-sort-key");
            if (this.features = [], !u3 && !c3) return;
            const p3 = r3.iconDependencies, f3 = r3.glyphDependencies, d3 = r3.availableImages, y3 = new li(this.zoom);
            for (const { feature: r4, id: o4, index: l4, sourceLayerIndex: m3 } of e2) {
              const e3 = i3._featureFilter.needGeometry, g3 = ss2(r4, e3);
              if (!i3._featureFilter.filter(y3, g3, n3)) continue;
              let x3, v3;
              if (e3 || (g3.geometry = as(r4)), u3) {
                const t3 = i3.getValueAndResolveTokens("text-field", g3, n3, d3), e4 = Qt.factory(t3);
                Lu(e4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === ai() || this.hasRTLText && oi.isParsed()) && (x3 = Bl(e4, i3, g3));
              }
              if (c3) {
                const t3 = i3.getValueAndResolveTokens("icon-image", g3, n3, d3);
                v3 = t3 instanceof ne2 ? t3 : ne2.fromString(t3);
              }
              if (!x3 && !v3) continue;
              const b3 = this.sortFeaturesByKey ? h3.evaluate(g3, {}, n3) : void 0;
              if (this.features.push({ id: o4, text: x3, icon: v3, index: l4, sourceLayerIndex: m3, geometry: g3.geometry, properties: r4.properties, type: Eu[r4.type], sortKey: b3 }), v3 && (p3[v3.name] = true), x3) {
                const e4 = s3.evaluate(g3, {}, n3).join(","), r5 = "viewport" !== a3.get("text-rotation-alignment") && "point" !== a3.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t2.ai.vertical) >= 0;
                for (const t3 of x3.sections) if (t3.image) p3[t3.image.name] = true;
                else {
                  const n4 = qn(x3.toString()), i4 = t3.fontStack || e4, a4 = f3[i4] = f3[i4] || {};
                  this.calculateGlyphDependencies(t3.text, a4, r5, this.allowVerticalPlacement, n4);
                }
              }
            }
            "line" === a3.get("symbol-placement") && (this.features = function(t3) {
              const e3 = {}, r4 = {}, n4 = [];
              let i4 = 0;
              function a4(e4) {
                n4.push(t3[e4]), i4++;
              }
              function s4(t4, e4, i5) {
                const a5 = r4[t4];
                return delete r4[t4], r4[e4] = a5, n4[a5].geometry[0].pop(), n4[a5].geometry[0] = n4[a5].geometry[0].concat(i5[0]), a5;
              }
              function o4(t4, r5, i5) {
                const a5 = e3[r5];
                return delete e3[r5], e3[t4] = a5, n4[a5].geometry[0].shift(), n4[a5].geometry[0] = i5[0].concat(n4[a5].geometry[0]), a5;
              }
              function l4(t4, e4, r5) {
                const n5 = r5 ? e4[0][e4[0].length - 1] : e4[0][0];
                return `${t4}:${n5.x}:${n5.y}`;
              }
              for (let u4 = 0; u4 < t3.length; u4++) {
                const c4 = t3[u4], h4 = c4.geometry, p4 = c4.text ? c4.text.toString() : null;
                if (!p4) {
                  a4(u4);
                  continue;
                }
                const f4 = l4(p4, h4), d4 = l4(p4, h4, true);
                if (f4 in r4 && d4 in e3 && r4[f4] !== e3[d4]) {
                  const t4 = o4(f4, d4, h4), i5 = s4(f4, d4, n4[t4].geometry);
                  delete e3[f4], delete r4[d4], r4[l4(p4, n4[i5].geometry, true)] = i5, n4[t4].geometry = null;
                } else f4 in r4 ? s4(f4, d4, h4) : d4 in e3 ? o4(f4, d4, h4) : (a4(u4), e3[f4] = i4 - 1, r4[d4] = i4 - 1);
              }
              return n4.filter((t4) => t4.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t3, e3) => t3.sortKey - e3.sortKey);
          }
          update(t3, e2, r3) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t3, e2, this.layers, r3), this.icon.programConfigurations.updatePaintArrays(t3, e2, this.layers, r3));
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t3) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t3), this.iconCollisionBox.upload(t3)), this.text.upload(t3, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t3, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t3, e2) {
            const r3 = this.lineVertexArray.length;
            if (void 0 !== t3.segment) {
              let r4 = t3.dist(e2[t3.segment + 1]), n3 = t3.dist(e2[t3.segment]);
              const i3 = {};
              for (let n4 = t3.segment + 1; n4 < e2.length; n4++) i3[n4] = { x: e2[n4].x, y: e2[n4].y, tileUnitDistanceFromAnchor: r4 }, n4 < e2.length - 1 && (r4 += e2[n4 + 1].dist(e2[n4]));
              for (let r5 = t3.segment || 0; r5 >= 0; r5--) i3[r5] = { x: e2[r5].x, y: e2[r5].y, tileUnitDistanceFromAnchor: n3 }, r5 > 0 && (n3 += e2[r5 - 1].dist(e2[r5]));
              for (let t4 = 0; t4 < e2.length; t4++) {
                const e3 = i3[t4];
                this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: r3, lineLength: this.lineVertexArray.length - r3 };
          }
          addSymbols(e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3) {
            const f3 = e2.indexArray, d3 = e2.layoutVertexArray, y3 = e2.segments.prepareSegment(4 * r3.length, d3, f3, this.canOverlap ? s3.sortKey : void 0), m3 = this.glyphOffsetArray.length, g3 = y3.vertexLength, x3 = this.allowVerticalPlacement && o3 === t2.ai.vertical ? Math.PI / 2 : 0, v3 = s3.text && s3.text.sections;
            for (let t3 = 0; t3 < r3.length; t3++) {
              const { tl: i4, tr: a4, bl: o4, br: u4, tex: c4, pixelOffsetTL: h4, pixelOffsetBR: m4, minFontScaleX: g4, minFontScaleY: b3, glyphOffset: w3, isSDF: _3, sectionIndex: A3 } = r3[t3], S3 = y3.vertexLength, k3 = w3[1];
              Tu(d3, l3.x, l3.y, i4.x, k3 + i4.y, c4.x, c4.y, n3, _3, h4.x, h4.y, g4, b3), Tu(d3, l3.x, l3.y, a4.x, k3 + a4.y, c4.x + c4.w, c4.y, n3, _3, m4.x, h4.y, g4, b3), Tu(d3, l3.x, l3.y, o4.x, k3 + o4.y, c4.x, c4.y + c4.h, n3, _3, h4.x, m4.y, g4, b3), Tu(d3, l3.x, l3.y, u4.x, k3 + u4.y, c4.x + c4.w, c4.y + c4.h, n3, _3, m4.x, m4.y, g4, b3), $u(e2.dynamicLayoutVertexArray, l3, x3), f3.emplaceBack(S3, S3 + 1, S3 + 2), f3.emplaceBack(S3 + 1, S3 + 2, S3 + 3), y3.vertexLength += 4, y3.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w3[0]), t3 !== r3.length - 1 && A3 === r3[t3 + 1].sectionIndex || e2.programConfigurations.populatePaintArrays(d3.length, s3, s3.index, {}, p3, v3 && v3[A3]);
            }
            e2.placedSymbolArray.emplaceBack(l3.x, l3.y, m3, this.glyphOffsetArray.length - m3, g3, u3, c3, l3.segment, n3 ? n3[0] : 0, n3 ? n3[1] : 0, i3[0], i3[1], o3, 0, false, 0, h3);
          }
          _addCollisionDebugVertex(t3, e2, r3, n3, i3, a3) {
            return e2.emplaceBack(0, 0), t3.emplaceBack(r3.x, r3.y, n3, i3, Math.round(a3.x), Math.round(a3.y));
          }
          addCollisionDebugVertices(t3, e2, r3, n3, i3, s3, o3) {
            const l3 = i3.segments.prepareSegment(4, i3.layoutVertexArray, i3.indexArray), u3 = l3.vertexLength, c3 = i3.layoutVertexArray, h3 = i3.collisionVertexArray, p3 = o3.anchorX, f3 = o3.anchorY;
            this._addCollisionDebugVertex(c3, h3, s3, p3, f3, new a2(t3, e2)), this._addCollisionDebugVertex(c3, h3, s3, p3, f3, new a2(r3, e2)), this._addCollisionDebugVertex(c3, h3, s3, p3, f3, new a2(r3, n3)), this._addCollisionDebugVertex(c3, h3, s3, p3, f3, new a2(t3, n3)), l3.vertexLength += 4;
            const d3 = i3.indexArray;
            d3.emplaceBack(u3, u3 + 1), d3.emplaceBack(u3 + 1, u3 + 2), d3.emplaceBack(u3 + 2, u3 + 3), d3.emplaceBack(u3 + 3, u3), l3.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t3, e2, r3, n3) {
            for (let i3 = t3; i3 < e2; i3++) {
              const t4 = this.collisionBoxArray.get(i3);
              this.addCollisionDebugVertices(t4.x1, t4.y1, t4.x2, t4.y2, n3 ? this.textCollisionBox : this.iconCollisionBox, t4.anchorPoint, r3);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Ou(wa, Ml.members, Sa), this.iconCollisionBox = new Ou(wa, Ml.members, Sa);
            for (let t3 = 0; t3 < this.symbolInstances.length; t3++) {
              const e2 = this.symbolInstances.get(t3);
              this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(t3, e2, r3, n3, i3, a3, s3, o3, l3) {
            const u3 = {};
            for (let n4 = e2; n4 < r3; n4++) {
              const e3 = t3.get(n4);
              u3.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, anchorPointX: e3.anchorPointX, anchorPointY: e3.anchorPointY }, u3.textFeatureIndex = e3.featureIndex;
              break;
            }
            for (let e3 = n3; e3 < i3; e3++) {
              const r4 = t3.get(e3);
              u3.verticalTextBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, anchorPointX: r4.anchorPointX, anchorPointY: r4.anchorPointY }, u3.verticalTextFeatureIndex = r4.featureIndex;
              break;
            }
            for (let e3 = a3; e3 < s3; e3++) {
              const r4 = t3.get(e3);
              u3.iconBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, anchorPointX: r4.anchorPointX, anchorPointY: r4.anchorPointY }, u3.iconFeatureIndex = r4.featureIndex;
              break;
            }
            for (let e3 = o3; e3 < l3; e3++) {
              const r4 = t3.get(e3);
              u3.verticalIconBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, anchorPointX: r4.anchorPointX, anchorPointY: r4.anchorPointY }, u3.verticalIconFeatureIndex = r4.featureIndex;
              break;
            }
            return u3;
          }
          deserializeCollisionBoxes(t3) {
            this.collisionArrays = [];
            for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
              const r3 = this.symbolInstances.get(e2);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t3, r3.textBoxStartIndex, r3.textBoxEndIndex, r3.verticalTextBoxStartIndex, r3.verticalTextBoxEndIndex, r3.iconBoxStartIndex, r3.iconBoxEndIndex, r3.verticalIconBoxStartIndex, r3.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t3, e2) {
            const r3 = t3.placedSymbolArray.get(e2), n3 = r3.vertexStartIndex + 4 * r3.numGlyphs;
            for (let e3 = r3.vertexStartIndex; e3 < n3; e3 += 4) t3.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t3.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
          }
          getSortedSymbolIndexes(t3) {
            if (this.sortedAngle === t3 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
            const e2 = Math.sin(t3), r3 = Math.cos(t3), n3 = [], i3 = [], a3 = [];
            for (let t4 = 0; t4 < this.symbolInstances.length; ++t4) {
              a3.push(t4);
              const s3 = this.symbolInstances.get(t4);
              n3.push(0 | Math.round(e2 * s3.anchorX + r3 * s3.anchorY)), i3.push(s3.featureIndex);
            }
            return a3.sort((t4, e3) => n3[t4] - n3[e3] || i3[e3] - i3[t4]), a3;
          }
          addToSortKeyRanges(t3, e2) {
            const r3 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r3 && r3.sortKey === e2 ? r3.symbolInstanceEnd = t3 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t3, symbolInstanceEnd: t3 + 1 });
          }
          sortFeatures(t3) {
            if (this.sortFeaturesByY && this.sortedAngle !== t3 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t3), this.sortedAngle = t3, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t4 of this.symbolInstanceIndexes) {
                const e2 = this.symbolInstances.get(t4);
                this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach((t5, e3, r3) => {
                  t5 >= 0 && r3.indexOf(t5) === e3 && this.addIndicesForPlacedSymbol(this.text, t5);
                }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let Ru, qu;
        $n("SymbolBucket", Uu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Uu.MAX_GLYPHS = 65535, Uu.addDynamicAttributes = $u;
        var ju = { get paint() {
          return qu = qu || new _i({ "icon-opacity": new xi(X2.paint_symbol["icon-opacity"]), "icon-color": new xi(X2.paint_symbol["icon-color"]), "icon-halo-color": new xi(X2.paint_symbol["icon-halo-color"]), "icon-halo-width": new xi(X2.paint_symbol["icon-halo-width"]), "icon-halo-blur": new xi(X2.paint_symbol["icon-halo-blur"]), "icon-translate": new gi(X2.paint_symbol["icon-translate"]), "icon-translate-anchor": new gi(X2.paint_symbol["icon-translate-anchor"]), "text-opacity": new xi(X2.paint_symbol["text-opacity"]), "text-color": new xi(X2.paint_symbol["text-color"], { runtimeType: yt, getOverride: (t3) => t3.textColor, hasOverride: (t3) => !!t3.textColor }), "text-halo-color": new xi(X2.paint_symbol["text-halo-color"]), "text-halo-width": new xi(X2.paint_symbol["text-halo-width"]), "text-halo-blur": new xi(X2.paint_symbol["text-halo-blur"]), "text-translate": new gi(X2.paint_symbol["text-translate"]), "text-translate-anchor": new gi(X2.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return Ru = Ru || new _i({ "symbol-placement": new gi(X2.layout_symbol["symbol-placement"]), "symbol-spacing": new gi(X2.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new gi(X2.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new xi(X2.layout_symbol["symbol-sort-key"]), "symbol-z-order": new gi(X2.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new gi(X2.layout_symbol["icon-allow-overlap"]), "icon-overlap": new gi(X2.layout_symbol["icon-overlap"]), "icon-ignore-placement": new gi(X2.layout_symbol["icon-ignore-placement"]), "icon-optional": new gi(X2.layout_symbol["icon-optional"]), "icon-rotation-alignment": new gi(X2.layout_symbol["icon-rotation-alignment"]), "icon-size": new xi(X2.layout_symbol["icon-size"]), "icon-text-fit": new gi(X2.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new gi(X2.layout_symbol["icon-text-fit-padding"]), "icon-image": new xi(X2.layout_symbol["icon-image"]), "icon-rotate": new xi(X2.layout_symbol["icon-rotate"]), "icon-padding": new xi(X2.layout_symbol["icon-padding"]), "icon-keep-upright": new gi(X2.layout_symbol["icon-keep-upright"]), "icon-offset": new xi(X2.layout_symbol["icon-offset"]), "icon-anchor": new xi(X2.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new gi(X2.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new gi(X2.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new gi(X2.layout_symbol["text-rotation-alignment"]), "text-field": new xi(X2.layout_symbol["text-field"]), "text-font": new xi(X2.layout_symbol["text-font"]), "text-size": new xi(X2.layout_symbol["text-size"]), "text-max-width": new xi(X2.layout_symbol["text-max-width"]), "text-line-height": new gi(X2.layout_symbol["text-line-height"]), "text-letter-spacing": new xi(X2.layout_symbol["text-letter-spacing"]), "text-justify": new xi(X2.layout_symbol["text-justify"]), "text-radial-offset": new xi(X2.layout_symbol["text-radial-offset"]), "text-variable-anchor": new gi(X2.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new xi(X2.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new xi(X2.layout_symbol["text-anchor"]), "text-max-angle": new gi(X2.layout_symbol["text-max-angle"]), "text-writing-mode": new gi(X2.layout_symbol["text-writing-mode"]), "text-rotate": new xi(X2.layout_symbol["text-rotate"]), "text-padding": new gi(X2.layout_symbol["text-padding"]), "text-keep-upright": new gi(X2.layout_symbol["text-keep-upright"]), "text-transform": new xi(X2.layout_symbol["text-transform"]), "text-offset": new xi(X2.layout_symbol["text-offset"]), "text-allow-overlap": new gi(X2.layout_symbol["text-allow-overlap"]), "text-overlap": new gi(X2.layout_symbol["text-overlap"]), "text-ignore-placement": new gi(X2.layout_symbol["text-ignore-placement"]), "text-optional": new gi(X2.layout_symbol["text-optional"]) });
        } };
        class Nu {
          constructor(t3) {
            if (void 0 === t3.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t3.property.overrides ? t3.property.overrides.runtimeType : ht, this.defaultValue = t3;
          }
          evaluate(t3) {
            if (t3.formattedSection) {
              const e2 = this.defaultValue.property.overrides;
              if (e2 && e2.hasOverride(t3.formattedSection)) return e2.getOverride(t3.formattedSection);
            }
            return t3.feature && t3.featureState ? this.defaultValue.evaluate(t3.feature, t3.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t3) {
            this.defaultValue.isConstant() || t3(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        $n("FormatSectionOverride", Nu, { omit: ["defaultValue"] });
        class Zu extends Si {
          constructor(t3) {
            super(t3, ju);
          }
          recalculate(t3, e2) {
            if (super.recalculate(t3, e2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
              const t4 = this.layout.get("text-writing-mode");
              if (t4) {
                const e3 = [];
                for (const r3 of t4) e3.indexOf(r3) < 0 && e3.push(r3);
                this.layout._values["text-writing-mode"] = e3;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t3, e2, r3, n3) {
            const i3 = this.layout.get(t3).evaluate(e2, {}, r3, n3), a3 = this._unevaluatedLayout._values[t3];
            return a3.isDataDriven() || Tr(a3.value) || !i3 ? i3 : function(t4, e3) {
              return e3.replace(/{([^{}]+)}/g, (e4, r4) => t4 && r4 in t4 ? String(t4[r4]) : "");
            }(e2.properties, i3);
          }
          createBucket(t3) {
            return new Uu(t3);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t3 of ju.paint.overridableProperties) {
              if (!Zu.hasPaintOverride(this.layout, t3)) continue;
              const e2 = this.paint.get(t3), r3 = new Nu(e2), n3 = new Fr(r3, e2.property.specification);
              let i3 = null;
              i3 = "constant" === e2.value.kind || "source" === e2.value.kind ? new Lr("source", n3) : new Dr("composite", n3, e2.value.zoomStops), this.paint._values[t3] = new yi(e2.property, i3, e2.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t3, e2, r3) {
            return !(!this.layout || e2.isDataDriven() || r3.isDataDriven()) && Zu.hasPaintOverride(this.layout, t3);
          }
          static hasPaintOverride(t3, e2) {
            const r3 = t3.get("text-field"), n3 = ju.paint.properties[e2];
            let i3 = false;
            const a3 = (t4) => {
              for (const e3 of t4) if (n3.overrides && n3.overrides.hasOverride(e3)) return void (i3 = true);
            };
            if ("constant" === r3.value.kind && r3.value.value instanceof Qt) a3(r3.value.value.sections);
            else if ("source" === r3.value.kind) {
              const t4 = (e4) => {
                i3 || (e4 instanceof le2 && se2(e4.value) === vt ? a3(e4.value.sections) : e4 instanceof pr ? a3(e4.sections) : e4.eachChild(t4));
              }, e3 = r3.value;
              e3._styleExpression && t4(e3._styleExpression.expression);
            }
            return i3;
          }
        }
        let Ku;
        var Gu = { get paint() {
          return Ku = Ku || new _i({ "background-color": new gi(X2.paint_background["background-color"]), "background-pattern": new bi(X2.paint_background["background-pattern"]), "background-opacity": new gi(X2.paint_background["background-opacity"]) });
        } };
        class Ju extends Si {
          constructor(t3) {
            super(t3, Gu);
          }
        }
        let Xu;
        var Yu = { get paint() {
          return Xu = Xu || new _i({ "raster-opacity": new gi(X2.paint_raster["raster-opacity"]), "raster-hue-rotate": new gi(X2.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new gi(X2.paint_raster["raster-brightness-min"]), "raster-brightness-max": new gi(X2.paint_raster["raster-brightness-max"]), "raster-saturation": new gi(X2.paint_raster["raster-saturation"]), "raster-contrast": new gi(X2.paint_raster["raster-contrast"]), "raster-resampling": new gi(X2.paint_raster["raster-resampling"]), "raster-fade-duration": new gi(X2.paint_raster["raster-fade-duration"]) });
        } };
        class Hu extends Si {
          constructor(t3) {
            super(t3, Yu);
          }
        }
        class Wu extends Si {
          constructor(t3) {
            super(t3, {}), this.onAdd = (t4) => {
              this.implementation.onAdd && this.implementation.onAdd(t4, t4.painter.context.gl);
            }, this.onRemove = (t4) => {
              this.implementation.onRemove && this.implementation.onRemove(t4, t4.painter.context.gl);
            }, this.implementation = t3;
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class Qu {
          constructor(t3) {
            this._callback = t3, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._callback();
            }, 0));
          }
          remove() {
            delete this._channel, this._callback = () => {
            };
          }
        }
        const tc = 63710088e-1;
        class ec {
          constructor(t3, e2) {
            if (isNaN(t3) || isNaN(e2)) throw new Error(`Invalid LngLat object: (${t3}, ${e2})`);
            if (this.lng = +t3, this.lat = +e2, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new ec(m2(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t3) {
            const e2 = Math.PI / 180, r3 = this.lat * e2, n3 = t3.lat * e2, i3 = Math.sin(r3) * Math.sin(n3) + Math.cos(r3) * Math.cos(n3) * Math.cos((t3.lng - this.lng) * e2);
            return tc * Math.acos(Math.min(i3, 1));
          }
          static convert(t3) {
            if (t3 instanceof ec) return t3;
            if (Array.isArray(t3) && (2 === t3.length || 3 === t3.length)) return new ec(Number(t3[0]), Number(t3[1]));
            if (!Array.isArray(t3) && "object" == typeof t3 && null !== t3) return new ec(Number("lng" in t3 ? t3.lng : t3.lon), Number(t3.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const rc = 2 * Math.PI * tc;
        function nc(t3) {
          return rc * Math.cos(t3 * Math.PI / 180);
        }
        function ic(t3) {
          return (180 + t3) / 360;
        }
        function ac(t3) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3 * Math.PI / 360))) / 360;
        }
        function sc(t3, e2) {
          return t3 / nc(e2);
        }
        function oc(t3) {
          return 360 * t3 - 180;
        }
        function lc(t3) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t3) * Math.PI / 180)) - 90;
        }
        class uc {
          constructor(t3, e2, r3 = 0) {
            this.x = +t3, this.y = +e2, this.z = +r3;
          }
          static fromLngLat(t3, e2 = 0) {
            const r3 = ec.convert(t3);
            return new uc(ic(r3.lng), ac(r3.lat), sc(e2, r3.lat));
          }
          toLngLat() {
            return new ec(oc(this.x), lc(this.y));
          }
          toAltitude() {
            return this.z * nc(lc(this.y));
          }
          meterInMercatorCoordinateUnits() {
            return 1 / rc * (t3 = lc(this.y), 1 / Math.cos(t3 * Math.PI / 180));
            var t3;
          }
        }
        function cc(t3, e2, r3) {
          var n3 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r3);
          return [t3 * n3 - 2 * Math.PI * 6378137 / 2, e2 * n3 - 2 * Math.PI * 6378137 / 2];
        }
        class hc {
          constructor(t3, e2, r3) {
            if (t3 < 0 || t3 > 25 || r3 < 0 || r3 >= Math.pow(2, t3) || e2 < 0 || e2 >= Math.pow(2, t3)) throw new Error(`x=${e2}, y=${r3}, z=${t3} outside of bounds. 0<=x<${Math.pow(2, t3)}, 0<=y<${Math.pow(2, t3)} 0<=z<=25 `);
            this.z = t3, this.x = e2, this.y = r3, this.key = dc(0, t3, t3, e2, r3);
          }
          equals(t3) {
            return this.z === t3.z && this.x === t3.x && this.y === t3.y;
          }
          url(t3, e2, r3) {
            const n3 = (a3 = this.y, s3 = this.z, o3 = cc(256 * (i3 = this.x), 256 * (a3 = Math.pow(2, s3) - a3 - 1), s3), l3 = cc(256 * (i3 + 1), 256 * (a3 + 1), s3), o3[0] + "," + o3[1] + "," + l3[0] + "," + l3[1]);
            var i3, a3, s3, o3, l3;
            const u3 = function(t4, e3, r4) {
              let n4, i4 = "";
              for (let a4 = t4; a4 > 0; a4--) n4 = 1 << a4 - 1, i4 += (e3 & n4 ? 1 : 0) + (r4 & n4 ? 2 : 0);
              return i4;
            }(this.z, this.x, this.y);
            return t3[(this.x + this.y) % t3.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r3 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e2 > 1 ? "@2x" : "").replace(/{quadkey}/g, u3).replace(/{bbox-epsg-3857}/g, n3);
          }
          isChildOf(t3) {
            const e2 = this.z - t3.z;
            return e2 > 0 && t3.x === this.x >> e2 && t3.y === this.y >> e2;
          }
          getTilePoint(t3) {
            const e2 = Math.pow(2, this.z);
            return new a2((t3.x * e2 - this.x) * rs, (t3.y * e2 - this.y) * rs);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class pc {
          constructor(t3, e2) {
            this.wrap = t3, this.canonical = e2, this.key = dc(t3, e2.z, e2.z, e2.x, e2.y);
          }
        }
        class fc {
          constructor(t3, e2, r3, n3, i3) {
            if (t3 < r3) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t3}; z = ${r3}`);
            this.overscaledZ = t3, this.wrap = e2, this.canonical = new hc(r3, +n3, +i3), this.key = dc(e2, t3, r3, n3, i3);
          }
          clone() {
            return new fc(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t3) {
            return this.overscaledZ === t3.overscaledZ && this.wrap === t3.wrap && this.canonical.equals(t3.canonical);
          }
          scaledTo(t3) {
            if (t3 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t3}; overscaledZ = ${this.overscaledZ}`);
            const e2 = this.canonical.z - t3;
            return t3 > this.canonical.z ? new fc(t3, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new fc(t3, this.wrap, t3, this.canonical.x >> e2, this.canonical.y >> e2);
          }
          calculateScaledKey(t3, e2) {
            if (t3 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t3}; overscaledZ = ${this.overscaledZ}`);
            const r3 = this.canonical.z - t3;
            return t3 > this.canonical.z ? dc(this.wrap * +e2, t3, this.canonical.z, this.canonical.x, this.canonical.y) : dc(this.wrap * +e2, t3, t3, this.canonical.x >> r3, this.canonical.y >> r3);
          }
          isChildOf(t3) {
            if (t3.wrap !== this.wrap) return false;
            const e2 = this.canonical.z - t3.canonical.z;
            return 0 === t3.overscaledZ || t3.overscaledZ < this.overscaledZ && t3.canonical.x === this.canonical.x >> e2 && t3.canonical.y === this.canonical.y >> e2;
          }
          children(t3) {
            if (this.overscaledZ >= t3) return [new fc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e2 = this.canonical.z + 1, r3 = 2 * this.canonical.x, n3 = 2 * this.canonical.y;
            return [new fc(e2, this.wrap, e2, r3, n3), new fc(e2, this.wrap, e2, r3 + 1, n3), new fc(e2, this.wrap, e2, r3, n3 + 1), new fc(e2, this.wrap, e2, r3 + 1, n3 + 1)];
          }
          isLessThan(t3) {
            return this.wrap < t3.wrap || !(this.wrap > t3.wrap) && (this.overscaledZ < t3.overscaledZ || !(this.overscaledZ > t3.overscaledZ) && (this.canonical.x < t3.canonical.x || !(this.canonical.x > t3.canonical.x) && this.canonical.y < t3.canonical.y));
          }
          wrapped() {
            return new fc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t3) {
            return new fc(this.overscaledZ, t3, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new pc(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t3) {
            return this.canonical.getTilePoint(new uc(t3.x - this.wrap, t3.y));
          }
        }
        function dc(t3, e2, r3, n3, i3) {
          (t3 *= 2) < 0 && (t3 = -1 * t3 - 1);
          const a3 = 1 << r3;
          return (a3 * a3 * t3 + a3 * i3 + n3).toString(36) + r3.toString(36) + e2.toString(36);
        }
        $n("CanonicalTileID", hc), $n("OverscaledTileID", fc, { omit: ["posMatrix"] });
        class yc {
          constructor(t3, e2, r3, n3 = 1, i3 = 1, a3 = 1, s3 = 0) {
            if (this.uid = t3, e2.height !== e2.width) throw new RangeError("DEM tiles must be square");
            if (r3 && !["mapbox", "terrarium", "custom"].includes(r3)) return void A2(`"${r3}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = e2.height;
            const o3 = this.dim = e2.height - 2;
            switch (this.data = new Uint32Array(e2.data.buffer), r3) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = n3, this.greenFactor = i3, this.blueFactor = a3, this.baseShift = s3;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let t4 = 0; t4 < o3; t4++) this.data[this._idx(-1, t4)] = this.data[this._idx(0, t4)], this.data[this._idx(o3, t4)] = this.data[this._idx(o3 - 1, t4)], this.data[this._idx(t4, -1)] = this.data[this._idx(t4, 0)], this.data[this._idx(t4, o3)] = this.data[this._idx(t4, o3 - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o3, -1)] = this.data[this._idx(o3 - 1, 0)], this.data[this._idx(-1, o3)] = this.data[this._idx(0, o3 - 1)], this.data[this._idx(o3, o3)] = this.data[this._idx(o3 - 1, o3 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let t4 = 0; t4 < o3; t4++) for (let e3 = 0; e3 < o3; e3++) {
              const r4 = this.get(t4, e3);
              r4 > this.max && (this.max = r4), r4 < this.min && (this.min = r4);
            }
          }
          get(t3, e2) {
            const r3 = new Uint8Array(this.data.buffer), n3 = 4 * this._idx(t3, e2);
            return this.unpack(r3[n3], r3[n3 + 1], r3[n3 + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t3, e2) {
            if (t3 < -1 || t3 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (e2 + 1) * this.stride + (t3 + 1);
          }
          unpack(t3, e2, r3) {
            return t3 * this.redFactor + e2 * this.greenFactor + r3 * this.blueFactor - this.baseShift;
          }
          getPixels() {
            return new qs({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t3, e2, r3) {
            if (this.dim !== t3.dim) throw new Error("dem dimension mismatch");
            let n3 = e2 * this.dim, i3 = e2 * this.dim + this.dim, a3 = r3 * this.dim, s3 = r3 * this.dim + this.dim;
            switch (e2) {
              case -1:
                n3 = i3 - 1;
                break;
              case 1:
                i3 = n3 + 1;
            }
            switch (r3) {
              case -1:
                a3 = s3 - 1;
                break;
              case 1:
                s3 = a3 + 1;
            }
            const o3 = -e2 * this.dim, l3 = -r3 * this.dim;
            for (let e3 = a3; e3 < s3; e3++) for (let r4 = n3; r4 < i3; r4++) this.data[this._idx(r4, e3)] = t3.data[this._idx(r4 + o3, e3 + l3)];
          }
        }
        $n("DEMData", yc);
        class mc {
          constructor(t3) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e2 = 0; e2 < t3.length; e2++) {
              const r3 = t3[e2];
              this._stringToNumber[r3] = e2, this._numberToString[e2] = r3;
            }
          }
          encode(t3) {
            return this._stringToNumber[t3];
          }
          decode(t3) {
            if (t3 >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t3} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t3];
          }
        }
        class gc {
          constructor(t3, e2, r3, n3, i3) {
            this.type = "Feature", this._vectorTileFeature = t3, t3._z = e2, t3._x = r3, t3._y = n3, this.properties = t3.properties, this.id = i3;
          }
          get geometry() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t3) {
            this._geometry = t3;
          }
          toJSON() {
            const t3 = { geometry: this.geometry };
            for (const e2 in this) "_geometry" !== e2 && "_vectorTileFeature" !== e2 && (t3[e2] = this[e2]);
            return t3;
          }
        }
        class xc {
          constructor(t3, e2) {
            this.tileID = t3, this.x = t3.canonical.x, this.y = t3.canonical.y, this.z = t3.canonical.z, this.grid = new Fn(rs, 16, 0), this.grid3D = new Fn(rs, 16, 0), this.featureIndexArray = new ca(), this.promoteId = e2;
          }
          insert(t3, e2, r3, n3, i3, a3) {
            const s3 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r3, n3, i3);
            const o3 = a3 ? this.grid3D : this.grid;
            for (let t4 = 0; t4 < e2.length; t4++) {
              const r4 = e2[t4], n4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t5 = 0; t5 < r4.length; t5++) {
                const e3 = r4[t5];
                n4[0] = Math.min(n4[0], e3.x), n4[1] = Math.min(n4[1], e3.y), n4[2] = Math.max(n4[2], e3.x), n4[3] = Math.max(n4[3], e3.y);
              }
              n4[0] < rs && n4[1] < rs && n4[2] >= 0 && n4[3] >= 0 && o3.insert(s3, n4[0], n4[1], n4[2], n4[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new Ro.VectorTile(new eu(this.rawTileData)).layers, this.sourceLayerCoder = new mc(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t3, e2, r3, n3) {
            this.loadVTLayers();
            const i3 = t3.params || {}, s3 = rs / t3.tileSize / t3.scale, o3 = Nr(i3.filter), l3 = t3.queryGeometry, u3 = t3.queryPadding * s3, c3 = bc(l3), h3 = this.grid.query(c3.minX - u3, c3.minY - u3, c3.maxX + u3, c3.maxY + u3), p3 = bc(t3.cameraQueryGeometry), f3 = this.grid3D.query(p3.minX - u3, p3.minY - u3, p3.maxX + u3, p3.maxY + u3, (e3, r4, n4, i4) => function(t4, e4, r5, n5, i5) {
              for (const a3 of t4) if (e4 <= a3.x && r5 <= a3.y && n5 >= a3.x && i5 >= a3.y) return true;
              const s4 = [new a2(e4, r5), new a2(e4, i5), new a2(n5, i5), new a2(n5, r5)];
              if (t4.length > 2) {
                for (const e5 of s4) if (xs(t4, e5)) return true;
              }
              for (let e5 = 0; e5 < t4.length - 1; e5++) if (vs(t4[e5], t4[e5 + 1], s4)) return true;
              return false;
            }(t3.cameraQueryGeometry, e3 - u3, r4 - u3, n4 + u3, i4 + u3));
            for (const t4 of f3) h3.push(t4);
            h3.sort(wc);
            const d3 = {};
            let y3;
            for (let a3 = 0; a3 < h3.length; a3++) {
              const u4 = h3[a3];
              if (u4 === y3) continue;
              y3 = u4;
              const c4 = this.featureIndexArray.get(u4);
              let p4 = null;
              this.loadMatchingFeature(d3, c4.bucketIndex, c4.sourceLayerIndex, c4.featureIndex, o3, i3.layers, i3.availableImages, e2, r3, n3, (e3, r4, n4) => (p4 || (p4 = as(e3)), r4.queryIntersectsFeature(l3, e3, n4, p4, this.z, t3.transform, s3, t3.pixelPosMatrix)));
            }
            return d3;
          }
          loadMatchingFeature(t3, e2, r3, n3, i3, a3, s3, o3, l3, u3, c3) {
            const h3 = this.bucketLayerIDs[e2];
            if (a3 && !function(t4, e3) {
              for (let r4 = 0; r4 < t4.length; r4++) if (e3.indexOf(t4[r4]) >= 0) return true;
              return false;
            }(a3, h3)) return;
            const p3 = this.sourceLayerCoder.decode(r3), f3 = this.vtLayers[p3].feature(n3);
            if (i3.needGeometry) {
              const t4 = ss2(f3, true);
              if (!i3.filter(new li(this.tileID.overscaledZ), t4, this.tileID.canonical)) return;
            } else if (!i3.filter(new li(this.tileID.overscaledZ), f3)) return;
            const d3 = this.getId(f3, p3);
            for (let e3 = 0; e3 < h3.length; e3++) {
              const r4 = h3[e3];
              if (a3 && a3.indexOf(r4) < 0) continue;
              const i4 = o3[r4];
              if (!i4) continue;
              let p4 = {};
              d3 && u3 && (p4 = u3.getState(i4.sourceLayer || "_geojsonTileLayer", d3));
              const y3 = g2({}, l3[r4]);
              y3.paint = vc(y3.paint, i4.paint, f3, p4, s3), y3.layout = vc(y3.layout, i4.layout, f3, p4, s3);
              const m3 = !c3 || c3(f3, i4, p4);
              if (!m3) continue;
              const x3 = new gc(f3, this.z, this.x, this.y, d3);
              x3.layer = y3;
              let v3 = t3[r4];
              void 0 === v3 && (v3 = t3[r4] = []), v3.push({ featureIndex: n3, feature: x3, intersectionZ: m3 });
            }
          }
          lookupSymbolFeatures(t3, e2, r3, n3, i3, a3, s3, o3) {
            const l3 = {};
            this.loadVTLayers();
            const u3 = Nr(i3);
            for (const i4 of t3) this.loadMatchingFeature(l3, r3, n3, i4, u3, a3, s3, o3, e2);
            return l3;
          }
          hasLayer(t3) {
            for (const e2 of this.bucketLayerIDs) for (const r3 of e2) if (t3 === r3) return true;
            return false;
          }
          getId(t3, e2) {
            let r3 = t3.id;
            return this.promoteId && (r3 = t3.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2]], "boolean" == typeof r3 && (r3 = Number(r3))), r3;
          }
        }
        function vc(t3, e2, r3, n3, i3) {
          return v2(t3, (t4, a3) => {
            const s3 = e2 instanceof mi ? e2.get(a3) : null;
            return s3 && s3.evaluate ? s3.evaluate(r3, n3, i3) : s3;
          });
        }
        function bc(t3) {
          let e2 = 1 / 0, r3 = 1 / 0, n3 = -1 / 0, i3 = -1 / 0;
          for (const a3 of t3) e2 = Math.min(e2, a3.x), r3 = Math.min(r3, a3.y), n3 = Math.max(n3, a3.x), i3 = Math.max(i3, a3.y);
          return { minX: e2, minY: r3, maxX: n3, maxY: i3 };
        }
        function wc(t3, e2) {
          return e2 - t3;
        }
        function _c(t3, e2, r3, n3, i3) {
          const s3 = [];
          for (let o3 = 0; o3 < t3.length; o3++) {
            const l3 = t3[o3];
            let u3;
            for (let t4 = 0; t4 < l3.length - 1; t4++) {
              let o4 = l3[t4], c3 = l3[t4 + 1];
              o4.x < e2 && c3.x < e2 || (o4.x < e2 ? o4 = new a2(e2, o4.y + (e2 - o4.x) / (c3.x - o4.x) * (c3.y - o4.y))._round() : c3.x < e2 && (c3 = new a2(e2, o4.y + (e2 - o4.x) / (c3.x - o4.x) * (c3.y - o4.y))._round()), o4.y < r3 && c3.y < r3 || (o4.y < r3 ? o4 = new a2(o4.x + (r3 - o4.y) / (c3.y - o4.y) * (c3.x - o4.x), r3)._round() : c3.y < r3 && (c3 = new a2(o4.x + (r3 - o4.y) / (c3.y - o4.y) * (c3.x - o4.x), r3)._round()), o4.x >= n3 && c3.x >= n3 || (o4.x >= n3 ? o4 = new a2(n3, o4.y + (n3 - o4.x) / (c3.x - o4.x) * (c3.y - o4.y))._round() : c3.x >= n3 && (c3 = new a2(n3, o4.y + (n3 - o4.x) / (c3.x - o4.x) * (c3.y - o4.y))._round()), o4.y >= i3 && c3.y >= i3 || (o4.y >= i3 ? o4 = new a2(o4.x + (i3 - o4.y) / (c3.y - o4.y) * (c3.x - o4.x), i3)._round() : c3.y >= i3 && (c3 = new a2(o4.x + (i3 - o4.y) / (c3.y - o4.y) * (c3.x - o4.x), i3)._round()), u3 && o4.equals(u3[u3.length - 1]) || (u3 = [o4], s3.push(u3)), u3.push(c3)))));
            }
          }
          return s3;
        }
        $n("FeatureIndex", xc, { omit: ["rawTileData", "sourceLayerCoder"] });
        class Ac extends a2 {
          constructor(t3, e2, r3, n3) {
            super(t3, e2), this.angle = r3, void 0 !== n3 && (this.segment = n3);
          }
          clone() {
            return new Ac(this.x, this.y, this.angle, this.segment);
          }
        }
        function Sc(t3, e2, r3, n3, i3) {
          if (void 0 === e2.segment || 0 === r3) return true;
          let a3 = e2, s3 = e2.segment + 1, o3 = 0;
          for (; o3 > -r3 / 2; ) {
            if (s3--, s3 < 0) return false;
            o3 -= t3[s3].dist(a3), a3 = t3[s3];
          }
          o3 += t3[s3].dist(t3[s3 + 1]), s3++;
          const l3 = [];
          let u3 = 0;
          for (; o3 < r3 / 2; ) {
            const e3 = t3[s3], r4 = t3[s3 + 1];
            if (!r4) return false;
            let a4 = t3[s3 - 1].angleTo(e3) - e3.angleTo(r4);
            for (a4 = Math.abs((a4 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l3.push({ distance: o3, angleDelta: a4 }), u3 += a4; o3 - l3[0].distance > n3; ) u3 -= l3.shift().angleDelta;
            if (u3 > i3) return false;
            s3++, o3 += e3.dist(r4);
          }
          return true;
        }
        function kc(t3) {
          let e2 = 0;
          for (let r3 = 0; r3 < t3.length - 1; r3++) e2 += t3[r3].dist(t3[r3 + 1]);
          return e2;
        }
        function Ic(t3, e2, r3) {
          return t3 ? 0.6 * e2 * r3 : 0;
        }
        function zc(t3, e2) {
          return Math.max(t3 ? t3.right - t3.left : 0, e2 ? e2.right - e2.left : 0);
        }
        function Mc(t3, e2, r3, n3, i3, a3) {
          const s3 = Ic(r3, i3, a3), o3 = zc(r3, n3) * a3;
          let l3 = 0;
          const u3 = kc(t3) / 2;
          for (let r4 = 0; r4 < t3.length - 1; r4++) {
            const n4 = t3[r4], i4 = t3[r4 + 1], a4 = n4.dist(i4);
            if (l3 + a4 > u3) {
              const c3 = (u3 - l3) / a4, h3 = Ze2.number(n4.x, i4.x, c3), p3 = Ze2.number(n4.y, i4.y, c3), f3 = new Ac(h3, p3, i4.angleTo(n4), r4);
              return f3._round(), !s3 || Sc(t3, f3, o3, s3, e2) ? f3 : void 0;
            }
            l3 += a4;
          }
        }
        function Cc(t3, e2, r3, n3, i3, a3, s3, o3, l3) {
          const u3 = Ic(n3, a3, s3), c3 = zc(n3, i3), h3 = c3 * s3, p3 = 0 === t3[0].x || t3[0].x === l3 || 0 === t3[0].y || t3[0].y === l3;
          return e2 - h3 < e2 / 4 && (e2 = h3 + e2 / 4), Bc(t3, p3 ? e2 / 2 * o3 % e2 : (c3 / 2 + 2 * a3) * s3 * o3 % e2, e2, u3, r3, h3, p3, false, l3);
        }
        function Bc(t3, e2, r3, n3, i3, a3, s3, o3, l3) {
          const u3 = a3 / 2, c3 = kc(t3);
          let h3 = 0, p3 = e2 - r3, f3 = [];
          for (let e3 = 0; e3 < t3.length - 1; e3++) {
            const s4 = t3[e3], o4 = t3[e3 + 1], d3 = s4.dist(o4), y3 = o4.angleTo(s4);
            for (; p3 + r3 < h3 + d3; ) {
              p3 += r3;
              const m3 = (p3 - h3) / d3, g3 = Ze2.number(s4.x, o4.x, m3), x3 = Ze2.number(s4.y, o4.y, m3);
              if (g3 >= 0 && g3 < l3 && x3 >= 0 && x3 < l3 && p3 - u3 >= 0 && p3 + u3 <= c3) {
                const r4 = new Ac(g3, x3, y3, e3);
                r4._round(), n3 && !Sc(t3, r4, a3, n3, i3) || f3.push(r4);
              }
            }
            h3 += d3;
          }
          return o3 || f3.length || s3 || (f3 = Bc(t3, h3 / 2, r3, n3, i3, a3, s3, true, l3)), f3;
        }
        $n("Anchor", Ac);
        const Pc = lu;
        function Vc(t3, e2, r3, n3) {
          const i3 = [], s3 = t3.image, o3 = s3.pixelRatio, l3 = s3.paddedRect.w - 2 * Pc, u3 = s3.paddedRect.h - 2 * Pc, c3 = t3.right - t3.left, h3 = t3.bottom - t3.top, p3 = s3.stretchX || [[0, l3]], f3 = s3.stretchY || [[0, u3]], d3 = (t4, e3) => t4 + e3[1] - e3[0], y3 = p3.reduce(d3, 0), m3 = f3.reduce(d3, 0), g3 = l3 - y3, x3 = u3 - m3;
          let v3 = 0, b3 = y3, w3 = 0, _3 = m3, A3 = 0, S3 = g3, k3 = 0, I3 = x3;
          if (s3.content && n3) {
            const t4 = s3.content;
            v3 = Ec(p3, 0, t4[0]), w3 = Ec(f3, 0, t4[1]), b3 = Ec(p3, t4[0], t4[2]), _3 = Ec(f3, t4[1], t4[3]), A3 = t4[0] - v3, k3 = t4[1] - w3, S3 = t4[2] - t4[0] - b3, I3 = t4[3] - t4[1] - _3;
          }
          const z3 = (n4, i4, l4, u4) => {
            const p4 = Tc(n4.stretch - v3, b3, c3, t3.left), f4 = $c(n4.fixed - A3, S3, n4.stretch, y3), d4 = Tc(i4.stretch - w3, _3, h3, t3.top), g4 = $c(i4.fixed - k3, I3, i4.stretch, m3), x4 = Tc(l4.stretch - v3, b3, c3, t3.left), z4 = $c(l4.fixed - A3, S3, l4.stretch, y3), M3 = Tc(u4.stretch - w3, _3, h3, t3.top), C3 = $c(u4.fixed - k3, I3, u4.stretch, m3), B3 = new a2(p4, d4), P3 = new a2(x4, d4), V3 = new a2(x4, M3), E3 = new a2(p4, M3), F3 = new a2(f4 / o3, g4 / o3), T3 = new a2(z4 / o3, C3 / o3), $3 = e2 * Math.PI / 180;
            if ($3) {
              const t4 = Math.sin($3), e3 = Math.cos($3), r4 = [e3, -t4, t4, e3];
              B3._matMult(r4), P3._matMult(r4), E3._matMult(r4), V3._matMult(r4);
            }
            const L3 = n4.stretch + n4.fixed, D3 = i4.stretch + i4.fixed;
            return { tl: B3, tr: P3, bl: E3, br: V3, tex: { x: s3.paddedRect.x + Pc + L3, y: s3.paddedRect.y + Pc + D3, w: l4.stretch + l4.fixed - L3, h: u4.stretch + u4.fixed - D3 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F3, pixelOffsetBR: T3, minFontScaleX: S3 / o3 / c3, minFontScaleY: I3 / o3 / h3, isSDF: r3 };
          };
          if (n3 && (s3.stretchX || s3.stretchY)) {
            const t4 = Fc(p3, g3, y3), e3 = Fc(f3, x3, m3);
            for (let r4 = 0; r4 < t4.length - 1; r4++) {
              const n4 = t4[r4], a3 = t4[r4 + 1];
              for (let t5 = 0; t5 < e3.length - 1; t5++) i3.push(z3(n4, e3[t5], a3, e3[t5 + 1]));
            }
          } else i3.push(z3({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l3 + 1 }, { fixed: 0, stretch: u3 + 1 }));
          return i3;
        }
        function Ec(t3, e2, r3) {
          let n3 = 0;
          for (const i3 of t3) n3 += Math.max(e2, Math.min(r3, i3[1])) - Math.max(e2, Math.min(r3, i3[0]));
          return n3;
        }
        function Fc(t3, e2, r3) {
          const n3 = [{ fixed: -1, stretch: 0 }];
          for (const [e3, r4] of t3) {
            const t4 = n3[n3.length - 1];
            n3.push({ fixed: e3 - t4.stretch, stretch: t4.stretch }), n3.push({ fixed: e3 - t4.stretch, stretch: t4.stretch + (r4 - e3) });
          }
          return n3.push({ fixed: e2 + Pc, stretch: r3 }), n3;
        }
        function Tc(t3, e2, r3, n3) {
          return t3 / e2 * r3 + n3;
        }
        function $c(t3, e2, r3, n3) {
          return t3 - e2 * r3 / n3;
        }
        class Lc {
          constructor(t3, e2, r3, n3, i3, s3, o3, l3, u3, c3) {
            if (this.boxStartIndex = t3.length, u3) {
              let t4 = s3.top, e3 = s3.bottom;
              const r4 = s3.collisionPadding;
              r4 && (t4 -= r4[1], e3 += r4[3]);
              let n4 = e3 - t4;
              n4 > 0 && (n4 = Math.max(10, n4), this.circleDiameter = n4);
            } else {
              let u4 = s3.top * o3 - l3[0], h3 = s3.bottom * o3 + l3[2], p3 = s3.left * o3 - l3[3], f3 = s3.right * o3 + l3[1];
              const d3 = s3.collisionPadding;
              if (d3 && (p3 -= d3[0] * o3, u4 -= d3[1] * o3, f3 += d3[2] * o3, h3 += d3[3] * o3), c3) {
                const t4 = new a2(p3, u4), e3 = new a2(f3, u4), r4 = new a2(p3, h3), n4 = new a2(f3, h3), i4 = c3 * Math.PI / 180;
                t4._rotate(i4), e3._rotate(i4), r4._rotate(i4), n4._rotate(i4), p3 = Math.min(t4.x, e3.x, r4.x, n4.x), f3 = Math.max(t4.x, e3.x, r4.x, n4.x), u4 = Math.min(t4.y, e3.y, r4.y, n4.y), h3 = Math.max(t4.y, e3.y, r4.y, n4.y);
              }
              t3.emplaceBack(e2.x, e2.y, p3, u4, f3, h3, r3, n3, i3);
            }
            this.boxEndIndex = t3.length;
          }
        }
        class Dc {
          constructor(t3 = [], e2 = Oc) {
            if (this.data = t3, this.length = this.data.length, this.compare = e2, this.length > 0) for (let t4 = (this.length >> 1) - 1; t4 >= 0; t4--) this._down(t4);
          }
          push(t3) {
            this.data.push(t3), this.length++, this._up(this.length - 1);
          }
          pop() {
            if (0 === this.length) return;
            const t3 = this.data[0], e2 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t3;
          }
          peek() {
            return this.data[0];
          }
          _up(t3) {
            const { data: e2, compare: r3 } = this, n3 = e2[t3];
            for (; t3 > 0; ) {
              const i3 = t3 - 1 >> 1, a3 = e2[i3];
              if (r3(n3, a3) >= 0) break;
              e2[t3] = a3, t3 = i3;
            }
            e2[t3] = n3;
          }
          _down(t3) {
            const { data: e2, compare: r3 } = this, n3 = this.length >> 1, i3 = e2[t3];
            for (; t3 < n3; ) {
              let n4 = 1 + (t3 << 1), a3 = e2[n4];
              const s3 = n4 + 1;
              if (s3 < this.length && r3(e2[s3], a3) < 0 && (n4 = s3, a3 = e2[s3]), r3(a3, i3) >= 0) break;
              e2[t3] = a3, t3 = n4;
            }
            e2[t3] = i3;
          }
        }
        function Oc(t3, e2) {
          return t3 < e2 ? -1 : t3 > e2 ? 1 : 0;
        }
        function Uc(t3, e2 = 1, r3 = false) {
          let n3 = 1 / 0, i3 = 1 / 0, s3 = -1 / 0, o3 = -1 / 0;
          const l3 = t3[0];
          for (let t4 = 0; t4 < l3.length; t4++) {
            const e3 = l3[t4];
            (!t4 || e3.x < n3) && (n3 = e3.x), (!t4 || e3.y < i3) && (i3 = e3.y), (!t4 || e3.x > s3) && (s3 = e3.x), (!t4 || e3.y > o3) && (o3 = e3.y);
          }
          const u3 = Math.min(s3 - n3, o3 - i3);
          let c3 = u3 / 2;
          const h3 = new Dc([], Rc);
          if (0 === u3) return new a2(n3, i3);
          for (let e3 = n3; e3 < s3; e3 += u3) for (let r4 = i3; r4 < o3; r4 += u3) h3.push(new qc(e3 + c3, r4 + c3, c3, t3));
          let p3 = function(t4) {
            let e3 = 0, r4 = 0, n4 = 0;
            const i4 = t4[0];
            for (let t5 = 0, a3 = i4.length, s4 = a3 - 1; t5 < a3; s4 = t5++) {
              const a4 = i4[t5], o4 = i4[s4], l4 = a4.x * o4.y - o4.x * a4.y;
              r4 += (a4.x + o4.x) * l4, n4 += (a4.y + o4.y) * l4, e3 += 3 * l4;
            }
            return new qc(r4 / e3, n4 / e3, 0, t4);
          }(t3), f3 = h3.length;
          for (; h3.length; ) {
            const n4 = h3.pop();
            (n4.d > p3.d || !p3.d) && (p3 = n4, r3 && console.log("found best %d after %d probes", Math.round(1e4 * n4.d) / 1e4, f3)), n4.max - p3.d <= e2 || (c3 = n4.h / 2, h3.push(new qc(n4.p.x - c3, n4.p.y - c3, c3, t3)), h3.push(new qc(n4.p.x + c3, n4.p.y - c3, c3, t3)), h3.push(new qc(n4.p.x - c3, n4.p.y + c3, c3, t3)), h3.push(new qc(n4.p.x + c3, n4.p.y + c3, c3, t3)), f3 += 4);
          }
          return r3 && (console.log(`num probes: ${f3}`), console.log(`best distance: ${p3.d}`)), p3.p;
        }
        function Rc(t3, e2) {
          return e2.max - t3.max;
        }
        function qc(t3, e2, r3, n3) {
          this.p = new a2(t3, e2), this.h = r3, this.d = function(t4, e3) {
            let r4 = false, n4 = 1 / 0;
            for (let i3 = 0; i3 < e3.length; i3++) {
              const a3 = e3[i3];
              for (let e4 = 0, i4 = a3.length, s3 = i4 - 1; e4 < i4; s3 = e4++) {
                const i5 = a3[e4], o3 = a3[s3];
                i5.y > t4.y != o3.y > t4.y && t4.x < (o3.x - i5.x) * (t4.y - i5.y) / (o3.y - i5.y) + i5.x && (r4 = !r4), n4 = Math.min(n4, ms(t4, i5, o3));
              }
            }
            return (r4 ? 1 : -1) * Math.sqrt(n4);
          }(this.p, n3), this.max = this.d + this.h * Math.SQRT2;
        }
        var jc;
        t2.aq = void 0, (jc = t2.aq || (t2.aq = {}))[jc.center = 1] = "center", jc[jc.left = 2] = "left", jc[jc.right = 3] = "right", jc[jc.top = 4] = "top", jc[jc.bottom = 5] = "bottom", jc[jc["top-left"] = 6] = "top-left", jc[jc["top-right"] = 7] = "top-right", jc[jc["bottom-left"] = 8] = "bottom-left", jc[jc["bottom-right"] = 9] = "bottom-right";
        const Nc = 7, Zc = Number.POSITIVE_INFINITY;
        function Kc(t3, e2) {
          return e2[1] !== Zc ? function(t4, e3, r3) {
            let n3 = 0, i3 = 0;
            switch (e3 = Math.abs(e3), r3 = Math.abs(r3), t4) {
              case "top-right":
              case "top-left":
              case "top":
                i3 = r3 - Nc;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i3 = -r3 + Nc;
            }
            switch (t4) {
              case "top-right":
              case "bottom-right":
              case "right":
                n3 = -e3;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n3 = e3;
            }
            return [n3, i3];
          }(t3, e2[0], e2[1]) : function(t4, e3) {
            let r3 = 0, n3 = 0;
            e3 < 0 && (e3 = 0);
            const i3 = e3 / Math.SQRT2;
            switch (t4) {
              case "top-right":
              case "top-left":
                n3 = i3 - Nc;
                break;
              case "bottom-right":
              case "bottom-left":
                n3 = -i3 + Nc;
                break;
              case "bottom":
                n3 = -e3 + Nc;
                break;
              case "top":
                n3 = e3 - Nc;
            }
            switch (t4) {
              case "top-right":
              case "bottom-right":
                r3 = -i3;
                break;
              case "top-left":
              case "bottom-left":
                r3 = i3;
                break;
              case "left":
                r3 = e3;
                break;
              case "right":
                r3 = -e3;
            }
            return [r3, n3];
          }(t3, e2[0]);
        }
        function Gc(t3, e2, r3) {
          var n3;
          const i3 = t3.layout, a3 = null === (n3 = i3.get("text-variable-anchor-offset")) || void 0 === n3 ? void 0 : n3.evaluate(e2, {}, r3);
          if (a3) {
            const t4 = a3.values, e3 = [];
            for (let r4 = 0; r4 < t4.length; r4 += 2) {
              const n4 = e3[r4] = t4[r4], i4 = t4[r4 + 1].map((t5) => t5 * Vl);
              n4.startsWith("top") ? i4[1] -= Nc : n4.startsWith("bottom") && (i4[1] += Nc), e3[r4 + 1] = i4;
            }
            return new re2(e3);
          }
          const s3 = i3.get("text-variable-anchor");
          if (s3) {
            let n4;
            n4 = void 0 !== t3._unevaluatedLayout.getValue("text-radial-offset") ? [i3.get("text-radial-offset").evaluate(e2, {}, r3) * Vl, Zc] : i3.get("text-offset").evaluate(e2, {}, r3).map((t4) => t4 * Vl);
            const a4 = [];
            for (const t4 of s3) a4.push(t4, Kc(t4, n4));
            return new re2(a4);
          }
          return null;
        }
        function Jc(t3) {
          switch (t3) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function Xc(e2, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3) {
          let p3 = s3.textMaxSize.evaluate(r3, {});
          void 0 === p3 && (p3 = o3);
          const f3 = e2.layers[0].layout, d3 = f3.get("icon-offset").evaluate(r3, {}, h3), y3 = Hc(n3.horizontal), m3 = o3 / 24, g3 = e2.tilePixelRatio * m3, x3 = e2.tilePixelRatio * p3 / 24, v3 = e2.tilePixelRatio * l3, b3 = e2.tilePixelRatio * f3.get("symbol-spacing"), w3 = f3.get("text-padding") * e2.tilePixelRatio, _3 = function(t3, e3, r4, n4 = 1) {
            const i4 = t3.get("icon-padding").evaluate(e3, {}, r4), a4 = i4 && i4.values;
            return [a4[0] * n4, a4[1] * n4, a4[2] * n4, a4[3] * n4];
          }(f3, r3, h3, e2.tilePixelRatio), S3 = f3.get("text-max-angle") / 180 * Math.PI, k3 = "viewport" !== f3.get("text-rotation-alignment") && "point" !== f3.get("symbol-placement"), I3 = "map" === f3.get("icon-rotation-alignment") && "point" !== f3.get("symbol-placement"), z3 = f3.get("symbol-placement"), M3 = b3 / 2, C3 = f3.get("icon-text-fit");
          let B3;
          i3 && "none" !== C3 && (e2.allowVerticalPlacement && n3.vertical && (B3 = zu(i3, n3.vertical, C3, f3.get("icon-text-fit-padding"), d3, m3)), y3 && (i3 = zu(i3, y3, C3, f3.get("icon-text-fit-padding"), d3, m3)));
          const P3 = (l4, p4) => {
            p4.x < 0 || p4.x >= rs || p4.y < 0 || p4.y >= rs || function(e3, r4, n4, i4, a4, s4, o4, l5, u4, c4, h4, p5, f4, d4, y4, m4, g4, x4, v4, b4, w4, _4, S4, k4, I4) {
              const z4 = e3.addToLineVertexArray(r4, n4);
              let M4, C4, B4, P4, V3 = 0, E3 = 0, F3 = 0, T3 = 0, $3 = -1, L3 = -1;
              const D3 = {};
              let O3 = $a("");
              if (e3.allowVerticalPlacement && i4.vertical) {
                const t3 = l5.layout.get("text-rotate").evaluate(w4, {}, k4) + 90;
                B4 = new Lc(u4, r4, c4, h4, p5, i4.vertical, f4, d4, y4, t3), o4 && (P4 = new Lc(u4, r4, c4, h4, p5, o4, g4, x4, y4, t3));
              }
              if (a4) {
                const n5 = l5.layout.get("icon-rotate").evaluate(w4, {}), i5 = "none" !== l5.layout.get("icon-text-fit"), s5 = Vc(a4, n5, S4, i5), f5 = o4 ? Vc(o4, n5, S4, i5) : void 0;
                C4 = new Lc(u4, r4, c4, h4, p5, a4, g4, x4, false, n5), V3 = 4 * s5.length;
                const d5 = e3.iconSizeData;
                let y5 = null;
                "source" === d5.kind ? (y5 = [Cu * l5.layout.get("icon-size").evaluate(w4, {})], y5[0] > Bu && A2(`${e3.layerIds[0]}: Value for "icon-size" is >= ${Mu}. Reduce your "icon-size".`)) : "composite" === d5.kind && (y5 = [Cu * _4.compositeIconSizes[0].evaluate(w4, {}, k4), Cu * _4.compositeIconSizes[1].evaluate(w4, {}, k4)], (y5[0] > Bu || y5[1] > Bu) && A2(`${e3.layerIds[0]}: Value for "icon-size" is >= ${Mu}. Reduce your "icon-size".`)), e3.addSymbols(e3.icon, s5, y5, b4, v4, w4, t2.ai.none, r4, z4.lineStartIndex, z4.lineLength, -1, k4), $3 = e3.icon.placedSymbolArray.length - 1, f5 && (E3 = 4 * f5.length, e3.addSymbols(e3.icon, f5, y5, b4, v4, w4, t2.ai.vertical, r4, z4.lineStartIndex, z4.lineLength, -1, k4), L3 = e3.icon.placedSymbolArray.length - 1);
              }
              const U3 = Object.keys(i4.horizontal);
              for (const n5 of U3) {
                const a5 = i4.horizontal[n5];
                if (!M4) {
                  O3 = $a(a5.text);
                  const t3 = l5.layout.get("text-rotate").evaluate(w4, {}, k4);
                  M4 = new Lc(u4, r4, c4, h4, p5, a5, f4, d4, y4, t3);
                }
                const o5 = 1 === a5.positionedLines.length;
                if (F3 += Yc(e3, r4, a5, s4, l5, y4, w4, m4, z4, i4.vertical ? t2.ai.horizontal : t2.ai.horizontalOnly, o5 ? U3 : [n5], D3, $3, _4, k4), o5) break;
              }
              i4.vertical && (T3 += Yc(e3, r4, i4.vertical, s4, l5, y4, w4, m4, z4, t2.ai.vertical, ["vertical"], D3, L3, _4, k4));
              const R3 = M4 ? M4.boxStartIndex : e3.collisionBoxArray.length, q3 = M4 ? M4.boxEndIndex : e3.collisionBoxArray.length, j3 = B4 ? B4.boxStartIndex : e3.collisionBoxArray.length, N3 = B4 ? B4.boxEndIndex : e3.collisionBoxArray.length, Z3 = C4 ? C4.boxStartIndex : e3.collisionBoxArray.length, K3 = C4 ? C4.boxEndIndex : e3.collisionBoxArray.length, G3 = P4 ? P4.boxStartIndex : e3.collisionBoxArray.length, J3 = P4 ? P4.boxEndIndex : e3.collisionBoxArray.length;
              let X3 = -1;
              const Y3 = (t3, e4) => t3 && t3.circleDiameter ? Math.max(t3.circleDiameter, e4) : e4;
              X3 = Y3(M4, X3), X3 = Y3(B4, X3), X3 = Y3(C4, X3), X3 = Y3(P4, X3);
              const H3 = X3 > -1 ? 1 : 0;
              H3 && (X3 *= I4 / Vl), e3.glyphOffsetArray.length >= Uu.MAX_GLYPHS && A2("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w4.sortKey && e3.addToSortKeyRanges(e3.symbolInstances.length, w4.sortKey);
              const W3 = Gc(l5, w4, k4), [Q3, tt2] = function(e4, r5) {
                const n5 = e4.length, i5 = null == r5 ? void 0 : r5.values;
                if ((null == i5 ? void 0 : i5.length) > 0) for (let r6 = 0; r6 < i5.length; r6 += 2) {
                  const n6 = i5[r6 + 1];
                  e4.emplaceBack(t2.aq[i5[r6]], n6[0], n6[1]);
                }
                return [n5, e4.length];
              }(e3.textAnchorOffsets, W3);
              e3.symbolInstances.emplaceBack(r4.x, r4.y, D3.right >= 0 ? D3.right : -1, D3.center >= 0 ? D3.center : -1, D3.left >= 0 ? D3.left : -1, D3.vertical || -1, $3, L3, O3, R3, q3, j3, N3, Z3, K3, G3, J3, c4, F3, T3, V3, E3, H3, 0, f4, X3, Q3, tt2);
            }(e2, p4, l4, n3, i3, a3, B3, e2.layers[0], e2.collisionBoxArray, r3.index, r3.sourceLayerIndex, e2.index, g3, [w3, w3, w3, w3], k3, u3, v3, _3, I3, d3, r3, s3, c3, h3, o3);
          };
          if ("line" === z3) for (const t3 of _c(r3.geometry, 0, 0, rs, rs)) {
            const r4 = Cc(t3, b3, S3, n3.vertical || y3, i3, 24, x3, e2.overscaling, rs);
            for (const n4 of r4) y3 && Wc(e2, y3.text, M3, n4) || P3(t3, n4);
          }
          else if ("line-center" === z3) {
            for (const t3 of r3.geometry) if (t3.length > 1) {
              const e3 = Mc(t3, S3, n3.vertical || y3, i3, 24, x3);
              e3 && P3(t3, e3);
            }
          } else if ("Polygon" === r3.type) for (const t3 of Co(r3.geometry, 0)) {
            const e3 = Uc(t3, 16);
            P3(t3[0], new Ac(e3.x, e3.y, 0));
          }
          else if ("LineString" === r3.type) for (const t3 of r3.geometry) P3(t3, new Ac(t3[0].x, t3[0].y, 0));
          else if ("Point" === r3.type) for (const t3 of r3.geometry) for (const e3 of t3) P3([e3], new Ac(e3.x, e3.y, 0));
        }
        function Yc(t3, e2, r3, n3, i3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3) {
          const m3 = function(t4, e3, r4, n4, i4, s4, o4, l4) {
            const u4 = n4.layout.get("text-rotate").evaluate(s4, {}) * Math.PI / 180, c4 = [];
            for (const t5 of e3.positionedLines) for (const n5 of t5.positionedGlyphs) {
              if (!n5.rect) continue;
              const s5 = n5.rect || {};
              let h4 = su + 1, p4 = true, f4 = 1, d4 = 0;
              const y4 = (i4 || l4) && n5.vertical, m4 = n5.metrics.advance * n5.scale / 2;
              if (l4 && e3.verticalizable && (d4 = t5.lineOffset / 2 - (n5.imageName ? -(Vl - n5.metrics.width * n5.scale) / 2 : (n5.scale - 1) * Vl)), n5.imageName) {
                const t6 = o4[n5.imageName];
                p4 = t6.sdf, f4 = t6.pixelRatio, h4 = lu / f4;
              }
              const g4 = i4 ? [n5.x + m4, n5.y] : [0, 0];
              let x4 = i4 ? [0, 0] : [n5.x + m4 + r4[0], n5.y + r4[1] - d4], v3 = [0, 0];
              y4 && (v3 = x4, x4 = [0, 0]);
              const b3 = n5.metrics.isDoubleResolution ? 2 : 1, w3 = (n5.metrics.left - h4) * n5.scale - m4 + x4[0], _3 = (-n5.metrics.top - h4) * n5.scale + x4[1], A3 = w3 + s5.w / b3 * n5.scale / f4, S3 = _3 + s5.h / b3 * n5.scale / f4, k3 = new a2(w3, _3), I3 = new a2(A3, _3), z3 = new a2(w3, S3), M3 = new a2(A3, S3);
              if (y4) {
                const t6 = new a2(-m4, m4 - pu), e4 = -Math.PI / 2, r5 = Vl / 2 - m4, i5 = new a2(5 - pu - r5, -(n5.imageName ? r5 : 0)), s6 = new a2(...v3);
                k3._rotateAround(e4, t6)._add(i5)._add(s6), I3._rotateAround(e4, t6)._add(i5)._add(s6), z3._rotateAround(e4, t6)._add(i5)._add(s6), M3._rotateAround(e4, t6)._add(i5)._add(s6);
              }
              if (u4) {
                const t6 = Math.sin(u4), e4 = Math.cos(u4), r5 = [e4, -t6, t6, e4];
                k3._matMult(r5), I3._matMult(r5), z3._matMult(r5), M3._matMult(r5);
              }
              const C3 = new a2(0, 0), B3 = new a2(0, 0);
              c4.push({ tl: k3, tr: I3, bl: z3, br: M3, tex: s5, writingMode: e3.writingMode, glyphOffset: g4, sectionIndex: n5.sectionIndex, isSDF: p4, pixelOffsetTL: C3, pixelOffsetBR: B3, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return c4;
          }(0, r3, l3, i3, s3, o3, n3, t3.allowVerticalPlacement), g3 = t3.textSizeData;
          let x3 = null;
          "source" === g3.kind ? (x3 = [Cu * i3.layout.get("text-size").evaluate(o3, {})], x3[0] > Bu && A2(`${t3.layerIds[0]}: Value for "text-size" is >= ${Mu}. Reduce your "text-size".`)) : "composite" === g3.kind && (x3 = [Cu * d3.compositeTextSizes[0].evaluate(o3, {}, y3), Cu * d3.compositeTextSizes[1].evaluate(o3, {}, y3)], (x3[0] > Bu || x3[1] > Bu) && A2(`${t3.layerIds[0]}: Value for "text-size" is >= ${Mu}. Reduce your "text-size".`)), t3.addSymbols(t3.text, m3, x3, l3, s3, o3, c3, e2, u3.lineStartIndex, u3.lineLength, f3, y3);
          for (const e3 of h3) p3[e3] = t3.text.placedSymbolArray.length - 1;
          return 4 * m3.length;
        }
        function Hc(t3) {
          for (const e2 in t3) return t3[e2];
          return null;
        }
        function Wc(t3, e2, r3, n3) {
          const i3 = t3.compareText;
          if (e2 in i3) {
            const t4 = i3[e2];
            for (let e3 = t4.length - 1; e3 >= 0; e3--) if (n3.dist(t4[e3]) < r3) return true;
          } else i3[e2] = [];
          return i3[e2].push(n3), false;
        }
        const Qc = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class th {
          static from(t3) {
            if (!(t3 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [e2, r3] = new Uint8Array(t3, 0, 2);
            if (219 !== e2) throw new Error("Data does not appear to be in a KDBush format.");
            const n3 = r3 >> 4;
            if (1 !== n3) throw new Error(`Got v${n3} data when expected v1.`);
            const i3 = Qc[15 & r3];
            if (!i3) throw new Error("Unrecognized array type.");
            const [a3] = new Uint16Array(t3, 2, 1), [s3] = new Uint32Array(t3, 4, 1);
            return new th(s3, a3, i3, t3);
          }
          constructor(t3, e2 = 64, r3 = Float64Array, n3) {
            if (isNaN(t3) || t3 < 0) throw new Error(`Unpexpected numItems value: ${t3}.`);
            this.numItems = +t3, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r3, this.IndexArrayType = t3 < 65536 ? Uint16Array : Uint32Array;
            const i3 = Qc.indexOf(this.ArrayType), a3 = 2 * t3 * this.ArrayType.BYTES_PER_ELEMENT, s3 = t3 * this.IndexArrayType.BYTES_PER_ELEMENT, o3 = (8 - s3 % 8) % 8;
            if (i3 < 0) throw new Error(`Unexpected typed array class: ${r3}.`);
            n3 && n3 instanceof ArrayBuffer ? (this.data = n3, this.ids = new this.IndexArrayType(this.data, 8, t3), this.coords = new this.ArrayType(this.data, 8 + s3 + o3, 2 * t3), this._pos = 2 * t3, this._finished = true) : (this.data = new ArrayBuffer(8 + a3 + s3 + o3), this.ids = new this.IndexArrayType(this.data, 8, t3), this.coords = new this.ArrayType(this.data, 8 + s3 + o3, 2 * t3), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i3]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t3);
          }
          add(t3, e2) {
            const r3 = this._pos >> 1;
            return this.ids[r3] = r3, this.coords[this._pos++] = t3, this.coords[this._pos++] = e2, r3;
          }
          finish() {
            const t3 = this._pos >> 1;
            if (t3 !== this.numItems) throw new Error(`Added ${t3} items when expected ${this.numItems}.`);
            return eh(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t3, e2, r3, n3) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: i3, coords: a3, nodeSize: s3 } = this, o3 = [0, i3.length - 1, 0], l3 = [];
            for (; o3.length; ) {
              const u3 = o3.pop() || 0, c3 = o3.pop() || 0, h3 = o3.pop() || 0;
              if (c3 - h3 <= s3) {
                for (let s4 = h3; s4 <= c3; s4++) {
                  const o4 = a3[2 * s4], u4 = a3[2 * s4 + 1];
                  o4 >= t3 && o4 <= r3 && u4 >= e2 && u4 <= n3 && l3.push(i3[s4]);
                }
                continue;
              }
              const p3 = h3 + c3 >> 1, f3 = a3[2 * p3], d3 = a3[2 * p3 + 1];
              f3 >= t3 && f3 <= r3 && d3 >= e2 && d3 <= n3 && l3.push(i3[p3]), (0 === u3 ? t3 <= f3 : e2 <= d3) && (o3.push(h3), o3.push(p3 - 1), o3.push(1 - u3)), (0 === u3 ? r3 >= f3 : n3 >= d3) && (o3.push(p3 + 1), o3.push(c3), o3.push(1 - u3));
            }
            return l3;
          }
          within(t3, e2, r3) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: n3, coords: i3, nodeSize: a3 } = this, s3 = [0, n3.length - 1, 0], o3 = [], l3 = r3 * r3;
            for (; s3.length; ) {
              const u3 = s3.pop() || 0, c3 = s3.pop() || 0, h3 = s3.pop() || 0;
              if (c3 - h3 <= a3) {
                for (let r4 = h3; r4 <= c3; r4++) ah(i3[2 * r4], i3[2 * r4 + 1], t3, e2) <= l3 && o3.push(n3[r4]);
                continue;
              }
              const p3 = h3 + c3 >> 1, f3 = i3[2 * p3], d3 = i3[2 * p3 + 1];
              ah(f3, d3, t3, e2) <= l3 && o3.push(n3[p3]), (0 === u3 ? t3 - r3 <= f3 : e2 - r3 <= d3) && (s3.push(h3), s3.push(p3 - 1), s3.push(1 - u3)), (0 === u3 ? t3 + r3 >= f3 : e2 + r3 >= d3) && (s3.push(p3 + 1), s3.push(c3), s3.push(1 - u3));
            }
            return o3;
          }
        }
        function eh(t3, e2, r3, n3, i3, a3) {
          if (i3 - n3 <= r3) return;
          const s3 = n3 + i3 >> 1;
          rh(t3, e2, s3, n3, i3, a3), eh(t3, e2, r3, n3, s3 - 1, 1 - a3), eh(t3, e2, r3, s3 + 1, i3, 1 - a3);
        }
        function rh(t3, e2, r3, n3, i3, a3) {
          for (; i3 > n3; ) {
            if (i3 - n3 > 600) {
              const s4 = i3 - n3 + 1, o4 = r3 - n3 + 1, l4 = Math.log(s4), u3 = 0.5 * Math.exp(2 * l4 / 3), c3 = 0.5 * Math.sqrt(l4 * u3 * (s4 - u3) / s4) * (o4 - s4 / 2 < 0 ? -1 : 1);
              rh(t3, e2, r3, Math.max(n3, Math.floor(r3 - o4 * u3 / s4 + c3)), Math.min(i3, Math.floor(r3 + (s4 - o4) * u3 / s4 + c3)), a3);
            }
            const s3 = e2[2 * r3 + a3];
            let o3 = n3, l3 = i3;
            for (nh(t3, e2, n3, r3), e2[2 * i3 + a3] > s3 && nh(t3, e2, n3, i3); o3 < l3; ) {
              for (nh(t3, e2, o3, l3), o3++, l3--; e2[2 * o3 + a3] < s3; ) o3++;
              for (; e2[2 * l3 + a3] > s3; ) l3--;
            }
            e2[2 * n3 + a3] === s3 ? nh(t3, e2, n3, l3) : (l3++, nh(t3, e2, l3, i3)), l3 <= r3 && (n3 = l3 + 1), r3 <= l3 && (i3 = l3 - 1);
          }
        }
        function nh(t3, e2, r3, n3) {
          ih(t3, r3, n3), ih(e2, 2 * r3, 2 * n3), ih(e2, 2 * r3 + 1, 2 * n3 + 1);
        }
        function ih(t3, e2, r3) {
          const n3 = t3[e2];
          t3[e2] = t3[r3], t3[r3] = n3;
        }
        function ah(t3, e2, r3, n3) {
          const i3 = t3 - r3, a3 = e2 - n3;
          return i3 * i3 + a3 * a3;
        }
        var sh;
        t2.bh = void 0, (sh = t2.bh || (t2.bh = {})).create = "create", sh.load = "load", sh.fullLoad = "fullLoad";
        let oh = null, lh = [];
        const uh = 1e3 / 60, ch = "loadTime", hh = "fullLoadTime", ph = { mark(t3) {
          performance.mark(t3);
        }, frame(t3) {
          const e2 = t3;
          null != oh && lh.push(e2 - oh), oh = e2;
        }, clearMetrics() {
          oh = null, lh = [], performance.clearMeasures(ch), performance.clearMeasures(hh);
          for (const e2 in t2.bh) performance.clearMarks(t2.bh[e2]);
        }, getPerformanceMetrics() {
          performance.measure(ch, t2.bh.create, t2.bh.load), performance.measure(hh, t2.bh.create, t2.bh.fullLoad);
          const e2 = performance.getEntriesByName(ch)[0].duration, r3 = performance.getEntriesByName(hh)[0].duration, n3 = lh.length, i3 = 1 / (lh.reduce((t3, e3) => t3 + e3, 0) / n3 / 1e3), a3 = lh.filter((t3) => t3 > uh).reduce((t3, e3) => t3 + (e3 - uh) / uh, 0);
          return { loadTime: e2, fullLoadTime: r3, fps: i3, percentDroppedFrames: a3 / (n3 + a3) * 100, totalFrames: n3 };
        } };
        t2.$ = function(t3, e2, r3) {
          var n3, i3, a3, s3, o3, l3, u3, c3, h3, p3, f3, d3, y3 = r3[0], m3 = r3[1], g3 = r3[2];
          return e2 === t3 ? (t3[12] = e2[0] * y3 + e2[4] * m3 + e2[8] * g3 + e2[12], t3[13] = e2[1] * y3 + e2[5] * m3 + e2[9] * g3 + e2[13], t3[14] = e2[2] * y3 + e2[6] * m3 + e2[10] * g3 + e2[14], t3[15] = e2[3] * y3 + e2[7] * m3 + e2[11] * g3 + e2[15]) : (i3 = e2[1], a3 = e2[2], s3 = e2[3], o3 = e2[4], l3 = e2[5], u3 = e2[6], c3 = e2[7], h3 = e2[8], p3 = e2[9], f3 = e2[10], d3 = e2[11], t3[0] = n3 = e2[0], t3[1] = i3, t3[2] = a3, t3[3] = s3, t3[4] = o3, t3[5] = l3, t3[6] = u3, t3[7] = c3, t3[8] = h3, t3[9] = p3, t3[10] = f3, t3[11] = d3, t3[12] = n3 * y3 + o3 * m3 + h3 * g3 + e2[12], t3[13] = i3 * y3 + l3 * m3 + p3 * g3 + e2[13], t3[14] = a3 * y3 + u3 * m3 + f3 * g3 + e2[14], t3[15] = s3 * y3 + c3 * m3 + d3 * g3 + e2[15]), t3;
        }, t2.A = zs, t2.B = Ze2, t2.C = class {
          constructor(t3, e2, r3) {
            this.receive = (t4) => {
              const e3 = t4.data, r4 = e3.id;
              if (r4 && (!e3.targetMapId || this.mapId === e3.targetMapId)) if ("<cancel>" === e3.type) {
                delete this.tasks[r4];
                const t5 = this.cancelCallbacks[r4];
                delete this.cancelCallbacks[r4], t5 && t5();
              } else I2() || e3.mustQueue ? (this.tasks[r4] = e3, this.taskQueue.push(r4), this.invoker.trigger()) : this.processTask(r4, e3);
            }, this.process = () => {
              if (!this.taskQueue.length) return;
              const t4 = this.taskQueue.shift(), e3 = this.tasks[t4];
              delete this.tasks[t4], this.taskQueue.length && this.invoker.trigger(), e3 && this.processTask(t4, e3);
            }, this.target = t3, this.parent = e2, this.mapId = r3, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, this.invoker = new Qu(this.process), this.target.addEventListener("message", this.receive, false), this.globalScope = I2() ? t3 : window;
          }
          send(t3, e2, r3, n3, i3 = false) {
            const a3 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            r3 && (this.callbacks[a3] = r3);
            const s3 = [], o3 = { id: a3, type: t3, hasCallback: !!r3, targetMapId: n3, mustQueue: i3, sourceMapId: this.mapId, data: Dn(e2, s3) };
            return this.target.postMessage(o3, { transfer: s3 }), { cancel: () => {
              r3 && delete this.callbacks[a3], this.target.postMessage({ id: a3, type: "<cancel>", targetMapId: n3, sourceMapId: this.mapId });
            } };
          }
          processTask(t3, e2) {
            if ("<response>" === e2.type) {
              const r3 = this.callbacks[t3];
              delete this.callbacks[t3], r3 && (e2.error ? r3(On(e2.error)) : r3(null, On(e2.data)));
            } else {
              let r3 = false;
              const n3 = [], i3 = e2.hasCallback ? (e3, i4) => {
                r3 = true, delete this.cancelCallbacks[t3];
                const a4 = { id: t3, type: "<response>", sourceMapId: this.mapId, error: e3 ? Dn(e3) : null, data: Dn(i4, n3) };
                this.target.postMessage(a4, { transfer: n3 });
              } : (t4) => {
                r3 = true;
              };
              let a3 = null;
              const s3 = On(e2.data);
              if (this.parent[e2.type]) a3 = this.parent[e2.type](e2.sourceMapId, s3, i3);
              else if ("getWorkerSource" in this.parent) {
                const t4 = e2.type.split(".");
                a3 = this.parent.getWorkerSource(e2.sourceMapId, t4[0], s3.source)[t4[1]](s3, i3);
              } else i3(new Error(`Could not find function ${e2.type}`));
              !r3 && a3 && a3.cancel && (this.cancelCallbacks[t3] = a3.cancel);
            }
          }
          remove() {
            this.invoker.remove(), this.target.removeEventListener("message", this.receive, false);
          }
        }, t2.D = gi, t2.E = J2, t2.F = function(t3, e2) {
          const r3 = {};
          for (let n3 = 0; n3 < e2.length; n3++) {
            const i3 = e2[n3];
            i3 in t3 && (r3[i3] = t3[i3]);
          }
          return r3;
        }, t2.G = ic, t2.H = ac, t2.I = uu, t2.J = h2, t2.K = p2, t2.L = ec, t2.M = B2, t2.N = rs, t2.O = fc, t2.P = a2, t2.Q = Mi, t2.R = qs, t2.S = za, t2.T = hi, t2.U = uc, t2.V = class extends Vi {
        }, t2.W = hc, t2.X = function(t3, e2) {
          const r3 = window.document.createElement("video");
          r3.muted = true, r3.onloadstart = function() {
            e2(null, r3);
          };
          for (let e3 = 0; e3 < t3.length; e3++) {
            const n3 = window.document.createElement("source");
            j2(t3[e3]) || (r3.crossOrigin = "Anonymous"), n3.src = t3[e3], r3.appendChild(n3);
          }
          return { cancel: () => {
          } };
        }, t2.Y = ot, t2.Z = function() {
          var t3 = new zs(16);
          return zs != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0), t3[0] = 1, t3[5] = 1, t3[10] = 1, t3[15] = 1, t3;
        }, t2._ = e, t2.a = M2, t2.a$ = class extends Hi {
        }, t2.a0 = function(t3, e2, r3) {
          var n3 = r3[0], i3 = r3[1], a3 = r3[2];
          return t3[0] = e2[0] * n3, t3[1] = e2[1] * n3, t3[2] = e2[2] * n3, t3[3] = e2[3] * n3, t3[4] = e2[4] * i3, t3[5] = e2[5] * i3, t3[6] = e2[6] * i3, t3[7] = e2[7] * i3, t3[8] = e2[8] * a3, t3[9] = e2[9] * a3, t3[10] = e2[10] * a3, t3[11] = e2[11] * a3, t3[12] = e2[12], t3[13] = e2[13], t3[14] = e2[14], t3[15] = e2[15], t3;
        }, t2.a1 = Cs, t2.a2 = function() {
          return x2++;
        }, t2.a3 = ta, t2.a4 = Uu, t2.a5 = function() {
          oi.isLoading() || oi.isLoaded() || "deferred" !== ai() || si();
        }, t2.a6 = Nr, t2.a7 = ss2, t2.a8 = li, t2.a9 = gc, t2.aA = ri, t2.aB = function(t3) {
          t3 = t3.slice();
          const e2 = /* @__PURE__ */ Object.create(null);
          for (let r3 = 0; r3 < t3.length; r3++) e2[t3[r3].id] = t3[r3];
          for (let r3 = 0; r3 < t3.length; r3++) "ref" in t3[r3] && (t3[r3] = H2(t3[r3], e2[t3[r3].ref]));
          return t3;
        }, t2.aC = function(t3) {
          if ("custom" === t3.type) return new Wu(t3);
          switch (t3.type) {
            case "background":
              return new Ju(t3);
            case "circle":
              return new Es(t3);
            case "fill":
              return new Lo(t3);
            case "fill-extrusion":
              return new ol(t3);
            case "heatmap":
              return new Ns(t3);
            case "hillshade":
              return new Gs(t3);
            case "line":
              return new Al(t3);
            case "raster":
              return new Hu(t3);
            case "symbol":
              return new Zu(t3);
          }
        }, t2.aD = w2, t2.aE = function(t3, e2) {
          if (!t3) return [{ command: Q2.setStyle, args: [e2] }];
          let r3 = [];
          try {
            if (!W2(t3.version, e2.version)) return [{ command: Q2.setStyle, args: [e2] }];
            W2(t3.center, e2.center) || r3.push({ command: Q2.setCenter, args: [e2.center] }), W2(t3.zoom, e2.zoom) || r3.push({ command: Q2.setZoom, args: [e2.zoom] }), W2(t3.bearing, e2.bearing) || r3.push({ command: Q2.setBearing, args: [e2.bearing] }), W2(t3.pitch, e2.pitch) || r3.push({ command: Q2.setPitch, args: [e2.pitch] }), W2(t3.sprite, e2.sprite) || r3.push({ command: Q2.setSprite, args: [e2.sprite] }), W2(t3.glyphs, e2.glyphs) || r3.push({ command: Q2.setGlyphs, args: [e2.glyphs] }), W2(t3.transition, e2.transition) || r3.push({ command: Q2.setTransition, args: [e2.transition] }), W2(t3.light, e2.light) || r3.push({ command: Q2.setLight, args: [e2.light] });
            const n3 = {}, i3 = [];
            !function(t4, e3, r4, n4) {
              let i4;
              for (i4 in e3 = e3 || {}, t4 = t4 || {}) Object.prototype.hasOwnProperty.call(t4, i4) && (Object.prototype.hasOwnProperty.call(e3, i4) || et(i4, r4, n4));
              for (i4 in e3) Object.prototype.hasOwnProperty.call(e3, i4) && (Object.prototype.hasOwnProperty.call(t4, i4) ? W2(t4[i4], e3[i4]) || ("geojson" === t4[i4].type && "geojson" === e3[i4].type && nt(t4, e3, i4) ? r4.push({ command: Q2.setGeoJSONSourceData, args: [i4, e3[i4].data] }) : rt(i4, e3, r4, n4)) : tt(i4, e3, r4));
            }(t3.sources, e2.sources, i3, n3);
            const a3 = [];
            t3.layers && t3.layers.forEach((t4) => {
              n3[t4.source] ? r3.push({ command: Q2.removeLayer, args: [t4.id] }) : a3.push(t4);
            }), r3 = r3.concat(i3), function(t4, e3, r4) {
              e3 = e3 || [];
              const n4 = (t4 = t4 || []).map(at), i4 = e3.map(at), a4 = t4.reduce(st, {}), s3 = e3.reduce(st, {}), o3 = n4.slice(), l3 = /* @__PURE__ */ Object.create(null);
              let u3, c3, h3, p3, f3, d3, y3;
              for (u3 = 0, c3 = 0; u3 < n4.length; u3++) h3 = n4[u3], Object.prototype.hasOwnProperty.call(s3, h3) ? c3++ : (r4.push({ command: Q2.removeLayer, args: [h3] }), o3.splice(o3.indexOf(h3, c3), 1));
              for (u3 = 0, c3 = 0; u3 < i4.length; u3++) h3 = i4[i4.length - 1 - u3], o3[o3.length - 1 - u3] !== h3 && (Object.prototype.hasOwnProperty.call(a4, h3) ? (r4.push({ command: Q2.removeLayer, args: [h3] }), o3.splice(o3.lastIndexOf(h3, o3.length - c3), 1)) : c3++, d3 = o3[o3.length - u3], r4.push({ command: Q2.addLayer, args: [s3[h3], d3] }), o3.splice(o3.length - u3, 0, h3), l3[h3] = true);
              for (u3 = 0; u3 < i4.length; u3++) if (h3 = i4[u3], p3 = a4[h3], f3 = s3[h3], !l3[h3] && !W2(p3, f3)) if (W2(p3.source, f3.source) && W2(p3["source-layer"], f3["source-layer"]) && W2(p3.type, f3.type)) {
                for (y3 in it(p3.layout, f3.layout, r4, h3, null, Q2.setLayoutProperty), it(p3.paint, f3.paint, r4, h3, null, Q2.setPaintProperty), W2(p3.filter, f3.filter) || r4.push({ command: Q2.setFilter, args: [h3, f3.filter] }), W2(p3.minzoom, f3.minzoom) && W2(p3.maxzoom, f3.maxzoom) || r4.push({ command: Q2.setLayerZoomRange, args: [h3, f3.minzoom, f3.maxzoom] }), p3) Object.prototype.hasOwnProperty.call(p3, y3) && "layout" !== y3 && "paint" !== y3 && "filter" !== y3 && "metadata" !== y3 && "minzoom" !== y3 && "maxzoom" !== y3 && (0 === y3.indexOf("paint.") ? it(p3[y3], f3[y3], r4, h3, y3.slice(6), Q2.setPaintProperty) : W2(p3[y3], f3[y3]) || r4.push({ command: Q2.setLayerProperty, args: [h3, y3, f3[y3]] }));
                for (y3 in f3) Object.prototype.hasOwnProperty.call(f3, y3) && !Object.prototype.hasOwnProperty.call(p3, y3) && "layout" !== y3 && "paint" !== y3 && "filter" !== y3 && "metadata" !== y3 && "minzoom" !== y3 && "maxzoom" !== y3 && (0 === y3.indexOf("paint.") ? it(p3[y3], f3[y3], r4, h3, y3.slice(6), Q2.setPaintProperty) : W2(p3[y3], f3[y3]) || r4.push({ command: Q2.setLayerProperty, args: [h3, y3, f3[y3]] }));
              } else r4.push({ command: Q2.removeLayer, args: [h3] }), d3 = o3[o3.lastIndexOf(h3) + 1], r4.push({ command: Q2.addLayer, args: [f3, d3] });
            }(a3, e2.layers, r3);
          } catch (t4) {
            console.warn("Unable to compute style diff:", t4), r3 = [{ command: Q2.setStyle, args: [e2] }];
          }
          return r3;
        }, t2.aF = function(t3) {
          const e2 = [], r3 = t3.id;
          return void 0 === r3 && e2.push({ message: `layers.${r3}: missing required property "id"` }), void 0 === t3.render && e2.push({ message: `layers.${r3}: missing required method "render"` }), t3.renderingMode && "2d" !== t3.renderingMode && "3d" !== t3.renderingMode && e2.push({ message: `layers.${r3}: property "renderingMode" must be either "2d" or "3d"` }), e2;
        }, t2.aG = function t3(e2, r3) {
          if (Array.isArray(e2)) {
            if (!Array.isArray(r3) || e2.length !== r3.length) return false;
            for (let n3 = 0; n3 < e2.length; n3++) if (!t3(e2[n3], r3[n3])) return false;
            return true;
          }
          if ("object" == typeof e2 && null !== e2 && null !== r3) {
            if ("object" != typeof r3) return false;
            if (Object.keys(e2).length !== Object.keys(r3).length) return false;
            for (const n3 in e2) if (!t3(e2[n3], r3[n3])) return false;
            return true;
          }
          return e2 === r3;
        }, t2.aH = v2, t2.aI = b2, t2.aJ = ii, t2.aK = function(t3) {
          return t3({ pluginStatus: ti, pluginURL: ei }), ii.on("pluginStateChange", t3), t3;
        }, t2.aL = class extends Ra {
          constructor(t3, e2) {
            super(t3, e2), this.current = 0;
          }
          set(t3) {
            this.current !== t3 && (this.current = t3, this.gl.uniform1i(this.location, t3));
          }
        }, t2.aM = qa, t2.aN = class extends Ra {
          constructor(t3, e2) {
            super(t3, e2), this.current = Za;
          }
          set(t3) {
            if (t3[12] !== this.current[12] || t3[0] !== this.current[0]) return this.current = t3, void this.gl.uniformMatrix4fv(this.location, false, t3);
            for (let e2 = 1; e2 < 16; e2++) if (t3[e2] !== this.current[e2]) {
              this.current = t3, this.gl.uniformMatrix4fv(this.location, false, t3);
              break;
            }
          }
        }, t2.aO = ja, t2.aP = class extends Ra {
          constructor(t3, e2) {
            super(t3, e2), this.current = [0, 0, 0];
          }
          set(t3) {
            t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] || (this.current = t3, this.gl.uniform3f(this.location, t3[0], t3[1], t3[2]));
          }
        }, t2.aQ = class extends Ra {
          constructor(t3, e2) {
            super(t3, e2), this.current = [0, 0];
          }
          set(t3) {
            t3[0] === this.current[0] && t3[1] === this.current[1] || (this.current = t3, this.gl.uniform2f(this.location, t3[0], t3[1]));
          }
        }, t2.aR = Na, t2.aS = function(t3, e2, r3, n3, i3, a3, s3) {
          var o3 = 1 / (e2 - r3), l3 = 1 / (n3 - i3), u3 = 1 / (a3 - s3);
          return t3[0] = -2 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * l3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 2 * u3, t3[11] = 0, t3[12] = (e2 + r3) * o3, t3[13] = (i3 + n3) * l3, t3[14] = (s3 + a3) * u3, t3[15] = 1, t3;
        }, t2.aT = Yt, t2.aU = Ps, t2.aV = class extends qi {
        }, t2.aW = Cl, t2.aX = class extends Ni {
        }, t2.aY = function(t3) {
          return t3 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t3) / Math.LN2));
        }, t2.aZ = js, t2.a_ = ha, t2.aa = function(t3) {
          const e2 = {};
          if (t3.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t4, r3, n3, i3) => {
            const a3 = n3 || i3;
            return e2[r3] = !a3 || a3.toLowerCase(), "";
          }), e2["max-age"]) {
            const t4 = parseInt(e2["max-age"], 10);
            isNaN(t4) ? delete e2["max-age"] : e2["max-age"] = t4;
          }
          return e2;
        }, t2.ab = function(t3, e2) {
          const r3 = [];
          for (const n3 in t3) n3 in e2 || r3.push(n3);
          return r3;
        }, t2.ac = function(t3) {
          if (null == z2) {
            const e2 = t3.navigator ? t3.navigator.userAgent : null;
            z2 = !!t3.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
          }
          return z2;
        }, t2.ad = y2, t2.ae = function(t3, e2, r3) {
          var n3 = Math.sin(r3), i3 = Math.cos(r3), a3 = e2[0], s3 = e2[1], o3 = e2[2], l3 = e2[3], u3 = e2[4], c3 = e2[5], h3 = e2[6], p3 = e2[7];
          return e2 !== t3 && (t3[8] = e2[8], t3[9] = e2[9], t3[10] = e2[10], t3[11] = e2[11], t3[12] = e2[12], t3[13] = e2[13], t3[14] = e2[14], t3[15] = e2[15]), t3[0] = a3 * i3 + u3 * n3, t3[1] = s3 * i3 + c3 * n3, t3[2] = o3 * i3 + h3 * n3, t3[3] = l3 * i3 + p3 * n3, t3[4] = u3 * i3 - a3 * n3, t3[5] = c3 * i3 - s3 * n3, t3[6] = h3 * i3 - o3 * n3, t3[7] = p3 * i3 - l3 * n3, t3;
        }, t2.af = function(t3) {
          var e2 = new zs(16);
          return e2[0] = t3[0], e2[1] = t3[1], e2[2] = t3[2], e2[3] = t3[3], e2[4] = t3[4], e2[5] = t3[5], e2[6] = t3[6], e2[7] = t3[7], e2[8] = t3[8], e2[9] = t3[9], e2[10] = t3[10], e2[11] = t3[11], e2[12] = t3[12], e2[13] = t3[13], e2[14] = t3[14], e2[15] = t3[15], e2;
        }, t2.ag = Vs, t2.ah = function(t3, e2) {
          let r3 = 0, n3 = 0;
          if ("constant" === t3.kind) n3 = t3.layoutSize;
          else if ("source" !== t3.kind) {
            const { interpolationType: i3, minZoom: a3, maxZoom: s3 } = t3, o3 = i3 ? y2(Ke.interpolationFactor(i3, e2, a3, s3), 0, 1) : 0;
            "camera" === t3.kind ? n3 = Ze2.number(t3.minSize, t3.maxSize, o3) : r3 = o3;
          }
          return { uSizeT: r3, uSize: n3 };
        }, t2.aj = function(t3, { uSize: e2, uSizeT: r3 }, { lowerSize: n3, upperSize: i3 }) {
          return "source" === t3.kind ? n3 / Cu : "composite" === t3.kind ? Ze2.number(n3 / Cu, i3 / Cu, r3) : e2;
        }, t2.ak = $u, t2.al = function(t3, e2, r3, n3) {
          const i3 = e2.y - t3.y, s3 = e2.x - t3.x, o3 = n3.y - r3.y, l3 = n3.x - r3.x, u3 = o3 * s3 - l3 * i3;
          if (0 === u3) return null;
          const c3 = (l3 * (t3.y - r3.y) - o3 * (t3.x - r3.x)) / u3;
          return new a2(t3.x + c3 * s3, t3.y + c3 * i3);
        }, t2.am = _c, t2.an = us, t2.ao = Ms, t2.ap = Vl, t2.ar = Vu, t2.as = function(t3, e2) {
          var r3 = e2[0], n3 = e2[1], i3 = e2[2], a3 = e2[3], s3 = e2[4], o3 = e2[5], l3 = e2[6], u3 = e2[7], c3 = e2[8], h3 = e2[9], p3 = e2[10], f3 = e2[11], d3 = e2[12], y3 = e2[13], m3 = e2[14], g3 = e2[15], x3 = r3 * o3 - n3 * s3, v3 = r3 * l3 - i3 * s3, b3 = r3 * u3 - a3 * s3, w3 = n3 * l3 - i3 * o3, _3 = n3 * u3 - a3 * o3, A3 = i3 * u3 - a3 * l3, S3 = c3 * y3 - h3 * d3, k3 = c3 * m3 - p3 * d3, I3 = c3 * g3 - f3 * d3, z3 = h3 * m3 - p3 * y3, M3 = h3 * g3 - f3 * y3, C3 = p3 * g3 - f3 * m3, B3 = x3 * C3 - v3 * M3 + b3 * z3 + w3 * I3 - _3 * k3 + A3 * S3;
          return B3 ? (t3[0] = (o3 * C3 - l3 * M3 + u3 * z3) * (B3 = 1 / B3), t3[1] = (i3 * M3 - n3 * C3 - a3 * z3) * B3, t3[2] = (y3 * A3 - m3 * _3 + g3 * w3) * B3, t3[3] = (p3 * _3 - h3 * A3 - f3 * w3) * B3, t3[4] = (l3 * I3 - s3 * C3 - u3 * k3) * B3, t3[5] = (r3 * C3 - i3 * I3 + a3 * k3) * B3, t3[6] = (m3 * b3 - d3 * A3 - g3 * v3) * B3, t3[7] = (c3 * A3 - p3 * b3 + f3 * v3) * B3, t3[8] = (s3 * M3 - o3 * I3 + u3 * S3) * B3, t3[9] = (n3 * I3 - r3 * M3 - a3 * S3) * B3, t3[10] = (d3 * _3 - y3 * b3 + g3 * x3) * B3, t3[11] = (h3 * b3 - c3 * _3 - f3 * x3) * B3, t3[12] = (o3 * k3 - s3 * z3 - l3 * S3) * B3, t3[13] = (r3 * z3 - n3 * k3 + i3 * S3) * B3, t3[14] = (y3 * v3 - d3 * w3 - m3 * x3) * B3, t3[15] = (c3 * w3 - h3 * v3 + p3 * x3) * B3, t3) : null;
        }, t2.at = Jc, t2.au = Su, t2.av = th, t2.aw = function() {
          const t3 = {}, e2 = X2.$version;
          for (const r3 in X2.$root) {
            const n3 = X2.$root[r3];
            if (n3.required) {
              let i3 = null;
              i3 = "version" === r3 ? e2 : "array" === n3.type ? [] : {}, null != i3 && (t3[r3] = i3);
            }
          }
          return t3;
        }, t2.ax = Q2, t2.ay = Un, t2.az = D2, t2.b = function(t3, e2) {
          const r3 = new Blob([new Uint8Array(t3)], { type: "image/png" });
          createImageBitmap(r3).then((t4) => {
            e2(null, t4);
          }).catch((t4) => {
            e2(new Error(`Could not load image because of ${t4.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
          });
        }, t2.b0 = Aa, t2.b1 = function(t3, e2) {
          var r3 = t3[0], n3 = t3[1], i3 = t3[2], a3 = t3[3], s3 = t3[4], o3 = t3[5], l3 = t3[6], u3 = t3[7], c3 = t3[8], h3 = t3[9], p3 = t3[10], f3 = t3[11], d3 = t3[12], y3 = t3[13], m3 = t3[14], g3 = t3[15], x3 = e2[0], v3 = e2[1], b3 = e2[2], w3 = e2[3], _3 = e2[4], A3 = e2[5], S3 = e2[6], k3 = e2[7], I3 = e2[8], z3 = e2[9], M3 = e2[10], C3 = e2[11], B3 = e2[12], P3 = e2[13], V3 = e2[14], E3 = e2[15];
          return Math.abs(r3 - x3) <= Is * Math.max(1, Math.abs(r3), Math.abs(x3)) && Math.abs(n3 - v3) <= Is * Math.max(1, Math.abs(n3), Math.abs(v3)) && Math.abs(i3 - b3) <= Is * Math.max(1, Math.abs(i3), Math.abs(b3)) && Math.abs(a3 - w3) <= Is * Math.max(1, Math.abs(a3), Math.abs(w3)) && Math.abs(s3 - _3) <= Is * Math.max(1, Math.abs(s3), Math.abs(_3)) && Math.abs(o3 - A3) <= Is * Math.max(1, Math.abs(o3), Math.abs(A3)) && Math.abs(l3 - S3) <= Is * Math.max(1, Math.abs(l3), Math.abs(S3)) && Math.abs(u3 - k3) <= Is * Math.max(1, Math.abs(u3), Math.abs(k3)) && Math.abs(c3 - I3) <= Is * Math.max(1, Math.abs(c3), Math.abs(I3)) && Math.abs(h3 - z3) <= Is * Math.max(1, Math.abs(h3), Math.abs(z3)) && Math.abs(p3 - M3) <= Is * Math.max(1, Math.abs(p3), Math.abs(M3)) && Math.abs(f3 - C3) <= Is * Math.max(1, Math.abs(f3), Math.abs(C3)) && Math.abs(d3 - B3) <= Is * Math.max(1, Math.abs(d3), Math.abs(B3)) && Math.abs(y3 - P3) <= Is * Math.max(1, Math.abs(y3), Math.abs(P3)) && Math.abs(m3 - V3) <= Is * Math.max(1, Math.abs(m3), Math.abs(V3)) && Math.abs(g3 - E3) <= Is * Math.max(1, Math.abs(g3), Math.abs(E3));
        }, t2.b2 = function(t3, e2) {
          return t3[0] = e2[0], t3[1] = e2[1], t3[2] = e2[2], t3[3] = e2[3], t3[4] = e2[4], t3[5] = e2[5], t3[6] = e2[6], t3[7] = e2[7], t3[8] = e2[8], t3[9] = e2[9], t3[10] = e2[10], t3[11] = e2[11], t3[12] = e2[12], t3[13] = e2[13], t3[14] = e2[14], t3[15] = e2[15], t3;
        }, t2.b3 = function(t3, e2, r3) {
          return t3[0] = e2[0] * r3[0], t3[1] = e2[1] * r3[1], t3[2] = e2[2] * r3[2], t3[3] = e2[3] * r3[3], t3;
        }, t2.b4 = function(t3, e2) {
          return t3[0] * e2[0] + t3[1] * e2[1] + t3[2] * e2[2] + t3[3] * e2[3];
        }, t2.b5 = m2, t2.b6 = pc, t2.b7 = sc, t2.b8 = function(t3, e2, r3, n3, i3) {
          var a3, s3 = 1 / Math.tan(e2 / 2);
          return t3[0] = s3 / r3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = s3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[15] = 0, null != i3 && i3 !== 1 / 0 ? (t3[10] = (i3 + n3) * (a3 = 1 / (n3 - i3)), t3[14] = 2 * i3 * n3 * a3) : (t3[10] = -1, t3[14] = -2 * n3), t3;
        }, t2.b9 = function(t3, e2, r3) {
          var n3 = Math.sin(r3), i3 = Math.cos(r3), a3 = e2[4], s3 = e2[5], o3 = e2[6], l3 = e2[7], u3 = e2[8], c3 = e2[9], h3 = e2[10], p3 = e2[11];
          return e2 !== t3 && (t3[0] = e2[0], t3[1] = e2[1], t3[2] = e2[2], t3[3] = e2[3], t3[12] = e2[12], t3[13] = e2[13], t3[14] = e2[14], t3[15] = e2[15]), t3[4] = a3 * i3 + u3 * n3, t3[5] = s3 * i3 + c3 * n3, t3[6] = o3 * i3 + h3 * n3, t3[7] = l3 * i3 + p3 * n3, t3[8] = u3 * i3 - a3 * n3, t3[9] = c3 * i3 - s3 * n3, t3[10] = h3 * i3 - o3 * n3, t3[11] = p3 * i3 - l3 * n3, t3;
        }, t2.bA = n2, t2.bB = El, t2.bC = $r, t2.bD = oi, t2.ba = f2, t2.bb = d2, t2.bc = function(t3, e2) {
          return t3[0] = e2[0], t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = e2[1], t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = e2[2], t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, t2.bd = class extends Pi {
        }, t2.be = tc, t2.bf = oc, t2.bg = ph, t2.bi = L2, t2.bj = function(t3, e2, r3 = false) {
          if (ti === Yn || ti === Hn || ti === Wn) throw new Error("setRTLTextPlugin cannot be called multiple times.");
          ei = T2.resolveURL(t3), ti = Yn, Qn = e2, ni(), r3 || si();
        }, t2.bk = ai, t2.bl = function(t3, e2) {
          const r3 = {};
          for (let n4 = 0; n4 < t3.length; n4++) {
            const i3 = e2 && e2[t3[n4].id] || Qr(t3[n4]);
            e2 && (e2[t3[n4].id] = i3);
            let a3 = r3[i3];
            a3 || (a3 = r3[i3] = []), a3.push(t3[n4]);
          }
          const n3 = [];
          for (const t4 in r3) n3.push(r3[t4]);
          return n3;
        }, t2.bm = $n, t2.bn = mc, t2.bo = xc, t2.bp = cu, t2.bq = function(e2) {
          e2.bucket.createArrays(), e2.bucket.tilePixelRatio = rs / (512 * e2.bucket.overscaling), e2.bucket.compareText = {}, e2.bucket.iconsNeedLinear = false;
          const r3 = e2.bucket.layers[0], n3 = r3.layout, i3 = r3._unevaluatedLayout._values, a3 = { layoutIconSize: i3["icon-size"].possiblyEvaluate(new li(e2.bucket.zoom + 1), e2.canonical), layoutTextSize: i3["text-size"].possiblyEvaluate(new li(e2.bucket.zoom + 1), e2.canonical), textMaxSize: i3["text-size"].possiblyEvaluate(new li(18)) };
          if ("composite" === e2.bucket.textSizeData.kind) {
            const { minZoom: t3, maxZoom: r4 } = e2.bucket.textSizeData;
            a3.compositeTextSizes = [i3["text-size"].possiblyEvaluate(new li(t3), e2.canonical), i3["text-size"].possiblyEvaluate(new li(r4), e2.canonical)];
          }
          if ("composite" === e2.bucket.iconSizeData.kind) {
            const { minZoom: t3, maxZoom: r4 } = e2.bucket.iconSizeData;
            a3.compositeIconSizes = [i3["icon-size"].possiblyEvaluate(new li(t3), e2.canonical), i3["icon-size"].possiblyEvaluate(new li(r4), e2.canonical)];
          }
          const s3 = n3.get("text-line-height") * Vl, o3 = "viewport" !== n3.get("text-rotation-alignment") && "point" !== n3.get("symbol-placement"), l3 = n3.get("text-keep-upright"), u3 = n3.get("text-size");
          for (const i4 of e2.bucket.features) {
            const c3 = n3.get("text-font").evaluate(i4, {}, e2.canonical).join(","), h3 = u3.evaluate(i4, {}, e2.canonical), p3 = a3.layoutTextSize.evaluate(i4, {}, e2.canonical), f3 = a3.layoutIconSize.evaluate(i4, {}, e2.canonical), d3 = { horizontal: {}, vertical: void 0 }, y3 = i4.text;
            let m3, g3 = [0, 0];
            if (y3) {
              const a4 = y3.toString(), u4 = n3.get("text-letter-spacing").evaluate(i4, {}, e2.canonical) * Vl, f4 = jn(a4) ? u4 : 0, m4 = n3.get("text-anchor").evaluate(i4, {}, e2.canonical), x4 = Gc(r3, i4, e2.canonical);
              if (!x4) {
                const t3 = n3.get("text-radial-offset").evaluate(i4, {}, e2.canonical);
                g3 = t3 ? Kc(m4, [t3 * Vl, Zc]) : n3.get("text-offset").evaluate(i4, {}, e2.canonical).map((t4) => t4 * Vl);
              }
              let v4 = o3 ? "center" : n3.get("text-justify").evaluate(i4, {}, e2.canonical);
              const b3 = n3.get("symbol-placement"), w3 = "point" === b3 ? n3.get("text-max-width").evaluate(i4, {}, e2.canonical) * Vl : 0, _3 = () => {
                e2.bucket.allowVerticalPlacement && qn(a4) && (d3.vertical = yu(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c3, w3, s3, m4, "left", f4, g3, t2.ai.vertical, true, b3, p3, h3));
              };
              if (!o3 && x4) {
                const r4 = /* @__PURE__ */ new Set();
                if ("auto" === v4) for (let t3 = 0; t3 < x4.values.length; t3 += 2) r4.add(Jc(x4.values[t3]));
                else r4.add(v4);
                let n4 = false;
                for (const i5 of r4) if (!d3.horizontal[i5]) if (n4) d3.horizontal[i5] = d3.horizontal[0];
                else {
                  const r5 = yu(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c3, w3, s3, "center", i5, f4, g3, t2.ai.horizontal, false, b3, p3, h3);
                  r5 && (d3.horizontal[i5] = r5, n4 = 1 === r5.positionedLines.length);
                }
                _3();
              } else {
                "auto" === v4 && (v4 = Jc(m4));
                const r4 = yu(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c3, w3, s3, m4, v4, f4, g3, t2.ai.horizontal, false, b3, p3, h3);
                r4 && (d3.horizontal[v4] = r4), _3(), qn(a4) && o3 && l3 && (d3.vertical = yu(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c3, w3, s3, m4, v4, f4, g3, t2.ai.vertical, false, b3, p3, h3));
              }
            }
            let x3 = false;
            if (i4.icon && i4.icon.name) {
              const t3 = e2.imageMap[i4.icon.name];
              t3 && (m3 = Iu(e2.imagePositions[i4.icon.name], n3.get("icon-offset").evaluate(i4, {}, e2.canonical), n3.get("icon-anchor").evaluate(i4, {}, e2.canonical)), x3 = !!t3.sdf, void 0 === e2.bucket.sdfIcons ? e2.bucket.sdfIcons = x3 : e2.bucket.sdfIcons !== x3 && A2("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t3.pixelRatio !== e2.bucket.pixelRatio || 0 !== n3.get("icon-rotate").constantOr(1)) && (e2.bucket.iconsNeedLinear = true));
            }
            const v3 = Hc(d3.horizontal) || d3.vertical;
            e2.bucket.iconsInText = !!v3 && v3.iconsInText, (v3 || m3) && Xc(e2.bucket, i4, d3, m3, e2.imageMap, a3, p3, f3, g3, x3, e2.canonical);
          }
          e2.showCollisionBoxes && e2.bucket.generateCollisionDebugBuffers();
        }, t2.br = gl, t2.bs = Eo, t2.bt = rl, t2.bu = class {
          constructor(t3) {
            this._marks = { start: [t3.url, "start"].join("#"), end: [t3.url, "end"].join("#"), measure: t3.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let t3 = performance.getEntriesByName(this._marks.measure);
            return 0 === t3.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t3 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t3;
          }
        }, t2.bv = eu, t2.bw = Ro, t2.bx = function(t3, r3, n3, i3, a3) {
          return e(this, void 0, void 0, function* () {
            if (p2()) try {
              return yield B2(t3, r3, n3, i3, a3);
            } catch (t4) {
            }
            return function(t4, e2, r4, n4, i4) {
              const a4 = t4.width, s3 = t4.height;
              P2 && V2 || (P2 = new OffscreenCanvas(a4, s3), V2 = P2.getContext("2d", { willReadFrequently: true })), P2.width = a4, P2.height = s3, V2.drawImage(t4, 0, 0, a4, s3);
              const o3 = V2.getImageData(e2, r4, n4, i4);
              return V2.clearRect(0, 0, a4, s3), o3.data;
            }(t3, r3, n3, i3, a3);
          });
        }, t2.by = yc, t2.bz = r2, t2.c = $2, t2.d = function(t3, e2) {
          const r3 = new Image();
          r3.onload = () => {
            e2(null, r3), URL.revokeObjectURL(r3.src), r3.onload = null, window.requestAnimationFrame(() => {
              r3.src = C2;
            });
          }, r3.onerror = () => e2(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const n3 = new Blob([new Uint8Array(t3)], { type: "image/png" });
          r3.src = t3.byteLength ? URL.createObjectURL(n3) : C2;
        }, t2.e = g2, t2.f = function(t3, e2) {
          return R2(g2(t3, { type: "json" }), e2);
        }, t2.g = O2, t2.h = T2, t2.i = I2, t2.j = G2, t2.k = K2, t2.l = q2, t2.m = R2, t2.n = function(t3) {
          return new eu(t3).readFields(nu, []);
        }, t2.o = function(t3, e2, r3) {
          if (!t3.length) return r3(null, []);
          let n3 = t3.length;
          const i3 = new Array(t3.length);
          let a3 = null;
          t3.forEach((t4, s3) => {
            e2(t4, (t5, e3) => {
              t5 && (a3 = t5), i3[s3] = e3, 0 == --n3 && r3(a3, i3);
            });
          });
        }, t2.p = ou, t2.q = Rs, t2.r = _i, t2.s = j2, t2.t = Bn, t2.u = Rn, t2.v = X2, t2.w = A2, t2.x = En, t2.y = Cn, t2.z = function([t3, e2, r3]) {
          return e2 += 90, e2 *= Math.PI / 180, r3 *= Math.PI / 180, { x: t3 * Math.cos(e2) * Math.sin(r3), y: t3 * Math.sin(e2) * Math.sin(r3), z: t3 * Math.cos(r3) };
        };
      });
      define(["./shared"], function(e) {
        class t2 {
          constructor(e2) {
            this.keyCache = {}, e2 && this.replace(e2);
          }
          replace(e2) {
            this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
          }
          update(t3, i3) {
            for (const i4 of t3) {
              this._layerConfigs[i4.id] = i4;
              const t4 = this._layers[i4.id] = e.aC(i4);
              t4._featureFilter = e.a6(t4.filter), this.keyCache[i4.id] && delete this.keyCache[i4.id];
            }
            for (const e2 of i3) delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
            this.familiesBySource = {};
            const o3 = e.bl(Object.values(this._layerConfigs), this.keyCache);
            for (const e2 of o3) {
              const t4 = e2.map((e3) => this._layers[e3.id]), i4 = t4[0];
              if ("none" === i4.visibility) continue;
              const o4 = i4.source || "";
              let r3 = this.familiesBySource[o4];
              r3 || (r3 = this.familiesBySource[o4] = {});
              const s3 = i4.sourceLayer || "_geojsonTileLayer";
              let n3 = r3[s3];
              n3 || (n3 = r3[s3] = []), n3.push(t4);
            }
          }
        }
        class i2 {
          constructor(t3) {
            const i3 = {}, o3 = [];
            for (const e2 in t3) {
              const r4 = t3[e2], s4 = i3[e2] = {};
              for (const e3 in r4) {
                const t4 = r4[+e3];
                if (!t4 || 0 === t4.bitmap.width || 0 === t4.bitmap.height) continue;
                const i4 = { x: 0, y: 0, w: t4.bitmap.width + 2, h: t4.bitmap.height + 2 };
                o3.push(i4), s4[e3] = { rect: i4, metrics: t4.metrics };
              }
            }
            const { w: r3, h: s3 } = e.p(o3), n3 = new e.q({ width: r3 || 1, height: s3 || 1 });
            for (const o4 in t3) {
              const r4 = t3[o4];
              for (const t4 in r4) {
                const s4 = r4[+t4];
                if (!s4 || 0 === s4.bitmap.width || 0 === s4.bitmap.height) continue;
                const a3 = i3[o4][t4].rect;
                e.q.copy(s4.bitmap, n3, { x: 0, y: 0 }, { x: a3.x + 1, y: a3.y + 1 }, s4.bitmap);
              }
            }
            this.image = n3, this.positions = i3;
          }
        }
        e.bm("GlyphAtlas", i2);
        class o2 {
          constructor(t3) {
            this.tileID = new e.O(t3.tileID.overscaledZ, t3.tileID.wrap, t3.tileID.canonical.z, t3.tileID.canonical.x, t3.tileID.canonical.y), this.uid = t3.uid, this.zoom = t3.zoom, this.pixelRatio = t3.pixelRatio, this.tileSize = t3.tileSize, this.source = t3.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t3.showCollisionBoxes, this.collectResourceTiming = !!t3.collectResourceTiming, this.returnDependencies = !!t3.returnDependencies, this.promoteId = t3.promoteId, this.inFlightDependencies = [], this.dependencySentinel = -1;
          }
          parse(t3, o3, s3, n3, a3) {
            this.status = "parsing", this.data = t3, this.collisionBoxArray = new e.a3();
            const l3 = new e.bn(Object.keys(t3.layers).sort()), c3 = new e.bo(this.tileID, this.promoteId);
            c3.bucketLayerIDs = [];
            const h3 = {}, u3 = { featureIndex: c3, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: s3 }, d3 = o3.familiesBySource[this.source];
            for (const i3 in d3) {
              const o4 = t3.layers[i3];
              if (!o4) continue;
              1 === o4.version && e.w(`Vector tile source "${this.source}" layer "${i3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const n4 = l3.encode(i3), a4 = [];
              for (let e2 = 0; e2 < o4.length; e2++) {
                const t4 = o4.feature(e2), r3 = c3.getId(t4, i3);
                a4.push({ feature: t4, id: r3, index: e2, sourceLayerIndex: n4 });
              }
              for (const t4 of d3[i3]) {
                const i4 = t4[0];
                i4.source !== this.source && e.w(`layer.source = ${i4.source} does not equal this.source = ${this.source}`), i4.minzoom && this.zoom < Math.floor(i4.minzoom) || i4.maxzoom && this.zoom >= i4.maxzoom || "none" !== i4.visibility && (r2(t4, this.zoom, s3), (h3[i4.id] = i4.createBucket({ index: c3.bucketLayerIDs.length, layers: t4, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n4, sourceID: this.source })).populate(a4, u3, this.tileID.canonical), c3.bucketLayerIDs.push(t4.map((e2) => e2.id)));
              }
            }
            let p3, f3, g3, m3;
            const y3 = e.aH(u3.glyphDependencies, (e2) => Object.keys(e2).map(Number));
            this.inFlightDependencies.forEach((e2) => null == e2 ? void 0 : e2.cancel()), this.inFlightDependencies = [];
            const v3 = ++this.dependencySentinel;
            Object.keys(y3).length ? this.inFlightDependencies.push(n3.send("getGlyphs", { uid: this.uid, stacks: y3, source: this.source, tileID: this.tileID, type: "glyphs" }, (e2, t4) => {
              v3 === this.dependencySentinel && (p3 || (p3 = e2, f3 = t4, b3.call(this)));
            })) : f3 = {};
            const w3 = Object.keys(u3.iconDependencies);
            w3.length ? this.inFlightDependencies.push(n3.send("getImages", { icons: w3, source: this.source, tileID: this.tileID, type: "icons" }, (e2, t4) => {
              v3 === this.dependencySentinel && (p3 || (p3 = e2, g3 = t4, b3.call(this)));
            })) : g3 = {};
            const x3 = Object.keys(u3.patternDependencies);
            function b3() {
              if (p3) return a3(p3);
              if (f3 && g3 && m3) {
                const t4 = new i2(f3), o4 = new e.bp(g3, m3);
                for (const i3 in h3) {
                  const n4 = h3[i3];
                  n4 instanceof e.a4 ? (r2(n4.layers, this.zoom, s3), e.bq({ bucket: n4, glyphMap: f3, glyphPositions: t4.positions, imageMap: g3, imagePositions: o4.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : n4.hasPattern && (n4 instanceof e.br || n4 instanceof e.bs || n4 instanceof e.bt) && (r2(n4.layers, this.zoom, s3), n4.addFeatures(u3, this.tileID.canonical, o4.patternPositions));
                }
                this.status = "done", a3(null, { buckets: Object.values(h3).filter((e2) => !e2.isEmpty()), featureIndex: c3, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t4.image, imageAtlas: o4, glyphMap: this.returnDependencies ? f3 : null, iconMap: this.returnDependencies ? g3 : null, glyphPositions: this.returnDependencies ? t4.positions : null });
              }
            }
            x3.length ? this.inFlightDependencies.push(n3.send("getImages", { icons: x3, source: this.source, tileID: this.tileID, type: "patterns" }, (e2, t4) => {
              v3 === this.dependencySentinel && (p3 || (p3 = e2, m3 = t4, b3.call(this)));
            })) : m3 = {}, b3.call(this);
          }
        }
        function r2(t3, i3, o3) {
          const r3 = new e.a8(i3);
          for (const e2 of t3) e2.recalculate(r3, o3);
        }
        function s2(t3, i3) {
          const o3 = e.l(t3.request, (o4, r3, s3, n3) => {
            if (o4) i3(o4);
            else if (r3) try {
              const t4 = new e.bw.VectorTile(new e.bv(r3));
              i3(null, { vectorTile: t4, rawData: r3, cacheControl: s3, expires: n3 });
            } catch (e2) {
              const o5 = new Uint8Array(r3);
              let s4 = `Unable to parse the tile at ${t3.request.url}, `;
              s4 += 31 === o5[0] && 139 === o5[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e2.messge}`, i3(new Error(s4));
            }
          });
          return () => {
            o3.cancel(), i3();
          };
        }
        class n2 {
          constructor(e2, t3, i3, o3) {
            this.actor = e2, this.layerIndex = t3, this.availableImages = i3, this.loadVectorData = o3 || s2, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadTile(t3, i3) {
            const r3 = t3.uid;
            this.loading || (this.loading = {});
            const s3 = !!(t3 && t3.request && t3.request.collectResourceTiming) && new e.bu(t3.request), n3 = this.loading[r3] = new o2(t3);
            n3.abort = this.loadVectorData(t3, (t4, o3) => {
              if (delete this.loading[r3], t4 || !o3) return n3.status = "done", this.loaded[r3] = n3, i3(t4);
              const a3 = o3.rawData, l3 = {};
              o3.expires && (l3.expires = o3.expires), o3.cacheControl && (l3.cacheControl = o3.cacheControl);
              const c3 = {};
              if (s3) {
                const e2 = s3.finish();
                e2 && (c3.resourceTiming = JSON.parse(JSON.stringify(e2)));
              }
              n3.vectorTile = o3.vectorTile, n3.parse(o3.vectorTile, this.layerIndex, this.availableImages, this.actor, (t5, o4) => {
                if (delete this.fetching[r3], t5 || !o4) return i3(t5);
                i3(null, e.e({ rawTileData: a3.slice(0) }, o4, l3, c3));
              }), this.loaded = this.loaded || {}, this.loaded[r3] = n3, this.fetching[r3] = { rawTileData: a3, cacheControl: l3, resourceTiming: c3 };
            });
          }
          reloadTile(t3, i3) {
            const o3 = this.loaded, r3 = t3.uid;
            if (o3 && o3[r3]) {
              const s3 = o3[r3];
              s3.showCollisionBoxes = t3.showCollisionBoxes, "parsing" === s3.status ? s3.parse(s3.vectorTile, this.layerIndex, this.availableImages, this.actor, (t4, o4) => {
                if (t4 || !o4) return i3(t4, o4);
                let s4;
                if (this.fetching[r3]) {
                  const { rawTileData: t5, cacheControl: i4, resourceTiming: n3 } = this.fetching[r3];
                  delete this.fetching[r3], s4 = e.e({ rawTileData: t5.slice(0) }, o4, i4, n3);
                } else s4 = o4;
                i3(null, s4);
              }) : "done" === s3.status && (s3.vectorTile ? s3.parse(s3.vectorTile, this.layerIndex, this.availableImages, this.actor, i3) : i3());
            }
          }
          abortTile(e2, t3) {
            const i3 = this.loading, o3 = e2.uid;
            i3 && i3[o3] && i3[o3].abort && (i3[o3].abort(), delete i3[o3]), t3();
          }
          removeTile(e2, t3) {
            const i3 = this.loaded, o3 = e2.uid;
            i3 && i3[o3] && delete i3[o3], t3();
          }
        }
        class a2 {
          constructor() {
            this.loaded = {};
          }
          loadTile(t3, i3) {
            return e._(this, void 0, void 0, function* () {
              const { uid: o3, encoding: r3, rawImageData: s3, redFactor: n3, greenFactor: a3, blueFactor: l3, baseShift: c3 } = t3, h3 = s3.width + 2, u3 = s3.height + 2, d3 = e.a(s3) ? new e.R({ width: h3, height: u3 }, yield e.bx(s3, -1, -1, h3, u3)) : s3, p3 = new e.by(o3, d3, r3, n3, a3, l3, c3);
              this.loaded = this.loaded || {}, this.loaded[o3] = p3, i3(null, p3);
            });
          }
          removeTile(e2) {
            const t3 = this.loaded, i3 = e2.uid;
            t3 && t3[i3] && delete t3[i3];
          }
        }
        function l2(e2, t3) {
          if (0 !== e2.length) {
            c2(e2[0], t3);
            for (var i3 = 1; i3 < e2.length; i3++) c2(e2[i3], !t3);
          }
        }
        function c2(e2, t3) {
          for (var i3 = 0, o3 = 0, r3 = 0, s3 = e2.length, n3 = s3 - 1; r3 < s3; n3 = r3++) {
            var a3 = (e2[r3][0] - e2[n3][0]) * (e2[n3][1] + e2[r3][1]), l3 = i3 + a3;
            o3 += Math.abs(i3) >= Math.abs(a3) ? i3 - l3 + a3 : a3 - l3 + i3, i3 = l3;
          }
          i3 + o3 >= 0 != !!t3 && e2.reverse();
        }
        var h2 = e.bz(function e2(t3, i3) {
          var o3, r3 = t3 && t3.type;
          if ("FeatureCollection" === r3) for (o3 = 0; o3 < t3.features.length; o3++) e2(t3.features[o3], i3);
          else if ("GeometryCollection" === r3) for (o3 = 0; o3 < t3.geometries.length; o3++) e2(t3.geometries[o3], i3);
          else if ("Feature" === r3) e2(t3.geometry, i3);
          else if ("Polygon" === r3) l2(t3.coordinates, i3);
          else if ("MultiPolygon" === r3) for (o3 = 0; o3 < t3.coordinates.length; o3++) l2(t3.coordinates[o3], i3);
          return t3;
        });
        const u2 = e.bw.VectorTileFeature.prototype.toGeoJSON;
        var d2 = { exports: {} }, p2 = e.bA, f2 = e.bw.VectorTileFeature, g2 = m2;
        function m2(e2, t3) {
          this.options = t3 || {}, this.features = e2, this.length = e2.length;
        }
        function y2(e2, t3) {
          this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t3 || 4096;
        }
        m2.prototype.feature = function(e2) {
          return new y2(this.features[e2], this.options.extent);
        }, y2.prototype.loadGeometry = function() {
          var e2 = this.rawGeometry;
          this.geometry = [];
          for (var t3 = 0; t3 < e2.length; t3++) {
            for (var i3 = e2[t3], o3 = [], r3 = 0; r3 < i3.length; r3++) o3.push(new p2(i3[r3][0], i3[r3][1]));
            this.geometry.push(o3);
          }
          return this.geometry;
        }, y2.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e2 = this.geometry, t3 = 1 / 0, i3 = -1 / 0, o3 = 1 / 0, r3 = -1 / 0, s3 = 0; s3 < e2.length; s3++) for (var n3 = e2[s3], a3 = 0; a3 < n3.length; a3++) {
            var l3 = n3[a3];
            t3 = Math.min(t3, l3.x), i3 = Math.max(i3, l3.x), o3 = Math.min(o3, l3.y), r3 = Math.max(r3, l3.y);
          }
          return [t3, o3, i3, r3];
        }, y2.prototype.toGeoJSON = f2.prototype.toGeoJSON;
        var v2 = e.bB, w2 = g2;
        function x2(e2) {
          var t3 = new v2();
          return function(e3, t4) {
            for (var i3 in e3.layers) t4.writeMessage(3, b2, e3.layers[i3]);
          }(e2, t3), t3.finish();
        }
        function b2(e2, t3) {
          var i3;
          t3.writeVarintField(15, e2.version || 1), t3.writeStringField(1, e2.name || ""), t3.writeVarintField(5, e2.extent || 4096);
          var o3 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (i3 = 0; i3 < e2.length; i3++) o3.feature = e2.feature(i3), t3.writeMessage(2, S2, o3);
          var r3 = o3.keys;
          for (i3 = 0; i3 < r3.length; i3++) t3.writeStringField(3, r3[i3]);
          var s3 = o3.values;
          for (i3 = 0; i3 < s3.length; i3++) t3.writeMessage(4, _2, s3[i3]);
        }
        function S2(e2, t3) {
          var i3 = e2.feature;
          void 0 !== i3.id && t3.writeVarintField(1, i3.id), t3.writeMessage(2, M2, e2), t3.writeVarintField(3, i3.type), t3.writeMessage(4, T2, i3);
        }
        function M2(e2, t3) {
          var i3 = e2.feature, o3 = e2.keys, r3 = e2.values, s3 = e2.keycache, n3 = e2.valuecache;
          for (var a3 in i3.properties) {
            var l3 = i3.properties[a3], c3 = s3[a3];
            if (null !== l3) {
              void 0 === c3 && (o3.push(a3), s3[a3] = c3 = o3.length - 1), t3.writeVarint(c3);
              var h3 = typeof l3;
              "string" !== h3 && "boolean" !== h3 && "number" !== h3 && (l3 = JSON.stringify(l3));
              var u3 = h3 + ":" + l3, d3 = n3[u3];
              void 0 === d3 && (r3.push(l3), n3[u3] = d3 = r3.length - 1), t3.writeVarint(d3);
            }
          }
        }
        function I2(e2, t3) {
          return (t3 << 3) + (7 & e2);
        }
        function P2(e2) {
          return e2 << 1 ^ e2 >> 31;
        }
        function T2(e2, t3) {
          for (var i3 = e2.loadGeometry(), o3 = e2.type, r3 = 0, s3 = 0, n3 = i3.length, a3 = 0; a3 < n3; a3++) {
            var l3 = i3[a3], c3 = 1;
            1 === o3 && (c3 = l3.length), t3.writeVarint(I2(1, c3));
            for (var h3 = 3 === o3 ? l3.length - 1 : l3.length, u3 = 0; u3 < h3; u3++) {
              1 === u3 && 1 !== o3 && t3.writeVarint(I2(2, h3 - 1));
              var d3 = l3[u3].x - r3, p3 = l3[u3].y - s3;
              t3.writeVarint(P2(d3)), t3.writeVarint(P2(p3)), r3 += d3, s3 += p3;
            }
            3 === o3 && t3.writeVarint(I2(7, 1));
          }
        }
        function _2(e2, t3) {
          var i3 = typeof e2;
          "string" === i3 ? t3.writeStringField(1, e2) : "boolean" === i3 ? t3.writeBooleanField(7, e2) : "number" === i3 && (e2 % 1 != 0 ? t3.writeDoubleField(3, e2) : e2 < 0 ? t3.writeSVarintField(6, e2) : t3.writeVarintField(5, e2));
        }
        d2.exports = x2, d2.exports.fromVectorTileJs = x2, d2.exports.fromGeojsonVt = function(e2, t3) {
          t3 = t3 || {};
          var i3 = {};
          for (var o3 in e2) i3[o3] = new w2(e2[o3].features, t3), i3[o3].name = o3, i3[o3].version = t3.version, i3[o3].extent = t3.extent;
          return x2({ layers: i3 });
        }, d2.exports.GeoJSONWrapper = w2;
        var k2 = e.bz(d2.exports);
        const D2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, O2 = Math.fround || (C2 = new Float32Array(1), (e2) => (C2[0] = +e2, C2[0]));
        var C2;
        const L2 = 3, F2 = 5, z2 = 6;
        class N2 {
          constructor(e2) {
            this.options = Object.assign(Object.create(D2), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(e2) {
            const { log: t3, minZoom: i3, maxZoom: o3 } = this.options;
            t3 && console.time("total time");
            const r3 = `prepare ${e2.length} points`;
            t3 && console.time(r3), this.points = e2;
            const s3 = [];
            for (let t4 = 0; t4 < e2.length; t4++) {
              const i4 = e2[t4];
              if (!i4.geometry) continue;
              const [o4, r4] = i4.geometry.coordinates, n4 = O2(Z2(o4)), a3 = O2(G2(r4));
              s3.push(n4, a3, 1 / 0, t4, -1, 1), this.options.reduce && s3.push(0);
            }
            let n3 = this.trees[o3 + 1] = this._createTree(s3);
            t3 && console.timeEnd(r3);
            for (let e3 = o3; e3 >= i3; e3--) {
              const i4 = +Date.now();
              n3 = this.trees[e3] = this._createTree(this._cluster(n3, e3)), t3 && console.log("z%d: %d clusters in %dms", e3, n3.numItems, +Date.now() - i4);
            }
            return t3 && console.timeEnd("total time"), this;
          }
          getClusters(e2, t3) {
            let i3 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
            const o3 = Math.max(-90, Math.min(90, e2[1]));
            let r3 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
            const s3 = Math.max(-90, Math.min(90, e2[3]));
            if (e2[2] - e2[0] >= 360) i3 = -180, r3 = 180;
            else if (i3 > r3) {
              const e3 = this.getClusters([i3, o3, 180, s3], t3), n4 = this.getClusters([-180, o3, r3, s3], t3);
              return e3.concat(n4);
            }
            const n3 = this.trees[this._limitZoom(t3)], a3 = n3.range(Z2(i3), G2(s3), Z2(r3), G2(o3)), l3 = n3.data, c3 = [];
            for (const e3 of a3) {
              const t4 = this.stride * e3;
              c3.push(l3[t4 + F2] > 1 ? E2(l3, t4, this.clusterProps) : this.points[l3[t4 + L2]]);
            }
            return c3;
          }
          getChildren(e2) {
            const t3 = this._getOriginId(e2), i3 = this._getOriginZoom(e2), o3 = "No cluster with the specified id.", r3 = this.trees[i3];
            if (!r3) throw new Error(o3);
            const s3 = r3.data;
            if (t3 * this.stride >= s3.length) throw new Error(o3);
            const n3 = this.options.radius / (this.options.extent * Math.pow(2, i3 - 1)), a3 = r3.within(s3[t3 * this.stride], s3[t3 * this.stride + 1], n3), l3 = [];
            for (const t4 of a3) {
              const i4 = t4 * this.stride;
              s3[i4 + 4] === e2 && l3.push(s3[i4 + F2] > 1 ? E2(s3, i4, this.clusterProps) : this.points[s3[i4 + L2]]);
            }
            if (0 === l3.length) throw new Error(o3);
            return l3;
          }
          getLeaves(e2, t3, i3) {
            const o3 = [];
            return this._appendLeaves(o3, e2, t3 = t3 || 10, i3 = i3 || 0, 0), o3;
          }
          getTile(e2, t3, i3) {
            const o3 = this.trees[this._limitZoom(e2)], r3 = Math.pow(2, e2), { extent: s3, radius: n3 } = this.options, a3 = n3 / s3, l3 = (i3 - a3) / r3, c3 = (i3 + 1 + a3) / r3, h3 = { features: [] };
            return this._addTileFeatures(o3.range((t3 - a3) / r3, l3, (t3 + 1 + a3) / r3, c3), o3.data, t3, i3, r3, h3), 0 === t3 && this._addTileFeatures(o3.range(1 - a3 / r3, l3, 1, c3), o3.data, r3, i3, r3, h3), t3 === r3 - 1 && this._addTileFeatures(o3.range(0, l3, a3 / r3, c3), o3.data, -1, i3, r3, h3), h3.features.length ? h3 : null;
          }
          getClusterExpansionZoom(e2) {
            let t3 = this._getOriginZoom(e2) - 1;
            for (; t3 <= this.options.maxZoom; ) {
              const i3 = this.getChildren(e2);
              if (t3++, 1 !== i3.length) break;
              e2 = i3[0].properties.cluster_id;
            }
            return t3;
          }
          _appendLeaves(e2, t3, i3, o3, r3) {
            const s3 = this.getChildren(t3);
            for (const t4 of s3) {
              const s4 = t4.properties;
              if (s4 && s4.cluster ? r3 + s4.point_count <= o3 ? r3 += s4.point_count : r3 = this._appendLeaves(e2, s4.cluster_id, i3, o3, r3) : r3 < o3 ? r3++ : e2.push(t4), e2.length === i3) break;
            }
            return r3;
          }
          _createTree(t3) {
            const i3 = new e.av(t3.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let e2 = 0; e2 < t3.length; e2 += this.stride) i3.add(t3[e2], t3[e2 + 1]);
            return i3.finish(), i3.data = t3, i3;
          }
          _addTileFeatures(e2, t3, i3, o3, r3, s3) {
            for (const n3 of e2) {
              const e3 = n3 * this.stride, a3 = t3[e3 + F2] > 1;
              let l3, c3, h3;
              if (a3) l3 = j2(t3, e3, this.clusterProps), c3 = t3[e3], h3 = t3[e3 + 1];
              else {
                const i4 = this.points[t3[e3 + L2]];
                l3 = i4.properties;
                const [o4, r4] = i4.geometry.coordinates;
                c3 = Z2(o4), h3 = G2(r4);
              }
              const u3 = { type: 1, geometry: [[Math.round(this.options.extent * (c3 * r3 - i3)), Math.round(this.options.extent * (h3 * r3 - o3))]], tags: l3 };
              let d3;
              d3 = a3 || this.options.generateId ? t3[e3 + L2] : this.points[t3[e3 + L2]].id, void 0 !== d3 && (u3.id = d3), s3.features.push(u3);
            }
          }
          _limitZoom(e2) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
          }
          _cluster(e2, t3) {
            const { radius: i3, extent: o3, reduce: r3, minPoints: s3 } = this.options, n3 = i3 / (o3 * Math.pow(2, t3)), a3 = e2.data, l3 = [], c3 = this.stride;
            for (let i4 = 0; i4 < a3.length; i4 += c3) {
              if (a3[i4 + 2] <= t3) continue;
              a3[i4 + 2] = t3;
              const o4 = a3[i4], h3 = a3[i4 + 1], u3 = e2.within(a3[i4], a3[i4 + 1], n3), d3 = a3[i4 + F2];
              let p3 = d3;
              for (const e3 of u3) {
                const i5 = e3 * c3;
                a3[i5 + 2] > t3 && (p3 += a3[i5 + F2]);
              }
              if (p3 > d3 && p3 >= s3) {
                let e3, s4 = o4 * d3, n4 = h3 * d3, f3 = -1;
                const g3 = ((i4 / c3 | 0) << 5) + (t3 + 1) + this.points.length;
                for (const o5 of u3) {
                  const l4 = o5 * c3;
                  if (a3[l4 + 2] <= t3) continue;
                  a3[l4 + 2] = t3;
                  const h4 = a3[l4 + F2];
                  s4 += a3[l4] * h4, n4 += a3[l4 + 1] * h4, a3[l4 + 4] = g3, r3 && (e3 || (e3 = this._map(a3, i4, true), f3 = this.clusterProps.length, this.clusterProps.push(e3)), r3(e3, this._map(a3, l4)));
                }
                a3[i4 + 4] = g3, l3.push(s4 / p3, n4 / p3, 1 / 0, g3, -1, p3), r3 && l3.push(f3);
              } else {
                for (let e3 = 0; e3 < c3; e3++) l3.push(a3[i4 + e3]);
                if (p3 > 1) for (const e3 of u3) {
                  const i5 = e3 * c3;
                  if (!(a3[i5 + 2] <= t3)) {
                    a3[i5 + 2] = t3;
                    for (let e4 = 0; e4 < c3; e4++) l3.push(a3[i5 + e4]);
                  }
                }
              }
            }
            return l3;
          }
          _getOriginId(e2) {
            return e2 - this.points.length >> 5;
          }
          _getOriginZoom(e2) {
            return (e2 - this.points.length) % 32;
          }
          _map(e2, t3, i3) {
            if (e2[t3 + F2] > 1) {
              const o4 = this.clusterProps[e2[t3 + z2]];
              return i3 ? Object.assign({}, o4) : o4;
            }
            const o3 = this.points[e2[t3 + L2]].properties, r3 = this.options.map(o3);
            return i3 && r3 === o3 ? Object.assign({}, r3) : r3;
          }
        }
        function E2(e2, t3, i3) {
          return { type: "Feature", id: e2[t3 + L2], properties: j2(e2, t3, i3), geometry: { type: "Point", coordinates: [(o3 = e2[t3], 360 * (o3 - 0.5)), J2(e2[t3 + 1])] } };
          var o3;
        }
        function j2(e2, t3, i3) {
          const o3 = e2[t3 + F2], r3 = o3 >= 1e4 ? `${Math.round(o3 / 1e3)}k` : o3 >= 1e3 ? Math.round(o3 / 100) / 10 + "k" : o3, s3 = e2[t3 + z2], n3 = -1 === s3 ? {} : Object.assign({}, i3[s3]);
          return Object.assign(n3, { cluster: true, cluster_id: e2[t3 + L2], point_count: o3, point_count_abbreviated: r3 });
        }
        function Z2(e2) {
          return e2 / 360 + 0.5;
        }
        function G2(e2) {
          const t3 = Math.sin(e2 * Math.PI / 180), i3 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
          return i3 < 0 ? 0 : i3 > 1 ? 1 : i3;
        }
        function J2(e2) {
          const t3 = (180 - 360 * e2) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t3)) / Math.PI - 90;
        }
        function Y2(e2, t3, i3, o3) {
          for (var r3, s3 = o3, n3 = i3 - t3 >> 1, a3 = i3 - t3, l3 = e2[t3], c3 = e2[t3 + 1], h3 = e2[i3], u3 = e2[i3 + 1], d3 = t3 + 3; d3 < i3; d3 += 3) {
            var p3 = A2(e2[d3], e2[d3 + 1], l3, c3, h3, u3);
            if (p3 > s3) r3 = d3, s3 = p3;
            else if (p3 === s3) {
              var f3 = Math.abs(d3 - n3);
              f3 < a3 && (r3 = d3, a3 = f3);
            }
          }
          s3 > o3 && (r3 - t3 > 3 && Y2(e2, t3, r3, o3), e2[r3 + 2] = s3, i3 - r3 > 3 && Y2(e2, r3, i3, o3));
        }
        function A2(e2, t3, i3, o3, r3, s3) {
          var n3 = r3 - i3, a3 = s3 - o3;
          if (0 !== n3 || 0 !== a3) {
            var l3 = ((e2 - i3) * n3 + (t3 - o3) * a3) / (n3 * n3 + a3 * a3);
            l3 > 1 ? (i3 = r3, o3 = s3) : l3 > 0 && (i3 += n3 * l3, o3 += a3 * l3);
          }
          return (n3 = e2 - i3) * n3 + (a3 = t3 - o3) * a3;
        }
        function V2(e2, t3, i3, o3) {
          var r3 = { id: void 0 === e2 ? null : e2, type: t3, geometry: i3, tags: o3, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e3) {
            var t4 = e3.geometry, i4 = e3.type;
            if ("Point" === i4 || "MultiPoint" === i4 || "LineString" === i4) B2(e3, t4);
            else if ("Polygon" === i4 || "MultiLineString" === i4) for (var o4 = 0; o4 < t4.length; o4++) B2(e3, t4[o4]);
            else if ("MultiPolygon" === i4) for (o4 = 0; o4 < t4.length; o4++) for (var r4 = 0; r4 < t4[o4].length; r4++) B2(e3, t4[o4][r4]);
          }(r3), r3;
        }
        function B2(e2, t3) {
          for (var i3 = 0; i3 < t3.length; i3 += 3) e2.minX = Math.min(e2.minX, t3[i3]), e2.minY = Math.min(e2.minY, t3[i3 + 1]), e2.maxX = Math.max(e2.maxX, t3[i3]), e2.maxY = Math.max(e2.maxY, t3[i3 + 1]);
        }
        function X2(e2, t3, i3, o3) {
          if (t3.geometry) {
            var r3 = t3.geometry.coordinates, s3 = t3.geometry.type, n3 = Math.pow(i3.tolerance / ((1 << i3.maxZoom) * i3.extent), 2), a3 = [], l3 = t3.id;
            if (i3.promoteId ? l3 = t3.properties[i3.promoteId] : i3.generateId && (l3 = o3 || 0), "Point" === s3) q2(r3, a3);
            else if ("MultiPoint" === s3) for (var c3 = 0; c3 < r3.length; c3++) q2(r3[c3], a3);
            else if ("LineString" === s3) R2(r3, a3, n3, false);
            else if ("MultiLineString" === s3) {
              if (i3.lineMetrics) {
                for (c3 = 0; c3 < r3.length; c3++) R2(r3[c3], a3 = [], n3, false), e2.push(V2(l3, "LineString", a3, t3.properties));
                return;
              }
              W2(r3, a3, n3, false);
            } else if ("Polygon" === s3) W2(r3, a3, n3, true);
            else {
              if ("MultiPolygon" !== s3) {
                if ("GeometryCollection" === s3) {
                  for (c3 = 0; c3 < t3.geometry.geometries.length; c3++) X2(e2, { id: l3, geometry: t3.geometry.geometries[c3], properties: t3.properties }, i3, o3);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (c3 = 0; c3 < r3.length; c3++) {
                var h3 = [];
                W2(r3[c3], h3, n3, true), a3.push(h3);
              }
            }
            e2.push(V2(l3, s3, a3, t3.properties));
          }
        }
        function q2(e2, t3) {
          t3.push($2(e2[0])), t3.push(U2(e2[1])), t3.push(0);
        }
        function R2(e2, t3, i3, o3) {
          for (var r3, s3, n3 = 0, a3 = 0; a3 < e2.length; a3++) {
            var l3 = $2(e2[a3][0]), c3 = U2(e2[a3][1]);
            t3.push(l3), t3.push(c3), t3.push(0), a3 > 0 && (n3 += o3 ? (r3 * c3 - l3 * s3) / 2 : Math.sqrt(Math.pow(l3 - r3, 2) + Math.pow(c3 - s3, 2))), r3 = l3, s3 = c3;
          }
          var h3 = t3.length - 3;
          t3[2] = 1, Y2(t3, 0, h3, i3), t3[h3 + 2] = 1, t3.size = Math.abs(n3), t3.start = 0, t3.end = t3.size;
        }
        function W2(e2, t3, i3, o3) {
          for (var r3 = 0; r3 < e2.length; r3++) {
            var s3 = [];
            R2(e2[r3], s3, i3, o3), t3.push(s3);
          }
        }
        function $2(e2) {
          return e2 / 360 + 0.5;
        }
        function U2(e2) {
          var t3 = Math.sin(e2 * Math.PI / 180), i3 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
          return i3 < 0 ? 0 : i3 > 1 ? 1 : i3;
        }
        function H2(e2, t3, i3, o3, r3, s3, n3, a3) {
          if (o3 /= t3, s3 >= (i3 /= t3) && n3 < o3) return e2;
          if (n3 < i3 || s3 >= o3) return null;
          for (var l3 = [], c3 = 0; c3 < e2.length; c3++) {
            var h3 = e2[c3], u3 = h3.geometry, d3 = h3.type, p3 = 0 === r3 ? h3.minX : h3.minY, f3 = 0 === r3 ? h3.maxX : h3.maxY;
            if (p3 >= i3 && f3 < o3) l3.push(h3);
            else if (!(f3 < i3 || p3 >= o3)) {
              var g3 = [];
              if ("Point" === d3 || "MultiPoint" === d3) K2(u3, g3, i3, o3, r3);
              else if ("LineString" === d3) Q2(u3, g3, i3, o3, r3, false, a3.lineMetrics);
              else if ("MultiLineString" === d3) te2(u3, g3, i3, o3, r3, false);
              else if ("Polygon" === d3) te2(u3, g3, i3, o3, r3, true);
              else if ("MultiPolygon" === d3) for (var m3 = 0; m3 < u3.length; m3++) {
                var y3 = [];
                te2(u3[m3], y3, i3, o3, r3, true), y3.length && g3.push(y3);
              }
              if (g3.length) {
                if (a3.lineMetrics && "LineString" === d3) {
                  for (m3 = 0; m3 < g3.length; m3++) l3.push(V2(h3.id, d3, g3[m3], h3.tags));
                  continue;
                }
                "LineString" !== d3 && "MultiLineString" !== d3 || (1 === g3.length ? (d3 = "LineString", g3 = g3[0]) : d3 = "MultiLineString"), "Point" !== d3 && "MultiPoint" !== d3 || (d3 = 3 === g3.length ? "Point" : "MultiPoint"), l3.push(V2(h3.id, d3, g3, h3.tags));
              }
            }
          }
          return l3.length ? l3 : null;
        }
        function K2(e2, t3, i3, o3, r3) {
          for (var s3 = 0; s3 < e2.length; s3 += 3) {
            var n3 = e2[s3 + r3];
            n3 >= i3 && n3 <= o3 && (t3.push(e2[s3]), t3.push(e2[s3 + 1]), t3.push(e2[s3 + 2]));
          }
        }
        function Q2(e2, t3, i3, o3, r3, s3, n3) {
          for (var a3, l3, c3 = ee2(e2), h3 = 0 === r3 ? oe2 : re2, u3 = e2.start, d3 = 0; d3 < e2.length - 3; d3 += 3) {
            var p3 = e2[d3], f3 = e2[d3 + 1], g3 = e2[d3 + 2], m3 = e2[d3 + 3], y3 = e2[d3 + 4], v3 = 0 === r3 ? p3 : f3, w3 = 0 === r3 ? m3 : y3, x3 = false;
            n3 && (a3 = Math.sqrt(Math.pow(p3 - m3, 2) + Math.pow(f3 - y3, 2))), v3 < i3 ? w3 > i3 && (l3 = h3(c3, p3, f3, m3, y3, i3), n3 && (c3.start = u3 + a3 * l3)) : v3 > o3 ? w3 < o3 && (l3 = h3(c3, p3, f3, m3, y3, o3), n3 && (c3.start = u3 + a3 * l3)) : ie2(c3, p3, f3, g3), w3 < i3 && v3 >= i3 && (l3 = h3(c3, p3, f3, m3, y3, i3), x3 = true), w3 > o3 && v3 <= o3 && (l3 = h3(c3, p3, f3, m3, y3, o3), x3 = true), !s3 && x3 && (n3 && (c3.end = u3 + a3 * l3), t3.push(c3), c3 = ee2(e2)), n3 && (u3 += a3);
          }
          var b3 = e2.length - 3;
          p3 = e2[b3], f3 = e2[b3 + 1], g3 = e2[b3 + 2], (v3 = 0 === r3 ? p3 : f3) >= i3 && v3 <= o3 && ie2(c3, p3, f3, g3), b3 = c3.length - 3, s3 && b3 >= 3 && (c3[b3] !== c3[0] || c3[b3 + 1] !== c3[1]) && ie2(c3, c3[0], c3[1], c3[2]), c3.length && t3.push(c3);
        }
        function ee2(e2) {
          var t3 = [];
          return t3.size = e2.size, t3.start = e2.start, t3.end = e2.end, t3;
        }
        function te2(e2, t3, i3, o3, r3, s3) {
          for (var n3 = 0; n3 < e2.length; n3++) Q2(e2[n3], t3, i3, o3, r3, s3, false);
        }
        function ie2(e2, t3, i3, o3) {
          e2.push(t3), e2.push(i3), e2.push(o3);
        }
        function oe2(e2, t3, i3, o3, r3, s3) {
          var n3 = (s3 - t3) / (o3 - t3);
          return e2.push(s3), e2.push(i3 + (r3 - i3) * n3), e2.push(1), n3;
        }
        function re2(e2, t3, i3, o3, r3, s3) {
          var n3 = (s3 - i3) / (r3 - i3);
          return e2.push(t3 + (o3 - t3) * n3), e2.push(s3), e2.push(1), n3;
        }
        function se2(e2, t3) {
          for (var i3 = [], o3 = 0; o3 < e2.length; o3++) {
            var r3, s3 = e2[o3], n3 = s3.type;
            if ("Point" === n3 || "MultiPoint" === n3 || "LineString" === n3) r3 = ne2(s3.geometry, t3);
            else if ("MultiLineString" === n3 || "Polygon" === n3) {
              r3 = [];
              for (var a3 = 0; a3 < s3.geometry.length; a3++) r3.push(ne2(s3.geometry[a3], t3));
            } else if ("MultiPolygon" === n3) for (r3 = [], a3 = 0; a3 < s3.geometry.length; a3++) {
              for (var l3 = [], c3 = 0; c3 < s3.geometry[a3].length; c3++) l3.push(ne2(s3.geometry[a3][c3], t3));
              r3.push(l3);
            }
            i3.push(V2(s3.id, n3, r3, s3.tags));
          }
          return i3;
        }
        function ne2(e2, t3) {
          var i3 = [];
          i3.size = e2.size, void 0 !== e2.start && (i3.start = e2.start, i3.end = e2.end);
          for (var o3 = 0; o3 < e2.length; o3 += 3) i3.push(e2[o3] + t3, e2[o3 + 1], e2[o3 + 2]);
          return i3;
        }
        function ae2(e2, t3) {
          if (e2.transformed) return e2;
          var i3, o3, r3, s3 = 1 << e2.z, n3 = e2.x, a3 = e2.y;
          for (i3 = 0; i3 < e2.features.length; i3++) {
            var l3 = e2.features[i3], c3 = l3.geometry, h3 = l3.type;
            if (l3.geometry = [], 1 === h3) for (o3 = 0; o3 < c3.length; o3 += 2) l3.geometry.push(le2(c3[o3], c3[o3 + 1], t3, s3, n3, a3));
            else for (o3 = 0; o3 < c3.length; o3++) {
              var u3 = [];
              for (r3 = 0; r3 < c3[o3].length; r3 += 2) u3.push(le2(c3[o3][r3], c3[o3][r3 + 1], t3, s3, n3, a3));
              l3.geometry.push(u3);
            }
          }
          return e2.transformed = true, e2;
        }
        function le2(e2, t3, i3, o3, r3, s3) {
          return [Math.round(i3 * (e2 * o3 - r3)), Math.round(i3 * (t3 * o3 - s3))];
        }
        function ce2(e2, t3, i3, o3, r3) {
          for (var s3 = t3 === r3.maxZoom ? 0 : r3.tolerance / ((1 << t3) * r3.extent), n3 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: i3, y: o3, z: t3, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a3 = 0; a3 < e2.length; a3++) {
            n3.numFeatures++, he2(n3, e2[a3], s3, r3);
            var l3 = e2[a3].minX, c3 = e2[a3].minY, h3 = e2[a3].maxX, u3 = e2[a3].maxY;
            l3 < n3.minX && (n3.minX = l3), c3 < n3.minY && (n3.minY = c3), h3 > n3.maxX && (n3.maxX = h3), u3 > n3.maxY && (n3.maxY = u3);
          }
          return n3;
        }
        function he2(e2, t3, i3, o3) {
          var r3 = t3.geometry, s3 = t3.type, n3 = [];
          if ("Point" === s3 || "MultiPoint" === s3) for (var a3 = 0; a3 < r3.length; a3 += 3) n3.push(r3[a3]), n3.push(r3[a3 + 1]), e2.numPoints++, e2.numSimplified++;
          else if ("LineString" === s3) ue2(n3, r3, e2, i3, false, false);
          else if ("MultiLineString" === s3 || "Polygon" === s3) for (a3 = 0; a3 < r3.length; a3++) ue2(n3, r3[a3], e2, i3, "Polygon" === s3, 0 === a3);
          else if ("MultiPolygon" === s3) for (var l3 = 0; l3 < r3.length; l3++) {
            var c3 = r3[l3];
            for (a3 = 0; a3 < c3.length; a3++) ue2(n3, c3[a3], e2, i3, true, 0 === a3);
          }
          if (n3.length) {
            var h3 = t3.tags || null;
            if ("LineString" === s3 && o3.lineMetrics) {
              for (var u3 in h3 = {}, t3.tags) h3[u3] = t3.tags[u3];
              h3.mapbox_clip_start = r3.start / r3.size, h3.mapbox_clip_end = r3.end / r3.size;
            }
            var d3 = { geometry: n3, type: "Polygon" === s3 || "MultiPolygon" === s3 ? 3 : "LineString" === s3 || "MultiLineString" === s3 ? 2 : 1, tags: h3 };
            null !== t3.id && (d3.id = t3.id), e2.features.push(d3);
          }
        }
        function ue2(e2, t3, i3, o3, r3, s3) {
          var n3 = o3 * o3;
          if (o3 > 0 && t3.size < (r3 ? n3 : o3)) i3.numPoints += t3.length / 3;
          else {
            for (var a3 = [], l3 = 0; l3 < t3.length; l3 += 3) (0 === o3 || t3[l3 + 2] > n3) && (i3.numSimplified++, a3.push(t3[l3]), a3.push(t3[l3 + 1])), i3.numPoints++;
            r3 && function(e3, t4) {
              for (var i4 = 0, o4 = 0, r4 = e3.length, s4 = r4 - 2; o4 < r4; s4 = o4, o4 += 2) i4 += (e3[o4] - e3[s4]) * (e3[o4 + 1] + e3[s4 + 1]);
              if (i4 > 0 === t4) for (o4 = 0, r4 = e3.length; o4 < r4 / 2; o4 += 2) {
                var n4 = e3[o4], a4 = e3[o4 + 1];
                e3[o4] = e3[r4 - 2 - o4], e3[o4 + 1] = e3[r4 - 1 - o4], e3[r4 - 2 - o4] = n4, e3[r4 - 1 - o4] = a4;
              }
            }(a3, s3), e2.push(a3);
          }
        }
        function de2(e2, t3) {
          var i3 = (t3 = this.options = function(e3, t4) {
            for (var i4 in t4) e3[i4] = t4[i4];
            return e3;
          }(Object.create(this.options), t3)).debug;
          if (i3 && console.time("preprocess data"), t3.maxZoom < 0 || t3.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
          if (t3.promoteId && t3.generateId) throw new Error("promoteId and generateId cannot be used together.");
          var o3 = function(e3, t4) {
            var i4 = [];
            if ("FeatureCollection" === e3.type) for (var o4 = 0; o4 < e3.features.length; o4++) X2(i4, e3.features[o4], t4, o4);
            else X2(i4, "Feature" === e3.type ? e3 : { geometry: e3 }, t4);
            return i4;
          }(e2, t3);
          this.tiles = {}, this.tileCoords = [], i3 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t3.indexMaxZoom, t3.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o3 = function(e3, t4) {
            var i4 = t4.buffer / t4.extent, o4 = e3, r3 = H2(e3, 1, -1 - i4, i4, 0, -1, 2, t4), s3 = H2(e3, 1, 1 - i4, 2 + i4, 0, -1, 2, t4);
            return (r3 || s3) && (o4 = H2(e3, 1, -i4, 1 + i4, 0, -1, 2, t4) || [], r3 && (o4 = se2(r3, 1).concat(o4)), s3 && (o4 = o4.concat(se2(s3, -1)))), o4;
          }(o3, t3), o3.length && this.splitTile(o3, 0, 0, 0), i3 && (o3.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function pe2(e2, t3, i3) {
          return 32 * ((1 << e2) * i3 + t3) + e2;
        }
        function fe2(e2, t3) {
          return t3 ? e2.properties[t3] : e2.id;
        }
        function ge2(e2, t3) {
          if (null == e2) return true;
          if ("Feature" === e2.type) return null != fe2(e2, t3);
          if ("FeatureCollection" === e2.type) {
            const i3 = /* @__PURE__ */ new Set();
            for (const o3 of e2.features) {
              const e3 = fe2(o3, t3);
              if (null == e3) return false;
              if (i3.has(e3)) return false;
              i3.add(e3);
            }
            return true;
          }
          return false;
        }
        function me2(e2, t3) {
          const i3 = /* @__PURE__ */ new Map();
          if (null == e2) ;
          else if ("Feature" === e2.type) i3.set(fe2(e2, t3), e2);
          else for (const o3 of e2.features) i3.set(fe2(o3, t3), o3);
          return i3;
        }
        de2.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, de2.prototype.splitTile = function(e2, t3, i3, o3, r3, s3, n3) {
          for (var a3 = [e2, t3, i3, o3], l3 = this.options, c3 = l3.debug; a3.length; ) {
            o3 = a3.pop(), i3 = a3.pop(), t3 = a3.pop(), e2 = a3.pop();
            var h3 = 1 << t3, u3 = pe2(t3, i3, o3), d3 = this.tiles[u3];
            if (!d3 && (c3 > 1 && console.time("creation"), d3 = this.tiles[u3] = ce2(e2, t3, i3, o3, l3), this.tileCoords.push({ z: t3, x: i3, y: o3 }), c3)) {
              c3 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t3, i3, o3, d3.numFeatures, d3.numPoints, d3.numSimplified), console.timeEnd("creation"));
              var p3 = "z" + t3;
              this.stats[p3] = (this.stats[p3] || 0) + 1, this.total++;
            }
            if (d3.source = e2, r3) {
              if (t3 === l3.maxZoom || t3 === r3) continue;
              var f3 = 1 << r3 - t3;
              if (i3 !== Math.floor(s3 / f3) || o3 !== Math.floor(n3 / f3)) continue;
            } else if (t3 === l3.indexMaxZoom || d3.numPoints <= l3.indexMaxPoints) continue;
            if (d3.source = null, 0 !== e2.length) {
              c3 > 1 && console.time("clipping");
              var g3, m3, y3, v3, w3, x3, b3 = 0.5 * l3.buffer / l3.extent, S3 = 0.5 - b3, M3 = 0.5 + b3, I3 = 1 + b3;
              g3 = m3 = y3 = v3 = null, w3 = H2(e2, h3, i3 - b3, i3 + M3, 0, d3.minX, d3.maxX, l3), x3 = H2(e2, h3, i3 + S3, i3 + I3, 0, d3.minX, d3.maxX, l3), e2 = null, w3 && (g3 = H2(w3, h3, o3 - b3, o3 + M3, 1, d3.minY, d3.maxY, l3), m3 = H2(w3, h3, o3 + S3, o3 + I3, 1, d3.minY, d3.maxY, l3), w3 = null), x3 && (y3 = H2(x3, h3, o3 - b3, o3 + M3, 1, d3.minY, d3.maxY, l3), v3 = H2(x3, h3, o3 + S3, o3 + I3, 1, d3.minY, d3.maxY, l3), x3 = null), c3 > 1 && console.timeEnd("clipping"), a3.push(g3 || [], t3 + 1, 2 * i3, 2 * o3), a3.push(m3 || [], t3 + 1, 2 * i3, 2 * o3 + 1), a3.push(y3 || [], t3 + 1, 2 * i3 + 1, 2 * o3), a3.push(v3 || [], t3 + 1, 2 * i3 + 1, 2 * o3 + 1);
            }
          }
        }, de2.prototype.getTile = function(e2, t3, i3) {
          var o3 = this.options, r3 = o3.extent, s3 = o3.debug;
          if (e2 < 0 || e2 > 24) return null;
          var n3 = 1 << e2, a3 = pe2(e2, t3 = (t3 % n3 + n3) % n3, i3);
          if (this.tiles[a3]) return ae2(this.tiles[a3], r3);
          s3 > 1 && console.log("drilling down to z%d-%d-%d", e2, t3, i3);
          for (var l3, c3 = e2, h3 = t3, u3 = i3; !l3 && c3 > 0; ) c3--, h3 = Math.floor(h3 / 2), u3 = Math.floor(u3 / 2), l3 = this.tiles[pe2(c3, h3, u3)];
          return l3 && l3.source ? (s3 > 1 && console.log("found parent tile z%d-%d-%d", c3, h3, u3), s3 > 1 && console.time("drilling down"), this.splitTile(l3.source, c3, h3, u3, e2, t3, i3), s3 > 1 && console.timeEnd("drilling down"), this.tiles[a3] ? ae2(this.tiles[a3], r3) : null) : null;
        };
        class ye2 extends n2 {
          constructor(t3, i3, o3, r3) {
            super(t3, i3, o3), this._dataUpdateable = /* @__PURE__ */ new Map(), this.loadGeoJSON = (t4, i4) => {
              const { promoteId: o4 } = t4;
              if (t4.request) return e.f(t4.request, (e2, t5, r4, s3) => {
                this._dataUpdateable = ge2(t5, o4) ? me2(t5, o4) : void 0, i4(e2, t5, r4, s3);
              });
              if ("string" == typeof t4.data) try {
                const e2 = JSON.parse(t4.data);
                this._dataUpdateable = ge2(e2, o4) ? me2(e2, o4) : void 0, i4(null, e2);
              } catch (e2) {
                i4(new Error(`Input data given to '${t4.source}' is not a valid GeoJSON object.`));
              }
              else t4.dataDiff ? this._dataUpdateable ? (function(e2, t5, i5) {
                var o5, r4, s3, n3;
                if (t5.removeAll && e2.clear(), t5.remove) for (const i6 of t5.remove) e2.delete(i6);
                if (t5.add) for (const o6 of t5.add) {
                  const t6 = fe2(o6, i5);
                  null != t6 && e2.set(t6, o6);
                }
                if (t5.update) for (const i6 of t5.update) {
                  let t6 = e2.get(i6.id);
                  if (null == t6) continue;
                  const a3 = !i6.removeAllProperties && ((null === (o5 = i6.removeProperties) || void 0 === o5 ? void 0 : o5.length) > 0 || (null === (r4 = i6.addOrUpdateProperties) || void 0 === r4 ? void 0 : r4.length) > 0);
                  if ((i6.newGeometry || i6.removeAllProperties || a3) && (t6 = Object.assign({}, t6), e2.set(i6.id, t6), a3 && (t6.properties = Object.assign({}, t6.properties))), i6.newGeometry && (t6.geometry = i6.newGeometry), i6.removeAllProperties) t6.properties = {};
                  else if ((null === (s3 = i6.removeProperties) || void 0 === s3 ? void 0 : s3.length) > 0) for (const e3 of i6.removeProperties) Object.prototype.hasOwnProperty.call(t6.properties, e3) && delete t6.properties[e3];
                  if ((null === (n3 = i6.addOrUpdateProperties) || void 0 === n3 ? void 0 : n3.length) > 0) for (const { key: e3, value: o6 } of i6.addOrUpdateProperties) t6.properties[e3] = o6;
                }
              }(this._dataUpdateable, t4.dataDiff, o4), i4(null, { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) })) : i4(new Error(`Cannot update existing geojson data in ${t4.source}`)) : i4(new Error(`Input data given to '${t4.source}' is not a valid GeoJSON object.`));
              return { cancel: () => {
              } };
            }, this.loadVectorData = this.loadGeoJSONTile, r3 && (this.loadGeoJSON = r3);
          }
          loadGeoJSONTile(t3, i3) {
            const o3 = t3.tileID.canonical;
            if (!this._geoJSONIndex) return i3(null, null);
            const r3 = this._geoJSONIndex.getTile(o3.z, o3.x, o3.y);
            if (!r3) return i3(null, null);
            const s3 = new class {
              constructor(t4) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.N, this.length = t4.length, this._features = t4;
              }
              feature(t4) {
                return new class {
                  constructor(t5) {
                    this._feature = t5, this.extent = e.N, this.type = t5.type, this.properties = t5.tags, "id" in t5 && !isNaN(t5.id) && (this.id = parseInt(t5.id, 10));
                  }
                  loadGeometry() {
                    if (1 === this._feature.type) {
                      const t5 = [];
                      for (const i4 of this._feature.geometry) t5.push([new e.P(i4[0], i4[1])]);
                      return t5;
                    }
                    {
                      const t5 = [];
                      for (const i4 of this._feature.geometry) {
                        const o4 = [];
                        for (const t6 of i4) o4.push(new e.P(t6[0], t6[1]));
                        t5.push(o4);
                      }
                      return t5;
                    }
                  }
                  toGeoJSON(e2, t5, i4) {
                    return u2.call(this, e2, t5, i4);
                  }
                }(this._features[t4]);
              }
            }(r3.features);
            let n3 = k2(s3);
            0 === n3.byteOffset && n3.byteLength === n3.buffer.byteLength || (n3 = new Uint8Array(n3)), i3(null, { vectorTile: s3, rawData: n3.buffer });
          }
          loadData(t3, i3) {
            var o3;
            null === (o3 = this._pendingRequest) || void 0 === o3 || o3.cancel(), this._pendingCallback && this._pendingCallback(null, { abandoned: true });
            const r3 = !!(t3 && t3.request && t3.request.collectResourceTiming) && new e.bu(t3.request);
            this._pendingCallback = i3, this._pendingRequest = this.loadGeoJSON(t3, (o4, s3) => {
              if (delete this._pendingCallback, delete this._pendingRequest, o4 || !s3) return i3(o4);
              if ("object" != typeof s3) return i3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
              {
                h2(s3, true);
                try {
                  if (t3.filter) {
                    const i4 = e.bC(t3.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                    if ("error" === i4.result) throw new Error(i4.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                    const o5 = s3.features.filter((e2) => i4.value.evaluate({ zoom: 0 }, e2));
                    s3 = { type: "FeatureCollection", features: o5 };
                  }
                  this._geoJSONIndex = t3.cluster ? new N2(function({ superclusterOptions: t4, clusterProperties: i4 }) {
                    if (!i4 || !t4) return t4;
                    const o5 = {}, r4 = {}, s4 = { accumulated: null, zoom: 0 }, n4 = { properties: null }, a3 = Object.keys(i4);
                    for (const t5 of a3) {
                      const [s5, n5] = i4[t5], a4 = e.bC(n5), l3 = e.bC("string" == typeof s5 ? [s5, ["accumulated"], ["get", t5]] : s5);
                      o5[t5] = a4.value, r4[t5] = l3.value;
                    }
                    return t4.map = (e2) => {
                      n4.properties = e2;
                      const t5 = {};
                      for (const e3 of a3) t5[e3] = o5[e3].evaluate(s4, n4);
                      return t5;
                    }, t4.reduce = (e2, t5) => {
                      n4.properties = t5;
                      for (const t6 of a3) s4.accumulated = e2[t6], e2[t6] = r4[t6].evaluate(s4, n4);
                    }, t4;
                  }(t3)).load(s3.features) : function(e2, t4) {
                    return new de2(e2, t4);
                  }(s3, t3.geojsonVtOptions);
                } catch (o5) {
                  return i3(o5);
                }
                this.loaded = {};
                const n3 = {};
                if (r3) {
                  const e2 = r3.finish();
                  e2 && (n3.resourceTiming = {}, n3.resourceTiming[t3.source] = JSON.parse(JSON.stringify(e2)));
                }
                i3(null, n3);
              }
            });
          }
          reloadTile(e2, t3) {
            const i3 = this.loaded;
            return i3 && i3[e2.uid] ? super.reloadTile(e2, t3) : this.loadTile(e2, t3);
          }
          removeSource(e2, t3) {
            this._pendingCallback && this._pendingCallback(null, { abandoned: true }), t3();
          }
          getClusterExpansionZoom(e2, t3) {
            try {
              t3(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
            } catch (e3) {
              t3(e3);
            }
          }
          getClusterChildren(e2, t3) {
            try {
              t3(null, this._geoJSONIndex.getChildren(e2.clusterId));
            } catch (e3) {
              t3(e3);
            }
          }
          getClusterLeaves(e2, t3) {
            try {
              t3(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
            } catch (e3) {
              t3(e3);
            }
          }
        }
        class ve2 {
          constructor(t3) {
            this.self = t3, this.actor = new e.C(t3, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: n2, geojson: ye2 }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e2, t4) => {
              if (this.workerSourceTypes[e2]) throw new Error(`Worker source with name "${e2}" already registered.`);
              this.workerSourceTypes[e2] = t4;
            }, this.self.registerRTLTextPlugin = (t4) => {
              if (e.bD.isParsed()) throw new Error("RTL text plugin already registered.");
              e.bD.applyArabicShaping = t4.applyArabicShaping, e.bD.processBidirectionalText = t4.processBidirectionalText, e.bD.processStyledBidirectionalText = t4.processStyledBidirectionalText;
            };
          }
          setReferrer(e2, t3) {
            this.referrer = t3;
          }
          setImages(e2, t3, i3) {
            this.availableImages[e2] = t3;
            for (const i4 in this.workerSources[e2]) {
              const o3 = this.workerSources[e2][i4];
              for (const e3 in o3) o3[e3].availableImages = t3;
            }
            i3();
          }
          setLayers(e2, t3, i3) {
            this.getLayerIndex(e2).replace(t3), i3();
          }
          updateLayers(e2, t3, i3) {
            this.getLayerIndex(e2).update(t3.layers, t3.removedIds), i3();
          }
          loadTile(e2, t3, i3) {
            this.getWorkerSource(e2, t3.type, t3.source).loadTile(t3, i3);
          }
          loadDEMTile(e2, t3, i3) {
            this.getDEMWorkerSource(e2, t3.source).loadTile(t3, i3);
          }
          reloadTile(e2, t3, i3) {
            this.getWorkerSource(e2, t3.type, t3.source).reloadTile(t3, i3);
          }
          abortTile(e2, t3, i3) {
            this.getWorkerSource(e2, t3.type, t3.source).abortTile(t3, i3);
          }
          removeTile(e2, t3, i3) {
            this.getWorkerSource(e2, t3.type, t3.source).removeTile(t3, i3);
          }
          removeDEMTile(e2, t3) {
            this.getDEMWorkerSource(e2, t3.source).removeTile(t3);
          }
          removeSource(e2, t3, i3) {
            if (!this.workerSources[e2] || !this.workerSources[e2][t3.type] || !this.workerSources[e2][t3.type][t3.source]) return;
            const o3 = this.workerSources[e2][t3.type][t3.source];
            delete this.workerSources[e2][t3.type][t3.source], void 0 !== o3.removeSource ? o3.removeSource(t3, i3) : i3();
          }
          loadWorkerSource(e2, t3, i3) {
            try {
              this.self.importScripts(t3.url), i3();
            } catch (e3) {
              i3(e3.toString());
            }
          }
          syncRTLPluginState(t3, i3, o3) {
            try {
              e.bD.setState(i3);
              const t4 = e.bD.getPluginURL();
              if (e.bD.isLoaded() && !e.bD.isParsed() && null != t4) {
                this.self.importScripts(t4);
                const i4 = e.bD.isParsed();
                o3(i4 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t4}`), i4);
              }
            } catch (e2) {
              o3(e2.toString());
            }
          }
          getAvailableImages(e2) {
            let t3 = this.availableImages[e2];
            return t3 || (t3 = []), t3;
          }
          getLayerIndex(e2) {
            let i3 = this.layerIndexes[e2];
            return i3 || (i3 = this.layerIndexes[e2] = new t2()), i3;
          }
          getWorkerSource(e2, t3, i3) {
            return this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t3] || (this.workerSources[e2][t3] = {}), this.workerSources[e2][t3][i3] || (this.workerSources[e2][t3][i3] = new this.workerSourceTypes[t3]({ send: (t4, i4, o3) => {
              this.actor.send(t4, i4, o3, e2);
            } }, this.getLayerIndex(e2), this.getAvailableImages(e2))), this.workerSources[e2][t3][i3];
          }
          getDEMWorkerSource(e2, t3) {
            return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t3] || (this.demWorkerSources[e2][t3] = new a2()), this.demWorkerSources[e2][t3];
          }
        }
        return e.i() && (self.worker = new ve2(self)), ve2;
      });
      define(["./shared"], function(t2) {
        var e = "3.6.2";
        class i2 {
          static testProp(t3) {
            if (!i2.docStyle) return t3[0];
            for (let e2 = 0; e2 < t3.length; e2++) if (t3[e2] in i2.docStyle) return t3[e2];
            return t3[0];
          }
          static create(t3, e2, i3) {
            const s3 = window.document.createElement(t3);
            return void 0 !== e2 && (s3.className = e2), i3 && i3.appendChild(s3), s3;
          }
          static createNS(t3, e2) {
            return window.document.createElementNS(t3, e2);
          }
          static disableDrag() {
            i2.docStyle && i2.selectProp && (i2.userSelect = i2.docStyle[i2.selectProp], i2.docStyle[i2.selectProp] = "none");
          }
          static enableDrag() {
            i2.docStyle && i2.selectProp && (i2.docStyle[i2.selectProp] = i2.userSelect);
          }
          static setTransform(t3, e2) {
            t3.style[i2.transformProp] = e2;
          }
          static addEventListener(t3, e2, i3, s3 = {}) {
            t3.addEventListener(e2, i3, "passive" in s3 ? s3 : s3.capture);
          }
          static removeEventListener(t3, e2, i3, s3 = {}) {
            t3.removeEventListener(e2, i3, "passive" in s3 ? s3 : s3.capture);
          }
          static suppressClickInternal(t3) {
            t3.preventDefault(), t3.stopPropagation(), window.removeEventListener("click", i2.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", i2.suppressClickInternal, true), window.setTimeout(() => {
              window.removeEventListener("click", i2.suppressClickInternal, true);
            }, 0);
          }
          static mousePos(e2, i3) {
            const s3 = e2.getBoundingClientRect();
            return new t2.P(i3.clientX - s3.left - e2.clientLeft, i3.clientY - s3.top - e2.clientTop);
          }
          static touchPos(e2, i3) {
            const s3 = e2.getBoundingClientRect(), a3 = [];
            for (let o3 = 0; o3 < i3.length; o3++) a3.push(new t2.P(i3[o3].clientX - s3.left - e2.clientLeft, i3[o3].clientY - s3.top - e2.clientTop));
            return a3;
          }
          static mouseButton(t3) {
            return t3.button;
          }
          static remove(t3) {
            t3.parentNode && t3.parentNode.removeChild(t3);
          }
        }
        i2.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, i2.selectProp = i2.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), i2.transformProp = i2.testProp(["transform", "WebkitTransform"]);
        const s2 = { supported: false, testSupport: function(t3) {
          !r2 && o2 && (n2 ? l2(t3) : a2 = t3);
        } };
        let a2, o2, r2 = false, n2 = false;
        function l2(t3) {
          const e2 = t3.createTexture();
          t3.bindTexture(t3.TEXTURE_2D, e2);
          try {
            if (t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE, o2), t3.isContextLost()) return;
            s2.supported = true;
          } catch (t4) {
          }
          t3.deleteTexture(e2), r2 = true;
        }
        var h2, c2;
        "undefined" != typeof document && (o2 = document.createElement("img"), o2.onload = function() {
          a2 && l2(a2), a2 = null, n2 = true;
        }, o2.onerror = function() {
          r2 = true, a2 = null;
        }, o2.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e2) {
          let i3, a3, o3, r3;
          e2.resetRequestQueue = () => {
            i3 = [], a3 = 0, o3 = 0, r3 = {};
          }, e2.addThrottleControl = (t3) => {
            const e3 = o3++;
            return r3[e3] = t3, e3;
          }, e2.removeThrottleControl = (t3) => {
            delete r3[t3], h3();
          }, e2.getImage = (t3, e3, o4 = true) => {
            s2.supported && (t3.headers || (t3.headers = {}), t3.headers.accept = "image/webp,*/*");
            const r4 = { requestParameters: t3, supportImageRefresh: o4, callback: e3, cancelled: false, completed: false, cancel: () => {
              r4.completed || r4.cancelled || (r4.cancelled = true, r4.innerRequest && (r4.innerRequest.cancel(), a3--), h3());
            } };
            return i3.push(r4), h3(), r4;
          };
          const n3 = (e3) => {
            const { requestParameters: i4, supportImageRefresh: s3, callback: a4 } = e3;
            return t2.e(i4, { type: "image" }), (false !== s3 || t2.i() || t2.g(i4.url) || i4.headers && !Object.keys(i4.headers).reduce((t3, e4) => t3 && "accept" === e4, true) ? t2.m : c3)(i4, (t3, i5, s4, o4) => {
              l3(e3, a4, t3, i5, s4, o4);
            });
          }, l3 = (e3, i4, s3, o4, r4, n4) => {
            s3 ? i4(s3) : o4 instanceof HTMLImageElement || t2.a(o4) ? i4(null, o4) : o4 && ((e4, i5) => {
              "function" == typeof createImageBitmap ? t2.b(e4, i5) : t2.d(e4, i5);
            })(o4, (t3, e4) => {
              null != t3 ? i4(t3) : null != e4 && i4(null, e4, { cacheControl: r4, expires: n4 });
            }), e3.cancelled || (e3.completed = true, a3--, h3());
          }, h3 = () => {
            const e3 = (() => {
              const t3 = Object.keys(r3);
              let e4 = false;
              if (t3.length > 0) {
                for (const i4 of t3) if (e4 = r3[i4](), e4) break;
              }
              return e4;
            })() ? t2.c.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t2.c.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let t3 = a3; t3 < e3 && i3.length > 0; t3++) {
              const e4 = i3.shift();
              if (e4.cancelled) {
                t3--;
                continue;
              }
              const s3 = n3(e4);
              a3++, e4.innerRequest = s3;
            }
          }, c3 = (e3, i4) => {
            const s3 = new Image(), a4 = e3.url;
            let o4 = false;
            const r4 = e3.credentials;
            return r4 && "include" === r4 ? s3.crossOrigin = "use-credentials" : (r4 && "same-origin" === r4 || !t2.s(a4)) && (s3.crossOrigin = "anonymous"), s3.fetchPriority = "high", s3.onload = () => {
              i4(null, s3), s3.onerror = s3.onload = null;
            }, s3.onerror = () => {
              o4 || i4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")), s3.onerror = s3.onload = null;
            }, s3.src = a4, { cancel: () => {
              o4 = true, s3.src = "";
            } };
          };
        }(h2 || (h2 = {})), h2.resetRequestQueue(), function(t3) {
          t3.Glyphs = "Glyphs", t3.Image = "Image", t3.Source = "Source", t3.SpriteImage = "SpriteImage", t3.SpriteJSON = "SpriteJSON", t3.Style = "Style", t3.Tile = "Tile", t3.Unknown = "Unknown";
        }(c2 || (c2 = {}));
        class u2 {
          constructor(t3) {
            this._transformRequestFn = t3;
          }
          transformRequest(t3, e2) {
            return this._transformRequestFn && this._transformRequestFn(t3, e2) || { url: t3 };
          }
          normalizeSpriteURL(t3, e2, i3) {
            const s3 = function(t4) {
              const e3 = t4.match(d2);
              if (!e3) throw new Error(`Unable to parse URL "${t4}"`);
              return { protocol: e3[1], authority: e3[2], path: e3[3] || "/", params: e3[4] ? e3[4].split("&") : [] };
            }(t3);
            return s3.path += `${e2}${i3}`, function(t4) {
              const e3 = t4.params.length ? `?${t4.params.join("&")}` : "";
              return `${t4.protocol}://${t4.authority}${t4.path}${e3}`;
            }(s3);
          }
          setTransformRequest(t3) {
            this._transformRequestFn = t3;
          }
        }
        const d2 = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function _2(e2) {
          var i3 = new t2.A(3);
          return i3[0] = e2[0], i3[1] = e2[1], i3[2] = e2[2], i3;
        }
        var p2, m2 = function(t3, e2, i3) {
          return t3[0] = e2[0] - i3[0], t3[1] = e2[1] - i3[1], t3[2] = e2[2] - i3[2], t3;
        };
        p2 = new t2.A(3), t2.A != Float32Array && (p2[0] = 0, p2[1] = 0, p2[2] = 0);
        var f2 = function(t3) {
          var e2 = t3[0], i3 = t3[1];
          return e2 * e2 + i3 * i3;
        };
        function g2(t3) {
          const e2 = [];
          if ("string" == typeof t3) e2.push({ id: "default", url: t3 });
          else if (t3 && t3.length > 0) {
            const i3 = [];
            for (const { id: s3, url: a3 } of t3) {
              const t4 = `${s3}${a3}`;
              -1 === i3.indexOf(t4) && (i3.push(t4), e2.push({ id: s3, url: a3 }));
            }
          }
          return e2;
        }
        function v2(e2, i3, s3, a3, o3) {
          if (a3) return void e2(a3);
          if (o3 !== Object.values(i3).length || o3 !== Object.values(s3).length) return;
          const r3 = {};
          for (const e3 in i3) {
            r3[e3] = {};
            const a4 = t2.h.getImageCanvasContext(s3[e3]), o4 = i3[e3];
            for (const t3 in o4) {
              const { width: i4, height: s4, x: n3, y: l3, sdf: h3, pixelRatio: c3, stretchX: u3, stretchY: d3, content: _3 } = o4[t3];
              r3[e3][t3] = { data: null, pixelRatio: c3, sdf: h3, stretchX: u3, stretchY: d3, content: _3, spriteData: { width: i4, height: s4, x: n3, y: l3, context: a4 } };
            }
          }
          e2(null, r3);
        }
        !function() {
          var e2 = new t2.A(2);
          t2.A != Float32Array && (e2[0] = 0, e2[1] = 0);
        }();
        class x2 {
          constructor(t3, e2, i3, s3) {
            this.context = t3, this.format = i3, this.texture = t3.gl.createTexture(), this.update(e2, s3);
          }
          update(e2, i3, s3) {
            const { width: a3, height: o3 } = e2, r3 = !(this.size && this.size[0] === a3 && this.size[1] === o3 || s3), { context: n3 } = this, { gl: l3 } = n3;
            if (this.useMipmap = Boolean(i3 && i3.useMipmap), l3.bindTexture(l3.TEXTURE_2D, this.texture), n3.pixelStoreUnpackFlipY.set(false), n3.pixelStoreUnpack.set(1), n3.pixelStoreUnpackPremultiplyAlpha.set(this.format === l3.RGBA && (!i3 || false !== i3.premultiply)), r3) this.size = [a3, o3], e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t2.a(e2) ? l3.texImage2D(l3.TEXTURE_2D, 0, this.format, this.format, l3.UNSIGNED_BYTE, e2) : l3.texImage2D(l3.TEXTURE_2D, 0, this.format, a3, o3, 0, this.format, l3.UNSIGNED_BYTE, e2.data);
            else {
              const { x: i4, y: r4 } = s3 || { x: 0, y: 0 };
              e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t2.a(e2) ? l3.texSubImage2D(l3.TEXTURE_2D, 0, i4, r4, l3.RGBA, l3.UNSIGNED_BYTE, e2) : l3.texSubImage2D(l3.TEXTURE_2D, 0, i4, r4, a3, o3, l3.RGBA, l3.UNSIGNED_BYTE, e2.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && l3.generateMipmap(l3.TEXTURE_2D);
          }
          bind(t3, e2, i3) {
            const { context: s3 } = this, { gl: a3 } = s3;
            a3.bindTexture(a3.TEXTURE_2D, this.texture), i3 !== a3.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i3 = a3.LINEAR), t3 !== this.filter && (a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_MAG_FILTER, t3), a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_MIN_FILTER, i3 || t3), this.filter = t3), e2 !== this.wrap && (a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_WRAP_S, e2), a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_WRAP_T, e2), this.wrap = e2);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t3 } = this.context;
            t3.deleteTexture(this.texture), this.texture = null;
          }
        }
        function y2(t3) {
          const { userImage: e2 } = t3;
          return !!(e2 && e2.render && e2.render()) && (t3.data.replace(new Uint8Array(e2.data.buffer)), true);
        }
        class b2 extends t2.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t2.R({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(t3) {
            if (this.loaded !== t3 && (this.loaded = t3, t3)) {
              for (const { ids: t4, callback: e2 } of this.requestors) this._notify(t4, e2);
              this.requestors = [];
            }
          }
          getImage(e2) {
            const i3 = this.images[e2];
            if (i3 && !i3.data && i3.spriteData) {
              const e3 = i3.spriteData;
              i3.data = new t2.R({ width: e3.width, height: e3.height }, e3.context.getImageData(e3.x, e3.y, e3.width, e3.height).data), i3.spriteData = null;
            }
            return i3;
          }
          addImage(t3, e2) {
            if (this.images[t3]) throw new Error(`Image id ${t3} already exist, use updateImage instead`);
            this._validate(t3, e2) && (this.images[t3] = e2);
          }
          _validate(e2, i3) {
            let s3 = true;
            const a3 = i3.data || i3.spriteData;
            return this._validateStretch(i3.stretchX, a3 && a3.width) || (this.fire(new t2.j(new Error(`Image "${e2}" has invalid "stretchX" value`))), s3 = false), this._validateStretch(i3.stretchY, a3 && a3.height) || (this.fire(new t2.j(new Error(`Image "${e2}" has invalid "stretchY" value`))), s3 = false), this._validateContent(i3.content, i3) || (this.fire(new t2.j(new Error(`Image "${e2}" has invalid "content" value`))), s3 = false), s3;
          }
          _validateStretch(t3, e2) {
            if (!t3) return true;
            let i3 = 0;
            for (const s3 of t3) {
              if (s3[0] < i3 || s3[1] < s3[0] || e2 < s3[1]) return false;
              i3 = s3[1];
            }
            return true;
          }
          _validateContent(t3, e2) {
            if (!t3) return true;
            if (4 !== t3.length) return false;
            const i3 = e2.spriteData, s3 = i3 && i3.width || e2.data.width, a3 = i3 && i3.height || e2.data.height;
            return !(t3[0] < 0 || s3 < t3[0] || t3[1] < 0 || a3 < t3[1] || t3[2] < 0 || s3 < t3[2] || t3[3] < 0 || a3 < t3[3] || t3[2] < t3[0] || t3[3] < t3[1]);
          }
          updateImage(t3, e2, i3 = true) {
            const s3 = this.getImage(t3);
            if (i3 && (s3.data.width !== e2.data.width || s3.data.height !== e2.data.height)) throw new Error(`size mismatch between old image (${s3.data.width}x${s3.data.height}) and new image (${e2.data.width}x${e2.data.height}).`);
            e2.version = s3.version + 1, this.images[t3] = e2, this.updatedImages[t3] = true;
          }
          removeImage(t3) {
            const e2 = this.images[t3];
            delete this.images[t3], delete this.patterns[t3], e2.userImage && e2.userImage.onRemove && e2.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(t3, e2) {
            let i3 = true;
            if (!this.isLoaded()) for (const e3 of t3) this.images[e3] || (i3 = false);
            this.isLoaded() || i3 ? this._notify(t3, e2) : this.requestors.push({ ids: t3, callback: e2 });
          }
          _notify(e2, i3) {
            const s3 = {};
            for (const i4 of e2) {
              let e3 = this.getImage(i4);
              e3 || (this.fire(new t2.k("styleimagemissing", { id: i4 })), e3 = this.getImage(i4)), e3 ? s3[i4] = { data: e3.data.clone(), pixelRatio: e3.pixelRatio, sdf: e3.sdf, version: e3.version, stretchX: e3.stretchX, stretchY: e3.stretchY, content: e3.content, hasRenderCallback: Boolean(e3.userImage && e3.userImage.render) } : t2.w(`Image "${i4}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            i3(null, s3);
          }
          getPixelSize() {
            const { width: t3, height: e2 } = this.atlasImage;
            return { width: t3, height: e2 };
          }
          getPattern(e2) {
            const i3 = this.patterns[e2], s3 = this.getImage(e2);
            if (!s3) return null;
            if (i3 && i3.position.version === s3.version) return i3.position;
            if (i3) i3.position.version = s3.version;
            else {
              const i4 = { w: s3.data.width + 2, h: s3.data.height + 2, x: 0, y: 0 }, a3 = new t2.I(i4, s3);
              this.patterns[e2] = { bin: i4, position: a3 };
            }
            return this._updatePatternAtlas(), this.patterns[e2].position;
          }
          bind(t3) {
            const e2 = t3.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new x2(t3, this.atlasImage, e2.RGBA), this.atlasTexture.bind(e2.LINEAR, e2.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e2 = [];
            for (const t3 in this.patterns) e2.push(this.patterns[t3].bin);
            const { w: i3, h: s3 } = t2.p(e2), a3 = this.atlasImage;
            a3.resize({ width: i3 || 1, height: s3 || 1 });
            for (const e3 in this.patterns) {
              const { bin: i4 } = this.patterns[e3], s4 = i4.x + 1, o3 = i4.y + 1, r3 = this.getImage(e3).data, n3 = r3.width, l3 = r3.height;
              t2.R.copy(r3, a3, { x: 0, y: 0 }, { x: s4, y: o3 }, { width: n3, height: l3 }), t2.R.copy(r3, a3, { x: 0, y: l3 - 1 }, { x: s4, y: o3 - 1 }, { width: n3, height: 1 }), t2.R.copy(r3, a3, { x: 0, y: 0 }, { x: s4, y: o3 + l3 }, { width: n3, height: 1 }), t2.R.copy(r3, a3, { x: n3 - 1, y: 0 }, { x: s4 - 1, y: o3 }, { width: 1, height: l3 }), t2.R.copy(r3, a3, { x: 0, y: 0 }, { x: s4 + n3, y: o3 }, { width: 1, height: l3 });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e2) {
            for (const i3 of e2) {
              if (this.callbackDispatchedThisFrame[i3]) continue;
              this.callbackDispatchedThisFrame[i3] = true;
              const e3 = this.getImage(i3);
              e3 || t2.w(`Image with ID: "${i3}" was not found`), y2(e3) && this.updateImage(i3, e3);
            }
          }
        }
        const w2 = 1e20;
        function T2(t3, e2, i3, s3, a3, o3, r3, n3, l3) {
          for (let h3 = e2; h3 < e2 + s3; h3++) I2(t3, i3 * o3 + h3, o3, a3, r3, n3, l3);
          for (let h3 = i3; h3 < i3 + a3; h3++) I2(t3, h3 * o3 + e2, 1, s3, r3, n3, l3);
        }
        function I2(t3, e2, i3, s3, a3, o3, r3) {
          o3[0] = 0, r3[0] = -1e20, r3[1] = w2, a3[0] = t3[e2];
          for (let n3 = 1, l3 = 0, h3 = 0; n3 < s3; n3++) {
            a3[n3] = t3[e2 + n3 * i3];
            const s4 = n3 * n3;
            do {
              const t4 = o3[l3];
              h3 = (a3[n3] - a3[t4] + s4 - t4 * t4) / (n3 - t4) / 2;
            } while (h3 <= r3[l3] && --l3 > -1);
            l3++, o3[l3] = n3, r3[l3] = h3, r3[l3 + 1] = w2;
          }
          for (let n3 = 0, l3 = 0; n3 < s3; n3++) {
            for (; r3[l3 + 1] < n3; ) l3++;
            const s4 = o3[l3], h3 = n3 - s4;
            t3[e2 + n3 * i3] = a3[s4] + h3 * h3;
          }
        }
        class E2 {
          constructor(t3, e2) {
            this.requestManager = t3, this.localIdeographFontFamily = e2, this.entries = {};
          }
          setURL(t3) {
            this.url = t3;
          }
          getGlyphs(e2, i3) {
            const s3 = [];
            for (const t3 in e2) for (const i4 of e2[t3]) s3.push({ stack: t3, id: i4 });
            t2.o(s3, ({ stack: t3, id: e3 }, i4) => {
              let s4 = this.entries[t3];
              s4 || (s4 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {} });
              let a3 = s4.glyphs[e3];
              if (void 0 !== a3) return void i4(null, { stack: t3, id: e3, glyph: a3 });
              if (a3 = this._tinySDF(s4, t3, e3), a3) return s4.glyphs[e3] = a3, void i4(null, { stack: t3, id: e3, glyph: a3 });
              const o3 = Math.floor(e3 / 256);
              if (256 * o3 > 65535) return void i4(new Error("glyphs > 65535 not supported"));
              if (s4.ranges[o3]) return void i4(null, { stack: t3, id: e3, glyph: a3 });
              if (!this.url) return void i4(new Error("glyphsUrl is not set"));
              let r3 = s4.requests[o3];
              r3 || (r3 = s4.requests[o3] = [], E2.loadGlyphRange(t3, o3, this.url, this.requestManager, (t4, e4) => {
                if (e4) {
                  for (const t5 in e4) this._doesCharSupportLocalGlyph(+t5) || (s4.glyphs[+t5] = e4[+t5]);
                  s4.ranges[o3] = true;
                }
                for (const i5 of r3) i5(t4, e4);
                delete s4.requests[o3];
              })), r3.push((s5, a4) => {
                s5 ? i4(s5) : a4 && i4(null, { stack: t3, id: e3, glyph: a4[e3] || null });
              });
            }, (t3, e3) => {
              if (t3) i3(t3);
              else if (e3) {
                const t4 = {};
                for (const { stack: i4, id: s4, glyph: a3 } of e3) (t4[i4] || (t4[i4] = {}))[s4] = a3 && { id: a3.id, bitmap: a3.bitmap.clone(), metrics: a3.metrics };
                i3(null, t4);
              }
            });
          }
          _doesCharSupportLocalGlyph(e2) {
            return !!this.localIdeographFontFamily && (t2.u["CJK Unified Ideographs"](e2) || t2.u["Hangul Syllables"](e2) || t2.u.Hiragana(e2) || t2.u.Katakana(e2));
          }
          _tinySDF(e2, i3, s3) {
            const a3 = this.localIdeographFontFamily;
            if (!a3) return;
            if (!this._doesCharSupportLocalGlyph(s3)) return;
            let o3 = e2.tinySDF;
            if (!o3) {
              let t3 = "400";
              /bold/i.test(i3) ? t3 = "900" : /medium/i.test(i3) ? t3 = "500" : /light/i.test(i3) && (t3 = "200"), o3 = e2.tinySDF = new E2.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: a3, fontWeight: t3 });
            }
            const r3 = o3.draw(String.fromCharCode(s3));
            return { id: s3, bitmap: new t2.q({ width: r3.width || 60, height: r3.height || 60 }, r3.data), metrics: { width: r3.glyphWidth / 2 || 24, height: r3.glyphHeight / 2 || 24, left: r3.glyphLeft / 2 + 0.5 || 0, top: r3.glyphTop / 2 - 27.5 || -8, advance: r3.glyphAdvance / 2 || 24, isDoubleResolution: true } };
          }
        }
        E2.loadGlyphRange = function(e2, i3, s3, a3, o3) {
          const r3 = 256 * i3, n3 = r3 + 255, l3 = a3.transformRequest(s3.replace("{fontstack}", e2).replace("{range}", `${r3}-${n3}`), c2.Glyphs);
          t2.l(l3, (e3, i4) => {
            if (e3) o3(e3);
            else if (i4) {
              const e4 = {};
              for (const s4 of t2.n(i4)) e4[s4.id] = s4;
              o3(null, e4);
            }
          });
        }, E2.TinySDF = class {
          constructor({ fontSize: t3 = 24, buffer: e2 = 3, radius: i3 = 8, cutoff: s3 = 0.25, fontFamily: a3 = "sans-serif", fontWeight: o3 = "normal", fontStyle: r3 = "normal" } = {}) {
            this.buffer = e2, this.cutoff = s3, this.radius = i3;
            const n3 = this.size = t3 + 4 * e2, l3 = this._createCanvas(n3), h3 = this.ctx = l3.getContext("2d", { willReadFrequently: true });
            h3.font = `${r3} ${o3} ${t3}px ${a3}`, h3.textBaseline = "alphabetic", h3.textAlign = "left", h3.fillStyle = "black", this.gridOuter = new Float64Array(n3 * n3), this.gridInner = new Float64Array(n3 * n3), this.f = new Float64Array(n3), this.z = new Float64Array(n3 + 1), this.v = new Uint16Array(n3);
          }
          _createCanvas(t3) {
            const e2 = document.createElement("canvas");
            return e2.width = e2.height = t3, e2;
          }
          draw(t3) {
            const { width: e2, actualBoundingBoxAscent: i3, actualBoundingBoxDescent: s3, actualBoundingBoxLeft: a3, actualBoundingBoxRight: o3 } = this.ctx.measureText(t3), r3 = Math.ceil(i3), n3 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o3 - a3))), l3 = Math.min(this.size - this.buffer, r3 + Math.ceil(s3)), h3 = n3 + 2 * this.buffer, c3 = l3 + 2 * this.buffer, u3 = Math.max(h3 * c3, 0), d3 = new Uint8ClampedArray(u3), _3 = { data: d3, width: h3, height: c3, glyphWidth: n3, glyphHeight: l3, glyphTop: r3, glyphLeft: 0, glyphAdvance: e2 };
            if (0 === n3 || 0 === l3) return _3;
            const { ctx: p3, buffer: m3, gridInner: f3, gridOuter: g3 } = this;
            p3.clearRect(m3, m3, n3, l3), p3.fillText(t3, m3, m3 + r3);
            const v3 = p3.getImageData(m3, m3, n3, l3);
            g3.fill(w2, 0, u3), f3.fill(0, 0, u3);
            for (let t4 = 0; t4 < l3; t4++) for (let e3 = 0; e3 < n3; e3++) {
              const i4 = v3.data[4 * (t4 * n3 + e3) + 3] / 255;
              if (0 === i4) continue;
              const s4 = (t4 + m3) * h3 + e3 + m3;
              if (1 === i4) g3[s4] = 0, f3[s4] = w2;
              else {
                const t5 = 0.5 - i4;
                g3[s4] = t5 > 0 ? t5 * t5 : 0, f3[s4] = t5 < 0 ? t5 * t5 : 0;
              }
            }
            T2(g3, 0, 0, h3, c3, h3, this.f, this.v, this.z), T2(f3, m3, m3, n3, l3, h3, this.f, this.v, this.z);
            for (let t4 = 0; t4 < u3; t4++) {
              const e3 = Math.sqrt(g3[t4]) - Math.sqrt(f3[t4]);
              d3[t4] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
            }
            return _3;
          }
        };
        class S2 {
          constructor() {
            this.specification = t2.v.light.position;
          }
          possiblyEvaluate(e2, i3) {
            return t2.z(e2.expression.evaluate(i3));
          }
          interpolate(e2, i3, s3) {
            return { x: t2.B.number(e2.x, i3.x, s3), y: t2.B.number(e2.y, i3.y, s3), z: t2.B.number(e2.z, i3.z, s3) };
          }
        }
        let C2;
        class P2 extends t2.E {
          constructor(e2) {
            super(), C2 = C2 || new t2.r({ anchor: new t2.D(t2.v.light.anchor), position: new S2(), color: new t2.D(t2.v.light.color), intensity: new t2.D(t2.v.light.intensity) }), this._transitionable = new t2.T(C2), this.setLight(e2), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e2, i3 = {}) {
            if (!this._validate(t2.t, e2, i3)) for (const t3 in e2) {
              const i4 = e2[t3];
              t3.endsWith("-transition") ? this._transitionable.setTransition(t3.slice(0, -11), i4) : this._transitionable.setValue(t3, i4);
            }
          }
          updateTransitions(t3) {
            this._transitioning = this._transitionable.transitioned(t3, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t3) {
            this.properties = this._transitioning.possiblyEvaluate(t3);
          }
          _validate(e2, i3, s3) {
            return (!s3 || false !== s3.validate) && t2.x(this, e2.call(t2.y, t2.e({ value: i3, style: { glyphs: true, sprite: true }, styleSpec: t2.v })));
          }
        }
        class D2 {
          constructor(t3, e2) {
            this.width = t3, this.height = e2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(t3, e2) {
            const i3 = t3.join(",") + String(e2);
            return this.dashEntry[i3] || (this.dashEntry[i3] = this.addDash(t3, e2)), this.dashEntry[i3];
          }
          getDashRanges(t3, e2, i3) {
            const s3 = [];
            let a3 = t3.length % 2 == 1 ? -t3[t3.length - 1] * i3 : 0, o3 = t3[0] * i3, r3 = true;
            s3.push({ left: a3, right: o3, isDash: r3, zeroLength: 0 === t3[0] });
            let n3 = t3[0];
            for (let e3 = 1; e3 < t3.length; e3++) {
              r3 = !r3;
              const l3 = t3[e3];
              a3 = n3 * i3, n3 += l3, o3 = n3 * i3, s3.push({ left: a3, right: o3, isDash: r3, zeroLength: 0 === l3 });
            }
            return s3;
          }
          addRoundDash(t3, e2, i3) {
            const s3 = e2 / 2;
            for (let e3 = -i3; e3 <= i3; e3++) {
              const a3 = this.width * (this.nextRow + i3 + e3);
              let o3 = 0, r3 = t3[o3];
              for (let n3 = 0; n3 < this.width; n3++) {
                n3 / r3.right > 1 && (r3 = t3[++o3]);
                const l3 = Math.abs(n3 - r3.left), h3 = Math.abs(n3 - r3.right), c3 = Math.min(l3, h3);
                let u3;
                const d3 = e3 / i3 * (s3 + 1);
                if (r3.isDash) {
                  const t4 = s3 - Math.abs(d3);
                  u3 = Math.sqrt(c3 * c3 + t4 * t4);
                } else u3 = s3 - Math.sqrt(c3 * c3 + d3 * d3);
                this.data[a3 + n3] = Math.max(0, Math.min(255, u3 + 128));
              }
            }
          }
          addRegularDash(t3) {
            for (let e3 = t3.length - 1; e3 >= 0; --e3) {
              const i4 = t3[e3], s4 = t3[e3 + 1];
              i4.zeroLength ? t3.splice(e3, 1) : s4 && s4.isDash === i4.isDash && (s4.left = i4.left, t3.splice(e3, 1));
            }
            const e2 = t3[0], i3 = t3[t3.length - 1];
            e2.isDash === i3.isDash && (e2.left = i3.left - this.width, i3.right = e2.right + this.width);
            const s3 = this.width * this.nextRow;
            let a3 = 0, o3 = t3[a3];
            for (let e3 = 0; e3 < this.width; e3++) {
              e3 / o3.right > 1 && (o3 = t3[++a3]);
              const i4 = Math.abs(e3 - o3.left), r3 = Math.abs(e3 - o3.right), n3 = Math.min(i4, r3);
              this.data[s3 + e3] = Math.max(0, Math.min(255, (o3.isDash ? n3 : -n3) + 128));
            }
          }
          addDash(e2, i3) {
            const s3 = i3 ? 7 : 0, a3 = 2 * s3 + 1;
            if (this.nextRow + a3 > this.height) return t2.w("LineAtlas out of space"), null;
            let o3 = 0;
            for (let t3 = 0; t3 < e2.length; t3++) o3 += e2[t3];
            if (0 !== o3) {
              const t3 = this.width / o3, a4 = this.getDashRanges(e2, this.width, t3);
              i3 ? this.addRoundDash(a4, t3, s3) : this.addRegularDash(a4);
            }
            const r3 = { y: (this.nextRow + s3 + 0.5) / this.height, height: 2 * s3 / this.height, width: o3 };
            return this.nextRow += a3, this.dirty = true, r3;
          }
          bind(t3) {
            const e2 = t3.gl;
            this.texture ? (e2.bindTexture(e2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, this.width, this.height, e2.ALPHA, e2.UNSIGNED_BYTE, this.data))) : (this.texture = e2.createTexture(), e2.bindTexture(e2.TEXTURE_2D, this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR), e2.texImage2D(e2.TEXTURE_2D, 0, e2.ALPHA, this.width, this.height, 0, e2.ALPHA, e2.UNSIGNED_BYTE, this.data));
          }
        }
        class M2 {
          constructor(e2, i3, s3) {
            this.workerPool = e2, this.actors = [], this.currentActor = 0, this.id = s3;
            const a3 = this.workerPool.acquire(s3);
            for (let e3 = 0; e3 < a3.length; e3++) {
              const o3 = new t2.C(a3[e3], i3, s3);
              o3.name = `Worker ${e3}`, this.actors.push(o3);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(e2, i3, s3) {
            t2.o(this.actors, (t3, s4) => {
              t3.send(e2, i3, s4);
            }, s3 = s3 || function() {
            });
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(t3 = true) {
            this.actors.forEach((t4) => {
              t4.remove();
            }), this.actors = [], t3 && this.workerPool.release(this.id);
          }
        }
        function z2(e2, i3, s3) {
          const a3 = function(i4, a4) {
            if (i4) return s3(i4);
            if (a4) {
              const i5 = t2.F(t2.e(a4, e2), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
              a4.vector_layers && (i5.vectorLayers = a4.vector_layers, i5.vectorLayerIds = i5.vectorLayers.map((t3) => t3.id)), s3(null, i5);
            }
          };
          return e2.url ? t2.f(i3.transformRequest(e2.url, c2.Source), a3) : t2.h.frame(() => a3(null, e2));
        }
        class L2 {
          constructor(t3, e2) {
            t3 && (e2 ? this.setSouthWest(t3).setNorthEast(e2) : Array.isArray(t3) && (4 === t3.length ? this.setSouthWest([t3[0], t3[1]]).setNorthEast([t3[2], t3[3]]) : this.setSouthWest(t3[0]).setNorthEast(t3[1])));
          }
          setNorthEast(e2) {
            return this._ne = e2 instanceof t2.L ? new t2.L(e2.lng, e2.lat) : t2.L.convert(e2), this;
          }
          setSouthWest(e2) {
            return this._sw = e2 instanceof t2.L ? new t2.L(e2.lng, e2.lat) : t2.L.convert(e2), this;
          }
          extend(e2) {
            const i3 = this._sw, s3 = this._ne;
            let a3, o3;
            if (e2 instanceof t2.L) a3 = e2, o3 = e2;
            else {
              if (!(e2 instanceof L2)) return Array.isArray(e2) ? 4 === e2.length || e2.every(Array.isArray) ? this.extend(L2.convert(e2)) : this.extend(t2.L.convert(e2)) : e2 && ("lng" in e2 || "lon" in e2) && "lat" in e2 ? this.extend(t2.L.convert(e2)) : this;
              if (a3 = e2._sw, o3 = e2._ne, !a3 || !o3) return this;
            }
            return i3 || s3 ? (i3.lng = Math.min(a3.lng, i3.lng), i3.lat = Math.min(a3.lat, i3.lat), s3.lng = Math.max(o3.lng, s3.lng), s3.lat = Math.max(o3.lat, s3.lat)) : (this._sw = new t2.L(a3.lng, a3.lat), this._ne = new t2.L(o3.lng, o3.lat)), this;
          }
          getCenter() {
            return new t2.L((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new t2.L(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new t2.L(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e2) {
            const { lng: i3, lat: s3 } = t2.L.convert(e2);
            let a3 = this._sw.lng <= i3 && i3 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (a3 = this._sw.lng >= i3 && i3 >= this._ne.lng), this._sw.lat <= s3 && s3 <= this._ne.lat && a3;
          }
          static convert(t3) {
            return t3 instanceof L2 ? t3 : t3 ? new L2(t3) : t3;
          }
          static fromLngLat(e2, i3 = 0) {
            const s3 = 360 * i3 / 40075017, a3 = s3 / Math.cos(Math.PI / 180 * e2.lat);
            return new L2(new t2.L(e2.lng - a3, e2.lat - s3), new t2.L(e2.lng + a3, e2.lat + s3));
          }
        }
        class A2 {
          constructor(t3, e2, i3) {
            this.bounds = L2.convert(this.validateBounds(t3)), this.minzoom = e2 || 0, this.maxzoom = i3 || 24;
          }
          validateBounds(t3) {
            return Array.isArray(t3) && 4 === t3.length ? [Math.max(-180, t3[0]), Math.max(-90, t3[1]), Math.min(180, t3[2]), Math.min(90, t3[3])] : [-180, -90, 180, 90];
          }
          contains(e2) {
            const i3 = Math.pow(2, e2.z), s3 = Math.floor(t2.G(this.bounds.getWest()) * i3), a3 = Math.floor(t2.H(this.bounds.getNorth()) * i3), o3 = Math.ceil(t2.G(this.bounds.getEast()) * i3), r3 = Math.ceil(t2.H(this.bounds.getSouth()) * i3);
            return e2.x >= s3 && e2.x < o3 && e2.y >= a3 && e2.y < r3;
          }
        }
        class R2 extends t2.E {
          constructor(e2, i3, s3, a3) {
            if (super(), this.load = () => {
              this._loaded = false, this.fire(new t2.k("dataloading", { dataType: "source" })), this._tileJSONRequest = z2(this._options, this.map._requestManager, (e3, i4) => {
                this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e3 ? this.fire(new t2.j(e3)) : i4 && (t2.e(this, i4), i4.bounds && (this.tileBounds = new A2(i4.bounds, this.minzoom, this.maxzoom)), this.fire(new t2.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t2.k("data", { dataType: "source", sourceDataType: "content" })));
              });
            }, this.serialize = () => t2.e({}, this._options), this.id = e2, this.dispatcher = s3, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t2.e(this, t2.F(i3, ["url", "scheme", "tileSize", "promoteId"])), this._options = t2.e({ type: "vector" }, i3), this._collectResourceTiming = i3.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(a3);
          }
          loaded() {
            return this._loaded;
          }
          hasTile(t3) {
            return !this.tileBounds || this.tileBounds.contains(t3.canonical);
          }
          onAdd(t3) {
            this.map = t3, this.load();
          }
          setSourceProperty(t3) {
            this._tileJSONRequest && this._tileJSONRequest.cancel(), t3(), this.load();
          }
          setTiles(t3) {
            return this.setSourceProperty(() => {
              this._options.tiles = t3;
            }), this;
          }
          setUrl(t3) {
            return this.setSourceProperty(() => {
              this.url = t3, this._options.url = t3;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          loadTile(t3, e2) {
            const i3 = t3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), s3 = { request: this.map._requestManager.transformRequest(i3, c2.Tile), uid: t3.uid, tileID: t3.tileID, zoom: t3.tileID.overscaledZ, tileSize: this.tileSize * t3.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            function a3(i4, s4) {
              return delete t3.request, t3.aborted ? e2(null) : i4 && 404 !== i4.status ? e2(i4) : (s4 && s4.resourceTiming && (t3.resourceTiming = s4.resourceTiming), this.map._refreshExpiredTiles && s4 && t3.setExpiryData(s4), t3.loadVectorData(s4, this.map.painter), e2(null), void (t3.reloadCallback && (this.loadTile(t3, t3.reloadCallback), t3.reloadCallback = null)));
            }
            s3.request.collectResourceTiming = this._collectResourceTiming, t3.actor && "expired" !== t3.state ? "loading" === t3.state ? t3.reloadCallback = e2 : t3.request = t3.actor.send("reloadTile", s3, a3.bind(this)) : (t3.actor = this.dispatcher.getActor(), t3.request = t3.actor.send("loadTile", s3, a3.bind(this)));
          }
          abortTile(t3) {
            t3.request && (t3.request.cancel(), delete t3.request), t3.actor && t3.actor.send("abortTile", { uid: t3.uid, type: this.type, source: this.id }, void 0);
          }
          unloadTile(t3) {
            t3.unloadVectorData(), t3.actor && t3.actor.send("removeTile", { uid: t3.uid, type: this.type, source: this.id }, void 0);
          }
          hasTransition() {
            return false;
          }
        }
        class k2 extends t2.E {
          constructor(e2, i3, s3, a3) {
            super(), this.id = e2, this.dispatcher = s3, this.setEventedParent(a3), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t2.e({ type: "raster" }, i3), t2.e(this, t2.F(i3, ["url", "scheme", "tileSize"]));
          }
          load() {
            this._loaded = false, this.fire(new t2.k("dataloading", { dataType: "source" })), this._tileJSONRequest = z2(this._options, this.map._requestManager, (e2, i3) => {
              this._tileJSONRequest = null, this._loaded = true, e2 ? this.fire(new t2.j(e2)) : i3 && (t2.e(this, i3), i3.bounds && (this.tileBounds = new A2(i3.bounds, this.minzoom, this.maxzoom)), this.fire(new t2.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t2.k("data", { dataType: "source", sourceDataType: "content" })));
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t3) {
            this.map = t3, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          setSourceProperty(t3) {
            this._tileJSONRequest && this._tileJSONRequest.cancel(), t3(), this.load();
          }
          setTiles(t3) {
            return this.setSourceProperty(() => {
              this._options.tiles = t3;
            }), this;
          }
          serialize() {
            return t2.e({}, this._options);
          }
          hasTile(t3) {
            return !this.tileBounds || this.tileBounds.contains(t3.canonical);
          }
          loadTile(t3, e2) {
            const i3 = t3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            t3.request = h2.getImage(this.map._requestManager.transformRequest(i3, c2.Tile), (i4, s3, a3) => {
              if (delete t3.request, t3.aborted) t3.state = "unloaded", e2(null);
              else if (i4) t3.state = "errored", e2(i4);
              else if (s3) {
                this.map._refreshExpiredTiles && a3 && t3.setExpiryData(a3);
                const i5 = this.map.painter.context, o3 = i5.gl;
                t3.texture = this.map.painter.getTileTexture(s3.width), t3.texture ? t3.texture.update(s3, { useMipmap: true }) : (t3.texture = new x2(i5, s3, o3.RGBA, { useMipmap: true }), t3.texture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE, o3.LINEAR_MIPMAP_NEAREST), i5.extTextureFilterAnisotropic && o3.texParameterf(o3.TEXTURE_2D, i5.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, i5.extTextureFilterAnisotropicMax)), t3.state = "loaded", e2(null);
              }
            }, this.map._refreshExpiredTiles);
          }
          abortTile(t3, e2) {
            t3.request && (t3.request.cancel(), delete t3.request), e2();
          }
          unloadTile(t3, e2) {
            t3.texture && this.map.painter.saveTileTexture(t3.texture), e2();
          }
          hasTransition() {
            return false;
          }
        }
        class F2 extends k2 {
          constructor(e2, i3, s3, a3) {
            super(e2, i3, s3, a3), this.type = "raster-dem", this.maxzoom = 22, this._options = t2.e({ type: "raster-dem" }, i3), this.encoding = i3.encoding || "mapbox", this.redFactor = i3.redFactor, this.greenFactor = i3.greenFactor, this.blueFactor = i3.blueFactor, this.baseShift = i3.baseShift;
          }
          loadTile(e2, i3) {
            const s3 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a3 = this.map._requestManager.transformRequest(s3, c2.Tile);
            function o3(t3, s4) {
              t3 && (e2.state = "errored", i3(t3)), s4 && (e2.dem = s4, e2.needsHillshadePrepare = true, e2.needsTerrainPrepare = true, e2.state = "loaded", i3(null));
            }
            e2.neighboringTiles = this._getNeighboringTiles(e2.tileID), e2.request = h2.getImage(a3, (s4, a4, r3) => t2._(this, void 0, void 0, function* () {
              if (delete e2.request, e2.aborted) e2.state = "unloaded", i3(null);
              else if (s4) e2.state = "errored", i3(s4);
              else if (a4) {
                this.map._refreshExpiredTiles && e2.setExpiryData(r3);
                const i4 = t2.a(a4) && t2.J() ? a4 : yield function(e3) {
                  return t2._(this, void 0, void 0, function* () {
                    if ("undefined" != typeof VideoFrame && t2.K()) {
                      const i5 = e3.width + 2, s6 = e3.height + 2;
                      try {
                        return new t2.R({ width: i5, height: s6 }, yield t2.M(e3, -1, -1, i5, s6));
                      } catch (t3) {
                      }
                    }
                    return t2.h.getImageData(e3, 1);
                  });
                }(a4), s5 = { uid: e2.uid, coord: e2.tileID, source: this.id, rawImageData: i4, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                e2.actor && "expired" !== e2.state || (e2.actor = this.dispatcher.getActor(), e2.actor.send("loadDEMTile", s5, o3));
              }
            }), this.map._refreshExpiredTiles);
          }
          _getNeighboringTiles(e2) {
            const i3 = e2.canonical, s3 = Math.pow(2, i3.z), a3 = (i3.x - 1 + s3) % s3, o3 = 0 === i3.x ? e2.wrap - 1 : e2.wrap, r3 = (i3.x + 1 + s3) % s3, n3 = i3.x + 1 === s3 ? e2.wrap + 1 : e2.wrap, l3 = {};
            return l3[new t2.O(e2.overscaledZ, o3, i3.z, a3, i3.y).key] = { backfilled: false }, l3[new t2.O(e2.overscaledZ, n3, i3.z, r3, i3.y).key] = { backfilled: false }, i3.y > 0 && (l3[new t2.O(e2.overscaledZ, o3, i3.z, a3, i3.y - 1).key] = { backfilled: false }, l3[new t2.O(e2.overscaledZ, e2.wrap, i3.z, i3.x, i3.y - 1).key] = { backfilled: false }, l3[new t2.O(e2.overscaledZ, n3, i3.z, r3, i3.y - 1).key] = { backfilled: false }), i3.y + 1 < s3 && (l3[new t2.O(e2.overscaledZ, o3, i3.z, a3, i3.y + 1).key] = { backfilled: false }, l3[new t2.O(e2.overscaledZ, e2.wrap, i3.z, i3.x, i3.y + 1).key] = { backfilled: false }, l3[new t2.O(e2.overscaledZ, n3, i3.z, r3, i3.y + 1).key] = { backfilled: false }), l3;
          }
          unloadTile(t3) {
            t3.demTexture && this.map.painter.saveTileTexture(t3.demTexture), t3.fbo && (t3.fbo.destroy(), delete t3.fbo), t3.dem && delete t3.dem, delete t3.neighboringTiles, t3.state = "unloaded", t3.actor && t3.actor.send("removeDEMTile", { uid: t3.uid, source: this.id });
          }
        }
        class B2 extends t2.E {
          constructor(e2, i3, s3, a3) {
            super(), this.load = () => {
              this._updateWorkerData();
            }, this.serialize = () => t2.e({}, this._options, { type: this.type, data: this._data }), this.id = e2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = s3.getActor(), this.setEventedParent(a3), this._data = i3.data, this._options = t2.e({}, i3), this._collectResourceTiming = i3.collectResourceTiming, void 0 !== i3.maxzoom && (this.maxzoom = i3.maxzoom), i3.type && (this.type = i3.type), i3.attribution && (this.attribution = i3.attribution), this.promoteId = i3.promoteId;
            const o3 = t2.N / this.tileSize;
            this.workerOptions = t2.e({ source: this.id, cluster: i3.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i3.buffer ? i3.buffer : 128) * o3, tolerance: (void 0 !== i3.tolerance ? i3.tolerance : 0.375) * o3, extent: t2.N, maxZoom: this.maxzoom, lineMetrics: i3.lineMetrics || false, generateId: i3.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i3.clusterMaxZoom ? i3.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i3.clusterMinPoints || 2), extent: t2.N, radius: (i3.clusterRadius || 50) * o3, log: false, generateId: i3.generateId || false }, clusterProperties: i3.clusterProperties, filter: i3.filter }, i3.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
          }
          onAdd(t3) {
            this.map = t3, this.load();
          }
          setData(t3) {
            return this._data = t3, this._updateWorkerData(), this;
          }
          updateData(t3) {
            return this._updateWorkerData(t3), this;
          }
          setClusterOptions(t3) {
            return this.workerOptions.cluster = t3.cluster, t3 && (void 0 !== t3.clusterRadius && (this.workerOptions.superclusterOptions.radius = t3.clusterRadius), void 0 !== t3.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = t3.clusterMaxZoom)), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(t3, e2) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t3, source: this.id }, e2), this;
          }
          getClusterChildren(t3, e2) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: t3, source: this.id }, e2), this;
          }
          getClusterLeaves(t3, e2, i3, s3) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t3, limit: e2, offset: i3 }, s3), this;
          }
          _updateWorkerData(e2) {
            const i3 = t2.e({}, this.workerOptions);
            e2 ? i3.dataDiff = e2 : "string" == typeof this._data ? (i3.request = this.map._requestManager.transformRequest(t2.h.resolveURL(this._data), c2.Source), i3.request.collectResourceTiming = this._collectResourceTiming) : i3.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new t2.k("dataloading", { dataType: "source" })), this.actor.send(`${this.type}.loadData`, i3, (e3, i4) => {
              if (this._pendingLoads--, this._removed || i4 && i4.abandoned) return void this.fire(new t2.k("dataabort", { dataType: "source" }));
              let s3 = null;
              if (i4 && i4.resourceTiming && i4.resourceTiming[this.id] && (s3 = i4.resourceTiming[this.id].slice(0)), e3) return void this.fire(new t2.j(e3));
              const a3 = { dataType: "source" };
              this._collectResourceTiming && s3 && s3.length > 0 && t2.e(a3, { resourceTiming: s3 }), this.fire(new t2.k("data", Object.assign(Object.assign({}, a3), { sourceDataType: "metadata" }))), this.fire(new t2.k("data", Object.assign(Object.assign({}, a3), { sourceDataType: "content" })));
            });
          }
          loaded() {
            return 0 === this._pendingLoads;
          }
          loadTile(t3, e2) {
            const i3 = t3.actor ? "reloadTile" : "loadTile";
            t3.actor = this.actor;
            const s3 = { type: this.type, uid: t3.uid, tileID: t3.tileID, zoom: t3.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            t3.request = this.actor.send(i3, s3, (s4, a3) => (delete t3.request, t3.unloadVectorData(), t3.aborted ? e2(null) : s4 ? e2(s4) : (t3.loadVectorData(a3, this.map.painter, "reloadTile" === i3), e2(null))));
          }
          abortTile(t3) {
            t3.request && (t3.request.cancel(), delete t3.request), t3.aborted = true;
          }
          unloadTile(t3) {
            t3.unloadVectorData(), this.actor.send("removeTile", { uid: t3.uid, type: this.type, source: this.id });
          }
          onRemove() {
            this._removed = true, this.actor.send("removeSource", { type: this.type, source: this.id });
          }
          hasTransition() {
            return false;
          }
        }
        var O2 = t2.Q([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class N2 extends t2.E {
          constructor(e2, i3, s3, a3) {
            super(), this.load = (e3, i4) => {
              this._loaded = false, this.fire(new t2.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = h2.getImage(this.map._requestManager.transformRequest(this.url, c2.Image), (s4, a4) => {
                this._request = null, this._loaded = true, s4 ? this.fire(new t2.j(s4)) : a4 && (this.image = a4, e3 && (this.coordinates = e3), i4 && i4(), this._finishLoading());
              });
            }, this.prepare = () => {
              if (0 === Object.keys(this.tiles).length || !this.image) return;
              const e3 = this.map.painter.context, i4 = e3.gl;
              this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, O2.members)), this.boundsSegments || (this.boundsSegments = t2.S.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new x2(e3, this.image, i4.RGBA), this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE));
              let s4 = false;
              for (const t3 in this.tiles) {
                const e4 = this.tiles[t3];
                "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture, s4 = true);
              }
              s4 && this.fire(new t2.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
            }, this.serialize = () => ({ type: "image", url: this.options.url, coordinates: this.coordinates }), this.id = e2, this.dispatcher = s3, this.coordinates = i3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(a3), this.options = i3;
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t3) {
            return t3.url ? (this._request && (this._request.cancel(), this._request = null), this.options.url = t3.url, this.load(t3.coordinates, () => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new t2.k("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(t3) {
            this.map = t3, this.load();
          }
          onRemove() {
            this._request && (this._request.cancel(), this._request = null);
          }
          setCoordinates(e2) {
            this.coordinates = e2;
            const i3 = e2.map(t2.U.fromLngLat);
            this.tileID = function(e3) {
              let i4 = 1 / 0, s4 = 1 / 0, a3 = -1 / 0, o3 = -1 / 0;
              for (const t3 of e3) i4 = Math.min(i4, t3.x), s4 = Math.min(s4, t3.y), a3 = Math.max(a3, t3.x), o3 = Math.max(o3, t3.y);
              const r3 = Math.max(a3 - i4, o3 - s4), n3 = Math.max(0, Math.floor(-Math.log(r3) / Math.LN2)), l3 = Math.pow(2, n3);
              return new t2.W(n3, Math.floor((i4 + a3) / 2 * l3), Math.floor((s4 + o3) / 2 * l3));
            }(i3), this.minzoom = this.maxzoom = this.tileID.z;
            const s3 = i3.map((t3) => this.tileID.getTilePoint(t3)._round());
            return this._boundsArray = new t2.V(), this._boundsArray.emplaceBack(s3[0].x, s3[0].y, 0, 0), this._boundsArray.emplaceBack(s3[1].x, s3[1].y, t2.N, 0), this._boundsArray.emplaceBack(s3[3].x, s3[3].y, 0, t2.N), this._boundsArray.emplaceBack(s3[2].x, s3[2].y, t2.N, t2.N), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t2.k("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          loadTile(t3, e2) {
            this.tileID && this.tileID.equals(t3.tileID.canonical) ? (this.tiles[String(t3.tileID.wrap)] = t3, t3.buckets = {}, e2(null)) : (t3.state = "errored", e2(null));
          }
          hasTransition() {
            return false;
          }
        }
        class U2 extends N2 {
          constructor(e2, i3, s3, a3) {
            super(e2, i3, s3, a3), this.load = () => {
              this._loaded = false;
              const e3 = this.options;
              this.urls = [];
              for (const t3 of e3.urls) this.urls.push(this.map._requestManager.transformRequest(t3, c2.Source).url);
              t2.X(this.urls, (e4, i4) => {
                this._loaded = true, e4 ? this.fire(new t2.j(e4)) : i4 && (this.video = i4, this.video.loop = true, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading());
              });
            }, this.prepare = () => {
              if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
              const e3 = this.map.painter.context, i4 = e3.gl;
              this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, O2.members)), this.boundsSegments || (this.boundsSegments = t2.S.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE), i4.texSubImage2D(i4.TEXTURE_2D, 0, 0, 0, i4.RGBA, i4.UNSIGNED_BYTE, this.video)) : (this.texture = new x2(e3, this.video, i4.RGBA), this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE));
              let s4 = false;
              for (const t3 in this.tiles) {
                const e4 = this.tiles[t3];
                "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture, s4 = true);
              }
              s4 && this.fire(new t2.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
            }, this.serialize = () => ({ type: "video", urls: this.urls, coordinates: this.coordinates }), this.roundZoom = true, this.type = "video", this.options = i3;
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e2) {
            if (this.video) {
              const i3 = this.video.seekable;
              e2 < i3.start(0) || e2 > i3.end(0) ? this.fire(new t2.j(new t2.Y(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i3.start(0)} and ${i3.end(0)}-second mark.`))) : this.video.currentTime = e2;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(t3) {
            this.map || (this.map = t3, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class Z2 extends N2 {
          constructor(e2, i3, s3, a3) {
            super(e2, i3, s3, a3), this.load = () => {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t2.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }, this.prepare = () => {
              let e3 = false;
              if (this.canvas.width !== this.width && (this.width = this.canvas.width, e3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e3 = true), this._hasInvalidDimensions()) return;
              if (0 === Object.keys(this.tiles).length) return;
              const i4 = this.map.painter.context, s4 = i4.gl;
              this.boundsBuffer || (this.boundsBuffer = i4.createVertexBuffer(this._boundsArray, O2.members)), this.boundsSegments || (this.boundsSegments = t2.S.simpleSegment(0, 0, 4, 2)), this.texture ? (e3 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new x2(i4, this.canvas, s4.RGBA, { premultiply: true });
              let a4 = false;
              for (const t3 in this.tiles) {
                const e4 = this.tiles[t3];
                "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture, a4 = true);
              }
              a4 && this.fire(new t2.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
            }, this.serialize = () => ({ type: "canvas", coordinates: this.coordinates }), i3.coordinates ? Array.isArray(i3.coordinates) && 4 === i3.coordinates.length && !i3.coordinates.some((t3) => !Array.isArray(t3) || 2 !== t3.length || t3.some((t4) => "number" != typeof t4)) || this.fire(new t2.j(new t2.Y(`sources.${e2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t2.j(new t2.Y(`sources.${e2}`, null, 'missing required property "coordinates"'))), i3.animate && "boolean" != typeof i3.animate && this.fire(new t2.j(new t2.Y(`sources.${e2}`, null, 'optional "animate" property must be a boolean value'))), i3.canvas ? "string" == typeof i3.canvas || i3.canvas instanceof HTMLCanvasElement || this.fire(new t2.j(new t2.Y(`sources.${e2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t2.j(new t2.Y(`sources.${e2}`, null, 'missing required property "canvas"'))), this.options = i3, this.animate = void 0 === i3.animate || i3.animate;
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(t3) {
            this.map = t3, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const t3 of [this.canvas.width, this.canvas.height]) if (isNaN(t3) || t3 <= 0) return true;
            return false;
          }
        }
        const G2 = {}, j2 = (t3) => {
          switch (t3) {
            case "geojson":
              return B2;
            case "image":
              return N2;
            case "raster":
              return k2;
            case "raster-dem":
              return F2;
            case "vector":
              return R2;
            case "video":
              return U2;
            case "canvas":
              return Z2;
          }
          return G2[t3];
        };
        function V2(e2, i3) {
          const s3 = t2.Z();
          return t2.$(s3, s3, [1, 1, 0]), t2.a0(s3, s3, [0.5 * e2.width, 0.5 * e2.height, 1]), t2.a1(s3, s3, e2.calculatePosMatrix(i3.toUnwrapped()));
        }
        function q2(t3, e2, i3, s3, a3, o3) {
          const r3 = function(t4, e3, i4) {
            if (t4) for (const s4 of t4) {
              const t5 = e3[s4];
              if (t5 && t5.source === i4 && "fill-extrusion" === t5.type) return true;
            }
            else for (const t5 in e3) {
              const s4 = e3[t5];
              if (s4.source === i4 && "fill-extrusion" === s4.type) return true;
            }
            return false;
          }(a3 && a3.layers, e2, t3.id), n3 = o3.maxPitchScaleFactor(), l3 = t3.tilesIn(s3, n3, r3);
          l3.sort($2);
          const h3 = [];
          for (const s4 of l3) h3.push({ wrappedTileID: s4.tileID.wrapped().key, queryResults: s4.tile.queryRenderedFeatures(e2, i3, t3._state, s4.queryGeometry, s4.cameraQueryGeometry, s4.scale, a3, o3, n3, V2(t3.transform, s4.tileID)) });
          const c3 = function(t4) {
            const e3 = {}, i4 = {};
            for (const s4 of t4) {
              const t5 = s4.queryResults, a4 = s4.wrappedTileID, o4 = i4[a4] = i4[a4] || {};
              for (const i5 in t5) {
                const s5 = t5[i5], a5 = o4[i5] = o4[i5] || {}, r4 = e3[i5] = e3[i5] || [];
                for (const t6 of s5) a5[t6.featureIndex] || (a5[t6.featureIndex] = true, r4.push(t6));
              }
            }
            return e3;
          }(h3);
          for (const e3 in c3) c3[e3].forEach((e4) => {
            const i4 = e4.feature, s4 = t3.getFeatureState(i4.layer["source-layer"], i4.id);
            i4.source = i4.layer.source, i4.layer["source-layer"] && (i4.sourceLayer = i4.layer["source-layer"]), i4.state = s4;
          });
          return c3;
        }
        function $2(t3, e2) {
          const i3 = t3.tileID, s3 = e2.tileID;
          return i3.overscaledZ - s3.overscaledZ || i3.canonical.y - s3.canonical.y || i3.wrap - s3.wrap || i3.canonical.x - s3.canonical.x;
        }
        class W2 {
          constructor(e2, i3) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e2, this.uid = t2.a2(), this.uses = 0, this.tileSize = i3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(t3) {
            const e2 = t3 + this.timeAdded;
            e2 < this.fadeEndTime || (this.fadeEndTime = e2);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          clearTextures(t3) {
            this.demTexture && t3.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e2, i3, s3) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e2) {
              e2.featureIndex && (this.latestFeatureIndex = e2.featureIndex, e2.rawTileData ? (this.latestRawTileData = e2.rawTileData, this.latestFeatureIndex.rawTileData = e2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e2.collisionBoxArray, this.buckets = function(t3, e3) {
                const i4 = {};
                if (!e3) return i4;
                for (const s4 of t3) {
                  const t4 = s4.layerIds.map((t5) => e3.getLayer(t5)).filter(Boolean);
                  if (0 !== t4.length) {
                    s4.layers = t4, s4.stateDependentLayerIds && (s4.stateDependentLayers = s4.stateDependentLayerIds.map((e4) => t4.filter((t5) => t5.id === e4)[0]));
                    for (const e4 of t4) i4[e4.id] = s4;
                  }
                }
                return i4;
              }(e2.buckets, i3.style), this.hasSymbolBuckets = false;
              for (const e3 in this.buckets) {
                const i4 = this.buckets[e3];
                if (i4 instanceof t2.a4) {
                  if (this.hasSymbolBuckets = true, !s3) break;
                  i4.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets) for (const e3 in this.buckets) {
                const i4 = this.buckets[e3];
                if (i4 instanceof t2.a4 && i4.hasRTLText) {
                  this.hasRTLText = true, t2.a5();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const t3 in this.buckets) {
                const e3 = this.buckets[t3];
                this.queryPadding = Math.max(this.queryPadding, i3.style.getLayer(t3).queryRadius(e3));
              }
              e2.imageAtlas && (this.imageAtlas = e2.imageAtlas), e2.glyphAtlasImage && (this.glyphAtlasImage = e2.glyphAtlasImage);
            } else this.collisionBoxArray = new t2.a3();
          }
          unloadVectorData() {
            for (const t3 in this.buckets) this.buckets[t3].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(t3) {
            return this.buckets[t3.id];
          }
          upload(t3) {
            for (const e3 in this.buckets) {
              const i3 = this.buckets[e3];
              i3.uploadPending() && i3.upload(t3);
            }
            const e2 = t3.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new x2(t3, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new x2(t3, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(t3) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t3, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t3, e2, i3, s3, a3, o3, r3, n3, l3, h3) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: s3, cameraQueryGeometry: a3, scale: o3, tileSize: this.tileSize, pixelPosMatrix: h3, transform: n3, params: r3, queryPadding: this.queryPadding * l3 }, t3, e2, i3) : {};
          }
          querySourceFeatures(e2, i3) {
            const s3 = this.latestFeatureIndex;
            if (!s3 || !s3.rawTileData) return;
            const a3 = s3.loadVTLayers(), o3 = i3 && i3.sourceLayer ? i3.sourceLayer : "", r3 = a3._geojsonTileLayer || a3[o3];
            if (!r3) return;
            const n3 = t2.a6(i3 && i3.filter), { z: l3, x: h3, y: c3 } = this.tileID.canonical, u3 = { z: l3, x: h3, y: c3 };
            for (let i4 = 0; i4 < r3.length; i4++) {
              const a4 = r3.feature(i4);
              if (n3.needGeometry) {
                const e3 = t2.a7(a4, true);
                if (!n3.filter(new t2.a8(this.tileID.overscaledZ), e3, this.tileID.canonical)) continue;
              } else if (!n3.filter(new t2.a8(this.tileID.overscaledZ), a4)) continue;
              const d3 = s3.getId(a4, o3), _3 = new t2.a9(a4, l3, h3, c3, d3);
              _3.tile = u3, e2.push(_3);
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e2) {
            const i3 = this.expirationTime;
            if (e2.cacheControl) {
              const i4 = t2.aa(e2.cacheControl);
              i4["max-age"] && (this.expirationTime = Date.now() + 1e3 * i4["max-age"]);
            } else e2.expires && (this.expirationTime = new Date(e2.expires).getTime());
            if (this.expirationTime) {
              const t3 = Date.now();
              let e3 = false;
              if (this.expirationTime > t3) e3 = false;
              else if (i3) if (this.expirationTime < i3) e3 = true;
              else {
                const s3 = this.expirationTime - i3;
                s3 ? this.expirationTime = t3 + Math.max(s3, 3e4) : e3 = true;
              }
              else e3 = true;
              e3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t3, e2) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t3).length) return;
            const i3 = this.latestFeatureIndex.loadVTLayers();
            for (const s3 in this.buckets) {
              if (!e2.style.hasLayer(s3)) continue;
              const a3 = this.buckets[s3], o3 = a3.layers[0].sourceLayer || "_geojsonTileLayer", r3 = i3[o3], n3 = t3[o3];
              if (!r3 || !n3 || 0 === Object.keys(n3).length) continue;
              a3.update(n3, r3, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const l3 = e2 && e2.style && e2.style.getLayer(s3);
              l3 && (this.queryPadding = Math.max(this.queryPadding, l3.queryRadius(a3)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < t2.h.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e2) {
            this.symbolFadeHoldUntil = t2.h.now() + e2;
          }
          setDependencies(t3, e2) {
            const i3 = {};
            for (const t4 of e2) i3[t4] = true;
            this.dependencies[t3] = i3;
          }
          hasDependency(t3, e2) {
            for (const i3 of t3) {
              const t4 = this.dependencies[i3];
              if (t4) {
                for (const i4 of e2) if (t4[i4]) return true;
              }
            }
            return false;
          }
        }
        class H2 {
          constructor(t3, e2) {
            this.max = t3, this.onRemove = e2, this.reset();
          }
          reset() {
            for (const t3 in this.data) for (const e2 of this.data[t3]) e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
            return this.data = {}, this.order = [], this;
          }
          add(t3, e2, i3) {
            const s3 = t3.wrapped().key;
            void 0 === this.data[s3] && (this.data[s3] = []);
            const a3 = { value: e2, timeout: void 0 };
            if (void 0 !== i3 && (a3.timeout = setTimeout(() => {
              this.remove(t3, a3);
            }, i3)), this.data[s3].push(a3), this.order.push(s3), this.order.length > this.max) {
              const t4 = this._getAndRemoveByKey(this.order[0]);
              t4 && this.onRemove(t4);
            }
            return this;
          }
          has(t3) {
            return t3.wrapped().key in this.data;
          }
          getAndRemove(t3) {
            return this.has(t3) ? this._getAndRemoveByKey(t3.wrapped().key) : null;
          }
          _getAndRemoveByKey(t3) {
            const e2 = this.data[t3].shift();
            return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t3].length && delete this.data[t3], this.order.splice(this.order.indexOf(t3), 1), e2.value;
          }
          getByKey(t3) {
            const e2 = this.data[t3];
            return e2 ? e2[0].value : null;
          }
          get(t3) {
            return this.has(t3) ? this.data[t3.wrapped().key][0].value : null;
          }
          remove(t3, e2) {
            if (!this.has(t3)) return this;
            const i3 = t3.wrapped().key, s3 = void 0 === e2 ? 0 : this.data[i3].indexOf(e2), a3 = this.data[i3][s3];
            return this.data[i3].splice(s3, 1), a3.timeout && clearTimeout(a3.timeout), 0 === this.data[i3].length && delete this.data[i3], this.onRemove(a3.value), this.order.splice(this.order.indexOf(i3), 1), this;
          }
          setMaxSize(t3) {
            for (this.max = t3; this.order.length > this.max; ) {
              const t4 = this._getAndRemoveByKey(this.order[0]);
              t4 && this.onRemove(t4);
            }
            return this;
          }
          filter(t3) {
            const e2 = [];
            for (const i3 in this.data) for (const s3 of this.data[i3]) t3(s3.value) || e2.push(s3);
            for (const t4 of e2) this.remove(t4.value.tileID, t4);
          }
        }
        class X2 {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e2, i3, s3) {
            const a3 = String(i3);
            if (this.stateChanges[e2] = this.stateChanges[e2] || {}, this.stateChanges[e2][a3] = this.stateChanges[e2][a3] || {}, t2.e(this.stateChanges[e2][a3], s3), null === this.deletedStates[e2]) {
              this.deletedStates[e2] = {};
              for (const t3 in this.state[e2]) t3 !== a3 && (this.deletedStates[e2][t3] = null);
            } else if (this.deletedStates[e2] && null === this.deletedStates[e2][a3]) {
              this.deletedStates[e2][a3] = {};
              for (const t3 in this.state[e2][a3]) s3[t3] || (this.deletedStates[e2][a3][t3] = null);
            } else for (const t3 in s3) this.deletedStates[e2] && this.deletedStates[e2][a3] && null === this.deletedStates[e2][a3][t3] && delete this.deletedStates[e2][a3][t3];
          }
          removeFeatureState(t3, e2, i3) {
            if (null === this.deletedStates[t3]) return;
            const s3 = String(e2);
            if (this.deletedStates[t3] = this.deletedStates[t3] || {}, i3 && void 0 !== e2) null !== this.deletedStates[t3][s3] && (this.deletedStates[t3][s3] = this.deletedStates[t3][s3] || {}, this.deletedStates[t3][s3][i3] = null);
            else if (void 0 !== e2) if (this.stateChanges[t3] && this.stateChanges[t3][s3]) for (i3 in this.deletedStates[t3][s3] = {}, this.stateChanges[t3][s3]) this.deletedStates[t3][s3][i3] = null;
            else this.deletedStates[t3][s3] = null;
            else this.deletedStates[t3] = null;
          }
          getState(e2, i3) {
            const s3 = String(i3), a3 = t2.e({}, (this.state[e2] || {})[s3], (this.stateChanges[e2] || {})[s3]);
            if (null === this.deletedStates[e2]) return {};
            if (this.deletedStates[e2]) {
              const t3 = this.deletedStates[e2][i3];
              if (null === t3) return {};
              for (const e3 in t3) delete a3[e3];
            }
            return a3;
          }
          initializeTileState(t3, e2) {
            t3.setFeatureState(this.state, e2);
          }
          coalesceChanges(e2, i3) {
            const s3 = {};
            for (const e3 in this.stateChanges) {
              this.state[e3] = this.state[e3] || {};
              const i4 = {};
              for (const s4 in this.stateChanges[e3]) this.state[e3][s4] || (this.state[e3][s4] = {}), t2.e(this.state[e3][s4], this.stateChanges[e3][s4]), i4[s4] = this.state[e3][s4];
              s3[e3] = i4;
            }
            for (const e3 in this.deletedStates) {
              this.state[e3] = this.state[e3] || {};
              const i4 = {};
              if (null === this.deletedStates[e3]) for (const t3 in this.state[e3]) i4[t3] = {}, this.state[e3][t3] = {};
              else for (const t3 in this.deletedStates[e3]) {
                if (null === this.deletedStates[e3][t3]) this.state[e3][t3] = {};
                else for (const i5 of Object.keys(this.deletedStates[e3][t3])) delete this.state[e3][t3][i5];
                i4[t3] = this.state[e3][t3];
              }
              s3[e3] = s3[e3] || {}, t2.e(s3[e3], i4);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(s3).length) for (const t3 in e2) e2[t3].setFeatureState(s3, i3);
          }
        }
        class K2 extends t2.E {
          constructor(t3, e2, i3) {
            super(), this.id = t3, this.dispatcher = i3, this.on("data", (t4) => {
              "source" === t4.dataType && "metadata" === t4.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t4.dataType && "content" === t4.sourceDataType && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
            }), this.on("dataloading", () => {
              this._sourceErrored = false;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = ((t4, e3, i4, s3) => {
              const a3 = new (j2(e3.type))(t4, e3, i4, s3);
              if (a3.id !== t4) throw new Error(`Expected Source id to be ${t4} instead of ${a3.id}`);
              return a3;
            })(t3, e2, i3, this), this._tiles = {}, this._cache = new H2(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new X2(), this._didEmitContent = false, this._updated = false;
          }
          onAdd(t3) {
            this.map = t3, this._maxTileCacheSize = t3 ? t3._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t3 ? t3._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t3);
          }
          onRemove(t3) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t3);
          }
          loaded() {
            if (this._sourceErrored) return true;
            if (!this._sourceLoaded) return false;
            if (!this._source.loaded()) return false;
            if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain)) return true;
            if (!this._updated) return false;
            for (const t3 in this._tiles) {
              const e2 = this._tiles[t3];
              if ("loaded" !== e2.state && "errored" !== e2.state) return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused) return;
            const t3 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, t3 && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(t3, e2) {
            return this._source.loadTile(t3, e2);
          }
          _unloadTile(t3) {
            if (this._source.unloadTile) return this._source.unloadTile(t3, () => {
            });
          }
          _abortTile(e2) {
            this._source.abortTile && this._source.abortTile(e2, () => {
            }), this._source.fire(new t2.k("dataabort", { tile: e2, coord: e2.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t3) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const e2 in this._tiles) {
              const i3 = this._tiles[e2];
              i3.upload(t3), i3.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((t3) => t3.tileID).sort(Q2).map((t3) => t3.key);
          }
          getRenderableIds(e2) {
            const i3 = [];
            for (const t3 in this._tiles) this._isIdRenderable(t3, e2) && i3.push(this._tiles[t3]);
            return e2 ? i3.sort((e3, i4) => {
              const s3 = e3.tileID, a3 = i4.tileID, o3 = new t2.P(s3.canonical.x, s3.canonical.y)._rotate(this.transform.angle), r3 = new t2.P(a3.canonical.x, a3.canonical.y)._rotate(this.transform.angle);
              return s3.overscaledZ - a3.overscaledZ || r3.y - o3.y || r3.x - o3.x;
            }).map((t3) => t3.tileID.key) : i3.map((t3) => t3.tileID).sort(Q2).map((t3) => t3.key);
          }
          hasRenderableParent(t3) {
            const e2 = this.findLoadedParent(t3, 0);
            return !!e2 && this._isIdRenderable(e2.tileID.key);
          }
          _isIdRenderable(t3, e2) {
            return this._tiles[t3] && this._tiles[t3].hasData() && !this._coveredTiles[t3] && (e2 || !this._tiles[t3].holdingForFade());
          }
          reload() {
            if (this._paused) this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const t3 in this._tiles) "errored" !== this._tiles[t3].state && this._reloadTile(t3, "reloading");
            }
          }
          _reloadTile(t3, e2) {
            const i3 = this._tiles[t3];
            i3 && ("loading" !== i3.state && (i3.state = e2), this._loadTile(i3, this._tileLoaded.bind(this, i3, t3, e2)));
          }
          _tileLoaded(e2, i3, s3, a3) {
            if (a3) return e2.state = "errored", void (404 !== a3.status ? this._source.fire(new t2.j(a3, { tile: e2 })) : this.update(this.transform, this.terrain));
            e2.timeAdded = t2.h.now(), "expired" === s3 && (e2.refreshedUponExpiration = true), this._setTileReloadTimer(i3, e2), "raster-dem" === this.getSource().type && e2.dem && this._backfillDEM(e2), this._state.initializeTileState(e2, this.map ? this.map.painter : null), e2.aborted || this._source.fire(new t2.k("data", { dataType: "source", tile: e2, coord: e2.tileID }));
          }
          _backfillDEM(t3) {
            const e2 = this.getRenderableIds();
            for (let s3 = 0; s3 < e2.length; s3++) {
              const a3 = e2[s3];
              if (t3.neighboringTiles && t3.neighboringTiles[a3]) {
                const e3 = this.getTileByID(a3);
                i3(t3, e3), i3(e3, t3);
              }
            }
            function i3(t4, e3) {
              t4.needsHillshadePrepare = true, t4.needsTerrainPrepare = true;
              let i4 = e3.tileID.canonical.x - t4.tileID.canonical.x;
              const s3 = e3.tileID.canonical.y - t4.tileID.canonical.y, a3 = Math.pow(2, t4.tileID.canonical.z), o3 = e3.tileID.key;
              0 === i4 && 0 === s3 || Math.abs(s3) > 1 || (Math.abs(i4) > 1 && (1 === Math.abs(i4 + a3) ? i4 += a3 : 1 === Math.abs(i4 - a3) && (i4 -= a3)), e3.dem && t4.dem && (t4.dem.backfillBorder(e3.dem, i4, s3), t4.neighboringTiles && t4.neighboringTiles[o3] && (t4.neighboringTiles[o3].backfilled = true)));
            }
          }
          getTile(t3) {
            return this.getTileByID(t3.key);
          }
          getTileByID(t3) {
            return this._tiles[t3];
          }
          _retainLoadedChildren(t3, e2, i3, s3) {
            for (const a3 in this._tiles) {
              let o3 = this._tiles[a3];
              if (s3[a3] || !o3.hasData() || o3.tileID.overscaledZ <= e2 || o3.tileID.overscaledZ > i3) continue;
              let r3 = o3.tileID;
              for (; o3 && o3.tileID.overscaledZ > e2 + 1; ) {
                const t4 = o3.tileID.scaledTo(o3.tileID.overscaledZ - 1);
                o3 = this._tiles[t4.key], o3 && o3.hasData() && (r3 = t4);
              }
              let n3 = r3;
              for (; n3.overscaledZ > e2; ) if (n3 = n3.scaledTo(n3.overscaledZ - 1), t3[n3.key]) {
                s3[r3.key] = r3;
                break;
              }
            }
          }
          findLoadedParent(t3, e2) {
            if (t3.key in this._loadedParentTiles) {
              const i3 = this._loadedParentTiles[t3.key];
              return i3 && i3.tileID.overscaledZ >= e2 ? i3 : null;
            }
            for (let i3 = t3.overscaledZ - 1; i3 >= e2; i3--) {
              const e3 = t3.scaledTo(i3), s3 = this._getLoadedTile(e3);
              if (s3) return s3;
            }
          }
          _getLoadedTile(t3) {
            const e2 = this._tiles[t3.key];
            return e2 && e2.hasData() ? e2 : this._cache.getByKey(t3.wrapped().key);
          }
          updateCacheSize(e2) {
            const i3 = Math.ceil(e2.width / this._source.tileSize) + 1, s3 = Math.ceil(e2.height / this._source.tileSize) + 1, a3 = Math.floor(i3 * s3 * (null === this._maxTileCacheZoomLevels ? t2.c.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o3 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, a3) : a3;
            this._cache.setMaxSize(o3);
          }
          handleWrapJump(t3) {
            const e2 = Math.round((t3 - (void 0 === this._prevLng ? t3 : this._prevLng)) / 360);
            if (this._prevLng = t3, e2) {
              const t4 = {};
              for (const i3 in this._tiles) {
                const s3 = this._tiles[i3];
                s3.tileID = s3.tileID.unwrapTo(s3.tileID.wrap + e2), t4[s3.tileID.key] = s3;
              }
              this._tiles = t4;
              for (const t5 in this._timers) clearTimeout(this._timers[t5]), delete this._timers[t5];
              for (const t5 in this._tiles) this._setTileReloadTimer(t5, this._tiles[t5]);
            }
          }
          update(e2, i3) {
            if (this.transform = e2, this.terrain = i3, !this._sourceLoaded || this._paused) return;
            let s3;
            this.updateCacheSize(e2), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? s3 = e2.getVisibleUnwrappedCoordinates(this._source.tileID).map((e3) => new t2.O(e3.canonical.z, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y)) : (s3 = e2.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i3 }), this._source.hasTile && (s3 = s3.filter((t3) => this._source.hasTile(t3)))) : s3 = [];
            const a3 = e2.coveringZoomLevel(this._source), o3 = Math.max(a3 - K2.maxOverzooming, this._source.minzoom), r3 = Math.max(a3 + K2.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const t3 = {};
              for (const e3 of s3) if (e3.canonical.z > this._source.minzoom) {
                const i4 = e3.scaledTo(e3.canonical.z - 1);
                t3[i4.key] = i4;
                const s4 = e3.scaledTo(Math.max(this._source.minzoom, Math.min(e3.canonical.z, 5)));
                t3[s4.key] = s4;
              }
              s3 = s3.concat(Object.values(t3));
            }
            const n3 = 0 === s3.length && !this._updated && this._didEmitContent;
            this._updated = true, n3 && this.fire(new t2.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const l3 = this._updateRetainedTiles(s3, a3);
            if (Y2(this._source.type)) {
              const e3 = {}, n4 = {}, h4 = Object.keys(l3), c3 = t2.h.now();
              for (const t3 of h4) {
                const i4 = l3[t3], s4 = this._tiles[t3];
                if (!s4 || 0 !== s4.fadeEndTime && s4.fadeEndTime <= c3) continue;
                const a4 = this.findLoadedParent(i4, o3);
                a4 && (this._addTile(a4.tileID), e3[a4.tileID.key] = a4.tileID), n4[t3] = i4;
              }
              this._retainLoadedChildren(n4, a3, r3, l3);
              for (const t3 in e3) l3[t3] || (this._coveredTiles[t3] = true, l3[t3] = e3[t3]);
              if (i3) {
                const t3 = {}, e4 = {};
                for (const i4 of s3) this._tiles[i4.key].hasData() ? t3[i4.key] = i4 : e4[i4.key] = i4;
                for (const i4 in e4) {
                  const s4 = e4[i4].children(this._source.maxzoom);
                  this._tiles[s4[0].key] && this._tiles[s4[1].key] && this._tiles[s4[2].key] && this._tiles[s4[3].key] && (t3[s4[0].key] = l3[s4[0].key] = s4[0], t3[s4[1].key] = l3[s4[1].key] = s4[1], t3[s4[2].key] = l3[s4[2].key] = s4[2], t3[s4[3].key] = l3[s4[3].key] = s4[3], delete e4[i4]);
                }
                for (const i4 in e4) {
                  const s4 = this.findLoadedParent(e4[i4], this._source.minzoom);
                  if (s4) {
                    t3[s4.tileID.key] = l3[s4.tileID.key] = s4.tileID;
                    for (const e5 in t3) t3[e5].isChildOf(s4.tileID) && delete t3[e5];
                  }
                }
                for (const e5 in this._tiles) t3[e5] || (this._coveredTiles[e5] = true);
              }
            }
            for (const t3 in l3) this._tiles[t3].clearFadeHold();
            const h3 = t2.ab(this._tiles, l3);
            for (const t3 of h3) {
              const e3 = this._tiles[t3];
              e3.hasSymbolBuckets && !e3.holdingForFade() ? e3.setHoldDuration(this.map._fadeDuration) : e3.hasSymbolBuckets && !e3.symbolFadeFinished() || this._removeTile(t3);
            }
            this._updateLoadedParentTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const t3 in this._tiles) this._tiles[t3].holdingForFade() && this._removeTile(t3);
          }
          _updateRetainedTiles(t3, e2) {
            const i3 = {}, s3 = {}, a3 = Math.max(e2 - K2.maxOverzooming, this._source.minzoom), o3 = Math.max(e2 + K2.maxUnderzooming, this._source.minzoom), r3 = {};
            for (const s4 of t3) {
              const t4 = this._addTile(s4);
              i3[s4.key] = s4, t4.hasData() || e2 < this._source.maxzoom && (r3[s4.key] = s4);
            }
            this._retainLoadedChildren(r3, e2, o3, i3);
            for (const o4 of t3) {
              let t4 = this._tiles[o4.key];
              if (t4.hasData()) continue;
              if (e2 + 1 > this._source.maxzoom) {
                const t5 = o4.children(this._source.maxzoom)[0], e3 = this.getTile(t5);
                if (e3 && e3.hasData()) {
                  i3[t5.key] = t5;
                  continue;
                }
              } else {
                const t5 = o4.children(this._source.maxzoom);
                if (i3[t5[0].key] && i3[t5[1].key] && i3[t5[2].key] && i3[t5[3].key]) continue;
              }
              let r4 = t4.wasRequested();
              for (let e3 = o4.overscaledZ - 1; e3 >= a3; --e3) {
                const a4 = o4.scaledTo(e3);
                if (s3[a4.key]) break;
                if (s3[a4.key] = true, t4 = this.getTile(a4), !t4 && r4 && (t4 = this._addTile(a4)), t4) {
                  const e4 = t4.hasData();
                  if ((r4 || e4) && (i3[a4.key] = a4), r4 = t4.wasRequested(), e4) break;
                }
              }
            }
            return i3;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const t3 in this._tiles) {
              const e2 = [];
              let i3, s3 = this._tiles[t3].tileID;
              for (; s3.overscaledZ > 0; ) {
                if (s3.key in this._loadedParentTiles) {
                  i3 = this._loadedParentTiles[s3.key];
                  break;
                }
                e2.push(s3.key);
                const t4 = s3.scaledTo(s3.overscaledZ - 1);
                if (i3 = this._getLoadedTile(t4), i3) break;
                s3 = t4;
              }
              for (const t4 of e2) this._loadedParentTiles[t4] = i3;
            }
          }
          _addTile(e2) {
            let i3 = this._tiles[e2.key];
            if (i3) return i3;
            i3 = this._cache.getAndRemove(e2), i3 && (this._setTileReloadTimer(e2.key, i3), i3.tileID = e2, this._state.initializeTileState(i3, this.map ? this.map.painter : null), this._cacheTimers[e2.key] && (clearTimeout(this._cacheTimers[e2.key]), delete this._cacheTimers[e2.key], this._setTileReloadTimer(e2.key, i3)));
            const s3 = i3;
            return i3 || (i3 = new W2(e2, this._source.tileSize * e2.overscaleFactor()), this._loadTile(i3, this._tileLoaded.bind(this, i3, e2.key, i3.state))), i3.uses++, this._tiles[e2.key] = i3, s3 || this._source.fire(new t2.k("dataloading", { tile: i3, coord: i3.tileID, dataType: "source" })), i3;
          }
          _setTileReloadTimer(t3, e2) {
            t3 in this._timers && (clearTimeout(this._timers[t3]), delete this._timers[t3]);
            const i3 = e2.getExpiryTimeout();
            i3 && (this._timers[t3] = setTimeout(() => {
              this._reloadTile(t3, "expired"), delete this._timers[t3];
            }, i3));
          }
          _removeTile(t3) {
            const e2 = this._tiles[t3];
            e2 && (e2.uses--, delete this._tiles[t3], this._timers[t3] && (clearTimeout(this._timers[t3]), delete this._timers[t3]), e2.uses > 0 || (e2.hasData() && "reloading" !== e2.state ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const t3 in this._tiles) this._removeTile(t3);
            this._cache.reset();
          }
          tilesIn(e2, i3, s3) {
            const a3 = [], o3 = this.transform;
            if (!o3) return a3;
            const r3 = s3 ? o3.getCameraQueryGeometry(e2) : e2, n3 = e2.map((t3) => o3.pointCoordinate(t3, this.terrain)), l3 = r3.map((t3) => o3.pointCoordinate(t3, this.terrain)), h3 = this.getIds();
            let c3 = 1 / 0, u3 = 1 / 0, d3 = -1 / 0, _3 = -1 / 0;
            for (const t3 of l3) c3 = Math.min(c3, t3.x), u3 = Math.min(u3, t3.y), d3 = Math.max(d3, t3.x), _3 = Math.max(_3, t3.y);
            for (let e3 = 0; e3 < h3.length; e3++) {
              const s4 = this._tiles[h3[e3]];
              if (s4.holdingForFade()) continue;
              const r4 = s4.tileID, p3 = Math.pow(2, o3.zoom - s4.tileID.overscaledZ), m3 = i3 * s4.queryPadding * t2.N / s4.tileSize / p3, f3 = [r4.getTilePoint(new t2.U(c3, u3)), r4.getTilePoint(new t2.U(d3, _3))];
              if (f3[0].x - m3 < t2.N && f3[0].y - m3 < t2.N && f3[1].x + m3 >= 0 && f3[1].y + m3 >= 0) {
                const t3 = n3.map((t4) => r4.getTilePoint(t4)), e4 = l3.map((t4) => r4.getTilePoint(t4));
                a3.push({ tile: s4, tileID: r4, queryGeometry: t3, cameraQueryGeometry: e4, scale: p3 });
              }
            }
            return a3;
          }
          getVisibleCoordinates(t3) {
            const e2 = this.getRenderableIds(t3).map((t4) => this._tiles[t4].tileID);
            for (const t4 of e2) t4.posMatrix = this.transform.calculatePosMatrix(t4.toUnwrapped());
            return e2;
          }
          hasTransition() {
            if (this._source.hasTransition()) return true;
            if (Y2(this._source.type)) {
              const e2 = t2.h.now();
              for (const t3 in this._tiles) if (this._tiles[t3].fadeEndTime >= e2) return true;
            }
            return false;
          }
          setFeatureState(t3, e2, i3) {
            this._state.updateState(t3 = t3 || "_geojsonTileLayer", e2, i3);
          }
          removeFeatureState(t3, e2, i3) {
            this._state.removeFeatureState(t3 = t3 || "_geojsonTileLayer", e2, i3);
          }
          getFeatureState(t3, e2) {
            return this._state.getState(t3 = t3 || "_geojsonTileLayer", e2);
          }
          setDependencies(t3, e2, i3) {
            const s3 = this._tiles[t3];
            s3 && s3.setDependencies(e2, i3);
          }
          reloadTilesForDependencies(t3, e2) {
            for (const i3 in this._tiles) this._tiles[i3].hasDependency(t3, e2) && this._reloadTile(i3, "reloading");
            this._cache.filter((i3) => !i3.hasDependency(t3, e2));
          }
        }
        function Q2(t3, e2) {
          const i3 = Math.abs(2 * t3.wrap) - +(t3.wrap < 0), s3 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
          return t3.overscaledZ - e2.overscaledZ || s3 - i3 || e2.canonical.y - t3.canonical.y || e2.canonical.x - t3.canonical.x;
        }
        function Y2(t3) {
          return "raster" === t3 || "image" === t3 || "video" === t3;
        }
        K2.maxOverzooming = 10, K2.maxUnderzooming = 3;
        const J2 = "mapboxgl_preloaded_worker_pool";
        class tt {
          constructor() {
            this.active = {};
          }
          acquire(e2) {
            if (!this.workers) for (this.workers = []; this.workers.length < tt.workerCount; ) this.workers.push(new Worker(t2.c.WORKER_URL));
            return this.active[e2] = true, this.workers.slice();
          }
          release(t3) {
            delete this.active[t3], 0 === this.numActive() && (this.workers.forEach((t4) => {
              t4.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[J2];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const et = Math.floor(t2.h.hardwareConcurrency / 2);
        let it;
        function st() {
          return it || (it = new tt()), it;
        }
        tt.workerCount = t2.ac(globalThis) ? Math.max(Math.min(et, 3), 1) : 1;
        class at {
          constructor(t3, e2) {
            this.reset(t3, e2);
          }
          reset(t3, e2) {
            this.points = t3 || [], this._distances = [0];
            for (let t4 = 1; t4 < this.points.length; t4++) this._distances[t4] = this._distances[t4 - 1] + this.points[t4].dist(this.points[t4 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e2) {
            if (1 === this.points.length) return this.points[0];
            e2 = t2.ad(e2, 0, 1);
            let i3 = 1, s3 = this._distances[i3];
            const a3 = e2 * this.paddedLength + this.padding;
            for (; s3 < a3 && i3 < this._distances.length; ) s3 = this._distances[++i3];
            const o3 = i3 - 1, r3 = this._distances[o3], n3 = s3 - r3, l3 = n3 > 0 ? (a3 - r3) / n3 : 0;
            return this.points[o3].mult(1 - l3).add(this.points[i3].mult(l3));
          }
        }
        function ot(t3, e2) {
          let i3 = true;
          return "always" === t3 || "never" !== t3 && "never" !== e2 || (i3 = false), i3;
        }
        class rt {
          constructor(t3, e2, i3) {
            const s3 = this.boxCells = [], a3 = this.circleCells = [];
            this.xCellCount = Math.ceil(t3 / i3), this.yCellCount = Math.ceil(e2 / i3);
            for (let t4 = 0; t4 < this.xCellCount * this.yCellCount; t4++) s3.push([]), a3.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t3, this.height = e2, this.xScale = this.xCellCount / t3, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(t3, e2, i3, s3, a3) {
            this._forEachCell(e2, i3, s3, a3, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t3), this.bboxes.push(e2), this.bboxes.push(i3), this.bboxes.push(s3), this.bboxes.push(a3);
          }
          insertCircle(t3, e2, i3, s3) {
            this._forEachCell(e2 - s3, i3 - s3, e2 + s3, i3 + s3, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t3), this.circles.push(e2), this.circles.push(i3), this.circles.push(s3);
          }
          _insertBoxCell(t3, e2, i3, s3, a3, o3) {
            this.boxCells[a3].push(o3);
          }
          _insertCircleCell(t3, e2, i3, s3, a3, o3) {
            this.circleCells[a3].push(o3);
          }
          _query(t3, e2, i3, s3, a3, o3, r3) {
            if (i3 < 0 || t3 > this.width || s3 < 0 || e2 > this.height) return [];
            const n3 = [];
            if (t3 <= 0 && e2 <= 0 && this.width <= i3 && this.height <= s3) {
              if (a3) return [{ key: null, x1: t3, y1: e2, x2: i3, y2: s3 }];
              for (let t4 = 0; t4 < this.boxKeys.length; t4++) n3.push({ key: this.boxKeys[t4], x1: this.bboxes[4 * t4], y1: this.bboxes[4 * t4 + 1], x2: this.bboxes[4 * t4 + 2], y2: this.bboxes[4 * t4 + 3] });
              for (let t4 = 0; t4 < this.circleKeys.length; t4++) {
                const e3 = this.circles[3 * t4], i4 = this.circles[3 * t4 + 1], s4 = this.circles[3 * t4 + 2];
                n3.push({ key: this.circleKeys[t4], x1: e3 - s4, y1: i4 - s4, x2: e3 + s4, y2: i4 + s4 });
              }
            } else this._forEachCell(t3, e2, i3, s3, this._queryCell, n3, { hitTest: a3, overlapMode: o3, seenUids: { box: {}, circle: {} } }, r3);
            return n3;
          }
          query(t3, e2, i3, s3) {
            return this._query(t3, e2, i3, s3, false, null);
          }
          hitTest(t3, e2, i3, s3, a3, o3) {
            return this._query(t3, e2, i3, s3, true, a3, o3).length > 0;
          }
          hitTestCircle(t3, e2, i3, s3, a3) {
            const o3 = t3 - i3, r3 = t3 + i3, n3 = e2 - i3, l3 = e2 + i3;
            if (r3 < 0 || o3 > this.width || l3 < 0 || n3 > this.height) return false;
            const h3 = [];
            return this._forEachCell(o3, n3, r3, l3, this._queryCellCircle, h3, { hitTest: true, overlapMode: s3, circle: { x: t3, y: e2, radius: i3 }, seenUids: { box: {}, circle: {} } }, a3), h3.length > 0;
          }
          _queryCell(t3, e2, i3, s3, a3, o3, r3, n3) {
            const { seenUids: l3, hitTest: h3, overlapMode: c3 } = r3, u3 = this.boxCells[a3];
            if (null !== u3) {
              const a4 = this.bboxes;
              for (const r4 of u3) if (!l3.box[r4]) {
                l3.box[r4] = true;
                const u4 = 4 * r4, d4 = this.boxKeys[r4];
                if (t3 <= a4[u4 + 2] && e2 <= a4[u4 + 3] && i3 >= a4[u4 + 0] && s3 >= a4[u4 + 1] && (!n3 || n3(d4)) && (!h3 || !ot(c3, d4.overlapMode)) && (o3.push({ key: d4, x1: a4[u4], y1: a4[u4 + 1], x2: a4[u4 + 2], y2: a4[u4 + 3] }), h3)) return true;
              }
            }
            const d3 = this.circleCells[a3];
            if (null !== d3) {
              const a4 = this.circles;
              for (const r4 of d3) if (!l3.circle[r4]) {
                l3.circle[r4] = true;
                const u4 = 3 * r4, d4 = this.circleKeys[r4];
                if (this._circleAndRectCollide(a4[u4], a4[u4 + 1], a4[u4 + 2], t3, e2, i3, s3) && (!n3 || n3(d4)) && (!h3 || !ot(c3, d4.overlapMode))) {
                  const t4 = a4[u4], e3 = a4[u4 + 1], i4 = a4[u4 + 2];
                  if (o3.push({ key: d4, x1: t4 - i4, y1: e3 - i4, x2: t4 + i4, y2: e3 + i4 }), h3) return true;
                }
              }
            }
            return false;
          }
          _queryCellCircle(t3, e2, i3, s3, a3, o3, r3, n3) {
            const { circle: l3, seenUids: h3, overlapMode: c3 } = r3, u3 = this.boxCells[a3];
            if (null !== u3) {
              const t4 = this.bboxes;
              for (const e3 of u3) if (!h3.box[e3]) {
                h3.box[e3] = true;
                const i4 = 4 * e3, s4 = this.boxKeys[e3];
                if (this._circleAndRectCollide(l3.x, l3.y, l3.radius, t4[i4 + 0], t4[i4 + 1], t4[i4 + 2], t4[i4 + 3]) && (!n3 || n3(s4)) && !ot(c3, s4.overlapMode)) return o3.push(true), true;
              }
            }
            const d3 = this.circleCells[a3];
            if (null !== d3) {
              const t4 = this.circles;
              for (const e3 of d3) if (!h3.circle[e3]) {
                h3.circle[e3] = true;
                const i4 = 3 * e3, s4 = this.circleKeys[e3];
                if (this._circlesCollide(t4[i4], t4[i4 + 1], t4[i4 + 2], l3.x, l3.y, l3.radius) && (!n3 || n3(s4)) && !ot(c3, s4.overlapMode)) return o3.push(true), true;
              }
            }
          }
          _forEachCell(t3, e2, i3, s3, a3, o3, r3, n3) {
            const l3 = this._convertToXCellCoord(t3), h3 = this._convertToYCellCoord(e2), c3 = this._convertToXCellCoord(i3), u3 = this._convertToYCellCoord(s3);
            for (let d3 = l3; d3 <= c3; d3++) for (let l4 = h3; l4 <= u3; l4++) if (a3.call(this, t3, e2, i3, s3, this.xCellCount * l4 + d3, o3, r3, n3)) return;
          }
          _convertToXCellCoord(t3) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t3 * this.xScale)));
          }
          _convertToYCellCoord(t3) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t3 * this.yScale)));
          }
          _circlesCollide(t3, e2, i3, s3, a3, o3) {
            const r3 = s3 - t3, n3 = a3 - e2, l3 = i3 + o3;
            return l3 * l3 > r3 * r3 + n3 * n3;
          }
          _circleAndRectCollide(t3, e2, i3, s3, a3, o3, r3) {
            const n3 = (o3 - s3) / 2, l3 = Math.abs(t3 - (s3 + n3));
            if (l3 > n3 + i3) return false;
            const h3 = (r3 - a3) / 2, c3 = Math.abs(e2 - (a3 + h3));
            if (c3 > h3 + i3) return false;
            if (l3 <= n3 || c3 <= h3) return true;
            const u3 = l3 - n3, d3 = c3 - h3;
            return u3 * u3 + d3 * d3 <= i3 * i3;
          }
        }
        function nt(e2, i3, s3, a3, o3) {
          const r3 = t2.Z();
          return i3 ? (t2.a0(r3, r3, [1 / o3, 1 / o3, 1]), s3 || t2.ae(r3, r3, a3.angle)) : t2.a1(r3, a3.labelPlaneMatrix, e2), r3;
        }
        function lt(e2, i3, s3, a3, o3) {
          if (i3) {
            const i4 = t2.af(e2);
            return t2.a0(i4, i4, [o3, o3, 1]), s3 || t2.ae(i4, i4, -a3.angle), i4;
          }
          return a3.glCoordMatrix;
        }
        function ht(e2, i3, s3) {
          let a3;
          s3 ? (a3 = [e2.x, e2.y, s3(e2.x, e2.y), 1], t2.ag(a3, a3, i3)) : (a3 = [e2.x, e2.y, 0, 1], Tt(a3, a3, i3));
          const o3 = a3[3];
          return { point: new t2.P(a3[0] / o3, a3[1] / o3), signedDistanceFromCamera: o3 };
        }
        function ct(t3, e2) {
          return 0.5 + t3 / e2 * 0.5;
        }
        function ut(t3, e2) {
          const i3 = t3[0] / t3[3], s3 = t3[1] / t3[3];
          return i3 >= -e2[0] && i3 <= e2[0] && s3 >= -e2[1] && s3 <= e2[1];
        }
        function dt(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3) {
          const u3 = a3 ? e2.textSizeData : e2.iconSizeData, d3 = t2.ah(u3, s3.transform.zoom), _3 = [256 / s3.width * 2 + 1, 256 / s3.height * 2 + 1], p3 = a3 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
          p3.clear();
          const m3 = e2.lineVertexArray, f3 = a3 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, g3 = s3.transform.width / s3.transform.height;
          let v3 = false;
          for (let a4 = 0; a4 < f3.length; a4++) {
            const x3 = f3.get(a4);
            if (x3.hidden || x3.writingMode === t2.ai.vertical && !v3) {
              wt(x3.numGlyphs, p3);
              continue;
            }
            let y3;
            if (v3 = false, c3 ? (y3 = [x3.anchorX, x3.anchorY, c3(x3.anchorX, x3.anchorY), 1], t2.ag(y3, y3, i3)) : (y3 = [x3.anchorX, x3.anchorY, 0, 1], Tt(y3, y3, i3)), !ut(y3, _3)) {
              wt(x3.numGlyphs, p3);
              continue;
            }
            const b3 = ct(s3.transform.cameraToCenterDistance, y3[3]), w3 = t2.aj(u3, d3, x3), T3 = n3 ? w3 / b3 : w3 * b3, I3 = new t2.P(x3.anchorX, x3.anchorY), E3 = ht(I3, o3, c3).point, S3 = { projections: {}, offsets: {} }, C3 = mt(x3, T3, false, l3, i3, o3, r3, e2.glyphOffsetArray, m3, p3, E3, I3, S3, g3, h3, c3);
            v3 = C3.useVertical, (C3.notEnoughRoom || v3 || C3.needsFlipping && mt(x3, T3, true, l3, i3, o3, r3, e2.glyphOffsetArray, m3, p3, E3, I3, S3, g3, h3, c3).notEnoughRoom) && wt(x3.numGlyphs, p3);
          }
          a3 ? e2.text.dynamicLayoutVertexBuffer.updateData(p3) : e2.icon.dynamicLayoutVertexBuffer.updateData(p3);
        }
        function _t(t3, e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3) {
          const _3 = n3.glyphStartIndex + n3.numGlyphs, p3 = n3.lineStartIndex, m3 = n3.lineStartIndex + n3.lineLength, f3 = e2.getoffsetX(n3.glyphStartIndex), g3 = e2.getoffsetX(_3 - 1), v3 = yt(t3 * f3, i3, s3, a3, o3, r3, n3.segment, p3, m3, l3, h3, c3, u3, d3);
          if (!v3) return null;
          const x3 = yt(t3 * g3, i3, s3, a3, o3, r3, n3.segment, p3, m3, l3, h3, c3, u3, d3);
          return x3 ? { first: v3, last: x3 } : null;
        }
        function pt(e2, i3, s3, a3) {
          return e2 === t2.ai.horizontal && Math.abs(s3.y - i3.y) > Math.abs(s3.x - i3.x) * a3 ? { useVertical: true } : (e2 === t2.ai.vertical ? i3.y < s3.y : i3.x > s3.x) ? { needsFlipping: true } : null;
        }
        function mt(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3, _3, p3, m3, f3) {
          const g3 = i3 / 24, v3 = e2.lineOffsetX * g3, x3 = e2.lineOffsetY * g3;
          let y3;
          if (e2.numGlyphs > 1) {
            const t3 = e2.glyphStartIndex + e2.numGlyphs, i4 = e2.lineStartIndex, o4 = e2.lineStartIndex + e2.lineLength, c4 = _t(g3, l3, v3, x3, s3, u3, d3, e2, h3, r3, _3, m3, f3);
            if (!c4) return { notEnoughRoom: true };
            const b3 = ht(c4.first.point, n3, f3).point, w3 = ht(c4.last.point, n3, f3).point;
            if (a3 && !s3) {
              const t4 = pt(e2.writingMode, b3, w3, p3);
              if (t4) return t4;
            }
            y3 = [c4.first];
            for (let a4 = e2.glyphStartIndex + 1; a4 < t3 - 1; a4++) y3.push(yt(g3 * l3.getoffsetX(a4), v3, x3, s3, u3, d3, e2.segment, i4, o4, h3, r3, _3, m3, f3));
            y3.push(c4.last);
          } else {
            if (a3 && !s3) {
              const i5 = ht(d3, o3, f3).point, s4 = e2.lineStartIndex + e2.segment + 1, a4 = new t2.P(h3.getx(s4), h3.gety(s4)), r4 = ht(a4, o3, f3), n4 = r4.signedDistanceFromCamera > 0 ? r4.point : ft(d3, a4, i5, 1, o3, f3), l4 = pt(e2.writingMode, i5, n4, p3);
              if (l4) return l4;
            }
            const i4 = yt(g3 * l3.getoffsetX(e2.glyphStartIndex), v3, x3, s3, u3, d3, e2.segment, e2.lineStartIndex, e2.lineStartIndex + e2.lineLength, h3, r3, _3, m3, f3);
            if (!i4) return { notEnoughRoom: true };
            y3 = [i4];
          }
          for (const e3 of y3) t2.ak(c3, e3.point, e3.angle);
          return {};
        }
        function ft(t3, e2, i3, s3, a3, o3) {
          const r3 = ht(t3.add(t3.sub(e2)._unit()), a3, o3).point, n3 = i3.sub(r3);
          return i3.add(n3._mult(s3 / n3.mag()));
        }
        function gt(e2, i3) {
          const { projectionCache: s3, lineVertexArray: a3, labelPlaneMatrix: o3, tileAnchorPoint: r3, distanceFromAnchor: n3, getElevation: l3, previousVertex: h3, direction: c3, absOffsetX: u3 } = i3;
          if (s3.projections[e2]) return s3.projections[e2];
          const d3 = new t2.P(a3.getx(e2), a3.gety(e2)), _3 = ht(d3, o3, l3);
          if (_3.signedDistanceFromCamera > 0) return s3.projections[e2] = _3.point, _3.point;
          const p3 = e2 - c3;
          return ft(0 === n3 ? r3 : new t2.P(a3.getx(p3), a3.gety(p3)), d3, h3, u3 - n3 + 1, o3, l3);
        }
        function vt(t3, e2, i3) {
          return t3._unit()._perp()._mult(e2 * i3);
        }
        function xt(e2, i3, s3, a3, o3, r3, n3, l3) {
          const { projectionCache: h3, direction: c3 } = l3;
          if (h3.offsets[e2]) return h3.offsets[e2];
          const u3 = s3.add(i3);
          if (e2 + c3 < a3 || e2 + c3 >= o3) return h3.offsets[e2] = u3, u3;
          const d3 = gt(e2 + c3, l3), _3 = vt(d3.sub(s3), n3, c3), p3 = s3.add(_3), m3 = d3.add(_3);
          return h3.offsets[e2] = t2.al(r3, u3, p3, m3) || u3, h3.offsets[e2];
        }
        function yt(t3, e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3, _3) {
          const p3 = s3 ? t3 - e2 : t3 + e2;
          let m3 = p3 > 0 ? 1 : -1, f3 = 0;
          s3 && (m3 *= -1, f3 = Math.PI), m3 < 0 && (f3 += Math.PI);
          let g3, v3, x3 = m3 > 0 ? n3 + r3 : n3 + r3 + 1, y3 = a3, b3 = a3, w3 = 0, T3 = 0;
          const I3 = Math.abs(p3), E3 = [];
          let S3;
          for (; w3 + T3 <= I3; ) {
            if (x3 += m3, x3 < n3 || x3 >= l3) return null;
            w3 += T3, b3 = y3, v3 = g3;
            const t4 = { projectionCache: u3, lineVertexArray: h3, labelPlaneMatrix: c3, tileAnchorPoint: o3, distanceFromAnchor: w3, getElevation: _3, previousVertex: b3, direction: m3, absOffsetX: I3 };
            if (y3 = gt(x3, t4), 0 === i3) E3.push(b3), S3 = y3.sub(b3);
            else {
              let e3;
              const s4 = y3.sub(b3);
              e3 = 0 === s4.mag() ? vt(gt(x3 + m3, t4).sub(y3), i3, m3) : vt(s4, i3, m3), v3 || (v3 = b3.add(e3)), g3 = xt(x3, e3, y3, n3, l3, v3, i3, t4), E3.push(v3), S3 = g3.sub(v3);
            }
            T3 = S3.mag();
          }
          const C3 = S3._mult((I3 - w3) / T3)._add(v3 || b3), P3 = f3 + Math.atan2(y3.y - b3.y, y3.x - b3.x);
          return E3.push(C3), { point: C3, angle: d3 ? P3 : 0, path: E3 };
        }
        const bt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function wt(t3, e2) {
          for (let i3 = 0; i3 < t3; i3++) {
            const t4 = e2.length;
            e2.resize(t4 + 4), e2.float32.set(bt, 3 * t4);
          }
        }
        function Tt(t3, e2, i3) {
          const s3 = e2[0], a3 = e2[1];
          return t3[0] = i3[0] * s3 + i3[4] * a3 + i3[12], t3[1] = i3[1] * s3 + i3[5] * a3 + i3[13], t3[3] = i3[3] * s3 + i3[7] * a3 + i3[15], t3;
        }
        const It = 100;
        class Et {
          constructor(t3, e2 = new rt(t3.width + 200, t3.height + 200, 25), i3 = new rt(t3.width + 200, t3.height + 200, 25)) {
            this.transform = t3, this.grid = e2, this.ignoredGrid = i3, this.pitchfactor = Math.cos(t3._pitch) * t3.cameraToCenterDistance, this.screenRightBoundary = t3.width + It, this.screenBottomBoundary = t3.height + It, this.gridRightBoundary = t3.width + 200, this.gridBottomBoundary = t3.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(t3, e2, i3, s3, a3, o3) {
            const r3 = this.projectAndGetPerspectiveRatio(s3, t3.anchorPointX, t3.anchorPointY, o3), n3 = i3 * r3.perspectiveRatio, l3 = t3.x1 * n3 + r3.point.x, h3 = t3.y1 * n3 + r3.point.y, c3 = t3.x2 * n3 + r3.point.x, u3 = t3.y2 * n3 + r3.point.y;
            return !this.isInsideGrid(l3, h3, c3, u3) || "always" !== e2 && this.grid.hitTest(l3, h3, c3, u3, e2, a3) || r3.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: false } : { box: [l3, h3, c3, u3], offscreen: this.isOffscreen(l3, h3, c3, u3) };
          }
          placeCollisionCircles(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3, _3, p3) {
            const m3 = [], f3 = new t2.P(i3.anchorX, i3.anchorY), g3 = ht(f3, r3, p3), v3 = ct(this.transform.cameraToCenterDistance, g3.signedDistanceFromCamera), x3 = (c3 ? o3 / v3 : o3 * v3) / t2.ap, y3 = ht(f3, n3, p3).point, b3 = _t(x3, a3, i3.lineOffsetX * x3, i3.lineOffsetY * x3, false, y3, f3, i3, s3, n3, { projections: {}, offsets: {} }, false, p3);
            let w3 = false, T3 = false, I3 = true;
            if (b3) {
              const i4 = 0.5 * d3 * v3 + _3, s4 = new t2.P(-100, -100), a4 = new t2.P(this.screenRightBoundary, this.screenBottomBoundary), o4 = new at(), r4 = b3.first, n4 = b3.last;
              let c4 = [];
              for (let t3 = r4.path.length - 1; t3 >= 1; t3--) c4.push(r4.path[t3]);
              for (let t3 = 1; t3 < n4.path.length; t3++) c4.push(n4.path[t3]);
              const f4 = 2.5 * i4;
              if (l3) {
                const t3 = c4.map((t4) => ht(t4, l3, p3));
                c4 = t3.some((t4) => t4.signedDistanceFromCamera <= 0) ? [] : t3.map((t4) => t4.point);
              }
              let g4 = [];
              if (c4.length > 0) {
                const e3 = c4[0].clone(), i5 = c4[0].clone();
                for (let t3 = 1; t3 < c4.length; t3++) e3.x = Math.min(e3.x, c4[t3].x), e3.y = Math.min(e3.y, c4[t3].y), i5.x = Math.max(i5.x, c4[t3].x), i5.y = Math.max(i5.y, c4[t3].y);
                g4 = e3.x >= s4.x && i5.x <= a4.x && e3.y >= s4.y && i5.y <= a4.y ? [c4] : i5.x < s4.x || e3.x > a4.x || i5.y < s4.y || e3.y > a4.y ? [] : t2.am([c4], s4.x, s4.y, a4.x, a4.y);
              }
              for (const t3 of g4) {
                o4.reset(t3, 0.25 * i4);
                let s5 = 0;
                s5 = o4.length <= 0.5 * i4 ? 1 : Math.ceil(o4.paddedLength / f4) + 1;
                for (let t4 = 0; t4 < s5; t4++) {
                  const a5 = t4 / Math.max(s5 - 1, 1), r5 = o4.lerp(a5), n5 = r5.x + It, l4 = r5.y + It;
                  m3.push(n5, l4, i4, 0);
                  const c5 = n5 - i4, d4 = l4 - i4, _4 = n5 + i4, p4 = l4 + i4;
                  if (I3 = I3 && this.isOffscreen(c5, d4, _4, p4), T3 = T3 || this.isInsideGrid(c5, d4, _4, p4), "always" !== e2 && this.grid.hitTestCircle(n5, l4, i4, e2, u3) && (w3 = true, !h3)) return { circles: [], offscreen: false, collisionDetected: w3 };
                }
              }
            }
            return { circles: !h3 && w3 || !T3 || v3 < this.perspectiveRatioCutoff ? [] : m3, offscreen: I3, collisionDetected: w3 };
          }
          queryRenderedSymbols(e2) {
            if (0 === e2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
            const i3 = [];
            let s3 = 1 / 0, a3 = 1 / 0, o3 = -1 / 0, r3 = -1 / 0;
            for (const n4 of e2) {
              const e3 = new t2.P(n4.x + It, n4.y + It);
              s3 = Math.min(s3, e3.x), a3 = Math.min(a3, e3.y), o3 = Math.max(o3, e3.x), r3 = Math.max(r3, e3.y), i3.push(e3);
            }
            const n3 = this.grid.query(s3, a3, o3, r3).concat(this.ignoredGrid.query(s3, a3, o3, r3)), l3 = {}, h3 = {};
            for (const e3 of n3) {
              const s4 = e3.key;
              if (void 0 === l3[s4.bucketInstanceId] && (l3[s4.bucketInstanceId] = {}), l3[s4.bucketInstanceId][s4.featureIndex]) continue;
              const a4 = [new t2.P(e3.x1, e3.y1), new t2.P(e3.x2, e3.y1), new t2.P(e3.x2, e3.y2), new t2.P(e3.x1, e3.y2)];
              t2.an(i3, a4) && (l3[s4.bucketInstanceId][s4.featureIndex] = true, void 0 === h3[s4.bucketInstanceId] && (h3[s4.bucketInstanceId] = []), h3[s4.bucketInstanceId].push(s4.featureIndex));
            }
            return h3;
          }
          insertCollisionBox(t3, e2, i3, s3, a3, o3) {
            (i3 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: s3, featureIndex: a3, collisionGroupID: o3, overlapMode: e2 }, t3[0], t3[1], t3[2], t3[3]);
          }
          insertCollisionCircles(t3, e2, i3, s3, a3, o3) {
            const r3 = i3 ? this.ignoredGrid : this.grid, n3 = { bucketInstanceId: s3, featureIndex: a3, collisionGroupID: o3, overlapMode: e2 };
            for (let e3 = 0; e3 < t3.length; e3 += 4) r3.insertCircle(n3, t3[e3], t3[e3 + 1], t3[e3 + 2]);
          }
          projectAndGetPerspectiveRatio(e2, i3, s3, a3) {
            let o3;
            return a3 ? (o3 = [i3, s3, a3(i3, s3), 1], t2.ag(o3, o3, e2)) : (o3 = [i3, s3, 0, 1], Tt(o3, o3, e2)), { point: new t2.P((o3[0] / o3[3] + 1) / 2 * this.transform.width + It, (-o3[1] / o3[3] + 1) / 2 * this.transform.height + It), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / o3[3] * 0.5 };
          }
          isOffscreen(t3, e2, i3, s3) {
            return i3 < It || t3 >= this.screenRightBoundary || s3 < It || e2 > this.screenBottomBoundary;
          }
          isInsideGrid(t3, e2, i3, s3) {
            return i3 >= 0 && t3 < this.gridRightBoundary && s3 >= 0 && e2 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e2 = t2.ao([]);
            return t2.$(e2, e2, [-100, -100, 0]), e2;
          }
        }
        function St(e2, i3, s3) {
          return i3 * (t2.N / (e2.tileSize * Math.pow(2, s3 - e2.tileID.overscaledZ)));
        }
        class Ct {
          constructor(t3, e2, i3, s3) {
            this.opacity = t3 ? Math.max(0, Math.min(1, t3.opacity + (t3.placed ? e2 : -e2))) : s3 && i3 ? 1 : 0, this.placed = i3;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class Pt {
          constructor(t3, e2, i3, s3, a3) {
            this.text = new Ct(t3 ? t3.text : null, e2, i3, a3), this.icon = new Ct(t3 ? t3.icon : null, e2, s3, a3);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Dt {
          constructor(t3, e2, i3) {
            this.text = t3, this.icon = e2, this.skipFade = i3;
          }
        }
        class Mt {
          constructor() {
            this.invProjMatrix = t2.Z(), this.viewportMatrix = t2.Z(), this.circles = [];
          }
        }
        class zt {
          constructor(t3, e2, i3, s3, a3) {
            this.bucketInstanceId = t3, this.featureIndex = e2, this.sourceLayerIndex = i3, this.bucketIndex = s3, this.tileID = a3;
          }
        }
        class Lt {
          constructor(t3) {
            this.crossSourceCollisions = t3, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(t3) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[t3]) {
              const e2 = ++this.maxGroupID;
              this.collisionGroups[t3] = { ID: e2, predicate: (t4) => t4.collisionGroupID === e2 };
            }
            return this.collisionGroups[t3];
          }
        }
        function At(e2, i3, s3, a3, o3) {
          const { horizontalAlign: r3, verticalAlign: n3 } = t2.au(e2);
          return new t2.P(-(r3 - 0.5) * i3 + a3[0] * o3, -(n3 - 0.5) * s3 + a3[1] * o3);
        }
        function Rt(e2, i3, s3, a3, o3, r3) {
          const { x1: n3, x2: l3, y1: h3, y2: c3, anchorPointX: u3, anchorPointY: d3 } = e2, _3 = new t2.P(i3, s3);
          return a3 && _3._rotate(o3 ? r3 : -r3), { x1: n3 + _3.x, y1: h3 + _3.y, x2: l3 + _3.x, y2: c3 + _3.y, anchorPointX: u3, anchorPointY: d3 };
        }
        class kt {
          constructor(t3, e2, i3, s3, a3) {
            this.transform = t3.clone(), this.terrain = e2, this.collisionIndex = new Et(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i3, this.retainedQueryData = {}, this.collisionGroups = new Lt(s3), this.collisionCircleArrays = {}, this.prevPlacement = a3, a3 && (a3.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(e2, i3, s3, a3) {
            const o3 = s3.getBucket(i3), r3 = s3.latestFeatureIndex;
            if (!o3 || !r3 || i3.id !== o3.layerIds[0]) return;
            const n3 = s3.collisionBoxArray, l3 = o3.layers[0].layout, h3 = Math.pow(2, this.transform.zoom - s3.tileID.overscaledZ), c3 = s3.tileSize / t2.N, u3 = this.transform.calculatePosMatrix(s3.tileID.toUnwrapped()), d3 = "map" === l3.get("text-pitch-alignment"), _3 = "map" === l3.get("text-rotation-alignment"), p3 = St(s3, 1, this.transform.zoom), m3 = nt(u3, d3, _3, this.transform, p3);
            let f3 = null;
            if (d3) {
              const e3 = lt(u3, d3, _3, this.transform, p3);
              f3 = t2.a1([], this.transform.labelPlaneMatrix, e3);
            }
            this.retainedQueryData[o3.bucketInstanceId] = new zt(o3.bucketInstanceId, r3, o3.sourceLayerIndex, o3.index, s3.tileID);
            const g3 = { bucket: o3, layout: l3, posMatrix: u3, textLabelPlaneMatrix: m3, labelToScreenMatrix: f3, scale: h3, textPixelRatio: c3, holdingForFade: s3.holdingForFade(), collisionBoxArray: n3, partiallyEvaluatedTextSize: t2.ah(o3.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o3.sourceID) };
            if (a3) for (const t3 of o3.sortKeyRanges) {
              const { sortKey: i4, symbolInstanceStart: s4, symbolInstanceEnd: a4 } = t3;
              e2.push({ sortKey: i4, symbolInstanceStart: s4, symbolInstanceEnd: a4, parameters: g3 });
            }
            else e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: o3.symbolInstances.length, parameters: g3 });
          }
          attemptAnchorPlacement(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3, _3, p3, m3, f3) {
            const g3 = t2.aq[e2.textAnchor], v3 = [e2.textOffset0, e2.textOffset1], x3 = At(g3, s3, a3, v3, o3), y3 = this.collisionIndex.placeCollisionBox(Rt(i3, x3.x, x3.y, r3, n3, this.transform.angle), u3, l3, h3, c3.predicate, f3);
            if ((!m3 || 0 !== this.collisionIndex.placeCollisionBox(Rt(m3, x3.x, x3.y, r3, n3, this.transform.angle), u3, l3, h3, c3.predicate, f3).box.length) && y3.box.length > 0) {
              let t3;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[d3.crossTileID] && this.prevPlacement.placements[d3.crossTileID] && this.prevPlacement.placements[d3.crossTileID].text && (t3 = this.prevPlacement.variableOffsets[d3.crossTileID].anchor), 0 === d3.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[d3.crossTileID] = { textOffset: v3, width: s3, height: a3, anchor: g3, textBoxScale: o3, prevAnchor: t3 }, this.markUsedJustification(_3, g3, d3, p3), _3.allowVerticalPlacement && (this.markUsedOrientation(_3, p3, d3), this.placedOrientations[d3.crossTileID] = p3), { shift: x3, placedGlyphBoxes: y3 };
            }
          }
          placeLayerBucketPart(e2, i3, s3) {
            const { bucket: a3, layout: o3, posMatrix: r3, textLabelPlaneMatrix: n3, labelToScreenMatrix: l3, textPixelRatio: h3, holdingForFade: c3, collisionBoxArray: u3, partiallyEvaluatedTextSize: d3, collisionGroup: _3 } = e2.parameters, p3 = o3.get("text-optional"), m3 = o3.get("icon-optional"), f3 = t2.ar(o3, "text-overlap", "text-allow-overlap"), g3 = "always" === f3, v3 = t2.ar(o3, "icon-overlap", "icon-allow-overlap"), x3 = "always" === v3, y3 = "map" === o3.get("text-rotation-alignment"), b3 = "map" === o3.get("text-pitch-alignment"), w3 = "none" !== o3.get("icon-text-fit"), T3 = "viewport-y" === o3.get("symbol-z-order"), I3 = g3 && (x3 || !a3.hasIconData() || m3), E3 = x3 && (g3 || !a3.hasTextData() || p3);
            !a3.collisionArrays && u3 && a3.deserializeCollisionBoxes(u3);
            const S3 = this.retainedQueryData[a3.bucketInstanceId].tileID, C3 = this.terrain ? (t3, e3) => this.terrain.getElevation(S3, t3, e3) : null, P3 = (e3, u4) => {
              var x4, T4;
              if (i3[e3.crossTileID]) return;
              if (c3) return void (this.placements[e3.crossTileID] = new Dt(false, false, false));
              let S4 = false, P4 = false, D3 = true, M3 = null, z3 = { box: null, offscreen: null }, L3 = { box: null }, A3 = null, R3 = null, k3 = null, F3 = 0, B3 = 0, O3 = 0;
              u4.textFeatureIndex ? F3 = u4.textFeatureIndex : e3.useRuntimeCollisionCircles && (F3 = e3.featureIndex), u4.verticalTextFeatureIndex && (B3 = u4.verticalTextFeatureIndex);
              const N3 = u4.textBox;
              if (N3) {
                const i4 = (i5) => {
                  let s5 = t2.ai.horizontal;
                  if (a3.allowVerticalPlacement && !i5 && this.prevPlacement) {
                    const t3 = this.prevPlacement.placedOrientations[e3.crossTileID];
                    t3 && (this.placedOrientations[e3.crossTileID] = t3, s5 = t3, this.markUsedOrientation(a3, s5, e3));
                  }
                  return s5;
                }, s4 = (i5, s5) => {
                  if (a3.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && u4.verticalTextBox) {
                    for (const e4 of a3.writingModes) if (e4 === t2.ai.vertical ? (z3 = s5(), L3 = z3) : z3 = i5(), z3 && z3.box && z3.box.length) break;
                  } else z3 = i5();
                }, o4 = e3.textAnchorOffsetStartIndex, n4 = e3.textAnchorOffsetEndIndex;
                if (n4 === o4) {
                  const o5 = (t3, i5) => {
                    const s5 = this.collisionIndex.placeCollisionBox(t3, f3, h3, r3, _3.predicate, C3);
                    return s5 && s5.box && s5.box.length && (this.markUsedOrientation(a3, i5, e3), this.placedOrientations[e3.crossTileID] = i5), s5;
                  };
                  s4(() => o5(N3, t2.ai.horizontal), () => {
                    const i5 = u4.verticalTextBox;
                    return a3.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && i5 ? o5(i5, t2.ai.vertical) : { box: null, offscreen: null };
                  }), i4(z3 && z3.box && z3.box.length);
                } else {
                  let l4 = t2.aq[null === (T4 = null === (x4 = this.prevPlacement) || void 0 === x4 ? void 0 : x4.variableOffsets[e3.crossTileID]) || void 0 === T4 ? void 0 : T4.anchor];
                  const c4 = (t3, i5, s5) => {
                    const c5 = t3.x2 - t3.x1, u5 = t3.y2 - t3.y1, d5 = e3.textBoxScale, p4 = w3 && "never" === v3 ? i5 : null;
                    let m4 = { box: [], offscreen: false }, g4 = "never" === f3 ? 1 : 2, x5 = "never";
                    l4 && g4++;
                    for (let i6 = 0; i6 < g4; i6++) {
                      for (let i7 = o4; i7 < n4; i7++) {
                        const o5 = a3.textAnchorOffsets.get(i7);
                        if (l4 && o5.textAnchor !== l4) continue;
                        const n5 = this.attemptAnchorPlacement(o5, t3, c5, u5, d5, y3, b3, h3, r3, _3, x5, e3, a3, s5, p4, C3);
                        if (n5 && (m4 = n5.placedGlyphBoxes, m4 && m4.box && m4.box.length)) return S4 = true, M3 = n5.shift, m4;
                      }
                      l4 ? l4 = null : x5 = f3;
                    }
                    return m4;
                  };
                  s4(() => c4(N3, u4.iconBox, t2.ai.horizontal), () => {
                    const i5 = u4.verticalTextBox;
                    return a3.allowVerticalPlacement && !(z3 && z3.box && z3.box.length) && e3.numVerticalGlyphVertices > 0 && i5 ? c4(i5, u4.verticalIconBox, t2.ai.vertical) : { box: null, offscreen: null };
                  }), z3 && (S4 = z3.box, D3 = z3.offscreen);
                  const d4 = i4(z3 && z3.box);
                  if (!S4 && this.prevPlacement) {
                    const t3 = this.prevPlacement.variableOffsets[e3.crossTileID];
                    t3 && (this.variableOffsets[e3.crossTileID] = t3, this.markUsedJustification(a3, t3.anchor, e3, d4));
                  }
                }
              }
              if (A3 = z3, S4 = A3 && A3.box && A3.box.length > 0, D3 = A3 && A3.offscreen, e3.useRuntimeCollisionCircles) {
                const i4 = a3.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex), h4 = t2.aj(a3.textSizeData, d3, i4), c4 = o3.get("text-padding");
                R3 = this.collisionIndex.placeCollisionCircles(f3, i4, a3.lineVertexArray, a3.glyphOffsetArray, h4, r3, n3, l3, s3, b3, _3.predicate, e3.collisionCircleDiameter, c4, C3), R3.circles.length && R3.collisionDetected && !s3 && t2.w("Collisions detected, but collision boxes are not shown"), S4 = g3 || R3.circles.length > 0 && !R3.collisionDetected, D3 = D3 && R3.offscreen;
              }
              if (u4.iconFeatureIndex && (O3 = u4.iconFeatureIndex), u4.iconBox) {
                const t3 = (t4) => {
                  const e4 = w3 && M3 ? Rt(t4, M3.x, M3.y, y3, b3, this.transform.angle) : t4;
                  return this.collisionIndex.placeCollisionBox(e4, v3, h3, r3, _3.predicate, C3);
                };
                L3 && L3.box && L3.box.length && u4.verticalIconBox ? (k3 = t3(u4.verticalIconBox), P4 = k3.box.length > 0) : (k3 = t3(u4.iconBox), P4 = k3.box.length > 0), D3 = D3 && k3.offscreen;
              }
              const U3 = p3 || 0 === e3.numHorizontalGlyphVertices && 0 === e3.numVerticalGlyphVertices, Z3 = m3 || 0 === e3.numIconVertices;
              if (U3 || Z3 ? Z3 ? U3 || (P4 = P4 && S4) : S4 = P4 && S4 : P4 = S4 = P4 && S4, S4 && A3 && A3.box && this.collisionIndex.insertCollisionBox(A3.box, f3, o3.get("text-ignore-placement"), a3.bucketInstanceId, L3 && L3.box && B3 ? B3 : F3, _3.ID), P4 && k3 && this.collisionIndex.insertCollisionBox(k3.box, v3, o3.get("icon-ignore-placement"), a3.bucketInstanceId, O3, _3.ID), R3 && (S4 && this.collisionIndex.insertCollisionCircles(R3.circles, f3, o3.get("text-ignore-placement"), a3.bucketInstanceId, F3, _3.ID), s3)) {
                const t3 = a3.bucketInstanceId;
                let e4 = this.collisionCircleArrays[t3];
                void 0 === e4 && (e4 = this.collisionCircleArrays[t3] = new Mt());
                for (let t4 = 0; t4 < R3.circles.length; t4 += 4) e4.circles.push(R3.circles[t4 + 0]), e4.circles.push(R3.circles[t4 + 1]), e4.circles.push(R3.circles[t4 + 2]), e4.circles.push(R3.collisionDetected ? 1 : 0);
              }
              if (0 === e3.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
              if (0 === a3.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[e3.crossTileID] = new Dt(S4 || I3, P4 || E3, D3 || a3.justReloaded), i3[e3.crossTileID] = true;
            };
            if (T3) {
              if (0 !== e2.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
              const t3 = a3.getSortedSymbolIndexes(this.transform.angle);
              for (let e3 = t3.length - 1; e3 >= 0; --e3) {
                const i4 = t3[e3];
                P3(a3.symbolInstances.get(i4), a3.collisionArrays[i4]);
              }
            } else for (let t3 = e2.symbolInstanceStart; t3 < e2.symbolInstanceEnd; t3++) P3(a3.symbolInstances.get(t3), a3.collisionArrays[t3]);
            if (s3 && a3.bucketInstanceId in this.collisionCircleArrays) {
              const e3 = this.collisionCircleArrays[a3.bucketInstanceId];
              t2.as(e3.invProjMatrix, r3), e3.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            a3.justReloaded = false;
          }
          markUsedJustification(e2, i3, s3, a3) {
            let o3;
            o3 = a3 === t2.ai.vertical ? s3.verticalPlacedTextSymbolIndex : { left: s3.leftJustifiedTextSymbolIndex, center: s3.centerJustifiedTextSymbolIndex, right: s3.rightJustifiedTextSymbolIndex }[t2.at(i3)];
            const r3 = [s3.leftJustifiedTextSymbolIndex, s3.centerJustifiedTextSymbolIndex, s3.rightJustifiedTextSymbolIndex, s3.verticalPlacedTextSymbolIndex];
            for (const t3 of r3) t3 >= 0 && (e2.text.placedSymbolArray.get(t3).crossTileID = o3 >= 0 && t3 !== o3 ? 0 : s3.crossTileID);
          }
          markUsedOrientation(e2, i3, s3) {
            const a3 = i3 === t2.ai.horizontal || i3 === t2.ai.horizontalOnly ? i3 : 0, o3 = i3 === t2.ai.vertical ? i3 : 0, r3 = [s3.leftJustifiedTextSymbolIndex, s3.centerJustifiedTextSymbolIndex, s3.rightJustifiedTextSymbolIndex];
            for (const t3 of r3) e2.text.placedSymbolArray.get(t3).placedOrientation = a3;
            s3.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(s3.verticalPlacedTextSymbolIndex).placedOrientation = o3);
          }
          commit(t3) {
            this.commitTime = t3, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const e2 = this.prevPlacement;
            let i3 = false;
            this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
            const s3 = e2 ? e2.symbolFadeChange(t3) : 1, a3 = e2 ? e2.opacities : {}, o3 = e2 ? e2.variableOffsets : {}, r3 = e2 ? e2.placedOrientations : {};
            for (const t4 in this.placements) {
              const e3 = this.placements[t4], o4 = a3[t4];
              o4 ? (this.opacities[t4] = new Pt(o4, s3, e3.text, e3.icon), i3 = i3 || e3.text !== o4.text.placed || e3.icon !== o4.icon.placed) : (this.opacities[t4] = new Pt(null, s3, e3.text, e3.icon, e3.skipFade), i3 = i3 || e3.text || e3.icon);
            }
            for (const t4 in a3) {
              const e3 = a3[t4];
              if (!this.opacities[t4]) {
                const a4 = new Pt(e3, s3, false, false);
                a4.isHidden() || (this.opacities[t4] = a4, i3 = i3 || e3.text.placed || e3.icon.placed);
              }
            }
            for (const t4 in o3) this.variableOffsets[t4] || !this.opacities[t4] || this.opacities[t4].isHidden() || (this.variableOffsets[t4] = o3[t4]);
            for (const t4 in r3) this.placedOrientations[t4] || !this.opacities[t4] || this.opacities[t4].isHidden() || (this.placedOrientations[t4] = r3[t4]);
            if (e2 && void 0 === e2.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
            i3 ? this.lastPlacementChangeTime = t3 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t3);
          }
          updateLayerOpacities(t3, e2) {
            const i3 = {};
            for (const s3 of e2) {
              const e3 = s3.getBucket(t3);
              e3 && s3.latestFeatureIndex && t3.id === e3.layerIds[0] && this.updateBucketOpacities(e3, i3, s3.collisionBoxArray);
            }
          }
          updateBucketOpacities(e2, i3, s3) {
            e2.hasTextData() && (e2.text.opacityVertexArray.clear(), e2.text.hasVisibleVertices = false), e2.hasIconData() && (e2.icon.opacityVertexArray.clear(), e2.icon.hasVisibleVertices = false), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
            const a3 = e2.layers[0], o3 = a3.layout, r3 = new Pt(null, 0, false, false, true), n3 = o3.get("text-allow-overlap"), l3 = o3.get("icon-allow-overlap"), h3 = a3._unevaluatedLayout.hasValue("text-variable-anchor") || a3._unevaluatedLayout.hasValue("text-variable-anchor-offset"), c3 = "map" === o3.get("text-rotation-alignment"), u3 = "map" === o3.get("text-pitch-alignment"), d3 = "none" !== o3.get("icon-text-fit"), _3 = new Pt(null, 0, n3 && (l3 || !e2.hasIconData() || o3.get("icon-optional")), l3 && (n3 || !e2.hasTextData() || o3.get("text-optional")), true);
            !e2.collisionArrays && s3 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(s3);
            const p3 = (t3, e3, i4) => {
              for (let s4 = 0; s4 < e3 / 4; s4++) t3.opacityVertexArray.emplaceBack(i4);
              t3.hasVisibleVertices = t3.hasVisibleVertices || i4 !== qt;
            };
            for (let s4 = 0; s4 < e2.symbolInstances.length; s4++) {
              const a4 = e2.symbolInstances.get(s4), { numHorizontalGlyphVertices: o4, numVerticalGlyphVertices: n4, crossTileID: l4 } = a4;
              let m3 = this.opacities[l4];
              i3[l4] ? m3 = r3 : m3 || (m3 = _3, this.opacities[l4] = m3), i3[l4] = true;
              const f3 = a4.numIconVertices > 0, g3 = this.placedOrientations[a4.crossTileID], v3 = g3 === t2.ai.vertical, x3 = g3 === t2.ai.horizontal || g3 === t2.ai.horizontalOnly;
              if (o4 > 0 || n4 > 0) {
                const t3 = Vt(m3.text);
                p3(e2.text, o4, v3 ? qt : t3), p3(e2.text, n4, x3 ? qt : t3);
                const i4 = m3.text.isHidden();
                [a4.rightJustifiedTextSymbolIndex, a4.centerJustifiedTextSymbolIndex, a4.leftJustifiedTextSymbolIndex].forEach((t4) => {
                  t4 >= 0 && (e2.text.placedSymbolArray.get(t4).hidden = i4 || v3 ? 1 : 0);
                }), a4.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(a4.verticalPlacedTextSymbolIndex).hidden = i4 || x3 ? 1 : 0);
                const s5 = this.variableOffsets[a4.crossTileID];
                s5 && this.markUsedJustification(e2, s5.anchor, a4, g3);
                const r4 = this.placedOrientations[a4.crossTileID];
                r4 && (this.markUsedJustification(e2, "left", a4, r4), this.markUsedOrientation(e2, r4, a4));
              }
              if (f3) {
                const t3 = Vt(m3.icon), i4 = !(d3 && a4.verticalPlacedIconSymbolIndex && v3);
                a4.placedIconSymbolIndex >= 0 && (p3(e2.icon, a4.numIconVertices, i4 ? t3 : qt), e2.icon.placedSymbolArray.get(a4.placedIconSymbolIndex).hidden = m3.icon.isHidden()), a4.verticalPlacedIconSymbolIndex >= 0 && (p3(e2.icon, a4.numVerticalIconVertices, i4 ? qt : t3), e2.icon.placedSymbolArray.get(a4.verticalPlacedIconSymbolIndex).hidden = m3.icon.isHidden());
              }
              if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
                const i4 = e2.collisionArrays[s4];
                if (i4) {
                  let s5 = new t2.P(0, 0);
                  if (i4.textBox || i4.verticalTextBox) {
                    let t3 = true;
                    if (h3) {
                      const e3 = this.variableOffsets[l4];
                      e3 ? (s5 = At(e3.anchor, e3.width, e3.height, e3.textOffset, e3.textBoxScale), c3 && s5._rotate(u3 ? this.transform.angle : -this.transform.angle)) : t3 = false;
                    }
                    i4.textBox && Ft(e2.textCollisionBox.collisionVertexArray, m3.text.placed, !t3 || v3, s5.x, s5.y), i4.verticalTextBox && Ft(e2.textCollisionBox.collisionVertexArray, m3.text.placed, !t3 || x3, s5.x, s5.y);
                  }
                  const a5 = Boolean(!x3 && i4.verticalIconBox);
                  i4.iconBox && Ft(e2.iconCollisionBox.collisionVertexArray, m3.icon.placed, a5, d3 ? s5.x : 0, d3 ? s5.y : 0), i4.verticalIconBox && Ft(e2.iconCollisionBox.collisionVertexArray, m3.icon.placed, !a5, d3 ? s5.x : 0, d3 ? s5.y : 0);
                }
              }
            }
            if (e2.sortFeatures(this.transform.angle), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.text.opacityVertexArray.length !== e2.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e2.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e2.text.layoutVertexArray.length}) / 4`);
            if (e2.icon.opacityVertexArray.length !== e2.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e2.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e2.icon.layoutVertexArray.length}) / 4`);
            if (e2.bucketInstanceId in this.collisionCircleArrays) {
              const t3 = this.collisionCircleArrays[e2.bucketInstanceId];
              e2.placementInvProjMatrix = t3.invProjMatrix, e2.placementViewportMatrix = t3.viewportMatrix, e2.collisionCircleArray = t3.circles, delete this.collisionCircleArrays[e2.bucketInstanceId];
            }
          }
          symbolFadeChange(t3) {
            return 0 === this.fadeDuration ? 1 : (t3 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(t3) {
            return Math.max(0, (this.transform.zoom - t3) / 1.5);
          }
          hasTransitions(t3) {
            return this.stale || t3 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(t3, e2) {
            const i3 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
            return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i3 > t3;
          }
          setStale() {
            this.stale = true;
          }
        }
        function Ft(t3, e2, i3, s3, a3) {
          t3.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, s3 || 0, a3 || 0), t3.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, s3 || 0, a3 || 0), t3.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, s3 || 0, a3 || 0), t3.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, s3 || 0, a3 || 0);
        }
        const Bt = Math.pow(2, 25), Ot = Math.pow(2, 24), Nt = Math.pow(2, 17), Ut = Math.pow(2, 16), Zt = Math.pow(2, 9), Gt = Math.pow(2, 8), jt = Math.pow(2, 1);
        function Vt(t3) {
          if (0 === t3.opacity && !t3.placed) return 0;
          if (1 === t3.opacity && t3.placed) return 4294967295;
          const e2 = t3.placed ? 1 : 0, i3 = Math.floor(127 * t3.opacity);
          return i3 * Bt + e2 * Ot + i3 * Nt + e2 * Ut + i3 * Zt + e2 * Gt + i3 * jt + e2;
        }
        const qt = 0;
        class $t {
          constructor(t3) {
            this._sortAcrossTiles = "viewport-y" !== t3.layout.get("symbol-z-order") && !t3.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(t3, e2, i3, s3, a3) {
            const o3 = this._bucketParts;
            for (; this._currentTileIndex < t3.length; ) if (e2.getBucketParts(o3, s3, t3[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a3()) return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o3.sort((t4, e3) => t4.sortKey - e3.sortKey)); this._currentPartIndex < o3.length; ) if (e2.placeLayerBucketPart(o3[this._currentPartIndex], this._seenCrossTileIDs, i3), this._currentPartIndex++, a3()) return true;
            return false;
          }
        }
        class Wt {
          constructor(t3, e2, i3, s3, a3, o3, r3, n3) {
            this.placement = new kt(t3, e2, o3, r3, n3), this._currentPlacementIndex = i3.length - 1, this._forceFullPlacement = s3, this._showCollisionBoxes = a3, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e2, i3, s3) {
            const a3 = t2.h.now(), o3 = () => !this._forceFullPlacement && t2.h.now() - a3 > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const t3 = i3[e2[this._currentPlacementIndex]], a4 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === t3.type && (!t3.minzoom || t3.minzoom <= a4) && (!t3.maxzoom || t3.maxzoom > a4)) {
                if (this._inProgressLayer || (this._inProgressLayer = new $t(t3)), this._inProgressLayer.continuePlacement(s3[t3.source], this.placement, this._showCollisionBoxes, t3, o3)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(t3) {
            return this.placement.commit(t3), this.placement;
          }
        }
        const Ht = 512 / t2.N / 2;
        class Xt {
          constructor(e2, i3, s3) {
            this.tileID = e2, this.bucketInstanceId = s3, this._symbolsByKey = {};
            const a3 = /* @__PURE__ */ new Map();
            for (let t3 = 0; t3 < i3.length; t3++) {
              const e3 = i3.get(t3), s4 = e3.key, o3 = a3.get(s4);
              o3 ? o3.push(e3) : a3.set(s4, [e3]);
            }
            for (const [e3, i4] of a3) {
              const s4 = { positions: i4.map((t3) => ({ x: Math.floor(t3.anchorX * Ht), y: Math.floor(t3.anchorY * Ht) })), crossTileIDs: i4.map((t3) => t3.crossTileID) };
              if (s4.positions.length > 128) {
                const e4 = new t2.av(s4.positions.length, 16, Uint16Array);
                for (const { x: t3, y: i5 } of s4.positions) e4.add(t3, i5);
                e4.finish(), delete s4.positions, s4.index = e4;
              }
              this._symbolsByKey[e3] = s4;
            }
          }
          getScaledCoordinates(e2, i3) {
            const { x: s3, y: a3, z: o3 } = this.tileID.canonical, { x: r3, y: n3, z: l3 } = i3.canonical, h3 = Ht / Math.pow(2, l3 - o3), c3 = (n3 * t2.N + e2.anchorY) * h3, u3 = a3 * t2.N * Ht;
            return { x: Math.floor((r3 * t2.N + e2.anchorX) * h3 - s3 * t2.N * Ht), y: Math.floor(c3 - u3) };
          }
          findMatches(t3, e2, i3) {
            const s3 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z);
            for (let a3 = 0; a3 < t3.length; a3++) {
              const o3 = t3.get(a3);
              if (o3.crossTileID) continue;
              const r3 = this._symbolsByKey[o3.key];
              if (!r3) continue;
              const n3 = this.getScaledCoordinates(o3, e2);
              if (r3.index) {
                const t4 = r3.index.range(n3.x - s3, n3.y - s3, n3.x + s3, n3.y + s3).sort();
                for (const e3 of t4) {
                  const t5 = r3.crossTileIDs[e3];
                  if (!i3[t5]) {
                    i3[t5] = true, o3.crossTileID = t5;
                    break;
                  }
                }
              } else if (r3.positions) for (let t4 = 0; t4 < r3.positions.length; t4++) {
                const e3 = r3.positions[t4], a4 = r3.crossTileIDs[t4];
                if (Math.abs(e3.x - n3.x) <= s3 && Math.abs(e3.y - n3.y) <= s3 && !i3[a4]) {
                  i3[a4] = true, o3.crossTileID = a4;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map(({ crossTileIDs: t3 }) => t3);
          }
        }
        class Kt {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Qt {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(t3) {
            const e2 = Math.round((t3 - this.lng) / 360);
            if (0 !== e2) for (const t4 in this.indexes) {
              const i3 = this.indexes[t4], s3 = {};
              for (const t5 in i3) {
                const a3 = i3[t5];
                a3.tileID = a3.tileID.unwrapTo(a3.tileID.wrap + e2), s3[a3.tileID.key] = a3;
              }
              this.indexes[t4] = s3;
            }
            this.lng = t3;
          }
          addBucket(t3, e2, i3) {
            if (this.indexes[t3.overscaledZ] && this.indexes[t3.overscaledZ][t3.key]) {
              if (this.indexes[t3.overscaledZ][t3.key].bucketInstanceId === e2.bucketInstanceId) return false;
              this.removeBucketCrossTileIDs(t3.overscaledZ, this.indexes[t3.overscaledZ][t3.key]);
            }
            for (let t4 = 0; t4 < e2.symbolInstances.length; t4++) e2.symbolInstances.get(t4).crossTileID = 0;
            this.usedCrossTileIDs[t3.overscaledZ] || (this.usedCrossTileIDs[t3.overscaledZ] = {});
            const s3 = this.usedCrossTileIDs[t3.overscaledZ];
            for (const i4 in this.indexes) {
              const a3 = this.indexes[i4];
              if (Number(i4) > t3.overscaledZ) for (const i5 in a3) {
                const o3 = a3[i5];
                o3.tileID.isChildOf(t3) && o3.findMatches(e2.symbolInstances, t3, s3);
              }
              else {
                const o3 = a3[t3.scaledTo(Number(i4)).key];
                o3 && o3.findMatches(e2.symbolInstances, t3, s3);
              }
            }
            for (let t4 = 0; t4 < e2.symbolInstances.length; t4++) {
              const a3 = e2.symbolInstances.get(t4);
              a3.crossTileID || (a3.crossTileID = i3.generate(), s3[a3.crossTileID] = true);
            }
            return void 0 === this.indexes[t3.overscaledZ] && (this.indexes[t3.overscaledZ] = {}), this.indexes[t3.overscaledZ][t3.key] = new Xt(t3, e2.symbolInstances, e2.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(t3, e2) {
            for (const i3 of e2.getCrossTileIDsLists()) for (const e3 of i3) delete this.usedCrossTileIDs[t3][e3];
          }
          removeStaleBuckets(t3) {
            let e2 = false;
            for (const i3 in this.indexes) {
              const s3 = this.indexes[i3];
              for (const a3 in s3) t3[s3[a3].bucketInstanceId] || (this.removeBucketCrossTileIDs(i3, s3[a3]), delete s3[a3], e2 = true);
            }
            return e2;
          }
        }
        class Yt {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Kt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(t3, e2, i3) {
            let s3 = this.layerIndexes[t3.id];
            void 0 === s3 && (s3 = this.layerIndexes[t3.id] = new Qt());
            let a3 = false;
            const o3 = {};
            s3.handleWrapJump(i3);
            for (const i4 of e2) {
              const e3 = i4.getBucket(t3);
              e3 && t3.id === e3.layerIds[0] && (e3.bucketInstanceId || (e3.bucketInstanceId = ++this.maxBucketInstanceId), s3.addBucket(i4.tileID, e3, this.crossTileIDs) && (a3 = true), o3[e3.bucketInstanceId] = true);
            }
            return s3.removeStaleBuckets(o3) && (a3 = true), a3;
          }
          pruneUnusedLayers(t3) {
            const e2 = {};
            t3.forEach((t4) => {
              e2[t4] = true;
            });
            for (const t4 in this.layerIndexes) e2[t4] || delete this.layerIndexes[t4];
          }
        }
        const Jt = (e2, i3) => t2.x(e2, i3 && i3.filter((t3) => "source.canvas" !== t3.identifier)), te2 = t2.F(t2.ax, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setGlyphs", "setSprite"]), ee2 = t2.F(t2.ax, ["setCenter", "setZoom", "setBearing", "setPitch"]), ie2 = t2.aw();
        class se2 extends t2.E {
          constructor(e2, i3 = {}) {
            super(), this.map = e2, this.dispatcher = new M2(st(), this, e2._getMapId()), this.imageManager = new b2(), this.imageManager.setEventedParent(this), this.glyphManager = new E2(e2._requestManager, i3.localIdeographFontFamily), this.lineAtlas = new D2(256, 512), this.crossTileSymbolIndex = new Yt(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t2.ay(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t2.az());
            const s3 = this;
            this._rtlTextPluginCallback = se2.registerForPluginStateChange((e3) => {
              s3.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e3.pluginStatus, pluginURL: e3.pluginURL }, (e4, i4) => {
                if (t2.aA(e4), i4 && i4.every((t3) => t3)) for (const t3 in s3.sourceCaches) {
                  const e5 = s3.sourceCaches[t3].getSource().type;
                  "vector" !== e5 && "geojson" !== e5 || s3.sourceCaches[t3].reload();
                }
              });
            }), this.on("data", (t3) => {
              if ("source" !== t3.dataType || "metadata" !== t3.sourceDataType) return;
              const e3 = this.sourceCaches[t3.sourceId];
              if (!e3) return;
              const i4 = e3.getSource();
              if (i4 && i4.vectorLayerIds) for (const t4 in this._layers) {
                const e4 = this._layers[t4];
                e4.source === i4.id && this._validateLayer(e4);
              }
            });
          }
          loadURL(e2, i3 = {}, s3) {
            this.fire(new t2.k("dataloading", { dataType: "style" })), i3.validate = "boolean" != typeof i3.validate || i3.validate;
            const a3 = this.map._requestManager.transformRequest(e2, c2.Style);
            this._request = t2.f(a3, (e3, a4) => {
              this._request = null, e3 ? this.fire(new t2.j(e3)) : a4 && this._load(a4, i3, s3);
            });
          }
          loadJSON(e2, i3 = {}, s3) {
            this.fire(new t2.k("dataloading", { dataType: "style" })), this._request = t2.h.frame(() => {
              this._request = null, i3.validate = false !== i3.validate, this._load(e2, i3, s3);
            });
          }
          loadEmpty() {
            this.fire(new t2.k("dataloading", { dataType: "style" })), this._load(ie2, { validate: false });
          }
          _load(e2, i3, s3) {
            var a3;
            const o3 = i3.transformStyle ? i3.transformStyle(s3, e2) : e2;
            if (!i3.validate || !Jt(this, t2.y(o3))) {
              this._loaded = true, this.stylesheet = o3;
              for (const t3 in o3.sources) this.addSource(t3, o3.sources[t3], { validate: false });
              o3.sprite ? this._loadSprite(o3.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(o3.glyphs), this._createLayers(), this.light = new P2(this.stylesheet.light), this.map.setTerrain(null !== (a3 = this.stylesheet.terrain) && void 0 !== a3 ? a3 : null), this.fire(new t2.k("data", { dataType: "style" })), this.fire(new t2.k("style.load"));
            }
          }
          _createLayers() {
            const e2 = t2.aB(this.stylesheet.layers);
            this.dispatcher.broadcast("setLayers", e2), this._order = e2.map((t3) => t3.id), this._layers = {}, this._serializedLayers = null;
            for (const i3 of e2) {
              const e3 = t2.aC(i3);
              e3.setEventedParent(this, { layer: { id: i3.id } }), this._layers[i3.id] = e3;
            }
          }
          _loadSprite(e2, i3 = false, s3 = void 0) {
            this.imageManager.setLoaded(false), this._spriteRequest = function(e3, i4, s4, a3) {
              const o3 = g2(e3), r3 = o3.length, n3 = s4 > 1 ? "@2x" : "", l3 = {}, u3 = {}, d3 = {};
              for (const { id: e4, url: s5 } of o3) {
                const o4 = i4.transformRequest(i4.normalizeSpriteURL(s5, n3, ".json"), c2.SpriteJSON), _3 = `${e4}_${o4.url}`;
                l3[_3] = t2.f(o4, (t3, i5) => {
                  delete l3[_3], u3[e4] = i5, v2(a3, u3, d3, t3, r3);
                });
                const p3 = i4.transformRequest(i4.normalizeSpriteURL(s5, n3, ".png"), c2.SpriteImage), m3 = `${e4}_${p3.url}`;
                l3[m3] = h2.getImage(p3, (t3, i5) => {
                  delete l3[m3], d3[e4] = i5, v2(a3, u3, d3, t3, r3);
                });
              }
              return { cancel() {
                for (const t3 of Object.values(l3)) t3.cancel();
              } };
            }(e2, this.map._requestManager, this.map.getPixelRatio(), (e3, a3) => {
              if (this._spriteRequest = null, e3) this.fire(new t2.j(e3));
              else if (a3) for (const t3 in a3) {
                this._spritesImagesIds[t3] = [];
                const e4 = this._spritesImagesIds[t3] ? this._spritesImagesIds[t3].filter((t4) => !(t4 in a3)) : [];
                for (const t4 of e4) this.imageManager.removeImage(t4), this._changedImages[t4] = true;
                for (const e5 in a3[t3]) {
                  const s4 = "default" === t3 ? e5 : `${t3}:${e5}`;
                  this._spritesImagesIds[t3].push(s4), s4 in this.imageManager.images ? this.imageManager.updateImage(s4, a3[t3][e5], false) : this.imageManager.addImage(s4, a3[t3][e5]), i3 && (this._changedImages[s4] = true);
                }
              }
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i3 && (this._changed = true), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t2.k("data", { dataType: "style" })), s3 && s3(e3);
            });
          }
          _unloadSprite() {
            for (const t3 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(t3), this._changedImages[t3] = true;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t2.k("data", { dataType: "style" }));
          }
          _validateLayer(e2) {
            const i3 = this.sourceCaches[e2.source];
            if (!i3) return;
            const s3 = e2.sourceLayer;
            if (!s3) return;
            const a3 = i3.getSource();
            ("geojson" === a3.type || a3.vectorLayerIds && -1 === a3.vectorLayerIds.indexOf(s3)) && this.fire(new t2.j(new Error(`Source layer "${s3}" does not exist on source "${a3.id}" as specified by style layer "${e2.id}".`)));
          }
          loaded() {
            if (!this._loaded) return false;
            if (Object.keys(this._updatedSources).length) return false;
            for (const t3 in this.sourceCaches) if (!this.sourceCaches[t3].loaded()) return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(t3) {
            const e2 = this._serializedAllLayers();
            if (!t3 || 0 === t3.length) return Object.values(e2);
            const i3 = [];
            for (const s3 of t3) e2[s3] && i3.push(e2[s3]);
            return i3;
          }
          _serializedAllLayers() {
            let t3 = this._serializedLayers;
            if (t3) return t3;
            t3 = this._serializedLayers = {};
            const e2 = Object.keys(this._layers);
            for (const i3 of e2) {
              const e3 = this._layers[i3];
              "custom" !== e3.type && (t3[i3] = e3.serialize());
            }
            return t3;
          }
          hasTransitions() {
            if (this.light && this.light.hasTransition()) return true;
            for (const t3 in this.sourceCaches) if (this.sourceCaches[t3].hasTransition()) return true;
            for (const t3 in this._layers) if (this._layers[t3].hasTransition()) return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e2) {
            if (!this._loaded) return;
            const i3 = this._changed;
            if (this._changed) {
              const t3 = Object.keys(this._updatedLayers), i4 = Object.keys(this._removedLayers);
              (t3.length || i4.length) && this._updateWorkerLayers(t3, i4);
              for (const t4 in this._updatedSources) {
                const e3 = this._updatedSources[t4];
                if ("reload" === e3) this._reloadSource(t4);
                else {
                  if ("clear" !== e3) throw new Error(`Invalid action ${e3}`);
                  this._clearSource(t4);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const t4 in this._updatedPaintProps) this._layers[t4].updateTransitions(e2);
              this.light.updateTransitions(e2), this._resetUpdates();
            }
            const s3 = {};
            for (const t3 in this.sourceCaches) {
              const e3 = this.sourceCaches[t3];
              s3[t3] = e3.used, e3.used = false;
            }
            for (const t3 of this._order) {
              const i4 = this._layers[t3];
              i4.recalculate(e2, this._availableImages), !i4.isHidden(e2.zoom) && i4.source && (this.sourceCaches[i4.source].used = true);
            }
            for (const e3 in s3) {
              const i4 = this.sourceCaches[e3];
              s3[e3] !== i4.used && i4.fire(new t2.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: e3 }));
            }
            this.light.recalculate(e2), this.z = e2.zoom, i3 && this.fire(new t2.k("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const t3 = Object.keys(this._changedImages);
            if (t3.length) {
              for (const e2 in this.sourceCaches) this.sourceCaches[e2].reloadTilesForDependencies(["icons", "patterns"], t3);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const t3 in this.sourceCaches) this.sourceCaches[t3].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = false;
            }
          }
          _updateWorkerLayers(t3, e2) {
            this.dispatcher.broadcast("updateLayers", { layers: this._serializeByIds(t3), removedIds: e2 });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
          }
          setState(e2, i3 = {}) {
            this._checkLoaded();
            const s3 = this.serialize();
            if (e2 = i3.transformStyle ? i3.transformStyle(s3, e2) : e2, Jt(this, t2.y(e2))) return false;
            (e2 = t2.aD(e2)).layers = t2.aB(e2.layers);
            const a3 = t2.aE(s3, e2).filter((t3) => !(t3.command in ee2));
            if (0 === a3.length) return false;
            const o3 = a3.filter((t3) => !(t3.command in te2));
            if (o3.length > 0) throw new Error(`Unimplemented: ${o3.map((t3) => t3.command).join(", ")}.`);
            for (const t3 of a3) "setTransition" !== t3.command && this[t3.command].apply(this, t3.args);
            return this.stylesheet = e2, this._serializedLayers = null, true;
          }
          addImage(e2, i3) {
            if (this.getImage(e2)) return this.fire(new t2.j(new Error(`An image named "${e2}" already exists.`)));
            this.imageManager.addImage(e2, i3), this._afterImageUpdated(e2);
          }
          updateImage(t3, e2) {
            this.imageManager.updateImage(t3, e2);
          }
          getImage(t3) {
            return this.imageManager.getImage(t3);
          }
          removeImage(e2) {
            if (!this.getImage(e2)) return this.fire(new t2.j(new Error(`An image named "${e2}" does not exist.`)));
            this.imageManager.removeImage(e2), this._afterImageUpdated(e2);
          }
          _afterImageUpdated(e2) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e2] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t2.k("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e2, i3, s3 = {}) {
            if (this._checkLoaded(), void 0 !== this.sourceCaches[e2]) throw new Error(`Source "${e2}" already exists.`);
            if (!i3.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i3).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i3.type) >= 0 && this._validate(t2.y.source, `sources.${e2}`, i3, null, s3)) return;
            this.map && this.map._collectResourceTiming && (i3.collectResourceTiming = true);
            const a3 = this.sourceCaches[e2] = new K2(e2, i3, this.dispatcher);
            a3.style = this, a3.setEventedParent(this, () => ({ isSourceLoaded: a3.loaded(), source: a3.serialize(), sourceId: e2 })), a3.onAdd(this.map), this._changed = true;
          }
          removeSource(e2) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[e2]) throw new Error("There is no source with this ID");
            for (const i4 in this._layers) if (this._layers[i4].source === e2) return this.fire(new t2.j(new Error(`Source "${e2}" cannot be removed while layer "${i4}" is using it.`)));
            const i3 = this.sourceCaches[e2];
            delete this.sourceCaches[e2], delete this._updatedSources[e2], i3.fire(new t2.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: e2 })), i3.setEventedParent(null), i3.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(t3, e2) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[t3]) throw new Error(`There is no source with this ID=${t3}`);
            const i3 = this.sourceCaches[t3].getSource();
            if ("geojson" !== i3.type) throw new Error(`geojsonSource.type is ${i3.type}, which is !== 'geojson`);
            i3.setData(e2), this._changed = true;
          }
          getSource(t3) {
            return this.sourceCaches[t3] && this.sourceCaches[t3].getSource();
          }
          addLayer(e2, i3, s3 = {}) {
            this._checkLoaded();
            const a3 = e2.id;
            if (this.getLayer(a3)) return void this.fire(new t2.j(new Error(`Layer "${a3}" already exists on this map.`)));
            let o3;
            if ("custom" === e2.type) {
              if (Jt(this, t2.aF(e2))) return;
              o3 = t2.aC(e2);
            } else {
              if ("source" in e2 && "object" == typeof e2.source && (this.addSource(a3, e2.source), e2 = t2.aD(e2), e2 = t2.e(e2, { source: a3 })), this._validate(t2.y.layer, `layers.${a3}`, e2, { arrayIndex: -1 }, s3)) return;
              o3 = t2.aC(e2), this._validateLayer(o3), o3.setEventedParent(this, { layer: { id: a3 } });
            }
            const r3 = i3 ? this._order.indexOf(i3) : this._order.length;
            if (i3 && -1 === r3) this.fire(new t2.j(new Error(`Cannot add layer "${a3}" before non-existing layer "${i3}".`)));
            else {
              if (this._order.splice(r3, 0, a3), this._layerOrderChanged = true, this._layers[a3] = o3, this._removedLayers[a3] && o3.source && "custom" !== o3.type) {
                const t3 = this._removedLayers[a3];
                delete this._removedLayers[a3], t3.type !== o3.type ? this._updatedSources[o3.source] = "clear" : (this._updatedSources[o3.source] = "reload", this.sourceCaches[o3.source].pause());
              }
              this._updateLayer(o3), o3.onAdd && o3.onAdd(this.map);
            }
          }
          moveLayer(e2, i3) {
            if (this._checkLoaded(), this._changed = true, !this._layers[e2]) return void this.fire(new t2.j(new Error(`The layer '${e2}' does not exist in the map's style and cannot be moved.`)));
            if (e2 === i3) return;
            const s3 = this._order.indexOf(e2);
            this._order.splice(s3, 1);
            const a3 = i3 ? this._order.indexOf(i3) : this._order.length;
            i3 && -1 === a3 ? this.fire(new t2.j(new Error(`Cannot move layer "${e2}" before non-existing layer "${i3}".`))) : (this._order.splice(a3, 0, e2), this._layerOrderChanged = true);
          }
          removeLayer(e2) {
            this._checkLoaded();
            const i3 = this._layers[e2];
            if (!i3) return void this.fire(new t2.j(new Error(`Cannot remove non-existing layer "${e2}".`)));
            i3.setEventedParent(null);
            const s3 = this._order.indexOf(e2);
            this._order.splice(s3, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e2] = i3, delete this._layers[e2], this._serializedLayers && delete this._serializedLayers[e2], delete this._updatedLayers[e2], delete this._updatedPaintProps[e2], i3.onRemove && i3.onRemove(this.map);
          }
          getLayer(t3) {
            return this._layers[t3];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(t3) {
            return t3 in this._layers;
          }
          setLayerZoomRange(e2, i3, s3) {
            this._checkLoaded();
            const a3 = this.getLayer(e2);
            a3 ? a3.minzoom === i3 && a3.maxzoom === s3 || (null != i3 && (a3.minzoom = i3), null != s3 && (a3.maxzoom = s3), this._updateLayer(a3)) : this.fire(new t2.j(new Error(`Cannot set the zoom range of non-existing layer "${e2}".`)));
          }
          setFilter(e2, i3, s3 = {}) {
            this._checkLoaded();
            const a3 = this.getLayer(e2);
            if (a3) {
              if (!t2.aG(a3.filter, i3)) return null == i3 ? (a3.filter = void 0, void this._updateLayer(a3)) : void (this._validate(t2.y.filter, `layers.${a3.id}.filter`, i3, null, s3) || (a3.filter = t2.aD(i3), this._updateLayer(a3)));
            } else this.fire(new t2.j(new Error(`Cannot filter non-existing layer "${e2}".`)));
          }
          getFilter(e2) {
            return t2.aD(this.getLayer(e2).filter);
          }
          setLayoutProperty(e2, i3, s3, a3 = {}) {
            this._checkLoaded();
            const o3 = this.getLayer(e2);
            o3 ? t2.aG(o3.getLayoutProperty(i3), s3) || (o3.setLayoutProperty(i3, s3, a3), this._updateLayer(o3)) : this.fire(new t2.j(new Error(`Cannot style non-existing layer "${e2}".`)));
          }
          getLayoutProperty(e2, i3) {
            const s3 = this.getLayer(e2);
            if (s3) return s3.getLayoutProperty(i3);
            this.fire(new t2.j(new Error(`Cannot get style of non-existing layer "${e2}".`)));
          }
          setPaintProperty(e2, i3, s3, a3 = {}) {
            this._checkLoaded();
            const o3 = this.getLayer(e2);
            o3 ? t2.aG(o3.getPaintProperty(i3), s3) || (o3.setPaintProperty(i3, s3, a3) && this._updateLayer(o3), this._changed = true, this._updatedPaintProps[e2] = true) : this.fire(new t2.j(new Error(`Cannot style non-existing layer "${e2}".`)));
          }
          getPaintProperty(t3, e2) {
            return this.getLayer(t3).getPaintProperty(e2);
          }
          setFeatureState(e2, i3) {
            this._checkLoaded();
            const s3 = e2.source, a3 = e2.sourceLayer, o3 = this.sourceCaches[s3];
            if (void 0 === o3) return void this.fire(new t2.j(new Error(`The source '${s3}' does not exist in the map's style.`)));
            const r3 = o3.getSource().type;
            "geojson" === r3 && a3 ? this.fire(new t2.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== r3 || a3 ? (void 0 === e2.id && this.fire(new t2.j(new Error("The feature id parameter must be provided."))), o3.setFeatureState(a3, e2.id, i3)) : this.fire(new t2.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e2, i3) {
            this._checkLoaded();
            const s3 = e2.source, a3 = this.sourceCaches[s3];
            if (void 0 === a3) return void this.fire(new t2.j(new Error(`The source '${s3}' does not exist in the map's style.`)));
            const o3 = a3.getSource().type, r3 = "vector" === o3 ? e2.sourceLayer : void 0;
            "vector" !== o3 || r3 ? i3 && "string" != typeof e2.id && "number" != typeof e2.id ? this.fire(new t2.j(new Error("A feature id is required to remove its specific state property."))) : a3.removeFeatureState(r3, e2.id, i3) : this.fire(new t2.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e2) {
            this._checkLoaded();
            const i3 = e2.source, s3 = e2.sourceLayer, a3 = this.sourceCaches[i3];
            if (void 0 !== a3) return "vector" !== a3.getSource().type || s3 ? (void 0 === e2.id && this.fire(new t2.j(new Error("The feature id parameter must be provided."))), a3.getFeatureState(s3, e2.id)) : void this.fire(new t2.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new t2.j(new Error(`The source '${i3}' does not exist in the map's style.`)));
          }
          getTransition() {
            return t2.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const e2 = t2.aH(this.sourceCaches, (t3) => t3.serialize()), i3 = this._serializeByIds(this._order), s3 = this.map.getTerrain() || void 0, a3 = this.stylesheet;
            return t2.aI({ version: a3.version, name: a3.name, metadata: a3.metadata, light: a3.light, center: a3.center, zoom: a3.zoom, bearing: a3.bearing, pitch: a3.pitch, sprite: a3.sprite, glyphs: a3.glyphs, transition: a3.transition, sources: e2, layers: i3, terrain: s3 }, (t3) => void 0 !== t3);
          }
          _updateLayer(t3) {
            this._updatedLayers[t3.id] = true, t3.source && !this._updatedSources[t3.source] && "raster" !== this.sourceCaches[t3.source].getSource().type && (this._updatedSources[t3.source] = "reload", this.sourceCaches[t3.source].pause()), this._serializedLayers = null, this._changed = true;
          }
          _flattenAndSortRenderedFeatures(t3) {
            const e2 = (t4) => "fill-extrusion" === this._layers[t4].type, i3 = {}, s3 = [];
            for (let a4 = this._order.length - 1; a4 >= 0; a4--) {
              const o3 = this._order[a4];
              if (e2(o3)) {
                i3[o3] = a4;
                for (const e3 of t3) {
                  const t4 = e3[o3];
                  if (t4) for (const e4 of t4) s3.push(e4);
                }
              }
            }
            s3.sort((t4, e3) => e3.intersectionZ - t4.intersectionZ);
            const a3 = [];
            for (let o3 = this._order.length - 1; o3 >= 0; o3--) {
              const r3 = this._order[o3];
              if (e2(r3)) for (let t4 = s3.length - 1; t4 >= 0; t4--) {
                const e3 = s3[t4].feature;
                if (i3[e3.layer.id] < o3) break;
                a3.push(e3), s3.pop();
              }
              else for (const e3 of t3) {
                const t4 = e3[r3];
                if (t4) for (const e4 of t4) a3.push(e4.feature);
              }
            }
            return a3;
          }
          queryRenderedFeatures(e2, i3, s3) {
            i3 && i3.filter && this._validate(t2.y.filter, "queryRenderedFeatures.filter", i3.filter, null, i3);
            const a3 = {};
            if (i3 && i3.layers) {
              if (!Array.isArray(i3.layers)) return this.fire(new t2.j(new Error("parameters.layers must be an Array."))), [];
              for (const e3 of i3.layers) {
                const i4 = this._layers[e3];
                if (!i4) return this.fire(new t2.j(new Error(`The layer '${e3}' does not exist in the map's style and cannot be queried for features.`))), [];
                a3[i4.source] = true;
              }
            }
            const o3 = [];
            i3.availableImages = this._availableImages;
            const r3 = this._serializedAllLayers();
            for (const t3 in this.sourceCaches) i3.layers && !a3[t3] || o3.push(q2(this.sourceCaches[t3], this._layers, r3, e2, i3, s3));
            return this.placement && o3.push(function(t3, e3, i4, s4, a4, o4, r4) {
              const n3 = {}, l3 = o4.queryRenderedSymbols(s4), h3 = [];
              for (const t4 of Object.keys(l3).map(Number)) h3.push(r4[t4]);
              h3.sort($2);
              for (const i5 of h3) {
                const s5 = i5.featureIndex.lookupSymbolFeatures(l3[i5.bucketInstanceId], e3, i5.bucketIndex, i5.sourceLayerIndex, a4.filter, a4.layers, a4.availableImages, t3);
                for (const t4 in s5) {
                  const e4 = n3[t4] = n3[t4] || [], a5 = s5[t4];
                  a5.sort((t5, e5) => {
                    const s6 = i5.featureSortOrder;
                    if (s6) {
                      const i6 = s6.indexOf(t5.featureIndex);
                      return s6.indexOf(e5.featureIndex) - i6;
                    }
                    return e5.featureIndex - t5.featureIndex;
                  });
                  for (const t5 of a5) e4.push(t5);
                }
              }
              for (const e4 in n3) n3[e4].forEach((s5) => {
                const a5 = s5.feature, o5 = i4[t3[e4].source].getFeatureState(a5.layer["source-layer"], a5.id);
                a5.source = a5.layer.source, a5.layer["source-layer"] && (a5.sourceLayer = a5.layer["source-layer"]), a5.state = o5;
              });
              return n3;
            }(this._layers, r3, this.sourceCaches, e2, i3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o3);
          }
          querySourceFeatures(e2, i3) {
            i3 && i3.filter && this._validate(t2.y.filter, "querySourceFeatures.filter", i3.filter, null, i3);
            const s3 = this.sourceCaches[e2];
            return s3 ? function(t3, e3) {
              const i4 = t3.getRenderableIds().map((e4) => t3.getTileByID(e4)), s4 = [], a3 = {};
              for (let t4 = 0; t4 < i4.length; t4++) {
                const o3 = i4[t4], r3 = o3.tileID.canonical.key;
                a3[r3] || (a3[r3] = true, o3.querySourceFeatures(s4, e3));
              }
              return s4;
            }(s3, i3) : [];
          }
          addSourceType(t3, e2, i3) {
            return j2(t3) ? i3(new Error(`A source type called "${t3}" already exists.`)) : (((t4, e3) => {
              G2[t4] = e3;
            })(t3, e2), e2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t3, url: e2.workerSourceURL }, i3) : i3(null, null));
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e2, i3 = {}) {
            this._checkLoaded();
            const s3 = this.light.getLight();
            let a3 = false;
            for (const i4 in e2) if (!t2.aG(e2[i4], s3[i4])) {
              a3 = true;
              break;
            }
            if (!a3) return;
            const o3 = { now: t2.h.now(), transition: t2.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e2, i3), this.light.updateTransitions(o3);
          }
          _validate(e2, i3, s3, a3, o3 = {}) {
            return (!o3 || false !== o3.validate) && Jt(this, e2.call(t2.y, t2.e({ key: i3, style: this.serialize(), value: s3, styleSpec: t2.v }, a3)));
          }
          _remove(e2 = true) {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t2.aJ.off("pluginStateChange", this._rtlTextPluginCallback);
            for (const t3 in this._layers) this._layers[t3].setEventedParent(null);
            for (const t3 in this.sourceCaches) {
              const e3 = this.sourceCaches[t3];
              e3.setEventedParent(null), e3.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove(e2);
          }
          _clearSource(t3) {
            this.sourceCaches[t3].clearTiles();
          }
          _reloadSource(t3) {
            this.sourceCaches[t3].resume(), this.sourceCaches[t3].reload();
          }
          _updateSources(t3) {
            for (const e2 in this.sourceCaches) this.sourceCaches[e2].update(t3, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const t3 in this.sourceCaches) this._reloadSource(t3);
          }
          _updatePlacement(e2, i3, s3, a3, o3 = false) {
            let r3 = false, n3 = false;
            const l3 = {};
            for (const t3 of this._order) {
              const i4 = this._layers[t3];
              if ("symbol" !== i4.type) continue;
              if (!l3[i4.source]) {
                const t4 = this.sourceCaches[i4.source];
                l3[i4.source] = t4.getRenderableIds(true).map((e3) => t4.getTileByID(e3)).sort((t5, e3) => e3.tileID.overscaledZ - t5.tileID.overscaledZ || (t5.tileID.isLessThan(e3.tileID) ? -1 : 1));
              }
              const s4 = this.crossTileSymbolIndex.addLayer(i4, l3[i4.source], e2.center.lng);
              r3 = r3 || s4;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((o3 = o3 || this._layerOrderChanged || 0 === s3) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t2.h.now(), e2.zoom)) && (this.pauseablePlacement = new Wt(e2, this.map.terrain, this._order, o3, i3, s3, a3, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l3), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t2.h.now()), n3 = true), r3 && this.pauseablePlacement.placement.setStale()), n3 || r3) for (const t3 of this._order) {
              const e3 = this._layers[t3];
              "symbol" === e3.type && this.placement.updateLayerOpacities(e3, l3[e3.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t2.h.now());
          }
          _releaseSymbolFadeTiles() {
            for (const t3 in this.sourceCaches) this.sourceCaches[t3].releaseSymbolFadeTiles();
          }
          getImages(t3, e2, i3) {
            this.imageManager.getImages(e2.icons, i3), this._updateTilesForChangedImages();
            const s3 = this.sourceCaches[e2.source];
            s3 && s3.setDependencies(e2.tileID.key, e2.type, e2.icons);
          }
          getGlyphs(t3, e2, i3) {
            this.glyphManager.getGlyphs(e2.stacks, i3);
            const s3 = this.sourceCaches[e2.source];
            s3 && s3.setDependencies(e2.tileID.key, e2.type, [""]);
          }
          getResource(e2, i3, s3) {
            return t2.m(i3, s3);
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e2, i3 = {}) {
            this._checkLoaded(), e2 && this._validate(t2.y.glyphs, "glyphs", e2, null, i3) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e2, this.glyphManager.entries = {}, this.glyphManager.setURL(e2));
          }
          addSprite(e2, i3, s3 = {}, a3) {
            this._checkLoaded();
            const o3 = [{ id: e2, url: i3 }], r3 = [...g2(this.stylesheet.sprite), ...o3];
            this._validate(t2.y.sprite, "sprite", r3, null, s3) || (this.stylesheet.sprite = r3, this._loadSprite(o3, true, a3));
          }
          removeSprite(e2) {
            this._checkLoaded();
            const i3 = g2(this.stylesheet.sprite);
            if (i3.find((t3) => t3.id === e2)) {
              if (this._spritesImagesIds[e2]) for (const t3 of this._spritesImagesIds[e2]) this.imageManager.removeImage(t3), this._changedImages[t3] = true;
              i3.splice(i3.findIndex((t3) => t3.id === e2), 1), this.stylesheet.sprite = i3.length > 0 ? i3 : void 0, delete this._spritesImagesIds[e2], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t2.k("data", { dataType: "style" }));
            } else this.fire(new t2.j(new Error(`Sprite "${e2}" doesn't exists on this map.`)));
          }
          getSprite() {
            return g2(this.stylesheet.sprite);
          }
          setSprite(e2, i3 = {}, s3) {
            this._checkLoaded(), e2 && this._validate(t2.y.sprite, "sprite", e2, null, i3) || (this.stylesheet.sprite = e2, e2 ? this._loadSprite(e2, true, s3) : (this._unloadSprite(), s3 && s3(null)));
          }
        }
        se2.registerForPluginStateChange = t2.aK;
        var ae2 = t2.Q([{ name: "a_pos", type: "Int16", components: 2 }]), oe2 = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
        const re2 = { prelude: ne2("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}"), background: ne2("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: ne2("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: ne2("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: ne2("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: ne2("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), heatmapTexture: ne2("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: ne2("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: ne2("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: ne2("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: ne2("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), fillOutline: ne2("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillOutlinePattern: ne2("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillPattern: ne2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: ne2("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: ne2("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: ne2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: ne2("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: ne2("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: ne2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: ne2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: ne2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: ne2("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: ne2("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: ne2("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: ne2("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: ne2("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", oe2), terrainDepth: ne2("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", oe2), terrainCoords: ne2("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", oe2) };
        function ne2(t3, e2) {
          const i3 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, s3 = e2.match(/attribute ([\w]+) ([\w]+)/g), a3 = t3.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o3 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r3 = o3 ? o3.concat(a3) : a3, n3 = {};
          return { fragmentSource: t3 = t3.replace(i3, (t4, e3, i4, s4, a4) => (n3[a4] = true, "define" === e3 ? `
#ifndef HAS_UNIFORM_u_${a4}
varying ${i4} ${s4} ${a4};
#else
uniform ${i4} ${s4} u_${a4};
#endif
` : `
#ifdef HAS_UNIFORM_u_${a4}
    ${i4} ${s4} ${a4} = u_${a4};
#endif
`)), vertexSource: e2 = e2.replace(i3, (t4, e3, i4, s4, a4) => {
            const o4 = "float" === s4 ? "vec2" : "vec4", r4 = a4.match(/color/) ? "color" : o4;
            return n3[a4] ? "define" === e3 ? `
#ifndef HAS_UNIFORM_u_${a4}
uniform lowp float u_${a4}_t;
attribute ${i4} ${o4} a_${a4};
varying ${i4} ${s4} ${a4};
#else
uniform ${i4} ${s4} u_${a4};
#endif
` : "vec4" === r4 ? `
#ifndef HAS_UNIFORM_u_${a4}
    ${a4} = a_${a4};
#else
    ${i4} ${s4} ${a4} = u_${a4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a4}
    ${a4} = unpack_mix_${r4}(a_${a4}, u_${a4}_t);
#else
    ${i4} ${s4} ${a4} = u_${a4};
#endif
` : "define" === e3 ? `
#ifndef HAS_UNIFORM_u_${a4}
uniform lowp float u_${a4}_t;
attribute ${i4} ${o4} a_${a4};
#else
uniform ${i4} ${s4} u_${a4};
#endif
` : "vec4" === r4 ? `
#ifndef HAS_UNIFORM_u_${a4}
    ${i4} ${s4} ${a4} = a_${a4};
#else
    ${i4} ${s4} ${a4} = u_${a4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a4}
    ${i4} ${s4} ${a4} = unpack_mix_${r4}(a_${a4}, u_${a4}_t);
#else
    ${i4} ${s4} ${a4} = u_${a4};
#endif
`;
          }), staticAttributes: s3, staticUniforms: r3 };
        }
        class le2 {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(t3, e2, i3, s3, a3, o3, r3, n3, l3) {
            this.context = t3;
            let h3 = this.boundPaintVertexBuffers.length !== s3.length;
            for (let t4 = 0; !h3 && t4 < s3.length; t4++) this.boundPaintVertexBuffers[t4] !== s3[t4] && (h3 = true);
            !this.vao || this.boundProgram !== e2 || this.boundLayoutVertexBuffer !== i3 || h3 || this.boundIndexBuffer !== a3 || this.boundVertexOffset !== o3 || this.boundDynamicVertexBuffer !== r3 || this.boundDynamicVertexBuffer2 !== n3 || this.boundDynamicVertexBuffer3 !== l3 ? this.freshBind(e2, i3, s3, a3, o3, r3, n3, l3) : (t3.bindVertexArray.set(this.vao), r3 && r3.bind(), a3 && a3.dynamicDraw && a3.bind(), n3 && n3.bind(), l3 && l3.bind());
          }
          freshBind(t3, e2, i3, s3, a3, o3, r3, n3) {
            const l3 = t3.numAttributes, h3 = this.context, c3 = h3.gl;
            this.vao && this.destroy(), this.vao = h3.createVertexArray(), h3.bindVertexArray.set(this.vao), this.boundProgram = t3, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i3, this.boundIndexBuffer = s3, this.boundVertexOffset = a3, this.boundDynamicVertexBuffer = o3, this.boundDynamicVertexBuffer2 = r3, this.boundDynamicVertexBuffer3 = n3, e2.enableAttributes(c3, t3);
            for (const e3 of i3) e3.enableAttributes(c3, t3);
            o3 && o3.enableAttributes(c3, t3), r3 && r3.enableAttributes(c3, t3), n3 && n3.enableAttributes(c3, t3), e2.bind(), e2.setVertexAttribPointers(c3, t3, a3);
            for (const e3 of i3) e3.bind(), e3.setVertexAttribPointers(c3, t3, a3);
            o3 && (o3.bind(), o3.setVertexAttribPointers(c3, t3, a3)), s3 && s3.bind(), r3 && (r3.bind(), r3.setVertexAttribPointers(c3, t3, a3)), n3 && (n3.bind(), n3.setVertexAttribPointers(c3, t3, a3)), h3.currentNumAttributes = l3;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        function he2(t3) {
          const e2 = [];
          for (let i3 = 0; i3 < t3.length; i3++) {
            if (null === t3[i3]) continue;
            const s3 = t3[i3].split(" ");
            e2.push(s3.pop());
          }
          return e2;
        }
        class ce2 {
          constructor(e2, i3, s3, a3, o3, r3) {
            const n3 = e2.gl;
            this.program = n3.createProgram();
            const l3 = he2(i3.staticAttributes), h3 = s3 ? s3.getBinderAttributes() : [], c3 = l3.concat(h3), u3 = re2.prelude.staticUniforms ? he2(re2.prelude.staticUniforms) : [], d3 = i3.staticUniforms ? he2(i3.staticUniforms) : [], _3 = s3 ? s3.getBinderUniforms() : [], p3 = u3.concat(d3).concat(_3), m3 = [];
            for (const t3 of p3) m3.indexOf(t3) < 0 && m3.push(t3);
            const f3 = s3 ? s3.defines() : [];
            o3 && f3.push("#define OVERDRAW_INSPECTOR;"), r3 && f3.push("#define TERRAIN3D;");
            const g3 = f3.concat(re2.prelude.fragmentSource, i3.fragmentSource).join("\n"), v3 = f3.concat(re2.prelude.vertexSource, i3.vertexSource).join("\n"), x3 = n3.createShader(n3.FRAGMENT_SHADER);
            if (n3.isContextLost()) return void (this.failedToCreate = true);
            if (n3.shaderSource(x3, g3), n3.compileShader(x3), !n3.getShaderParameter(x3, n3.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${n3.getShaderInfoLog(x3)}`);
            n3.attachShader(this.program, x3);
            const y3 = n3.createShader(n3.VERTEX_SHADER);
            if (n3.isContextLost()) return void (this.failedToCreate = true);
            if (n3.shaderSource(y3, v3), n3.compileShader(y3), !n3.getShaderParameter(y3, n3.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${n3.getShaderInfoLog(y3)}`);
            n3.attachShader(this.program, y3), this.attributes = {};
            const b3 = {};
            this.numAttributes = c3.length;
            for (let t3 = 0; t3 < this.numAttributes; t3++) c3[t3] && (n3.bindAttribLocation(this.program, t3, c3[t3]), this.attributes[c3[t3]] = t3);
            if (n3.linkProgram(this.program), !n3.getProgramParameter(this.program, n3.LINK_STATUS)) throw new Error(`Program failed to link: ${n3.getProgramInfoLog(this.program)}`);
            n3.deleteShader(y3), n3.deleteShader(x3);
            for (let t3 = 0; t3 < m3.length; t3++) {
              const e3 = m3[t3];
              if (e3 && !b3[e3]) {
                const t4 = n3.getUniformLocation(this.program, e3);
                t4 && (b3[e3] = t4);
              }
            }
            this.fixedUniforms = a3(e2, b3), this.terrainUniforms = ((e3, i4) => ({ u_depth: new t2.aL(e3, i4.u_depth), u_terrain: new t2.aL(e3, i4.u_terrain), u_terrain_dim: new t2.aM(e3, i4.u_terrain_dim), u_terrain_matrix: new t2.aN(e3, i4.u_terrain_matrix), u_terrain_unpack: new t2.aO(e3, i4.u_terrain_unpack), u_terrain_exaggeration: new t2.aM(e3, i4.u_terrain_exaggeration) }))(e2, b3), this.binderUniforms = s3 ? s3.getUniforms(e2, b3) : [];
          }
          draw(t3, e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3, _3, p3, m3, f3, g3) {
            const v3 = t3.gl;
            if (this.failedToCreate) return;
            if (t3.program.set(this.program), t3.setDepthMode(i3), t3.setStencilMode(s3), t3.setColorMode(a3), t3.setCullFace(o3), n3) {
              t3.activeTexture.set(v3.TEXTURE2), v3.bindTexture(v3.TEXTURE_2D, n3.depthTexture), t3.activeTexture.set(v3.TEXTURE3), v3.bindTexture(v3.TEXTURE_2D, n3.texture);
              for (const t4 in this.terrainUniforms) this.terrainUniforms[t4].set(n3[t4]);
            }
            for (const t4 in this.fixedUniforms) this.fixedUniforms[t4].set(r3[t4]);
            p3 && p3.setUniforms(t3, this.binderUniforms, d3, { zoom: _3 });
            let x3 = 0;
            switch (e2) {
              case v3.LINES:
                x3 = 2;
                break;
              case v3.TRIANGLES:
                x3 = 3;
                break;
              case v3.LINE_STRIP:
                x3 = 1;
            }
            for (const i4 of u3.get()) {
              const s4 = i4.vaos || (i4.vaos = {});
              (s4[l3] || (s4[l3] = new le2())).bind(t3, this, h3, p3 ? p3.getPaintVertexBuffers() : [], c3, i4.vertexOffset, m3, f3, g3), v3.drawElements(e2, i4.primitiveLength * x3, v3.UNSIGNED_SHORT, i4.primitiveOffset * x3 * 2);
            }
          }
        }
        function ue2(t3, e2, i3) {
          const s3 = 1 / St(i3, 1, e2.transform.tileZoom), a3 = Math.pow(2, i3.tileID.overscaledZ), o3 = i3.tileSize * Math.pow(2, e2.transform.tileZoom) / a3, r3 = o3 * (i3.tileID.canonical.x + i3.tileID.wrap * a3), n3 = o3 * i3.tileID.canonical.y;
          return { u_image: 0, u_texsize: i3.imageAtlasTexture.size, u_scale: [s3, t3.fromScale, t3.toScale], u_fade: t3.t, u_pixel_coord_upper: [r3 >> 16, n3 >> 16], u_pixel_coord_lower: [65535 & r3, 65535 & n3] };
        }
        const de2 = (e2, i3, s3, a3) => {
          const o3 = i3.style.light, r3 = o3.properties.get("position"), n3 = [r3.x, r3.y, r3.z], l3 = function() {
            var e3 = new t2.A(9);
            return t2.A != Float32Array && (e3[1] = 0, e3[2] = 0, e3[3] = 0, e3[5] = 0, e3[6] = 0, e3[7] = 0), e3[0] = 1, e3[4] = 1, e3[8] = 1, e3;
          }();
          "viewport" === o3.properties.get("anchor") && function(t3, e3) {
            var i4 = Math.sin(e3), s4 = Math.cos(e3);
            t3[0] = s4, t3[1] = i4, t3[2] = 0, t3[3] = -i4, t3[4] = s4, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1;
          }(l3, -i3.transform.angle), function(t3, e3, i4) {
            var s4 = e3[0], a4 = e3[1], o4 = e3[2];
            t3[0] = s4 * i4[0] + a4 * i4[3] + o4 * i4[6], t3[1] = s4 * i4[1] + a4 * i4[4] + o4 * i4[7], t3[2] = s4 * i4[2] + a4 * i4[5] + o4 * i4[8];
          }(n3, n3, l3);
          const h3 = o3.properties.get("color");
          return { u_matrix: e2, u_lightpos: n3, u_lightintensity: o3.properties.get("intensity"), u_lightcolor: [h3.r, h3.g, h3.b], u_vertical_gradient: +s3, u_opacity: a3 };
        }, _e2 = (e2, i3, s3, a3, o3, r3, n3) => t2.e(de2(e2, i3, s3, a3), ue2(r3, i3, n3), { u_height_factor: -Math.pow(2, o3.overscaledZ) / n3.tileSize / 8 }), pe2 = (t3) => ({ u_matrix: t3 }), me2 = (e2, i3, s3, a3) => t2.e(pe2(e2), ue2(s3, i3, a3)), fe2 = (t3, e2) => ({ u_matrix: t3, u_world: e2 }), ge2 = (e2, i3, s3, a3, o3) => t2.e(me2(e2, i3, s3, a3), { u_world: o3 }), ve2 = (t3, e2, i3, s3) => {
          const a3 = t3.transform;
          let o3, r3;
          if ("map" === s3.paint.get("circle-pitch-alignment")) {
            const t4 = St(i3, 1, a3.zoom);
            o3 = true, r3 = [t4, t4];
          } else o3 = false, r3 = a3.pixelsToGLUnits;
          return { u_camera_to_center_distance: a3.cameraToCenterDistance, u_scale_with_map: +("map" === s3.paint.get("circle-pitch-scale")), u_matrix: t3.translatePosMatrix(e2.posMatrix, i3, s3.paint.get("circle-translate"), s3.paint.get("circle-translate-anchor")), u_pitch_with_map: +o3, u_device_pixel_ratio: t3.pixelRatio, u_extrude_scale: r3 };
        }, xe2 = (t3, e2, i3) => {
          const s3 = St(i3, 1, e2.zoom), a3 = Math.pow(2, e2.zoom - i3.tileID.overscaledZ), o3 = i3.tileID.overscaleFactor();
          return { u_matrix: t3, u_camera_to_center_distance: e2.cameraToCenterDistance, u_pixels_to_tile_units: s3, u_extrude_scale: [e2.pixelsToGLUnits[0] / (s3 * a3), e2.pixelsToGLUnits[1] / (s3 * a3)], u_overscale_factor: o3 };
        }, ye2 = (t3, e2, i3 = 1) => ({ u_matrix: t3, u_color: e2, u_overlay: 0, u_overlay_scale: i3 }), be2 = (t3) => ({ u_matrix: t3 }), we2 = (t3, e2, i3, s3) => ({ u_matrix: t3, u_extrude_scale: St(e2, 1, i3), u_intensity: s3 });
        function Te2(e2, i3) {
          const s3 = Math.pow(2, i3.canonical.z), a3 = i3.canonical.y;
          return [new t2.U(0, a3 / s3).toLngLat().lat, new t2.U(0, (a3 + 1) / s3).toLngLat().lat];
        }
        const Ie2 = (t3, e2, i3, s3) => {
          const a3 = t3.transform;
          return { u_matrix: De2(t3, e2, i3, s3), u_ratio: 1 / St(e2, 1, a3.zoom), u_device_pixel_ratio: t3.pixelRatio, u_units_to_pixels: [1 / a3.pixelsToGLUnits[0], 1 / a3.pixelsToGLUnits[1]] };
        }, Ee2 = (e2, i3, s3, a3, o3) => t2.e(Ie2(e2, i3, s3, o3), { u_image: 0, u_image_height: a3 }), Se2 = (t3, e2, i3, s3, a3) => {
          const o3 = t3.transform, r3 = Pe2(e2, o3);
          return { u_matrix: De2(t3, e2, i3, a3), u_texsize: e2.imageAtlasTexture.size, u_ratio: 1 / St(e2, 1, o3.zoom), u_device_pixel_ratio: t3.pixelRatio, u_image: 0, u_scale: [r3, s3.fromScale, s3.toScale], u_fade: s3.t, u_units_to_pixels: [1 / o3.pixelsToGLUnits[0], 1 / o3.pixelsToGLUnits[1]] };
        }, Ce2 = (e2, i3, s3, a3, o3, r3) => {
          const n3 = e2.lineAtlas, l3 = Pe2(i3, e2.transform), h3 = "round" === s3.layout.get("line-cap"), c3 = n3.getDash(a3.from, h3), u3 = n3.getDash(a3.to, h3), d3 = c3.width * o3.fromScale, _3 = u3.width * o3.toScale;
          return t2.e(Ie2(e2, i3, s3, r3), { u_patternscale_a: [l3 / d3, -c3.height / 2], u_patternscale_b: [l3 / _3, -u3.height / 2], u_sdfgamma: n3.width / (256 * Math.min(d3, _3) * e2.pixelRatio) / 2, u_image: 0, u_tex_y_a: c3.y, u_tex_y_b: u3.y, u_mix: o3.t });
        };
        function Pe2(t3, e2) {
          return 1 / St(t3, 1, e2.tileZoom);
        }
        function De2(t3, e2, i3, s3) {
          return t3.translatePosMatrix(s3 ? s3.posMatrix : e2.tileID.posMatrix, e2, i3.paint.get("line-translate"), i3.paint.get("line-translate-anchor"));
        }
        const Me2 = (t3, e2, i3, s3, a3) => {
          return { u_matrix: t3, u_tl_parent: e2, u_scale_parent: i3, u_buffer_scale: 1, u_fade_t: s3.mix, u_opacity: s3.opacity * a3.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a3.paint.get("raster-brightness-min"), u_brightness_high: a3.paint.get("raster-brightness-max"), u_saturation_factor: (r3 = a3.paint.get("raster-saturation"), r3 > 0 ? 1 - 1 / (1.001 - r3) : -r3), u_contrast_factor: (o3 = a3.paint.get("raster-contrast"), o3 > 0 ? 1 / (1 - o3) : 1 + o3), u_spin_weights: ze2(a3.paint.get("raster-hue-rotate")) };
          var o3, r3;
        };
        function ze2(t3) {
          t3 *= Math.PI / 180;
          const e2 = Math.sin(t3), i3 = Math.cos(t3);
          return [(2 * i3 + 1) / 3, (-Math.sqrt(3) * e2 - i3 + 1) / 3, (Math.sqrt(3) * e2 - i3 + 1) / 3];
        }
        const Le2 = (t3, e2, i3, s3, a3, o3, r3, n3, l3, h3) => {
          const c3 = a3.transform;
          return { u_is_size_zoom_constant: +("constant" === t3 || "source" === t3), u_is_size_feature_constant: +("constant" === t3 || "camera" === t3), u_size_t: e2 ? e2.uSizeT : 0, u_size: e2 ? e2.uSize : 0, u_camera_to_center_distance: c3.cameraToCenterDistance, u_pitch: c3.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i3, u_aspect_ratio: c3.width / c3.height, u_fade_change: a3.options.fadeDuration ? a3.symbolFadeChange : 1, u_matrix: o3, u_label_plane_matrix: r3, u_coord_matrix: n3, u_is_text: +l3, u_pitch_with_map: +s3, u_texsize: h3, u_texture: 0 };
        }, Ae2 = (e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3) => {
          const d3 = o3.transform;
          return t2.e(Le2(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3), { u_gamma_scale: a3 ? Math.cos(d3._pitch) * d3.cameraToCenterDistance : 1, u_device_pixel_ratio: o3.pixelRatio, u_is_halo: 1 });
        }, Re2 = (e2, i3, s3, a3, o3, r3, n3, l3, h3, c3) => t2.e(Ae2(e2, i3, s3, a3, o3, r3, n3, l3, true, h3), { u_texsize_icon: c3, u_texture_icon: 1 }), ke2 = (t3, e2, i3) => ({ u_matrix: t3, u_opacity: e2, u_color: i3 }), Fe2 = (e2, i3, s3, a3, o3, r3) => t2.e(function(t3, e3, i4, s4) {
          const a4 = i4.imageManager.getPattern(t3.from.toString()), o4 = i4.imageManager.getPattern(t3.to.toString()), { width: r4, height: n3 } = i4.imageManager.getPixelSize(), l3 = Math.pow(2, s4.tileID.overscaledZ), h3 = s4.tileSize * Math.pow(2, i4.transform.tileZoom) / l3, c3 = h3 * (s4.tileID.canonical.x + s4.tileID.wrap * l3), u3 = h3 * s4.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: a4.tl, u_pattern_br_a: a4.br, u_pattern_tl_b: o4.tl, u_pattern_br_b: o4.br, u_texsize: [r4, n3], u_mix: e3.t, u_pattern_size_a: a4.displaySize, u_pattern_size_b: o4.displaySize, u_scale_a: e3.fromScale, u_scale_b: e3.toScale, u_tile_units_to_pixels: 1 / St(s4, 1, i4.transform.tileZoom), u_pixel_coord_upper: [c3 >> 16, u3 >> 16], u_pixel_coord_lower: [65535 & c3, 65535 & u3] };
        }(a3, r3, s3, o3), { u_matrix: e2, u_opacity: i3 }), Be2 = { fillExtrusion: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_lightpos: new t2.aP(e2, i3.u_lightpos), u_lightintensity: new t2.aM(e2, i3.u_lightintensity), u_lightcolor: new t2.aP(e2, i3.u_lightcolor), u_vertical_gradient: new t2.aM(e2, i3.u_vertical_gradient), u_opacity: new t2.aM(e2, i3.u_opacity) }), fillExtrusionPattern: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_lightpos: new t2.aP(e2, i3.u_lightpos), u_lightintensity: new t2.aM(e2, i3.u_lightintensity), u_lightcolor: new t2.aP(e2, i3.u_lightcolor), u_vertical_gradient: new t2.aM(e2, i3.u_vertical_gradient), u_height_factor: new t2.aM(e2, i3.u_height_factor), u_image: new t2.aL(e2, i3.u_image), u_texsize: new t2.aQ(e2, i3.u_texsize), u_pixel_coord_upper: new t2.aQ(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t2.aQ(e2, i3.u_pixel_coord_lower), u_scale: new t2.aP(e2, i3.u_scale), u_fade: new t2.aM(e2, i3.u_fade), u_opacity: new t2.aM(e2, i3.u_opacity) }), fill: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix) }), fillPattern: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_image: new t2.aL(e2, i3.u_image), u_texsize: new t2.aQ(e2, i3.u_texsize), u_pixel_coord_upper: new t2.aQ(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t2.aQ(e2, i3.u_pixel_coord_lower), u_scale: new t2.aP(e2, i3.u_scale), u_fade: new t2.aM(e2, i3.u_fade) }), fillOutline: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_world: new t2.aQ(e2, i3.u_world) }), fillOutlinePattern: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_world: new t2.aQ(e2, i3.u_world), u_image: new t2.aL(e2, i3.u_image), u_texsize: new t2.aQ(e2, i3.u_texsize), u_pixel_coord_upper: new t2.aQ(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t2.aQ(e2, i3.u_pixel_coord_lower), u_scale: new t2.aP(e2, i3.u_scale), u_fade: new t2.aM(e2, i3.u_fade) }), circle: (e2, i3) => ({ u_camera_to_center_distance: new t2.aM(e2, i3.u_camera_to_center_distance), u_scale_with_map: new t2.aL(e2, i3.u_scale_with_map), u_pitch_with_map: new t2.aL(e2, i3.u_pitch_with_map), u_extrude_scale: new t2.aQ(e2, i3.u_extrude_scale), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_matrix: new t2.aN(e2, i3.u_matrix) }), collisionBox: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_camera_to_center_distance: new t2.aM(e2, i3.u_camera_to_center_distance), u_pixels_to_tile_units: new t2.aM(e2, i3.u_pixels_to_tile_units), u_extrude_scale: new t2.aQ(e2, i3.u_extrude_scale), u_overscale_factor: new t2.aM(e2, i3.u_overscale_factor) }), collisionCircle: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_inv_matrix: new t2.aN(e2, i3.u_inv_matrix), u_camera_to_center_distance: new t2.aM(e2, i3.u_camera_to_center_distance), u_viewport_size: new t2.aQ(e2, i3.u_viewport_size) }), debug: (e2, i3) => ({ u_color: new t2.aR(e2, i3.u_color), u_matrix: new t2.aN(e2, i3.u_matrix), u_overlay: new t2.aL(e2, i3.u_overlay), u_overlay_scale: new t2.aM(e2, i3.u_overlay_scale) }), clippingMask: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix) }), heatmap: (e2, i3) => ({ u_extrude_scale: new t2.aM(e2, i3.u_extrude_scale), u_intensity: new t2.aM(e2, i3.u_intensity), u_matrix: new t2.aN(e2, i3.u_matrix) }), heatmapTexture: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_world: new t2.aQ(e2, i3.u_world), u_image: new t2.aL(e2, i3.u_image), u_color_ramp: new t2.aL(e2, i3.u_color_ramp), u_opacity: new t2.aM(e2, i3.u_opacity) }), hillshade: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_image: new t2.aL(e2, i3.u_image), u_latrange: new t2.aQ(e2, i3.u_latrange), u_light: new t2.aQ(e2, i3.u_light), u_shadow: new t2.aR(e2, i3.u_shadow), u_highlight: new t2.aR(e2, i3.u_highlight), u_accent: new t2.aR(e2, i3.u_accent) }), hillshadePrepare: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_image: new t2.aL(e2, i3.u_image), u_dimension: new t2.aQ(e2, i3.u_dimension), u_zoom: new t2.aM(e2, i3.u_zoom), u_unpack: new t2.aO(e2, i3.u_unpack) }), line: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_ratio: new t2.aM(e2, i3.u_ratio), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_units_to_pixels: new t2.aQ(e2, i3.u_units_to_pixels) }), lineGradient: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_ratio: new t2.aM(e2, i3.u_ratio), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_units_to_pixels: new t2.aQ(e2, i3.u_units_to_pixels), u_image: new t2.aL(e2, i3.u_image), u_image_height: new t2.aM(e2, i3.u_image_height) }), linePattern: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_texsize: new t2.aQ(e2, i3.u_texsize), u_ratio: new t2.aM(e2, i3.u_ratio), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_image: new t2.aL(e2, i3.u_image), u_units_to_pixels: new t2.aQ(e2, i3.u_units_to_pixels), u_scale: new t2.aP(e2, i3.u_scale), u_fade: new t2.aM(e2, i3.u_fade) }), lineSDF: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_ratio: new t2.aM(e2, i3.u_ratio), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_units_to_pixels: new t2.aQ(e2, i3.u_units_to_pixels), u_patternscale_a: new t2.aQ(e2, i3.u_patternscale_a), u_patternscale_b: new t2.aQ(e2, i3.u_patternscale_b), u_sdfgamma: new t2.aM(e2, i3.u_sdfgamma), u_image: new t2.aL(e2, i3.u_image), u_tex_y_a: new t2.aM(e2, i3.u_tex_y_a), u_tex_y_b: new t2.aM(e2, i3.u_tex_y_b), u_mix: new t2.aM(e2, i3.u_mix) }), raster: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_tl_parent: new t2.aQ(e2, i3.u_tl_parent), u_scale_parent: new t2.aM(e2, i3.u_scale_parent), u_buffer_scale: new t2.aM(e2, i3.u_buffer_scale), u_fade_t: new t2.aM(e2, i3.u_fade_t), u_opacity: new t2.aM(e2, i3.u_opacity), u_image0: new t2.aL(e2, i3.u_image0), u_image1: new t2.aL(e2, i3.u_image1), u_brightness_low: new t2.aM(e2, i3.u_brightness_low), u_brightness_high: new t2.aM(e2, i3.u_brightness_high), u_saturation_factor: new t2.aM(e2, i3.u_saturation_factor), u_contrast_factor: new t2.aM(e2, i3.u_contrast_factor), u_spin_weights: new t2.aP(e2, i3.u_spin_weights) }), symbolIcon: (e2, i3) => ({ u_is_size_zoom_constant: new t2.aL(e2, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t2.aL(e2, i3.u_is_size_feature_constant), u_size_t: new t2.aM(e2, i3.u_size_t), u_size: new t2.aM(e2, i3.u_size), u_camera_to_center_distance: new t2.aM(e2, i3.u_camera_to_center_distance), u_pitch: new t2.aM(e2, i3.u_pitch), u_rotate_symbol: new t2.aL(e2, i3.u_rotate_symbol), u_aspect_ratio: new t2.aM(e2, i3.u_aspect_ratio), u_fade_change: new t2.aM(e2, i3.u_fade_change), u_matrix: new t2.aN(e2, i3.u_matrix), u_label_plane_matrix: new t2.aN(e2, i3.u_label_plane_matrix), u_coord_matrix: new t2.aN(e2, i3.u_coord_matrix), u_is_text: new t2.aL(e2, i3.u_is_text), u_pitch_with_map: new t2.aL(e2, i3.u_pitch_with_map), u_texsize: new t2.aQ(e2, i3.u_texsize), u_texture: new t2.aL(e2, i3.u_texture) }), symbolSDF: (e2, i3) => ({ u_is_size_zoom_constant: new t2.aL(e2, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t2.aL(e2, i3.u_is_size_feature_constant), u_size_t: new t2.aM(e2, i3.u_size_t), u_size: new t2.aM(e2, i3.u_size), u_camera_to_center_distance: new t2.aM(e2, i3.u_camera_to_center_distance), u_pitch: new t2.aM(e2, i3.u_pitch), u_rotate_symbol: new t2.aL(e2, i3.u_rotate_symbol), u_aspect_ratio: new t2.aM(e2, i3.u_aspect_ratio), u_fade_change: new t2.aM(e2, i3.u_fade_change), u_matrix: new t2.aN(e2, i3.u_matrix), u_label_plane_matrix: new t2.aN(e2, i3.u_label_plane_matrix), u_coord_matrix: new t2.aN(e2, i3.u_coord_matrix), u_is_text: new t2.aL(e2, i3.u_is_text), u_pitch_with_map: new t2.aL(e2, i3.u_pitch_with_map), u_texsize: new t2.aQ(e2, i3.u_texsize), u_texture: new t2.aL(e2, i3.u_texture), u_gamma_scale: new t2.aM(e2, i3.u_gamma_scale), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_is_halo: new t2.aL(e2, i3.u_is_halo) }), symbolTextAndIcon: (e2, i3) => ({ u_is_size_zoom_constant: new t2.aL(e2, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t2.aL(e2, i3.u_is_size_feature_constant), u_size_t: new t2.aM(e2, i3.u_size_t), u_size: new t2.aM(e2, i3.u_size), u_camera_to_center_distance: new t2.aM(e2, i3.u_camera_to_center_distance), u_pitch: new t2.aM(e2, i3.u_pitch), u_rotate_symbol: new t2.aL(e2, i3.u_rotate_symbol), u_aspect_ratio: new t2.aM(e2, i3.u_aspect_ratio), u_fade_change: new t2.aM(e2, i3.u_fade_change), u_matrix: new t2.aN(e2, i3.u_matrix), u_label_plane_matrix: new t2.aN(e2, i3.u_label_plane_matrix), u_coord_matrix: new t2.aN(e2, i3.u_coord_matrix), u_is_text: new t2.aL(e2, i3.u_is_text), u_pitch_with_map: new t2.aL(e2, i3.u_pitch_with_map), u_texsize: new t2.aQ(e2, i3.u_texsize), u_texsize_icon: new t2.aQ(e2, i3.u_texsize_icon), u_texture: new t2.aL(e2, i3.u_texture), u_texture_icon: new t2.aL(e2, i3.u_texture_icon), u_gamma_scale: new t2.aM(e2, i3.u_gamma_scale), u_device_pixel_ratio: new t2.aM(e2, i3.u_device_pixel_ratio), u_is_halo: new t2.aL(e2, i3.u_is_halo) }), background: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_opacity: new t2.aM(e2, i3.u_opacity), u_color: new t2.aR(e2, i3.u_color) }), backgroundPattern: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_opacity: new t2.aM(e2, i3.u_opacity), u_image: new t2.aL(e2, i3.u_image), u_pattern_tl_a: new t2.aQ(e2, i3.u_pattern_tl_a), u_pattern_br_a: new t2.aQ(e2, i3.u_pattern_br_a), u_pattern_tl_b: new t2.aQ(e2, i3.u_pattern_tl_b), u_pattern_br_b: new t2.aQ(e2, i3.u_pattern_br_b), u_texsize: new t2.aQ(e2, i3.u_texsize), u_mix: new t2.aM(e2, i3.u_mix), u_pattern_size_a: new t2.aQ(e2, i3.u_pattern_size_a), u_pattern_size_b: new t2.aQ(e2, i3.u_pattern_size_b), u_scale_a: new t2.aM(e2, i3.u_scale_a), u_scale_b: new t2.aM(e2, i3.u_scale_b), u_pixel_coord_upper: new t2.aQ(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t2.aQ(e2, i3.u_pixel_coord_lower), u_tile_units_to_pixels: new t2.aM(e2, i3.u_tile_units_to_pixels) }), terrain: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_texture: new t2.aL(e2, i3.u_texture), u_ele_delta: new t2.aM(e2, i3.u_ele_delta) }), terrainDepth: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_ele_delta: new t2.aM(e2, i3.u_ele_delta) }), terrainCoords: (e2, i3) => ({ u_matrix: new t2.aN(e2, i3.u_matrix), u_texture: new t2.aL(e2, i3.u_texture), u_terrain_coords_id: new t2.aM(e2, i3.u_terrain_coords_id), u_ele_delta: new t2.aM(e2, i3.u_ele_delta) }) };
        class Oe2 {
          constructor(t3, e2, i3) {
            this.context = t3;
            const s3 = t3.gl;
            this.buffer = s3.createBuffer(), this.dynamicDraw = Boolean(i3), this.context.unbindVAO(), t3.bindElementBuffer.set(this.buffer), s3.bufferData(s3.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? s3.DYNAMIC_DRAW : s3.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(t3) {
            const e2 = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t3.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Ne2 = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Ue2 {
          constructor(t3, e2, i3, s3) {
            this.length = e2.length, this.attributes = i3, this.itemSize = e2.bytesPerElement, this.dynamicDraw = s3, this.context = t3;
            const a3 = t3.gl;
            this.buffer = a3.createBuffer(), t3.bindVertexBuffer.set(this.buffer), a3.bufferData(a3.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? a3.DYNAMIC_DRAW : a3.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(t3) {
            if (t3.length !== this.length) throw new Error(`Length of new data is ${t3.length}, which doesn't match current length of ${this.length}`);
            const e2 = this.context.gl;
            this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t3.arrayBuffer);
          }
          enableAttributes(t3, e2) {
            for (let i3 = 0; i3 < this.attributes.length; i3++) {
              const s3 = e2.attributes[this.attributes[i3].name];
              void 0 !== s3 && t3.enableVertexAttribArray(s3);
            }
          }
          setVertexAttribPointers(t3, e2, i3) {
            for (let s3 = 0; s3 < this.attributes.length; s3++) {
              const a3 = this.attributes[s3], o3 = e2.attributes[a3.name];
              void 0 !== o3 && t3.vertexAttribPointer(o3, a3.components, t3[Ne2[a3.type]], false, this.itemSize, a3.offset + this.itemSize * (i3 || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Ze2 = /* @__PURE__ */ new WeakMap();
        function Ge2(t3) {
          var e2;
          if (Ze2.has(t3)) return Ze2.get(t3);
          {
            const i3 = null === (e2 = t3.getParameter(t3.VERSION)) || void 0 === e2 ? void 0 : e2.startsWith("WebGL 2.0");
            return Ze2.set(t3, i3), i3;
          }
        }
        class je2 {
          constructor(t3) {
            this.gl = t3.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(t3) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Ve2 extends je2 {
          getDefault() {
            return t2.aT.transparent;
          }
          set(t3) {
            const e2 = this.current;
            (t3.r !== e2.r || t3.g !== e2.g || t3.b !== e2.b || t3.a !== e2.a || this.dirty) && (this.gl.clearColor(t3.r, t3.g, t3.b, t3.a), this.current = t3, this.dirty = false);
          }
        }
        class qe2 extends je2 {
          getDefault() {
            return 1;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.clearDepth(t3), this.current = t3, this.dirty = false);
          }
        }
        class $e2 extends je2 {
          getDefault() {
            return 0;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.clearStencil(t3), this.current = t3, this.dirty = false);
          }
        }
        class We2 extends je2 {
          getDefault() {
            return [true, true, true, true];
          }
          set(t3) {
            const e2 = this.current;
            (t3[0] !== e2[0] || t3[1] !== e2[1] || t3[2] !== e2[2] || t3[3] !== e2[3] || this.dirty) && (this.gl.colorMask(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
          }
        }
        class He2 extends je2 {
          getDefault() {
            return true;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.depthMask(t3), this.current = t3, this.dirty = false);
          }
        }
        class Xe2 extends je2 {
          getDefault() {
            return 255;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.stencilMask(t3), this.current = t3, this.dirty = false);
          }
        }
        class Ke extends je2 {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(t3) {
            const e2 = this.current;
            (t3.func !== e2.func || t3.ref !== e2.ref || t3.mask !== e2.mask || this.dirty) && (this.gl.stencilFunc(t3.func, t3.ref, t3.mask), this.current = t3, this.dirty = false);
          }
        }
        class Qe2 extends je2 {
          getDefault() {
            const t3 = this.gl;
            return [t3.KEEP, t3.KEEP, t3.KEEP];
          }
          set(t3) {
            const e2 = this.current;
            (t3[0] !== e2[0] || t3[1] !== e2[1] || t3[2] !== e2[2] || this.dirty) && (this.gl.stencilOp(t3[0], t3[1], t3[2]), this.current = t3, this.dirty = false);
          }
        }
        class Ye extends je2 {
          getDefault() {
            return false;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            const e2 = this.gl;
            t3 ? e2.enable(e2.STENCIL_TEST) : e2.disable(e2.STENCIL_TEST), this.current = t3, this.dirty = false;
          }
        }
        class Je extends je2 {
          getDefault() {
            return [0, 1];
          }
          set(t3) {
            const e2 = this.current;
            (t3[0] !== e2[0] || t3[1] !== e2[1] || this.dirty) && (this.gl.depthRange(t3[0], t3[1]), this.current = t3, this.dirty = false);
          }
        }
        class ti extends je2 {
          getDefault() {
            return false;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            const e2 = this.gl;
            t3 ? e2.enable(e2.DEPTH_TEST) : e2.disable(e2.DEPTH_TEST), this.current = t3, this.dirty = false;
          }
        }
        class ei extends je2 {
          getDefault() {
            return this.gl.LESS;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.depthFunc(t3), this.current = t3, this.dirty = false);
          }
        }
        class ii extends je2 {
          getDefault() {
            return false;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            const e2 = this.gl;
            t3 ? e2.enable(e2.BLEND) : e2.disable(e2.BLEND), this.current = t3, this.dirty = false;
          }
        }
        class si extends je2 {
          getDefault() {
            const t3 = this.gl;
            return [t3.ONE, t3.ZERO];
          }
          set(t3) {
            const e2 = this.current;
            (t3[0] !== e2[0] || t3[1] !== e2[1] || this.dirty) && (this.gl.blendFunc(t3[0], t3[1]), this.current = t3, this.dirty = false);
          }
        }
        class ai extends je2 {
          getDefault() {
            return t2.aT.transparent;
          }
          set(t3) {
            const e2 = this.current;
            (t3.r !== e2.r || t3.g !== e2.g || t3.b !== e2.b || t3.a !== e2.a || this.dirty) && (this.gl.blendColor(t3.r, t3.g, t3.b, t3.a), this.current = t3, this.dirty = false);
          }
        }
        class oi extends je2 {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.blendEquation(t3), this.current = t3, this.dirty = false);
          }
        }
        class ri extends je2 {
          getDefault() {
            return false;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            const e2 = this.gl;
            t3 ? e2.enable(e2.CULL_FACE) : e2.disable(e2.CULL_FACE), this.current = t3, this.dirty = false;
          }
        }
        class ni extends je2 {
          getDefault() {
            return this.gl.BACK;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.cullFace(t3), this.current = t3, this.dirty = false);
          }
        }
        class li extends je2 {
          getDefault() {
            return this.gl.CCW;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.frontFace(t3), this.current = t3, this.dirty = false);
          }
        }
        class hi extends je2 {
          getDefault() {
            return null;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.useProgram(t3), this.current = t3, this.dirty = false);
          }
        }
        class ci extends je2 {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.activeTexture(t3), this.current = t3, this.dirty = false);
          }
        }
        class ui extends je2 {
          getDefault() {
            const t3 = this.gl;
            return [0, 0, t3.drawingBufferWidth, t3.drawingBufferHeight];
          }
          set(t3) {
            const e2 = this.current;
            (t3[0] !== e2[0] || t3[1] !== e2[1] || t3[2] !== e2[2] || t3[3] !== e2[3] || this.dirty) && (this.gl.viewport(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
          }
        }
        class di extends je2 {
          getDefault() {
            return null;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.bindFramebuffer(e2.FRAMEBUFFER, t3), this.current = t3, this.dirty = false;
          }
        }
        class _i extends je2 {
          getDefault() {
            return null;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.bindRenderbuffer(e2.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
          }
        }
        class pi extends je2 {
          getDefault() {
            return null;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.bindTexture(e2.TEXTURE_2D, t3), this.current = t3, this.dirty = false;
          }
        }
        class mi extends je2 {
          getDefault() {
            return null;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.bindBuffer(e2.ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
          }
        }
        class fi extends je2 {
          getDefault() {
            return null;
          }
          set(t3) {
            const e2 = this.gl;
            e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
          }
        }
        class gi extends je2 {
          getDefault() {
            return null;
          }
          set(t3) {
            var e2;
            if (t3 === this.current && !this.dirty) return;
            const i3 = this.gl;
            Ge2(i3) ? i3.bindVertexArray(t3) : null === (e2 = i3.getExtension("OES_vertex_array_object")) || void 0 === e2 || e2.bindVertexArrayOES(t3), this.current = t3, this.dirty = false;
          }
        }
        class vi extends je2 {
          getDefault() {
            return 4;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_ALIGNMENT, t3), this.current = t3, this.dirty = false;
          }
        }
        class xi extends je2 {
          getDefault() {
            return false;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t3), this.current = t3, this.dirty = false;
          }
        }
        class yi extends je2 {
          getDefault() {
            return false;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_FLIP_Y_WEBGL, t3), this.current = t3, this.dirty = false;
          }
        }
        class bi extends je2 {
          constructor(t3, e2) {
            super(t3), this.context = t3, this.parent = e2;
          }
          getDefault() {
            return null;
          }
        }
        class wi extends bi {
          setDirty() {
            this.dirty = true;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const e2 = this.gl;
            e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t3, 0), this.current = t3, this.dirty = false;
          }
        }
        class Ti extends bi {
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const e2 = this.gl;
            e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_ATTACHMENT, e2.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
          }
        }
        class Ii extends bi {
          set(t3) {
            if (t3 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const e2 = this.gl;
            e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_STENCIL_ATTACHMENT, e2.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
          }
        }
        class Ei {
          constructor(t3, e2, i3, s3, a3) {
            this.context = t3, this.width = e2, this.height = i3;
            const o3 = t3.gl, r3 = this.framebuffer = o3.createFramebuffer();
            if (this.colorAttachment = new wi(t3, r3), s3) this.depthAttachment = a3 ? new Ii(t3, r3) : new Ti(t3, r3);
            else if (a3) throw new Error("Stencil cannot be setted without depth");
            if (o3.checkFramebufferStatus(o3.FRAMEBUFFER) !== o3.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
          }
          destroy() {
            const t3 = this.context.gl, e2 = this.colorAttachment.get();
            if (e2 && t3.deleteTexture(e2), this.depthAttachment) {
              const e3 = this.depthAttachment.get();
              e3 && t3.deleteRenderbuffer(e3);
            }
            t3.deleteFramebuffer(this.framebuffer);
          }
        }
        class Si {
          constructor(t3, e2, i3) {
            this.blendFunction = t3, this.blendColor = e2, this.mask = i3;
          }
        }
        Si.Replace = [1, 0], Si.disabled = new Si(Si.Replace, t2.aT.transparent, [false, false, false, false]), Si.unblended = new Si(Si.Replace, t2.aT.transparent, [true, true, true, true]), Si.alphaBlended = new Si([1, 771], t2.aT.transparent, [true, true, true, true]);
        class Ci {
          constructor(t3) {
            var e2, i3;
            if (this.gl = t3, this.clearColor = new Ve2(this), this.clearDepth = new qe2(this), this.clearStencil = new $e2(this), this.colorMask = new We2(this), this.depthMask = new He2(this), this.stencilMask = new Xe2(this), this.stencilFunc = new Ke(this), this.stencilOp = new Qe2(this), this.stencilTest = new Ye(this), this.depthRange = new Je(this), this.depthTest = new ti(this), this.depthFunc = new ei(this), this.blend = new ii(this), this.blendFunc = new si(this), this.blendColor = new ai(this), this.blendEquation = new oi(this), this.cullFace = new ri(this), this.cullFaceSide = new ni(this), this.frontFace = new li(this), this.program = new hi(this), this.activeTexture = new ci(this), this.viewport = new ui(this), this.bindFramebuffer = new di(this), this.bindRenderbuffer = new _i(this), this.bindTexture = new pi(this), this.bindVertexBuffer = new mi(this), this.bindElementBuffer = new fi(this), this.bindVertexArray = new gi(this), this.pixelStoreUnpack = new vi(this), this.pixelStoreUnpackPremultiplyAlpha = new xi(this), this.pixelStoreUnpackFlipY = new yi(this), this.extTextureFilterAnisotropic = t3.getExtension("EXT_texture_filter_anisotropic") || t3.getExtension("MOZ_EXT_texture_filter_anisotropic") || t3.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t3.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t3.getParameter(t3.MAX_TEXTURE_SIZE), Ge2(t3)) {
              this.HALF_FLOAT = t3.HALF_FLOAT;
              const s3 = t3.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = null !== (e2 = t3.RGBA16F) && void 0 !== e2 ? e2 : null == s3 ? void 0 : s3.RGBA16F_EXT, this.RGB16F = null !== (i3 = t3.RGB16F) && void 0 !== i3 ? i3 : null == s3 ? void 0 : s3.RGB16F_EXT, t3.getExtension("EXT_color_buffer_float");
            } else {
              t3.getExtension("EXT_color_buffer_half_float"), t3.getExtension("OES_texture_half_float_linear");
              const e3 = t3.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = null == e3 ? void 0 : e3.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(t3, e2) {
            return new Oe2(this, t3, e2);
          }
          createVertexBuffer(t3, e2, i3) {
            return new Ue2(this, t3, e2, i3);
          }
          createRenderbuffer(t3, e2, i3) {
            const s3 = this.gl, a3 = s3.createRenderbuffer();
            return this.bindRenderbuffer.set(a3), s3.renderbufferStorage(s3.RENDERBUFFER, t3, e2, i3), this.bindRenderbuffer.set(null), a3;
          }
          createFramebuffer(t3, e2, i3, s3) {
            return new Ei(this, t3, e2, i3, s3);
          }
          clear({ color: t3, depth: e2, stencil: i3 }) {
            const s3 = this.gl;
            let a3 = 0;
            t3 && (a3 |= s3.COLOR_BUFFER_BIT, this.clearColor.set(t3), this.colorMask.set([true, true, true, true])), void 0 !== e2 && (a3 |= s3.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e2), this.depthMask.set(true)), void 0 !== i3 && (a3 |= s3.STENCIL_BUFFER_BIT, this.clearStencil.set(i3), this.stencilMask.set(255)), s3.clear(a3);
          }
          setCullFace(t3) {
            false === t3.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t3.mode), this.frontFace.set(t3.frontFace));
          }
          setDepthMode(t3) {
            t3.func !== this.gl.ALWAYS || t3.mask ? (this.depthTest.set(true), this.depthFunc.set(t3.func), this.depthMask.set(t3.mask), this.depthRange.set(t3.range)) : this.depthTest.set(false);
          }
          setStencilMode(t3) {
            t3.test.func !== this.gl.ALWAYS || t3.mask ? (this.stencilTest.set(true), this.stencilMask.set(t3.mask), this.stencilOp.set([t3.fail, t3.depthFail, t3.pass]), this.stencilFunc.set({ func: t3.test.func, ref: t3.ref, mask: t3.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(e2) {
            t2.aG(e2.blendFunction, Si.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e2.blendFunction), this.blendColor.set(e2.blendColor)), this.colorMask.set(e2.mask);
          }
          createVertexArray() {
            var t3;
            return Ge2(this.gl) ? this.gl.createVertexArray() : null === (t3 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t3 ? void 0 : t3.createVertexArrayOES();
          }
          deleteVertexArray(t3) {
            var e2;
            return Ge2(this.gl) ? this.gl.deleteVertexArray(t3) : null === (e2 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e2 ? void 0 : e2.deleteVertexArrayOES(t3);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        class Pi {
          constructor(t3, e2, i3) {
            this.func = t3, this.mask = e2, this.range = i3;
          }
        }
        Pi.ReadOnly = false, Pi.ReadWrite = true, Pi.disabled = new Pi(519, Pi.ReadOnly, [0, 1]);
        const Di = 7680;
        class Mi {
          constructor(t3, e2, i3, s3, a3, o3) {
            this.test = t3, this.ref = e2, this.mask = i3, this.fail = s3, this.depthFail = a3, this.pass = o3;
          }
        }
        Mi.disabled = new Mi({ func: 519, mask: 0 }, 0, 0, Di, Di, Di);
        class zi {
          constructor(t3, e2, i3) {
            this.enable = t3, this.mode = e2, this.frontFace = i3;
          }
        }
        let Li;
        function Ai(e2, i3, s3, a3, o3, r3, n3) {
          const l3 = e2.context, h3 = l3.gl, c3 = e2.useProgram("collisionBox"), u3 = [];
          let d3 = 0, _3 = 0;
          for (let p4 = 0; p4 < a3.length; p4++) {
            const m4 = a3[p4], f4 = i3.getTile(m4), g4 = f4.getBucket(s3);
            if (!g4) continue;
            let v4 = m4.posMatrix;
            0 === o3[0] && 0 === o3[1] || (v4 = e2.translatePosMatrix(m4.posMatrix, f4, o3, r3));
            const x4 = n3 ? g4.textCollisionBox : g4.iconCollisionBox, y3 = g4.collisionCircleArray;
            if (y3.length > 0) {
              const i4 = t2.Z(), s4 = v4;
              t2.aU(i4, g4.placementInvProjMatrix, e2.transform.glCoordMatrix), t2.aU(i4, i4, g4.placementViewportMatrix), u3.push({ circleArray: y3, circleOffset: _3, transform: s4, invTransform: i4, coord: m4 }), d3 += y3.length / 4, _3 = d3;
            }
            x4 && c3.draw(l3, h3.LINES, Pi.disabled, Mi.disabled, e2.colorModeForRenderPass(), zi.disabled, xe2(v4, e2.transform, f4), e2.style.map.terrain && e2.style.map.terrain.getTerrainData(m4), s3.id, x4.layoutVertexBuffer, x4.indexBuffer, x4.segments, null, e2.transform.zoom, null, null, x4.collisionVertexBuffer);
          }
          if (!n3 || !u3.length) return;
          const p3 = e2.useProgram("collisionCircle"), m3 = new t2.aV();
          m3.resize(4 * d3), m3._trim();
          let f3 = 0;
          for (const t3 of u3) for (let e3 = 0; e3 < t3.circleArray.length / 4; e3++) {
            const i4 = 4 * e3, s4 = t3.circleArray[i4 + 0], a4 = t3.circleArray[i4 + 1], o4 = t3.circleArray[i4 + 2], r4 = t3.circleArray[i4 + 3];
            m3.emplace(f3++, s4, a4, o4, r4, 0), m3.emplace(f3++, s4, a4, o4, r4, 1), m3.emplace(f3++, s4, a4, o4, r4, 2), m3.emplace(f3++, s4, a4, o4, r4, 3);
          }
          (!Li || Li.length < 2 * d3) && (Li = function(e3) {
            const i4 = 2 * e3, s4 = new t2.aX();
            s4.resize(i4), s4._trim();
            for (let t3 = 0; t3 < i4; t3++) {
              const e4 = 6 * t3;
              s4.uint16[e4 + 0] = 4 * t3 + 0, s4.uint16[e4 + 1] = 4 * t3 + 1, s4.uint16[e4 + 2] = 4 * t3 + 2, s4.uint16[e4 + 3] = 4 * t3 + 2, s4.uint16[e4 + 4] = 4 * t3 + 3, s4.uint16[e4 + 5] = 4 * t3 + 0;
            }
            return s4;
          }(d3));
          const g3 = l3.createIndexBuffer(Li, true), v3 = l3.createVertexBuffer(m3, t2.aW.members, true);
          for (const i4 of u3) {
            const a4 = { u_matrix: i4.transform, u_inv_matrix: i4.invTransform, u_camera_to_center_distance: (x3 = e2.transform).cameraToCenterDistance, u_viewport_size: [x3.width, x3.height] };
            p3.draw(l3, h3.TRIANGLES, Pi.disabled, Mi.disabled, e2.colorModeForRenderPass(), zi.disabled, a4, e2.style.map.terrain && e2.style.map.terrain.getTerrainData(i4.coord), s3.id, v3, g3, t2.S.simpleSegment(0, 2 * i4.circleOffset, i4.circleArray.length, i4.circleArray.length / 2), null, e2.transform.zoom, null, null, null);
          }
          var x3;
          v3.destroy(), g3.destroy();
        }
        zi.disabled = new zi(false, 1029, 2305), zi.backCCW = new zi(true, 1029, 2305);
        const Ri = t2.ao(new Float32Array(16));
        function ki(e2, i3, s3, a3, o3, r3) {
          const { horizontalAlign: n3, verticalAlign: l3 } = t2.au(e2);
          return new t2.P((-(n3 - 0.5) * i3 / o3 + a3[0]) * r3, (-(l3 - 0.5) * s3 / o3 + a3[1]) * r3);
        }
        function Fi(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3) {
          const d3 = e2.text.placedSymbolArray, _3 = e2.text.dynamicLayoutVertexArray, p3 = e2.icon.dynamicLayoutVertexArray, m3 = {};
          _3.clear();
          for (let p4 = 0; p4 < d3.length; p4++) {
            const f3 = d3.get(p4), g3 = f3.hidden || !f3.crossTileID || e2.allowVerticalPlacement && !f3.placedOrientation ? null : a3[f3.crossTileID];
            if (g3) {
              const a4 = new t2.P(f3.anchorX, f3.anchorY), d4 = ht(a4, s3 ? n3 : r3, u3), p5 = ct(o3.cameraToCenterDistance, d4.signedDistanceFromCamera);
              let v3 = t2.aj(e2.textSizeData, h3, f3) * p5 / t2.ap;
              s3 && (v3 *= e2.tilePixelRatio / l3);
              const { width: x3, height: y3, anchor: b3, textOffset: w3, textBoxScale: T3 } = g3, I3 = ki(b3, x3, y3, w3, T3, v3), E3 = s3 ? ht(a4.add(I3), r3, u3).point : d4.point.add(i3 ? I3.rotate(-o3.angle) : I3), S3 = e2.allowVerticalPlacement && f3.placedOrientation === t2.ai.vertical ? Math.PI / 2 : 0;
              for (let e3 = 0; e3 < f3.numGlyphs; e3++) t2.ak(_3, E3, S3);
              c3 && f3.associatedIconIndex >= 0 && (m3[f3.associatedIconIndex] = { shiftedAnchor: E3, angle: S3 });
            } else wt(f3.numGlyphs, _3);
          }
          if (c3) {
            p3.clear();
            const i4 = e2.icon.placedSymbolArray;
            for (let e3 = 0; e3 < i4.length; e3++) {
              const s4 = i4.get(e3);
              if (s4.hidden) wt(s4.numGlyphs, p3);
              else {
                const i5 = m3[e3];
                if (i5) for (let e4 = 0; e4 < s4.numGlyphs; e4++) t2.ak(p3, i5.shiftedAnchor, i5.angle);
                else wt(s4.numGlyphs, p3);
              }
            }
            e2.icon.dynamicLayoutVertexBuffer.updateData(p3);
          }
          e2.text.dynamicLayoutVertexBuffer.updateData(_3);
        }
        function Bi(t3, e2, i3) {
          return i3.iconsInText && e2 ? "symbolTextAndIcon" : t3 ? "symbolSDF" : "symbolIcon";
        }
        function Oi(e2, i3, s3, a3, o3, r3, n3, l3, h3, c3, u3, d3) {
          const _3 = e2.context, p3 = _3.gl, m3 = e2.transform, f3 = "map" === l3, g3 = "map" === h3, v3 = "viewport" !== l3 && "point" !== s3.layout.get("symbol-placement"), x3 = f3 && !g3 && !v3, y3 = !s3.layout.get("symbol-sort-key").isConstant();
          let b3 = false;
          const w3 = e2.depthModeForSublayer(0, Pi.ReadOnly), T3 = s3._unevaluatedLayout.hasValue("text-variable-anchor") || s3._unevaluatedLayout.hasValue("text-variable-anchor-offset"), I3 = [];
          for (const l4 of a3) {
            const a4 = i3.getTile(l4), h4 = a4.getBucket(s3);
            if (!h4) continue;
            const u4 = o3 ? h4.text : h4.icon;
            if (!u4 || !u4.segments.get().length || !u4.hasVisibleVertices) continue;
            const d4 = u4.programConfigurations.get(s3.id), _4 = o3 || h4.sdfIcons, w4 = o3 ? h4.textSizeData : h4.iconSizeData, E3 = g3 || 0 !== m3.pitch, S3 = e2.useProgram(Bi(_4, o3, h4), d4), C3 = t2.ah(w4, m3.zoom), P3 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(l4);
            let D3, M3, z3, L3, A3 = [0, 0], R3 = null;
            if (o3) M3 = a4.glyphAtlasTexture, z3 = p3.LINEAR, D3 = a4.glyphAtlasTexture.size, h4.iconsInText && (A3 = a4.imageAtlasTexture.size, R3 = a4.imageAtlasTexture, L3 = E3 || e2.options.rotating || e2.options.zooming || "composite" === w4.kind || "camera" === w4.kind ? p3.LINEAR : p3.NEAREST);
            else {
              const t3 = 1 !== s3.layout.get("icon-size").constantOr(0) || h4.iconsNeedLinear;
              M3 = a4.imageAtlasTexture, z3 = _4 || e2.options.rotating || e2.options.zooming || t3 || E3 ? p3.LINEAR : p3.NEAREST, D3 = a4.imageAtlasTexture.size;
            }
            const k3 = St(a4, 1, e2.transform.zoom), F3 = nt(l4.posMatrix, g3, f3, e2.transform, k3), B3 = lt(l4.posMatrix, g3, f3, e2.transform, k3), O3 = T3 && h4.hasTextData(), N3 = "none" !== s3.layout.get("icon-text-fit") && O3 && h4.hasIconData();
            if (v3) {
              const t3 = e2.style.map.terrain ? (t4, i5) => e2.style.map.terrain.getElevation(l4, t4, i5) : null, i4 = "map" === s3.layout.get("text-rotation-alignment");
              dt(h4, l4.posMatrix, e2, o3, F3, B3, g3, c3, i4, t3);
            }
            const U3 = e2.translatePosMatrix(l4.posMatrix, a4, r3, n3), Z3 = v3 || o3 && T3 || N3 ? Ri : F3, G3 = e2.translatePosMatrix(B3, a4, r3, n3, true), j3 = _4 && 0 !== s3.paint.get(o3 ? "text-halo-width" : "icon-halo-width").constantOr(1);
            let V3;
            V3 = _4 ? h4.iconsInText ? Re2(w4.kind, C3, x3, g3, e2, U3, Z3, G3, D3, A3) : Ae2(w4.kind, C3, x3, g3, e2, U3, Z3, G3, o3, D3) : Le2(w4.kind, C3, x3, g3, e2, U3, Z3, G3, o3, D3);
            const q3 = { program: S3, buffers: u4, uniformValues: V3, atlasTexture: M3, atlasTextureIcon: R3, atlasInterpolation: z3, atlasInterpolationIcon: L3, isSDF: _4, hasHalo: j3 };
            if (y3 && h4.canOverlap) {
              b3 = true;
              const e3 = u4.segments.get();
              for (const i4 of e3) I3.push({ segments: new t2.S([i4]), sortKey: i4.sortKey, state: q3, terrainData: P3 });
            } else I3.push({ segments: u4.segments, sortKey: 0, state: q3, terrainData: P3 });
          }
          b3 && I3.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const t3 of I3) {
            const i4 = t3.state;
            if (_3.activeTexture.set(p3.TEXTURE0), i4.atlasTexture.bind(i4.atlasInterpolation, p3.CLAMP_TO_EDGE), i4.atlasTextureIcon && (_3.activeTexture.set(p3.TEXTURE1), i4.atlasTextureIcon && i4.atlasTextureIcon.bind(i4.atlasInterpolationIcon, p3.CLAMP_TO_EDGE)), i4.isSDF) {
              const a4 = i4.uniformValues;
              i4.hasHalo && (a4.u_is_halo = 1, Ni(i4.buffers, t3.segments, s3, e2, i4.program, w3, u3, d3, a4, t3.terrainData)), a4.u_is_halo = 0;
            }
            Ni(i4.buffers, t3.segments, s3, e2, i4.program, w3, u3, d3, i4.uniformValues, t3.terrainData);
          }
        }
        function Ni(t3, e2, i3, s3, a3, o3, r3, n3, l3, h3) {
          const c3 = s3.context;
          a3.draw(c3, c3.gl.TRIANGLES, o3, r3, n3, zi.disabled, l3, h3, i3.id, t3.layoutVertexBuffer, t3.indexBuffer, e2, i3.paint, s3.transform.zoom, t3.programConfigurations.get(i3.id), t3.dynamicLayoutVertexBuffer, t3.opacityVertexBuffer);
        }
        function Ui(t3, e2, i3, s3, a3) {
          if (!i3 || !s3 || !s3.imageAtlas) return;
          const o3 = s3.imageAtlas.patternPositions;
          let r3 = o3[i3.to.toString()], n3 = o3[i3.from.toString()];
          if (!r3 && n3 && (r3 = n3), !n3 && r3 && (n3 = r3), !r3 || !n3) {
            const t4 = a3.getPaintProperty(e2);
            r3 = o3[t4], n3 = o3[t4];
          }
          r3 && n3 && t3.setConstantPatternPositions(r3, n3);
        }
        function Zi(t3, e2, i3, s3, a3, o3, r3) {
          const n3 = t3.context.gl, l3 = "fill-pattern", h3 = i3.paint.get(l3), c3 = h3 && h3.constantOr(1), u3 = i3.getCrossfadeParameters();
          let d3, _3, p3, m3, f3;
          r3 ? (_3 = c3 && !i3.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", d3 = n3.LINES) : (_3 = c3 ? "fillPattern" : "fill", d3 = n3.TRIANGLES);
          const g3 = h3.constantOr(null);
          for (const h4 of s3) {
            const s4 = e2.getTile(h4);
            if (c3 && !s4.patternsLoaded()) continue;
            const v3 = s4.getBucket(i3);
            if (!v3) continue;
            const x3 = v3.programConfigurations.get(i3.id), y3 = t3.useProgram(_3, x3), b3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(h4);
            c3 && (t3.context.activeTexture.set(n3.TEXTURE0), s4.imageAtlasTexture.bind(n3.LINEAR, n3.CLAMP_TO_EDGE), x3.updatePaintBuffers(u3)), Ui(x3, l3, g3, s4, i3);
            const w3 = b3 ? h4 : null, T3 = t3.translatePosMatrix(w3 ? w3.posMatrix : h4.posMatrix, s4, i3.paint.get("fill-translate"), i3.paint.get("fill-translate-anchor"));
            if (r3) {
              m3 = v3.indexBuffer2, f3 = v3.segments2;
              const e3 = [n3.drawingBufferWidth, n3.drawingBufferHeight];
              p3 = "fillOutlinePattern" === _3 && c3 ? ge2(T3, t3, u3, s4, e3) : fe2(T3, e3);
            } else m3 = v3.indexBuffer, f3 = v3.segments, p3 = c3 ? me2(T3, t3, u3, s4) : pe2(T3);
            y3.draw(t3.context, d3, a3, t3.stencilModeForClipping(h4), o3, zi.disabled, p3, b3, i3.id, v3.layoutVertexBuffer, m3, f3, i3.paint, t3.transform.zoom, x3);
          }
        }
        function Gi(t3, e2, i3, s3, a3, o3, r3) {
          const n3 = t3.context, l3 = n3.gl, h3 = "fill-extrusion-pattern", c3 = i3.paint.get(h3), u3 = c3.constantOr(1), d3 = i3.getCrossfadeParameters(), _3 = i3.paint.get("fill-extrusion-opacity"), p3 = c3.constantOr(null);
          for (const c4 of s3) {
            const s4 = e2.getTile(c4), m3 = s4.getBucket(i3);
            if (!m3) continue;
            const f3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(c4), g3 = m3.programConfigurations.get(i3.id), v3 = t3.useProgram(u3 ? "fillExtrusionPattern" : "fillExtrusion", g3);
            u3 && (t3.context.activeTexture.set(l3.TEXTURE0), s4.imageAtlasTexture.bind(l3.LINEAR, l3.CLAMP_TO_EDGE), g3.updatePaintBuffers(d3)), Ui(g3, h3, p3, s4, i3);
            const x3 = t3.translatePosMatrix(c4.posMatrix, s4, i3.paint.get("fill-extrusion-translate"), i3.paint.get("fill-extrusion-translate-anchor")), y3 = i3.paint.get("fill-extrusion-vertical-gradient"), b3 = u3 ? _e2(x3, t3, y3, _3, c4, d3, s4) : de2(x3, t3, y3, _3);
            v3.draw(n3, n3.gl.TRIANGLES, a3, o3, r3, zi.backCCW, b3, f3, i3.id, m3.layoutVertexBuffer, m3.indexBuffer, m3.segments, i3.paint, t3.transform.zoom, g3, t3.style.map.terrain && m3.centroidVertexBuffer);
          }
        }
        function ji(t3, e2, i3, s3, a3, o3, r3) {
          const n3 = t3.context, l3 = n3.gl, h3 = i3.fbo;
          if (!h3) return;
          const c3 = t3.useProgram("hillshade"), u3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(e2);
          n3.activeTexture.set(l3.TEXTURE0), l3.bindTexture(l3.TEXTURE_2D, h3.colorAttachment.get()), c3.draw(n3, l3.TRIANGLES, a3, o3, r3, zi.disabled, ((t4, e3, i4, s4) => {
            const a4 = i4.paint.get("hillshade-shadow-color"), o4 = i4.paint.get("hillshade-highlight-color"), r4 = i4.paint.get("hillshade-accent-color");
            let n4 = i4.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            "viewport" === i4.paint.get("hillshade-illumination-anchor") && (n4 -= t4.transform.angle);
            const l4 = !t4.options.moving;
            return { u_matrix: s4 ? s4.posMatrix : t4.transform.calculatePosMatrix(e3.tileID.toUnwrapped(), l4), u_image: 0, u_latrange: Te2(0, e3.tileID), u_light: [i4.paint.get("hillshade-exaggeration"), n4], u_shadow: a4, u_highlight: o4, u_accent: r4 };
          })(t3, i3, s3, u3 ? e2 : null), u3, s3.id, t3.rasterBoundsBuffer, t3.quadTriangleIndexBuffer, t3.rasterBoundsSegments);
        }
        function Vi(e2, i3, s3, a3, o3, r3) {
          const n3 = e2.context, l3 = n3.gl, h3 = i3.dem;
          if (h3 && h3.data) {
            const c3 = h3.dim, u3 = h3.stride, d3 = h3.getPixels();
            if (n3.activeTexture.set(l3.TEXTURE1), n3.pixelStoreUnpackPremultiplyAlpha.set(false), i3.demTexture = i3.demTexture || e2.getTileTexture(u3), i3.demTexture) {
              const t3 = i3.demTexture;
              t3.update(d3, { premultiply: false }), t3.bind(l3.NEAREST, l3.CLAMP_TO_EDGE);
            } else i3.demTexture = new x2(n3, d3, l3.RGBA, { premultiply: false }), i3.demTexture.bind(l3.NEAREST, l3.CLAMP_TO_EDGE);
            n3.activeTexture.set(l3.TEXTURE0);
            let _3 = i3.fbo;
            if (!_3) {
              const t3 = new x2(n3, { width: c3, height: c3, data: null }, l3.RGBA);
              t3.bind(l3.LINEAR, l3.CLAMP_TO_EDGE), _3 = i3.fbo = n3.createFramebuffer(c3, c3, true, false), _3.colorAttachment.set(t3.texture);
            }
            n3.bindFramebuffer.set(_3.framebuffer), n3.viewport.set([0, 0, c3, c3]), e2.useProgram("hillshadePrepare").draw(n3, l3.TRIANGLES, a3, o3, r3, zi.disabled, ((e3, i4) => {
              const s4 = i4.stride, a4 = t2.Z();
              return t2.aS(a4, 0, t2.N, -t2.N, 0, 0, 1), t2.$(a4, a4, [0, -t2.N, 0]), { u_matrix: a4, u_image: 1, u_dimension: [s4, s4], u_zoom: e3.overscaledZ, u_unpack: i4.getUnpackVector() };
            })(i3.tileID, h3), null, s3.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments), i3.needsHillshadePrepare = false;
          }
        }
        function qi(e2, i3, s3, a3, o3, r3) {
          const n3 = a3.paint.get("raster-fade-duration");
          if (!r3 && n3 > 0) {
            const a4 = t2.h.now(), r4 = (a4 - e2.timeAdded) / n3, l3 = i3 ? (a4 - i3.timeAdded) / n3 : -1, h3 = s3.getSource(), c3 = o3.coveringZoomLevel({ tileSize: h3.tileSize, roundZoom: h3.roundZoom }), u3 = !i3 || Math.abs(i3.tileID.overscaledZ - c3) > Math.abs(e2.tileID.overscaledZ - c3), d3 = u3 && e2.refreshedUponExpiration ? 1 : t2.ad(u3 ? r4 : 1 - l3, 0, 1);
            return e2.refreshedUponExpiration && r4 >= 1 && (e2.refreshedUponExpiration = false), i3 ? { opacity: 1, mix: 1 - d3 } : { opacity: d3, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const $i = new t2.aT(1, 0, 0, 1), Wi = new t2.aT(0, 1, 0, 1), Hi = new t2.aT(0, 0, 1, 1), Xi = new t2.aT(1, 0, 1, 1), Ki = new t2.aT(0, 1, 1, 1);
        function Qi(t3, e2, i3, s3) {
          Ji(t3, 0, e2 + i3 / 2, t3.transform.width, i3, s3);
        }
        function Yi(t3, e2, i3, s3) {
          Ji(t3, e2 - i3 / 2, 0, i3, t3.transform.height, s3);
        }
        function Ji(t3, e2, i3, s3, a3, o3) {
          const r3 = t3.context, n3 = r3.gl;
          n3.enable(n3.SCISSOR_TEST), n3.scissor(e2 * t3.pixelRatio, i3 * t3.pixelRatio, s3 * t3.pixelRatio, a3 * t3.pixelRatio), r3.clear({ color: o3 }), n3.disable(n3.SCISSOR_TEST);
        }
        function ts(e2, i3, s3) {
          const a3 = e2.context, o3 = a3.gl, r3 = s3.posMatrix, n3 = e2.useProgram("debug"), l3 = Pi.disabled, h3 = Mi.disabled, c3 = e2.colorModeForRenderPass(), u3 = "$debug", d3 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(s3);
          a3.activeTexture.set(o3.TEXTURE0);
          const _3 = i3.getTileByID(s3.key).latestRawTileData, p3 = Math.floor((_3 && _3.byteLength || 0) / 1024), m3 = i3.getTile(s3).tileSize, f3 = 512 / Math.min(m3, 512) * (s3.overscaledZ / e2.transform.zoom) * 0.5;
          let g3 = s3.canonical.toString();
          s3.overscaledZ !== s3.canonical.z && (g3 += ` => ${s3.overscaledZ}`), function(t3, e3) {
            t3.initDebugOverlayCanvas();
            const i4 = t3.debugOverlayCanvas, s4 = t3.context.gl, a4 = t3.debugOverlayCanvas.getContext("2d");
            a4.clearRect(0, 0, i4.width, i4.height), a4.shadowColor = "white", a4.shadowBlur = 2, a4.lineWidth = 1.5, a4.strokeStyle = "white", a4.textBaseline = "top", a4.font = "bold 36px Open Sans, sans-serif", a4.fillText(e3, 5, 5), a4.strokeText(e3, 5, 5), t3.debugOverlayTexture.update(i4), t3.debugOverlayTexture.bind(s4.LINEAR, s4.CLAMP_TO_EDGE);
          }(e2, `${g3} ${p3}kB`), n3.draw(a3, o3.TRIANGLES, l3, h3, Si.alphaBlended, zi.disabled, ye2(r3, t2.aT.transparent, f3), null, u3, e2.debugBuffer, e2.quadTriangleIndexBuffer, e2.debugSegments), n3.draw(a3, o3.LINE_STRIP, l3, h3, c3, zi.disabled, ye2(r3, t2.aT.red), d3, u3, e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
        }
        function es(t3, e2, i3) {
          const s3 = t3.context, a3 = s3.gl, o3 = t3.colorModeForRenderPass(), r3 = new Pi(a3.LEQUAL, Pi.ReadWrite, t3.depthRangeFor3D), n3 = t3.useProgram("terrain"), l3 = e2.getTerrainMesh();
          s3.bindFramebuffer.set(null), s3.viewport.set([0, 0, t3.width, t3.height]);
          for (const h3 of i3) {
            const i4 = t3.renderToTexture.getTexture(h3), c3 = e2.getTerrainData(h3.tileID);
            s3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_2D, i4.texture);
            const u3 = { u_matrix: t3.transform.calculatePosMatrix(h3.tileID.toUnwrapped()), u_texture: 0, u_ele_delta: e2.getMeshFrameDelta(t3.transform.zoom) };
            n3.draw(s3, a3.TRIANGLES, r3, Mi.disabled, o3, zi.backCCW, u3, c3, "terrain", l3.vertexBuffer, l3.indexBuffer, l3.segments);
          }
        }
        class is {
          constructor(e2, i3) {
            this.context = new Ci(e2), this.transform = i3, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t2.Z(), renderTime: 0 }, this.setup(), this.numSublayers = K2.maxUnderzooming + K2.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Yt();
          }
          resize(t3, e2, i3) {
            if (this.width = Math.floor(t3 * i3), this.height = Math.floor(e2 * i3), this.pixelRatio = i3, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const t4 of this.style._order) this.style._layers[t4].resize();
          }
          setup() {
            const e2 = this.context, i3 = new t2.a_();
            i3.emplaceBack(0, 0), i3.emplaceBack(t2.N, 0), i3.emplaceBack(0, t2.N), i3.emplaceBack(t2.N, t2.N), this.tileExtentBuffer = e2.createVertexBuffer(i3, ae2.members), this.tileExtentSegments = t2.S.simpleSegment(0, 0, 4, 2);
            const s3 = new t2.a_();
            s3.emplaceBack(0, 0), s3.emplaceBack(t2.N, 0), s3.emplaceBack(0, t2.N), s3.emplaceBack(t2.N, t2.N), this.debugBuffer = e2.createVertexBuffer(s3, ae2.members), this.debugSegments = t2.S.simpleSegment(0, 0, 4, 5);
            const a3 = new t2.V();
            a3.emplaceBack(0, 0, 0, 0), a3.emplaceBack(t2.N, 0, t2.N, 0), a3.emplaceBack(0, t2.N, 0, t2.N), a3.emplaceBack(t2.N, t2.N, t2.N, t2.N), this.rasterBoundsBuffer = e2.createVertexBuffer(a3, O2.members), this.rasterBoundsSegments = t2.S.simpleSegment(0, 0, 4, 2);
            const o3 = new t2.a_();
            o3.emplaceBack(0, 0), o3.emplaceBack(1, 0), o3.emplaceBack(0, 1), o3.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(o3, ae2.members), this.viewportSegments = t2.S.simpleSegment(0, 0, 4, 2);
            const r3 = new t2.a$();
            r3.emplaceBack(0), r3.emplaceBack(1), r3.emplaceBack(3), r3.emplaceBack(2), r3.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(r3);
            const n3 = new t2.b0();
            n3.emplaceBack(0, 1, 2), n3.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(n3);
            const l3 = this.context.gl;
            this.stencilClearMode = new Mi({ func: l3.ALWAYS, mask: 0 }, 0, 255, l3.ZERO, l3.ZERO, l3.ZERO);
          }
          clearStencil() {
            const e2 = this.context, i3 = e2.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const s3 = t2.Z();
            t2.aS(s3, 0, this.width, this.height, 0, 0, 1), t2.a0(s3, s3, [i3.drawingBufferWidth, i3.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e2, i3.TRIANGLES, Pi.disabled, this.stencilClearMode, Si.disabled, zi.disabled, be2(s3), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(t3, e2) {
            if (this.currentStencilSource === t3.source || !t3.isTileClipped() || !e2 || !e2.length) return;
            this.currentStencilSource = t3.source;
            const i3 = this.context, s3 = i3.gl;
            this.nextStencilID + e2.length > 256 && this.clearStencil(), i3.setColorMode(Si.disabled), i3.setDepthMode(Pi.disabled);
            const a3 = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const t4 of e2) {
              const e3 = this._tileClippingMaskIDs[t4.key] = this.nextStencilID++, o3 = this.style.map.terrain && this.style.map.terrain.getTerrainData(t4);
              a3.draw(i3, s3.TRIANGLES, Pi.disabled, new Mi({ func: s3.ALWAYS, mask: 0 }, e3, 255, s3.KEEP, s3.KEEP, s3.REPLACE), Si.disabled, zi.disabled, be2(t4.posMatrix), o3, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t3 = this.nextStencilID++, e2 = this.context.gl;
            return new Mi({ func: e2.NOTEQUAL, mask: 255 }, t3, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
          }
          stencilModeForClipping(t3) {
            const e2 = this.context.gl;
            return new Mi({ func: e2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t3.key], 0, e2.KEEP, e2.KEEP, e2.REPLACE);
          }
          stencilConfigForOverlap(t3) {
            const e2 = this.context.gl, i3 = t3.sort((t4, e3) => e3.overscaledZ - t4.overscaledZ), s3 = i3[i3.length - 1].overscaledZ, a3 = i3[0].overscaledZ - s3 + 1;
            if (a3 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + a3 > 256 && this.clearStencil();
              const t4 = {};
              for (let i4 = 0; i4 < a3; i4++) t4[i4 + s3] = new Mi({ func: e2.GEQUAL, mask: 255 }, i4 + this.nextStencilID, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
              return this.nextStencilID += a3, [t4, i3];
            }
            return [{ [s3]: Mi.disabled }, i3];
          }
          colorModeForRenderPass() {
            const e2 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i3 = 1 / 8;
              return new Si([e2.CONSTANT_COLOR, e2.ONE], new t2.aT(i3, i3, i3, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? Si.unblended : Si.alphaBlended;
          }
          depthModeForSublayer(t3, e2, i3) {
            if (!this.opaquePassEnabledForLayer()) return Pi.disabled;
            const s3 = 1 - ((1 + this.currentLayer) * this.numSublayers + t3) * this.depthEpsilon;
            return new Pi(i3 || this.context.gl.LEQUAL, e2, [s3, s3]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e2, i3) {
            this.style = e2, this.options = i3, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(t2.h.now()), this.imageManager.beginFrame();
            const s3 = this.style._order, a3 = this.style.sourceCaches, o3 = {}, r3 = {}, n3 = {};
            for (const t3 in a3) {
              const e3 = a3[t3];
              e3.used && e3.prepare(this.context), o3[t3] = e3.getVisibleCoordinates(), r3[t3] = o3[t3].slice().reverse(), n3[t3] = e3.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let t3 = 0; t3 < s3.length; t3++) if (this.style._layers[s3[t3]].is3D()) {
              this.opaquePassCutoff = t3;
              break;
            }
            if (this.renderToTexture) {
              this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0;
              const e3 = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime);
              (this.terrainFacilitator.dirty || !t2.b1(this.terrainFacilitator.matrix, this.transform.projMatrix) || e3.length) && (t2.b2(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(e4, i4) {
                const s4 = e4.context, a4 = s4.gl, o4 = Si.unblended, r4 = new Pi(a4.LEQUAL, Pi.ReadWrite, [0, 1]), n4 = i4.getTerrainMesh(), l3 = i4.sourceCache.getRenderableTiles(), h3 = e4.useProgram("terrainDepth");
                s4.bindFramebuffer.set(i4.getFramebuffer("depth").framebuffer), s4.viewport.set([0, 0, e4.width / devicePixelRatio, e4.height / devicePixelRatio]), s4.clear({ color: t2.aT.transparent, depth: 1 });
                for (const t3 of l3) {
                  const l4 = i4.getTerrainData(t3.tileID), c3 = { u_matrix: e4.transform.calculatePosMatrix(t3.tileID.toUnwrapped()), u_ele_delta: i4.getMeshFrameDelta(e4.transform.zoom) };
                  h3.draw(s4, a4.TRIANGLES, r4, Mi.disabled, o4, zi.backCCW, c3, l4, "terrain", n4.vertexBuffer, n4.indexBuffer, n4.segments);
                }
                s4.bindFramebuffer.set(null), s4.viewport.set([0, 0, e4.width, e4.height]);
              }(this, this.style.map.terrain), function(e4, i4) {
                const s4 = e4.context, a4 = s4.gl, o4 = Si.unblended, r4 = new Pi(a4.LEQUAL, Pi.ReadWrite, [0, 1]), n4 = i4.getTerrainMesh(), l3 = i4.getCoordsTexture(), h3 = i4.sourceCache.getRenderableTiles(), c3 = e4.useProgram("terrainCoords");
                s4.bindFramebuffer.set(i4.getFramebuffer("coords").framebuffer), s4.viewport.set([0, 0, e4.width / devicePixelRatio, e4.height / devicePixelRatio]), s4.clear({ color: t2.aT.transparent, depth: 1 }), i4.coordsIndex = [];
                for (const t3 of h3) {
                  const h4 = i4.getTerrainData(t3.tileID);
                  s4.activeTexture.set(a4.TEXTURE0), a4.bindTexture(a4.TEXTURE_2D, l3.texture);
                  const u3 = { u_matrix: e4.transform.calculatePosMatrix(t3.tileID.toUnwrapped()), u_terrain_coords_id: (255 - i4.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i4.getMeshFrameDelta(e4.transform.zoom) };
                  c3.draw(s4, a4.TRIANGLES, r4, Mi.disabled, o4, zi.backCCW, u3, h4, "terrain", n4.vertexBuffer, n4.indexBuffer, n4.segments), i4.coordsIndex.push(t3.tileID.key);
                }
                s4.bindFramebuffer.set(null), s4.viewport.set([0, 0, e4.width, e4.height]);
              }(this, this.style.map.terrain));
            }
            this.renderPass = "offscreen";
            for (const t3 of s3) {
              const e3 = this.style._layers[t3];
              if (!e3.hasOffscreenPass() || e3.isHidden(this.transform.zoom)) continue;
              const i4 = r3[e3.source];
              ("custom" === e3.type || i4.length) && this.renderLayer(this, a3[e3.source], e3, i4);
            }
            if (this.context.bindFramebuffer.set(null), this.context.clear({ color: i3.showOverdrawInspector ? t2.aT.black : t2.aT.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i3.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e2._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = s3.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const t3 = this.style._layers[s3[this.currentLayer]], e3 = a3[t3.source], i4 = o3[t3.source];
              this._renderTileClippingMasks(t3, i4), this.renderLayer(this, e3, t3, i4);
            }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < s3.length; this.currentLayer++) {
              const t3 = this.style._layers[s3[this.currentLayer]], e3 = a3[t3.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(t3)) continue;
              const i4 = ("symbol" === t3.type ? n3 : r3)[t3.source];
              this._renderTileClippingMasks(t3, o3[t3.source]), this.renderLayer(this, e3, t3, i4);
            }
            if (this.options.showTileBoundaries) {
              const t3 = function(t4, e3) {
                let i4 = null;
                const s4 = Object.values(t4._layers).flatMap((i5) => i5.source && !i5.isHidden(e3) ? [t4.sourceCaches[i5.source]] : []), a4 = s4.filter((t5) => "vector" === t5.getSource().type), o4 = s4.filter((t5) => "vector" !== t5.getSource().type), r4 = (t5) => {
                  (!i4 || i4.getSource().maxzoom < t5.getSource().maxzoom) && (i4 = t5);
                };
                return a4.forEach((t5) => r4(t5)), i4 || o4.forEach((t5) => r4(t5)), i4;
              }(this.style, this.transform.zoom);
              t3 && function(t4, e3, i4) {
                for (let s4 = 0; s4 < i4.length; s4++) ts(t4, e3, i4[s4]);
              }(this, t3, t3.getVisibleCoordinates());
            }
            this.options.showPadding && function(t3) {
              const e3 = t3.transform.padding;
              Qi(t3, t3.transform.height - (e3.top || 0), 3, $i), Qi(t3, e3.bottom || 0, 3, Wi), Yi(t3, e3.left || 0, 3, Hi), Yi(t3, t3.transform.width - (e3.right || 0), 3, Xi);
              const i4 = t3.transform.centerPoint;
              !function(t4, e4, i5, s4) {
                Ji(t4, e4 - 1, i5 - 10, 2, 20, s4), Ji(t4, e4 - 10, i5 - 1, 20, 2, s4);
              }(t3, i4.x, t3.transform.height - i4.y, Ki);
            }(this), this.context.setDefault();
          }
          renderLayer(e2, i3, s3, a3) {
            if (!s3.isHidden(this.transform.zoom) && ("background" === s3.type || "custom" === s3.type || (a3 || []).length)) switch (this.id = s3.id, s3.type) {
              case "symbol":
                !function(e3, i4, s4, a4, o3) {
                  if ("translucent" !== e3.renderPass) return;
                  const r3 = Mi.disabled, n3 = e3.colorModeForRenderPass();
                  (s4._unevaluatedLayout.hasValue("text-variable-anchor") || s4._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e4, i5, s5, a5, o4, r4, n4) {
                    const l3 = i5.transform, h3 = "map" === o4, c3 = "map" === r4;
                    for (const o5 of e4) {
                      const e5 = a5.getTile(o5), r5 = e5.getBucket(s5);
                      if (!r5 || !r5.text || !r5.text.segments.get().length) continue;
                      const u3 = t2.ah(r5.textSizeData, l3.zoom), d3 = St(e5, 1, i5.transform.zoom), _3 = nt(o5.posMatrix, c3, h3, i5.transform, d3), p3 = "none" !== s5.layout.get("icon-text-fit") && r5.hasIconData();
                      if (u3) {
                        const t3 = Math.pow(2, l3.zoom - e5.tileID.overscaledZ);
                        Fi(r5, h3, c3, n4, l3, _3, o5.posMatrix, t3, u3, p3, i5.style.map.terrain ? (t4, e6) => i5.style.map.terrain.getElevation(o5, t4, e6) : null);
                      }
                    }
                  }(a4, e3, s4, i4, s4.layout.get("text-rotation-alignment"), s4.layout.get("text-pitch-alignment"), o3), 0 !== s4.paint.get("icon-opacity").constantOr(1) && Oi(e3, i4, s4, a4, false, s4.paint.get("icon-translate"), s4.paint.get("icon-translate-anchor"), s4.layout.get("icon-rotation-alignment"), s4.layout.get("icon-pitch-alignment"), s4.layout.get("icon-keep-upright"), r3, n3), 0 !== s4.paint.get("text-opacity").constantOr(1) && Oi(e3, i4, s4, a4, true, s4.paint.get("text-translate"), s4.paint.get("text-translate-anchor"), s4.layout.get("text-rotation-alignment"), s4.layout.get("text-pitch-alignment"), s4.layout.get("text-keep-upright"), r3, n3), i4.map.showCollisionBoxes && (Ai(e3, i4, s4, a4, s4.paint.get("text-translate"), s4.paint.get("text-translate-anchor"), true), Ai(e3, i4, s4, a4, s4.paint.get("icon-translate"), s4.paint.get("icon-translate-anchor"), false));
                }(e2, i3, s3, a3, this.style.placement.variableOffsets);
                break;
              case "circle":
                !function(e3, i4, s4, a4) {
                  if ("translucent" !== e3.renderPass) return;
                  const o3 = s4.paint.get("circle-opacity"), r3 = s4.paint.get("circle-stroke-width"), n3 = s4.paint.get("circle-stroke-opacity"), l3 = !s4.layout.get("circle-sort-key").isConstant();
                  if (0 === o3.constantOr(1) && (0 === r3.constantOr(1) || 0 === n3.constantOr(1))) return;
                  const h3 = e3.context, c3 = h3.gl, u3 = e3.depthModeForSublayer(0, Pi.ReadOnly), d3 = Mi.disabled, _3 = e3.colorModeForRenderPass(), p3 = [];
                  for (let o4 = 0; o4 < a4.length; o4++) {
                    const r4 = a4[o4], n4 = i4.getTile(r4), h4 = n4.getBucket(s4);
                    if (!h4) continue;
                    const c4 = h4.programConfigurations.get(s4.id), u4 = e3.useProgram("circle", c4), d4 = h4.layoutVertexBuffer, _4 = h4.indexBuffer, m3 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(r4), f3 = { programConfiguration: c4, program: u4, layoutVertexBuffer: d4, indexBuffer: _4, uniformValues: ve2(e3, r4, n4, s4), terrainData: m3 };
                    if (l3) {
                      const e4 = h4.segments.get();
                      for (const i5 of e4) p3.push({ segments: new t2.S([i5]), sortKey: i5.sortKey, state: f3 });
                    } else p3.push({ segments: h4.segments, sortKey: 0, state: f3 });
                  }
                  l3 && p3.sort((t3, e4) => t3.sortKey - e4.sortKey);
                  for (const t3 of p3) {
                    const { programConfiguration: i5, program: a5, layoutVertexBuffer: o4, indexBuffer: r4, uniformValues: n4, terrainData: l4 } = t3.state;
                    a5.draw(h3, c3.TRIANGLES, u3, d3, _3, zi.disabled, n4, l4, s4.id, o4, r4, t3.segments, s4.paint, e3.transform.zoom, i5);
                  }
                }(e2, i3, s3, a3);
                break;
              case "heatmap":
                !function(e3, i4, s4, a4) {
                  if (0 !== s4.paint.get("heatmap-opacity")) if ("offscreen" === e3.renderPass) {
                    const o3 = e3.context, r3 = o3.gl, n3 = Mi.disabled, l3 = new Si([r3.ONE, r3.ONE], t2.aT.transparent, [true, true, true, true]);
                    !function(t3, e4, i5) {
                      const s5 = t3.gl;
                      t3.activeTexture.set(s5.TEXTURE1), t3.viewport.set([0, 0, e4.width / 4, e4.height / 4]);
                      let a5 = i5.heatmapFbo;
                      if (a5) s5.bindTexture(s5.TEXTURE_2D, a5.colorAttachment.get()), t3.bindFramebuffer.set(a5.framebuffer);
                      else {
                        const o4 = s5.createTexture();
                        s5.bindTexture(s5.TEXTURE_2D, o4), s5.texParameteri(s5.TEXTURE_2D, s5.TEXTURE_WRAP_S, s5.CLAMP_TO_EDGE), s5.texParameteri(s5.TEXTURE_2D, s5.TEXTURE_WRAP_T, s5.CLAMP_TO_EDGE), s5.texParameteri(s5.TEXTURE_2D, s5.TEXTURE_MIN_FILTER, s5.LINEAR), s5.texParameteri(s5.TEXTURE_2D, s5.TEXTURE_MAG_FILTER, s5.LINEAR), a5 = i5.heatmapFbo = t3.createFramebuffer(e4.width / 4, e4.height / 4, false, false), function(t4, e5, i6, s6) {
                          var a6, o5;
                          const r4 = t4.gl, n4 = null !== (a6 = t4.HALF_FLOAT) && void 0 !== a6 ? a6 : r4.UNSIGNED_BYTE, l4 = null !== (o5 = t4.RGBA16F) && void 0 !== o5 ? o5 : r4.RGBA;
                          r4.texImage2D(r4.TEXTURE_2D, 0, l4, e5.width / 4, e5.height / 4, 0, r4.RGBA, n4, null), s6.colorAttachment.set(i6);
                        }(t3, e4, o4, a5);
                      }
                    }(o3, e3, s4), o3.clear({ color: t2.aT.transparent });
                    for (let t3 = 0; t3 < a4.length; t3++) {
                      const h3 = a4[t3];
                      if (i4.hasRenderableParent(h3)) continue;
                      const c3 = i4.getTile(h3), u3 = c3.getBucket(s4);
                      if (!u3) continue;
                      const d3 = u3.programConfigurations.get(s4.id), _3 = e3.useProgram("heatmap", d3), { zoom: p3 } = e3.transform;
                      _3.draw(o3, r3.TRIANGLES, Pi.disabled, n3, l3, zi.disabled, we2(h3.posMatrix, c3, p3, s4.paint.get("heatmap-intensity")), null, s4.id, u3.layoutVertexBuffer, u3.indexBuffer, u3.segments, s4.paint, e3.transform.zoom, d3);
                    }
                    o3.viewport.set([0, 0, e3.width, e3.height]);
                  } else "translucent" === e3.renderPass && (e3.context.setColorMode(e3.colorModeForRenderPass()), function(e4, i5) {
                    const s5 = e4.context, a5 = s5.gl, o3 = i5.heatmapFbo;
                    if (!o3) return;
                    s5.activeTexture.set(a5.TEXTURE0), a5.bindTexture(a5.TEXTURE_2D, o3.colorAttachment.get()), s5.activeTexture.set(a5.TEXTURE1);
                    let r3 = i5.colorRampTexture;
                    r3 || (r3 = i5.colorRampTexture = new x2(s5, i5.colorRamp, a5.RGBA)), r3.bind(a5.LINEAR, a5.CLAMP_TO_EDGE), e4.useProgram("heatmapTexture").draw(s5, a5.TRIANGLES, Pi.disabled, Mi.disabled, e4.colorModeForRenderPass(), zi.disabled, ((e5, i6, s6, a6) => {
                      const o4 = t2.Z();
                      t2.aS(o4, 0, e5.width, e5.height, 0, 0, 1);
                      const r4 = e5.context.gl;
                      return { u_matrix: o4, u_world: [r4.drawingBufferWidth, r4.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i6.paint.get("heatmap-opacity") };
                    })(e4, i5), null, i5.id, e4.viewportBuffer, e4.quadTriangleIndexBuffer, e4.viewportSegments, i5.paint, e4.transform.zoom);
                  }(e3, s4));
                }(e2, i3, s3, a3);
                break;
              case "line":
                !function(e3, i4, s4, a4) {
                  if ("translucent" !== e3.renderPass) return;
                  const o3 = s4.paint.get("line-opacity"), r3 = s4.paint.get("line-width");
                  if (0 === o3.constantOr(1) || 0 === r3.constantOr(1)) return;
                  const n3 = e3.depthModeForSublayer(0, Pi.ReadOnly), l3 = e3.colorModeForRenderPass(), h3 = s4.paint.get("line-dasharray"), c3 = s4.paint.get("line-pattern"), u3 = c3.constantOr(1), d3 = s4.paint.get("line-gradient"), _3 = s4.getCrossfadeParameters(), p3 = u3 ? "linePattern" : h3 ? "lineSDF" : d3 ? "lineGradient" : "line", m3 = e3.context, f3 = m3.gl;
                  let g3 = true;
                  for (const o4 of a4) {
                    const a5 = i4.getTile(o4);
                    if (u3 && !a5.patternsLoaded()) continue;
                    const r4 = a5.getBucket(s4);
                    if (!r4) continue;
                    const v3 = r4.programConfigurations.get(s4.id), y3 = e3.context.program.get(), b3 = e3.useProgram(p3, v3), w3 = g3 || b3.program !== y3, T3 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(o4), I3 = c3.constantOr(null);
                    if (I3 && a5.imageAtlas) {
                      const t3 = a5.imageAtlas, e4 = t3.patternPositions[I3.to.toString()], i5 = t3.patternPositions[I3.from.toString()];
                      e4 && i5 && v3.setConstantPatternPositions(e4, i5);
                    }
                    const E3 = T3 ? o4 : null, S3 = u3 ? Se2(e3, a5, s4, _3, E3) : h3 ? Ce2(e3, a5, s4, h3, _3, E3) : d3 ? Ee2(e3, a5, s4, r4.lineClipsArray.length, E3) : Ie2(e3, a5, s4, E3);
                    if (u3) m3.activeTexture.set(f3.TEXTURE0), a5.imageAtlasTexture.bind(f3.LINEAR, f3.CLAMP_TO_EDGE), v3.updatePaintBuffers(_3);
                    else if (h3 && (w3 || e3.lineAtlas.dirty)) m3.activeTexture.set(f3.TEXTURE0), e3.lineAtlas.bind(m3);
                    else if (d3) {
                      const a6 = r4.gradients[s4.id];
                      let n4 = a6.texture;
                      if (s4.gradientVersion !== a6.version) {
                        let l4 = 256;
                        if (s4.stepInterpolant) {
                          const s5 = i4.getSource().maxzoom, a7 = o4.canonical.z === s5 ? Math.ceil(1 << e3.transform.maxZoom - o4.canonical.z) : 1;
                          l4 = t2.ad(t2.aY(r4.maxLineLength / t2.N * 1024 * a7), 256, m3.maxTextureSize);
                        }
                        a6.gradient = t2.aZ({ expression: s4.gradientExpression(), evaluationKey: "lineProgress", resolution: l4, image: a6.gradient || void 0, clips: r4.lineClipsArray }), a6.texture ? a6.texture.update(a6.gradient) : a6.texture = new x2(m3, a6.gradient, f3.RGBA), a6.version = s4.gradientVersion, n4 = a6.texture;
                      }
                      m3.activeTexture.set(f3.TEXTURE0), n4.bind(s4.stepInterpolant ? f3.NEAREST : f3.LINEAR, f3.CLAMP_TO_EDGE);
                    }
                    b3.draw(m3, f3.TRIANGLES, n3, e3.stencilModeForClipping(o4), l3, zi.disabled, S3, T3, s4.id, r4.layoutVertexBuffer, r4.indexBuffer, r4.segments, s4.paint, e3.transform.zoom, v3, r4.layoutVertexBuffer2), g3 = false;
                  }
                }(e2, i3, s3, a3);
                break;
              case "fill":
                !function(e3, i4, s4, a4) {
                  const o3 = s4.paint.get("fill-color"), r3 = s4.paint.get("fill-opacity");
                  if (0 === r3.constantOr(1)) return;
                  const n3 = e3.colorModeForRenderPass(), l3 = s4.paint.get("fill-pattern"), h3 = e3.opaquePassEnabledForLayer() && !l3.constantOr(1) && 1 === o3.constantOr(t2.aT.transparent).a && 1 === r3.constantOr(0) ? "opaque" : "translucent";
                  if (e3.renderPass === h3) {
                    const t3 = e3.depthModeForSublayer(1, "opaque" === e3.renderPass ? Pi.ReadWrite : Pi.ReadOnly);
                    Zi(e3, i4, s4, a4, t3, n3, false);
                  }
                  if ("translucent" === e3.renderPass && s4.paint.get("fill-antialias")) {
                    const t3 = e3.depthModeForSublayer(s4.getPaintProperty("fill-outline-color") ? 2 : 0, Pi.ReadOnly);
                    Zi(e3, i4, s4, a4, t3, n3, true);
                  }
                }(e2, i3, s3, a3);
                break;
              case "fill-extrusion":
                !function(t3, e3, i4, s4) {
                  const a4 = i4.paint.get("fill-extrusion-opacity");
                  if (0 !== a4 && "translucent" === t3.renderPass) {
                    const o3 = new Pi(t3.context.gl.LEQUAL, Pi.ReadWrite, t3.depthRangeFor3D);
                    if (1 !== a4 || i4.paint.get("fill-extrusion-pattern").constantOr(1)) Gi(t3, e3, i4, s4, o3, Mi.disabled, Si.disabled), Gi(t3, e3, i4, s4, o3, t3.stencilModeFor3D(), t3.colorModeForRenderPass());
                    else {
                      const a5 = t3.colorModeForRenderPass();
                      Gi(t3, e3, i4, s4, o3, Mi.disabled, a5);
                    }
                  }
                }(e2, i3, s3, a3);
                break;
              case "hillshade":
                !function(t3, e3, i4, s4) {
                  if ("offscreen" !== t3.renderPass && "translucent" !== t3.renderPass) return;
                  const a4 = t3.context, o3 = t3.depthModeForSublayer(0, Pi.ReadOnly), r3 = t3.colorModeForRenderPass(), [n3, l3] = "translucent" === t3.renderPass ? t3.stencilConfigForOverlap(s4) : [{}, s4];
                  for (const s5 of l3) {
                    const a5 = e3.getTile(s5);
                    void 0 !== a5.needsHillshadePrepare && a5.needsHillshadePrepare && "offscreen" === t3.renderPass ? Vi(t3, a5, i4, o3, Mi.disabled, r3) : "translucent" === t3.renderPass && ji(t3, s5, a5, i4, o3, n3[s5.overscaledZ], r3);
                  }
                  a4.viewport.set([0, 0, t3.width, t3.height]);
                }(e2, i3, s3, a3);
                break;
              case "raster":
                !function(t3, e3, i4, s4) {
                  if ("translucent" !== t3.renderPass) return;
                  if (0 === i4.paint.get("raster-opacity")) return;
                  if (!s4.length) return;
                  const a4 = t3.context, o3 = a4.gl, r3 = e3.getSource(), n3 = t3.useProgram("raster"), l3 = t3.colorModeForRenderPass(), [h3, c3] = r3 instanceof N2 ? [{}, s4] : t3.stencilConfigForOverlap(s4), u3 = c3[c3.length - 1].overscaledZ, d3 = !t3.options.moving;
                  for (const s5 of c3) {
                    const c4 = t3.depthModeForSublayer(s5.overscaledZ - u3, 1 === i4.paint.get("raster-opacity") ? Pi.ReadWrite : Pi.ReadOnly, o3.LESS), _3 = e3.getTile(s5);
                    _3.registerFadeDuration(i4.paint.get("raster-fade-duration"));
                    const p3 = e3.findLoadedParent(s5, 0), m3 = qi(_3, p3, e3, i4, t3.transform, t3.style.map.terrain);
                    let f3, g3;
                    const v3 = "nearest" === i4.paint.get("raster-resampling") ? o3.NEAREST : o3.LINEAR;
                    a4.activeTexture.set(o3.TEXTURE0), _3.texture.bind(v3, o3.CLAMP_TO_EDGE, o3.LINEAR_MIPMAP_NEAREST), a4.activeTexture.set(o3.TEXTURE1), p3 ? (p3.texture.bind(v3, o3.CLAMP_TO_EDGE, o3.LINEAR_MIPMAP_NEAREST), f3 = Math.pow(2, p3.tileID.overscaledZ - _3.tileID.overscaledZ), g3 = [_3.tileID.canonical.x * f3 % 1, _3.tileID.canonical.y * f3 % 1]) : _3.texture.bind(v3, o3.CLAMP_TO_EDGE, o3.LINEAR_MIPMAP_NEAREST);
                    const x3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(s5), y3 = x3 ? s5 : null, b3 = y3 ? y3.posMatrix : t3.transform.calculatePosMatrix(s5.toUnwrapped(), d3), w3 = Me2(b3, g3 || [0, 0], f3 || 1, m3, i4);
                    r3 instanceof N2 ? n3.draw(a4, o3.TRIANGLES, c4, Mi.disabled, l3, zi.disabled, w3, x3, i4.id, r3.boundsBuffer, t3.quadTriangleIndexBuffer, r3.boundsSegments) : n3.draw(a4, o3.TRIANGLES, c4, h3[s5.overscaledZ], l3, zi.disabled, w3, x3, i4.id, t3.rasterBoundsBuffer, t3.quadTriangleIndexBuffer, t3.rasterBoundsSegments);
                  }
                }(e2, i3, s3, a3);
                break;
              case "background":
                !function(t3, e3, i4, s4) {
                  const a4 = i4.paint.get("background-color"), o3 = i4.paint.get("background-opacity");
                  if (0 === o3) return;
                  const r3 = t3.context, n3 = r3.gl, l3 = t3.transform, h3 = l3.tileSize, c3 = i4.paint.get("background-pattern");
                  if (t3.isPatternMissing(c3)) return;
                  const u3 = !c3 && 1 === a4.a && 1 === o3 && t3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                  if (t3.renderPass !== u3) return;
                  const d3 = Mi.disabled, _3 = t3.depthModeForSublayer(0, "opaque" === u3 ? Pi.ReadWrite : Pi.ReadOnly), p3 = t3.colorModeForRenderPass(), m3 = t3.useProgram(c3 ? "backgroundPattern" : "background"), f3 = s4 || l3.coveringTiles({ tileSize: h3, terrain: t3.style.map.terrain });
                  c3 && (r3.activeTexture.set(n3.TEXTURE0), t3.imageManager.bind(t3.context));
                  const g3 = i4.getCrossfadeParameters();
                  for (const e4 of f3) {
                    const l4 = s4 ? e4.posMatrix : t3.transform.calculatePosMatrix(e4.toUnwrapped()), u4 = c3 ? Fe2(l4, o3, t3, c3, { tileID: e4, tileSize: h3 }, g3) : ke2(l4, o3, a4), f4 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(e4);
                    m3.draw(r3, n3.TRIANGLES, _3, d3, p3, zi.disabled, u4, f4, i4.id, t3.tileExtentBuffer, t3.quadTriangleIndexBuffer, t3.tileExtentSegments);
                  }
                }(e2, 0, s3, a3);
                break;
              case "custom":
                !function(t3, e3, i4) {
                  const s4 = t3.context, a4 = i4.implementation;
                  if ("offscreen" === t3.renderPass) {
                    const e4 = a4.prerender;
                    e4 && (t3.setCustomLayerDefaults(), s4.setColorMode(t3.colorModeForRenderPass()), e4.call(a4, s4.gl, t3.transform.customLayerMatrix()), s4.setDirty(), t3.setBaseState());
                  } else if ("translucent" === t3.renderPass) {
                    t3.setCustomLayerDefaults(), s4.setColorMode(t3.colorModeForRenderPass()), s4.setStencilMode(Mi.disabled);
                    const e4 = "3d" === a4.renderingMode ? new Pi(t3.context.gl.LEQUAL, Pi.ReadWrite, t3.depthRangeFor3D) : t3.depthModeForSublayer(0, Pi.ReadOnly);
                    s4.setDepthMode(e4), a4.render(s4.gl, t3.transform.customLayerMatrix()), s4.setDirty(), t3.setBaseState(), s4.bindFramebuffer.set(null);
                  }
                }(e2, 0, s3);
            }
          }
          translatePosMatrix(e2, i3, s3, a3, o3) {
            if (!s3[0] && !s3[1]) return e2;
            const r3 = o3 ? "map" === a3 ? this.transform.angle : 0 : "viewport" === a3 ? -this.transform.angle : 0;
            if (r3) {
              const t3 = Math.sin(r3), e3 = Math.cos(r3);
              s3 = [s3[0] * e3 - s3[1] * t3, s3[0] * t3 + s3[1] * e3];
            }
            const n3 = [o3 ? s3[0] : St(i3, s3[0], this.transform.zoom), o3 ? s3[1] : St(i3, s3[1], this.transform.zoom), 0], l3 = new Float32Array(16);
            return t2.$(l3, e2, n3), l3;
          }
          saveTileTexture(t3) {
            const e2 = this._tileTextures[t3.size[0]];
            e2 ? e2.push(t3) : this._tileTextures[t3.size[0]] = [t3];
          }
          getTileTexture(t3) {
            const e2 = this._tileTextures[t3];
            return e2 && e2.length > 0 ? e2.pop() : null;
          }
          isPatternMissing(t3) {
            if (!t3) return false;
            if (!t3.from || !t3.to) return true;
            const e2 = this.imageManager.getPattern(t3.from.toString()), i3 = this.imageManager.getPattern(t3.to.toString());
            return !e2 || !i3;
          }
          useProgram(t3, e2) {
            this.cache = this.cache || {};
            const i3 = t3 + (e2 ? e2.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
            return this.cache[i3] || (this.cache[i3] = new ce2(this.context, re2[t3], e2, Be2[t3], this._showOverdrawInspector, this.style.map.terrain)), this.cache[i3];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const t3 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t3.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new x2(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: t3, drawingBufferHeight: e2 } = this.context.gl;
            return this.width !== t3 || this.height !== e2;
          }
        }
        class ss2 {
          constructor(t3, e2) {
            this.points = t3, this.planes = e2;
          }
          static fromInvProjectionMatrix(e2, i3, s3) {
            const a3 = Math.pow(2, s3), o3 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((s4) => {
              const o4 = 1 / (s4 = t2.ag([], s4, e2))[3] / i3 * a3;
              return t2.b3(s4, s4, [o4, o4, 1 / s4[3], o4]);
            }), r3 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
              const e3 = function(t4, e4) {
                var i5 = e4[0], s5 = e4[1], a5 = e4[2], o4 = i5 * i5 + s5 * s5 + a5 * a5;
                return o4 > 0 && (o4 = 1 / Math.sqrt(o4)), t4[0] = e4[0] * o4, t4[1] = e4[1] * o4, t4[2] = e4[2] * o4, t4;
              }([], function(t4, e4, i5) {
                var s5 = e4[0], a5 = e4[1], o4 = e4[2], r4 = i5[0], n3 = i5[1], l3 = i5[2];
                return t4[0] = a5 * l3 - o4 * n3, t4[1] = o4 * r4 - s5 * l3, t4[2] = s5 * n3 - a5 * r4, t4;
              }([], m2([], o3[t3[0]], o3[t3[1]]), m2([], o3[t3[2]], o3[t3[1]]))), i4 = -((s4 = e3)[0] * (a4 = o3[t3[1]])[0] + s4[1] * a4[1] + s4[2] * a4[2]);
              var s4, a4;
              return e3.concat(i4);
            });
            return new ss2(o3, r3);
          }
        }
        class as {
          constructor(t3, e2) {
            this.min = t3, this.max = e2, this.center = function(t4, e3, i3) {
              return t4[0] = 0.5 * e3[0], t4[1] = 0.5 * e3[1], t4[2] = 0.5 * e3[2], t4;
            }([], function(t4, e3, i3) {
              return t4[0] = e3[0] + i3[0], t4[1] = e3[1] + i3[1], t4[2] = e3[2] + i3[2], t4;
            }([], this.min, this.max));
          }
          quadrant(t3) {
            const e2 = [t3 % 2 == 0, t3 < 2], i3 = _2(this.min), s3 = _2(this.max);
            for (let t4 = 0; t4 < e2.length; t4++) i3[t4] = e2[t4] ? this.min[t4] : this.center[t4], s3[t4] = e2[t4] ? this.center[t4] : this.max[t4];
            return s3[2] = this.max[2], new as(i3, s3);
          }
          distanceX(t3) {
            return Math.max(Math.min(this.max[0], t3[0]), this.min[0]) - t3[0];
          }
          distanceY(t3) {
            return Math.max(Math.min(this.max[1], t3[1]), this.min[1]) - t3[1];
          }
          intersects(e2) {
            const i3 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
            let s3 = true;
            for (let a3 = 0; a3 < e2.planes.length; a3++) {
              const o3 = e2.planes[a3];
              let r3 = 0;
              for (let e3 = 0; e3 < i3.length; e3++) t2.b4(o3, i3[e3]) >= 0 && r3++;
              if (0 === r3) return 0;
              r3 !== i3.length && (s3 = false);
            }
            if (s3) return 2;
            for (let t3 = 0; t3 < 3; t3++) {
              let i4 = Number.MAX_VALUE, s4 = -Number.MAX_VALUE;
              for (let a3 = 0; a3 < e2.points.length; a3++) {
                const o3 = e2.points[a3][t3] - this.min[t3];
                i4 = Math.min(i4, o3), s4 = Math.max(s4, o3);
              }
              if (s4 < 0 || i4 > this.max[t3] - this.min[t3]) return 0;
            }
            return 1;
          }
        }
        class os {
          constructor(t3 = 0, e2 = 0, i3 = 0, s3 = 0) {
            if (isNaN(t3) || t3 < 0 || isNaN(e2) || e2 < 0 || isNaN(i3) || i3 < 0 || isNaN(s3) || s3 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = t3, this.bottom = e2, this.left = i3, this.right = s3;
          }
          interpolate(e2, i3, s3) {
            return null != i3.top && null != e2.top && (this.top = t2.B.number(e2.top, i3.top, s3)), null != i3.bottom && null != e2.bottom && (this.bottom = t2.B.number(e2.bottom, i3.bottom, s3)), null != i3.left && null != e2.left && (this.left = t2.B.number(e2.left, i3.left, s3)), null != i3.right && null != e2.right && (this.right = t2.B.number(e2.right, i3.right, s3)), this;
          }
          getCenter(e2, i3) {
            const s3 = t2.ad((this.left + e2 - this.right) / 2, 0, e2), a3 = t2.ad((this.top + i3 - this.bottom) / 2, 0, i3);
            return new t2.P(s3, a3);
          }
          equals(t3) {
            return this.top === t3.top && this.bottom === t3.bottom && this.left === t3.left && this.right === t3.right;
          }
          clone() {
            return new os(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        class rs {
          constructor(e2, i3, s3, a3, o3) {
            this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === o3 || !!o3, this._minZoom = e2 || 0, this._maxZoom = i3 || 22, this._minPitch = null == s3 ? 0 : s3, this._maxPitch = null == a3 ? 60 : a3, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t2.L(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new os(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._minEleveationForCurrentTile = 0;
          }
          clone() {
            const t3 = new rs(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
            return t3.apply(this), t3;
          }
          apply(t3) {
            this.tileSize = t3.tileSize, this.latRange = t3.latRange, this.width = t3.width, this.height = t3.height, this._center = t3._center, this._elevation = t3._elevation, this._minEleveationForCurrentTile = t3._minEleveationForCurrentTile, this.zoom = t3.zoom, this.angle = t3.angle, this._fov = t3._fov, this._pitch = t3._pitch, this._unmodified = t3._unmodified, this._edgeInsets = t3._edgeInsets.clone(), this._calcMatrices();
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(t3) {
            this._minZoom !== t3 && (this._minZoom = t3, this.zoom = Math.max(this.zoom, t3));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(t3) {
            this._maxZoom !== t3 && (this._maxZoom = t3, this.zoom = Math.min(this.zoom, t3));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(t3) {
            this._minPitch !== t3 && (this._minPitch = t3, this.pitch = Math.max(this.pitch, t3));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(t3) {
            this._maxPitch !== t3 && (this._maxPitch = t3, this.pitch = Math.min(this.pitch, t3));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          set renderWorldCopies(t3) {
            void 0 === t3 ? t3 = true : null === t3 && (t3 = false), this._renderWorldCopies = t3;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new t2.P(this.width, this.height);
          }
          get bearing() {
            return -this.angle / Math.PI * 180;
          }
          set bearing(e2) {
            const i3 = -t2.b5(e2, -180, 180) * Math.PI / 180;
            this.angle !== i3 && (this._unmodified = false, this.angle = i3, this._calcMatrices(), this.rotationMatrix = function() {
              var e3 = new t2.A(4);
              return t2.A != Float32Array && (e3[1] = 0, e3[2] = 0), e3[0] = 1, e3[3] = 1, e3;
            }(), function(t3, e3, i4) {
              var s3 = e3[0], a3 = e3[1], o3 = e3[2], r3 = e3[3], n3 = Math.sin(i4), l3 = Math.cos(i4);
              t3[0] = s3 * l3 + o3 * n3, t3[1] = a3 * l3 + r3 * n3, t3[2] = s3 * -n3 + o3 * l3, t3[3] = a3 * -n3 + r3 * l3;
            }(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(e2) {
            const i3 = t2.ad(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i3 && (this._unmodified = false, this._pitch = i3, this._calcMatrices());
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          set fov(t3) {
            t3 = Math.max(0.01, Math.min(60, t3)), this._fov !== t3 && (this._unmodified = false, this._fov = t3 / 180 * Math.PI, this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(t3) {
            const e2 = Math.min(Math.max(t3, this.minZoom), this.maxZoom);
            this._zoom !== e2 && (this._unmodified = false, this._zoom = e2, this.tileZoom = Math.max(0, Math.floor(e2)), this.scale = this.zoomScale(e2), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          set center(t3) {
            t3.lat === this._center.lat && t3.lng === this._center.lng || (this._unmodified = false, this._center = t3, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(t3) {
            t3 !== this._elevation && (this._elevation = t3, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(t3) {
            this._edgeInsets.equals(t3) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t3, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          isPaddingEqual(t3) {
            return this._edgeInsets.equals(t3);
          }
          interpolatePadding(t3, e2, i3) {
            this._unmodified = false, this._edgeInsets.interpolate(t3, e2, i3), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(t3) {
            const e2 = (t3.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t3.tileSize));
            return Math.max(0, e2);
          }
          getVisibleUnwrappedCoordinates(e2) {
            const i3 = [new t2.b6(0, e2)];
            if (this._renderWorldCopies) {
              const s3 = this.pointCoordinate(new t2.P(0, 0)), a3 = this.pointCoordinate(new t2.P(this.width, 0)), o3 = this.pointCoordinate(new t2.P(this.width, this.height)), r3 = this.pointCoordinate(new t2.P(0, this.height)), n3 = Math.floor(Math.min(s3.x, a3.x, o3.x, r3.x)), l3 = Math.floor(Math.max(s3.x, a3.x, o3.x, r3.x)), h3 = 1;
              for (let s4 = n3 - h3; s4 <= l3 + h3; s4++) 0 !== s4 && i3.push(new t2.b6(s4, e2));
            }
            return i3;
          }
          coveringTiles(e2) {
            var i3, s3;
            let a3 = this.coveringZoomLevel(e2);
            const o3 = a3;
            if (void 0 !== e2.minzoom && a3 < e2.minzoom) return [];
            void 0 !== e2.maxzoom && a3 > e2.maxzoom && (a3 = e2.maxzoom);
            const r3 = this.pointCoordinate(this.getCameraPoint()), n3 = t2.U.fromLngLat(this.center), l3 = Math.pow(2, a3), h3 = [l3 * r3.x, l3 * r3.y, 0], c3 = [l3 * n3.x, l3 * n3.y, 0], u3 = ss2.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, a3);
            let d3 = e2.minzoom || 0;
            !e2.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (d3 = a3);
            const _3 = e2.terrain ? 2 / Math.min(this.tileSize, e2.tileSize) * this.tileSize : 3, p3 = (t3) => ({ aabb: new as([t3 * l3, 0, 0], [(t3 + 1) * l3, l3, 0]), zoom: 0, x: 0, y: 0, wrap: t3, fullyVisible: false }), m3 = [], g3 = [], v3 = a3, x3 = e2.reparseOverscaled ? o3 : a3;
            if (this._renderWorldCopies) for (let t3 = 1; t3 <= 3; t3++) m3.push(p3(-t3)), m3.push(p3(t3));
            for (m3.push(p3(0)); m3.length > 0; ) {
              const a4 = m3.pop(), o4 = a4.x, r4 = a4.y;
              let n4 = a4.fullyVisible;
              if (!n4) {
                const t3 = a4.aabb.intersects(u3);
                if (0 === t3) continue;
                n4 = 2 === t3;
              }
              const l4 = e2.terrain ? h3 : c3, p4 = a4.aabb.distanceX(l4), y3 = a4.aabb.distanceY(l4), b3 = Math.max(Math.abs(p4), Math.abs(y3));
              if (a4.zoom === v3 || b3 > _3 + (1 << v3 - a4.zoom) - 2 && a4.zoom >= d3) {
                const e3 = v3 - a4.zoom, i4 = h3[0] - 0.5 - (o4 << e3), s4 = h3[1] - 0.5 - (r4 << e3);
                g3.push({ tileID: new t2.O(a4.zoom === v3 ? x3 : a4.zoom, a4.wrap, a4.zoom, o4, r4), distanceSq: f2([c3[0] - 0.5 - o4, c3[1] - 0.5 - r4]), tileDistanceToCamera: Math.sqrt(i4 * i4 + s4 * s4) });
              } else for (let l5 = 0; l5 < 4; l5++) {
                const h4 = (o4 << 1) + l5 % 2, c4 = (r4 << 1) + (l5 >> 1), u4 = a4.zoom + 1;
                let d4 = a4.aabb.quadrant(l5);
                if (e2.terrain) {
                  const o5 = new t2.O(u4, a4.wrap, u4, h4, c4), r5 = e2.terrain.getMinMaxElevation(o5), n5 = null !== (i3 = r5.minElevation) && void 0 !== i3 ? i3 : this.elevation, l6 = null !== (s3 = r5.maxElevation) && void 0 !== s3 ? s3 : this.elevation;
                  d4 = new as([d4.min[0], d4.min[1], n5], [d4.max[0], d4.max[1], l6]);
                }
                m3.push({ aabb: d4, zoom: u4, x: h4, y: c4, wrap: a4.wrap, fullyVisible: n4 });
              }
            }
            return g3.sort((t3, e3) => t3.distanceSq - e3.distanceSq).map((t3) => t3.tileID);
          }
          resize(t3, e2) {
            this.width = t3, this.height = e2, this.pixelsToGLUnits = [2 / t3, -2 / e2], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(t3) {
            return Math.pow(2, t3);
          }
          scaleZoom(t3) {
            return Math.log(t3) / Math.LN2;
          }
          project(e2) {
            const i3 = t2.ad(e2.lat, -this.maxValidLatitude, this.maxValidLatitude);
            return new t2.P(t2.G(e2.lng) * this.worldSize, t2.H(i3) * this.worldSize);
          }
          unproject(e2) {
            return new t2.U(e2.x / this.worldSize, e2.y / this.worldSize).toLngLat();
          }
          get point() {
            return this.project(this.center);
          }
          getCameraPosition() {
            return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
          }
          recalculateZoom(e2) {
            const i3 = this.pointLocation(this.centerPoint, e2), s3 = e2.getElevationForLngLatZoom(i3, this.tileZoom);
            if (!(this.elevation - s3)) return;
            const a3 = this.getCameraPosition(), o3 = t2.U.fromLngLat(a3.lngLat, a3.altitude), r3 = t2.U.fromLngLat(i3, s3), n3 = o3.x - r3.x, l3 = o3.y - r3.y, h3 = o3.z - r3.z, c3 = Math.sqrt(n3 * n3 + l3 * l3 + h3 * h3), u3 = this.scaleZoom(this.cameraToCenterDistance / c3 / this.tileSize);
            this._elevation = s3, this._center = i3, this.zoom = u3;
          }
          setLocationAtPoint(e2, i3) {
            const s3 = this.pointCoordinate(i3), a3 = this.pointCoordinate(this.centerPoint), o3 = this.locationCoordinate(e2), r3 = new t2.U(o3.x - (s3.x - a3.x), o3.y - (s3.y - a3.y));
            this.center = this.coordinateLocation(r3), this._renderWorldCopies && (this.center = this.center.wrap());
          }
          locationPoint(t3, e2) {
            return e2 ? this.coordinatePoint(this.locationCoordinate(t3), e2.getElevationForLngLatZoom(t3, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t3));
          }
          pointLocation(t3, e2) {
            return this.coordinateLocation(this.pointCoordinate(t3, e2));
          }
          locationCoordinate(e2) {
            return t2.U.fromLngLat(e2);
          }
          coordinateLocation(t3) {
            return t3 && t3.toLngLat();
          }
          pointCoordinate(e2, i3) {
            if (i3) {
              const t3 = i3.pointCoordinate(e2);
              if (null != t3) return t3;
            }
            const s3 = [e2.x, e2.y, 0, 1], a3 = [e2.x, e2.y, 1, 1];
            t2.ag(s3, s3, this.pixelMatrixInverse), t2.ag(a3, a3, this.pixelMatrixInverse);
            const o3 = s3[3], r3 = a3[3], n3 = s3[1] / o3, l3 = a3[1] / r3, h3 = s3[2] / o3, c3 = a3[2] / r3, u3 = h3 === c3 ? 0 : (0 - h3) / (c3 - h3);
            return new t2.U(t2.B.number(s3[0] / o3, a3[0] / r3, u3) / this.worldSize, t2.B.number(n3, l3, u3) / this.worldSize);
          }
          coordinatePoint(e2, i3 = 0, s3 = this.pixelMatrix) {
            const a3 = [e2.x * this.worldSize, e2.y * this.worldSize, i3, 1];
            return t2.ag(a3, a3, s3), new t2.P(a3[0] / a3[3], a3[1] / a3[3]);
          }
          getBounds() {
            const e2 = Math.max(0, this.height / 2 - this.getHorizon());
            return new L2().extend(this.pointLocation(new t2.P(0, e2))).extend(this.pointLocation(new t2.P(this.width, e2))).extend(this.pointLocation(new t2.P(this.width, this.height))).extend(this.pointLocation(new t2.P(0, this.height)));
          }
          getMaxBounds() {
            return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new L2([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
          }
          getHorizon() {
            return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
          }
          setMaxBounds(t3) {
            t3 ? (this.lngRange = [t3.getWest(), t3.getEast()], this.latRange = [t3.getSouth(), t3.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
          }
          calculatePosMatrix(e2, i3 = false) {
            const s3 = e2.key, a3 = i3 ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (a3[s3]) return a3[s3];
            const o3 = e2.canonical, r3 = this.worldSize / this.zoomScale(o3.z), n3 = o3.x + Math.pow(2, o3.z) * e2.wrap, l3 = t2.ao(new Float64Array(16));
            return t2.$(l3, l3, [n3 * r3, o3.y * r3, 0]), t2.a0(l3, l3, [r3 / t2.N, r3 / t2.N, 1]), t2.a1(l3, i3 ? this.alignedProjMatrix : this.projMatrix, l3), a3[s3] = new Float32Array(l3), a3[s3];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining) return;
            this._constraining = true;
            let e2, i3, s3, a3, o3 = -90, r3 = 90, n3 = -180, l3 = 180;
            const h3 = this.size, c3 = this._unmodified;
            if (this.latRange) {
              const i4 = this.latRange;
              o3 = t2.H(i4[1]) * this.worldSize, r3 = t2.H(i4[0]) * this.worldSize, e2 = r3 - o3 < h3.y ? h3.y / (r3 - o3) : 0;
            }
            if (this.lngRange) {
              const e3 = this.lngRange;
              n3 = t2.b5(t2.G(e3[0]) * this.worldSize, 0, this.worldSize), l3 = t2.b5(t2.G(e3[1]) * this.worldSize, 0, this.worldSize), l3 < n3 && (l3 += this.worldSize), i3 = l3 - n3 < h3.x ? h3.x / (l3 - n3) : 0;
            }
            const u3 = this.point, d3 = Math.max(i3 || 0, e2 || 0);
            if (d3) return this.center = this.unproject(new t2.P(i3 ? (l3 + n3) / 2 : u3.x, e2 ? (r3 + o3) / 2 : u3.y)), this.zoom += this.scaleZoom(d3), this._unmodified = c3, void (this._constraining = false);
            if (this.latRange) {
              const t3 = u3.y, e3 = h3.y / 2;
              t3 - e3 < o3 && (a3 = o3 + e3), t3 + e3 > r3 && (a3 = r3 - e3);
            }
            if (this.lngRange) {
              const e3 = (n3 + l3) / 2, i4 = t2.b5(u3.x, e3 - this.worldSize / 2, e3 + this.worldSize / 2), a4 = h3.x / 2;
              i4 - a4 < n3 && (s3 = n3 + a4), i4 + a4 > l3 && (s3 = l3 - a4);
            }
            void 0 === s3 && void 0 === a3 || (this.center = this.unproject(new t2.P(void 0 !== s3 ? s3 : u3.x, void 0 !== a3 ? a3 : u3.y)).wrap()), this._unmodified = c3, this._constraining = false;
          }
          _calcMatrices() {
            if (!this.height) return;
            const e2 = this.centerOffset, i3 = this.point.x, s3 = this.point.y;
            this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = t2.b7(1, this.center.lat) * this.worldSize;
            let a3 = t2.ao(new Float64Array(16));
            t2.a0(a3, a3, [this.width / 2, -this.height / 2, 1]), t2.$(a3, a3, [1, -1, 0]), this.labelPlaneMatrix = a3, a3 = t2.ao(new Float64Array(16)), t2.a0(a3, a3, [1, -1, 1]), t2.$(a3, a3, [-1, -1, 0]), t2.a0(a3, a3, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a3;
            const o3 = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), r3 = Math.min(this.elevation, this._minEleveationForCurrentTile), n3 = o3 - r3 * this._pixelPerMeter / Math.cos(this._pitch), l3 = r3 < 0 ? n3 : o3, h3 = Math.PI / 2 + this._pitch, c3 = this._fov * (0.5 + e2.y / this.height), u3 = Math.sin(c3) * l3 / Math.sin(t2.ad(Math.PI - h3 - c3, 0.01, Math.PI - 0.01)), d3 = this.getHorizon(), _3 = 2 * Math.atan(d3 / this.cameraToCenterDistance) * (0.5 + e2.y / (2 * d3)), p3 = Math.sin(_3) * l3 / Math.sin(t2.ad(Math.PI - h3 - _3, 0.01, Math.PI - 0.01)), m3 = Math.min(u3, p3), f3 = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * m3 + l3), g3 = this.height / 50;
            a3 = new Float64Array(16), t2.b8(a3, this._fov, this.width / this.height, g3, f3), a3[8] = 2 * -e2.x / this.width, a3[9] = 2 * e2.y / this.height, t2.a0(a3, a3, [1, -1, 1]), t2.$(a3, a3, [0, 0, -this.cameraToCenterDistance]), t2.b9(a3, a3, this._pitch), t2.ae(a3, a3, this.angle), t2.$(a3, a3, [-i3, -s3, 0]), this.mercatorMatrix = t2.a0([], a3, [this.worldSize, this.worldSize, this.worldSize]), t2.a0(a3, a3, [1, 1, this._pixelPerMeter]), this.pixelMatrix = t2.a1(new Float64Array(16), this.labelPlaneMatrix, a3), t2.$(a3, a3, [0, 0, -this.elevation]), this.projMatrix = a3, this.invProjMatrix = t2.as([], a3), this.pixelMatrix3D = t2.a1(new Float64Array(16), this.labelPlaneMatrix, a3);
            const v3 = this.width % 2 / 2, x3 = this.height % 2 / 2, y3 = Math.cos(this.angle), b3 = Math.sin(this.angle), w3 = i3 - Math.round(i3) + y3 * v3 + b3 * x3, T3 = s3 - Math.round(s3) + y3 * x3 + b3 * v3, I3 = new Float64Array(a3);
            if (t2.$(I3, I3, [w3 > 0.5 ? w3 - 1 : w3, T3 > 0.5 ? T3 - 1 : T3, 0]), this.alignedProjMatrix = I3, a3 = t2.as(new Float64Array(16), this.pixelMatrix), !a3) throw new Error("failed to invert matrix");
            this.pixelMatrixInverse = a3, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
          }
          maxPitchScaleFactor() {
            if (!this.pixelMatrixInverse) return 1;
            const e2 = this.pointCoordinate(new t2.P(0, 0)), i3 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
            return t2.ag(i3, i3, this.pixelMatrix)[3] / this.cameraToCenterDistance;
          }
          getCameraPoint() {
            const e2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new t2.P(0, e2));
          }
          getCameraQueryGeometry(e2) {
            const i3 = this.getCameraPoint();
            if (1 === e2.length) return [e2[0], i3];
            {
              let s3 = i3.x, a3 = i3.y, o3 = i3.x, r3 = i3.y;
              for (const t3 of e2) s3 = Math.min(s3, t3.x), a3 = Math.min(a3, t3.y), o3 = Math.max(o3, t3.x), r3 = Math.max(r3, t3.y);
              return [new t2.P(s3, a3), new t2.P(o3, a3), new t2.P(o3, r3), new t2.P(s3, r3), new t2.P(s3, a3)];
            }
          }
        }
        function ns(t3, e2) {
          let i3, s3 = false, a3 = null, o3 = null;
          const r3 = () => {
            a3 = null, s3 && (t3.apply(o3, i3), a3 = setTimeout(r3, e2), s3 = false);
          };
          return (...t4) => (s3 = true, o3 = this, i3 = t4, a3 || r3(), a3);
        }
        class ls {
          constructor(t3) {
            this._getCurrentHash = () => {
              const t4 = window.location.hash.replace("#", "");
              if (this._hashName) {
                let e2;
                return t4.split("&").map((t5) => t5.split("=")).forEach((t5) => {
                  t5[0] === this._hashName && (e2 = t5);
                }), (e2 && e2[1] || "").split("/");
              }
              return t4.split("/");
            }, this._onHashChange = () => {
              const t4 = this._getCurrentHash();
              if (t4.length >= 3 && !t4.some((t5) => isNaN(t5))) {
                const e2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t4[3] || 0) : this._map.getBearing();
                return this._map.jumpTo({ center: [+t4[2], +t4[1]], zoom: +t4[0], bearing: e2, pitch: +(t4[4] || 0) }), true;
              }
              return false;
            }, this._updateHashUnthrottled = () => {
              const t4 = window.location.href.replace(/(#.+)?$/, this.getHashString());
              try {
                window.history.replaceState(window.history.state, null, t4);
              } catch (t5) {
              }
            }, this._updateHash = ns(this._updateHashUnthrottled, 300), this._hashName = t3 && encodeURIComponent(t3);
          }
          addTo(t3) {
            return this._map = t3, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
          }
          getHashString(t3) {
            const e2 = this._map.getCenter(), i3 = Math.round(100 * this._map.getZoom()) / 100, s3 = Math.ceil((i3 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a3 = Math.pow(10, s3), o3 = Math.round(e2.lng * a3) / a3, r3 = Math.round(e2.lat * a3) / a3, n3 = this._map.getBearing(), l3 = this._map.getPitch();
            let h3 = "";
            if (h3 += t3 ? `/${o3}/${r3}/${i3}` : `${i3}/${r3}/${o3}`, (n3 || l3) && (h3 += "/" + Math.round(10 * n3) / 10), l3 && (h3 += `/${Math.round(l3)}`), this._hashName) {
              const t4 = this._hashName;
              let e3 = false;
              const i4 = window.location.hash.slice(1).split("&").map((i5) => {
                const s4 = i5.split("=")[0];
                return s4 === t4 ? (e3 = true, `${s4}=${h3}`) : i5;
              }).filter((t5) => t5);
              return e3 || i4.push(`${t4}=${h3}`), `#${i4.join("&")}`;
            }
            return `#${h3}`;
          }
        }
        const hs = { linearity: 0.3, easing: t2.ba(0, 0, 0.3, 1) }, cs = t2.e({ deceleration: 2500, maxSpeed: 1400 }, hs), us = t2.e({ deceleration: 20, maxSpeed: 1400 }, hs), ds = t2.e({ deceleration: 1e3, maxSpeed: 360 }, hs), _s = t2.e({ deceleration: 1e3, maxSpeed: 90 }, hs);
        class ps {
          constructor(t3) {
            this._map = t3, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e2) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t2.h.now(), settings: e2 });
          }
          _drainInertiaBuffer() {
            const e2 = this._inertiaBuffer, i3 = t2.h.now();
            for (; e2.length > 0 && i3 - e2[0].time > 160; ) e2.shift();
          }
          _onMoveEnd(e2) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const i3 = { zoom: 0, bearing: 0, pitch: 0, pan: new t2.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: t3 } of this._inertiaBuffer) i3.zoom += t3.zoomDelta || 0, i3.bearing += t3.bearingDelta || 0, i3.pitch += t3.pitchDelta || 0, t3.panDelta && i3.pan._add(t3.panDelta), t3.around && (i3.around = t3.around), t3.pinchAround && (i3.pinchAround = t3.pinchAround);
            const s3 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a3 = {};
            if (i3.pan.mag()) {
              const o3 = fs(i3.pan.mag(), s3, t2.e({}, cs, e2 || {}));
              a3.offset = i3.pan.mult(o3.amount / i3.pan.mag()), a3.center = this._map.transform.center, ms(a3, o3);
            }
            if (i3.zoom) {
              const t3 = fs(i3.zoom, s3, us);
              a3.zoom = this._map.transform.zoom + t3.amount, ms(a3, t3);
            }
            if (i3.bearing) {
              const e3 = fs(i3.bearing, s3, ds);
              a3.bearing = this._map.transform.bearing + t2.ad(e3.amount, -179, 179), ms(a3, e3);
            }
            if (i3.pitch) {
              const t3 = fs(i3.pitch, s3, _s);
              a3.pitch = this._map.transform.pitch + t3.amount, ms(a3, t3);
            }
            if (a3.zoom || a3.bearing) {
              const t3 = void 0 === i3.pinchAround ? i3.around : i3.pinchAround;
              a3.around = t3 ? this._map.unproject(t3) : this._map.getCenter();
            }
            return this.clear(), t2.e(a3, { noMoveStart: true });
          }
        }
        function ms(t3, e2) {
          (!t3.duration || t3.duration < e2.duration) && (t3.duration = e2.duration, t3.easing = e2.easing);
        }
        function fs(e2, i3, s3) {
          const { maxSpeed: a3, linearity: o3, deceleration: r3 } = s3, n3 = t2.ad(e2 * o3 / (i3 / 1e3), -a3, a3), l3 = Math.abs(n3) / (r3 * o3);
          return { easing: s3.easing, duration: 1e3 * l3, amount: n3 * (l3 / 2) };
        }
        class gs extends t2.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e2, s3, a3, o3 = {}) {
            const r3 = i2.mousePos(s3.getCanvasContainer(), a3), n3 = s3.unproject(r3);
            super(e2, t2.e({ point: r3, lngLat: n3, originalEvent: a3 }, o3)), this._defaultPrevented = false, this.target = s3;
          }
        }
        class vs extends t2.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e2, s3, a3) {
            const o3 = "touchend" === e2 ? a3.changedTouches : a3.touches, r3 = i2.touchPos(s3.getCanvasContainer(), o3), n3 = r3.map((t3) => s3.unproject(t3)), l3 = r3.reduce((t3, e3, i3, s4) => t3.add(e3.div(s4.length)), new t2.P(0, 0));
            super(e2, { points: r3, point: l3, lngLats: n3, lngLat: s3.unproject(l3), originalEvent: a3 }), this._defaultPrevented = false;
          }
        }
        class xs extends t2.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t3, e2, i3) {
            super(t3, { originalEvent: i3 }), this._defaultPrevented = false;
          }
        }
        class ys {
          constructor(t3, e2) {
            this._map = t3, this._clickTolerance = e2.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(t3) {
            return this._firePreventable(new xs(t3.type, this._map, t3));
          }
          mousedown(t3, e2) {
            return this._mousedownPos = e2, this._firePreventable(new gs(t3.type, this._map, t3));
          }
          mouseup(t3) {
            this._map.fire(new gs(t3.type, this._map, t3));
          }
          click(t3, e2) {
            this._mousedownPos && this._mousedownPos.dist(e2) >= this._clickTolerance || this._map.fire(new gs(t3.type, this._map, t3));
          }
          dblclick(t3) {
            return this._firePreventable(new gs(t3.type, this._map, t3));
          }
          mouseover(t3) {
            this._map.fire(new gs(t3.type, this._map, t3));
          }
          mouseout(t3) {
            this._map.fire(new gs(t3.type, this._map, t3));
          }
          touchstart(t3) {
            return this._firePreventable(new vs(t3.type, this._map, t3));
          }
          touchmove(t3) {
            this._map.fire(new vs(t3.type, this._map, t3));
          }
          touchend(t3) {
            this._map.fire(new vs(t3.type, this._map, t3));
          }
          touchcancel(t3) {
            this._map.fire(new vs(t3.type, this._map, t3));
          }
          _firePreventable(t3) {
            if (this._map.fire(t3), t3.defaultPrevented) return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class bs {
          constructor(t3) {
            this._map = t3;
          }
          reset() {
            this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
          }
          mousemove(t3) {
            this._map.fire(new gs(t3.type, this._map, t3));
          }
          mousedown() {
            this._delayContextMenu = true, this._ignoreContextMenu = false;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new gs("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(t3) {
            this._delayContextMenu ? this._contextMenuEvent = t3 : this._ignoreContextMenu || this._map.fire(new gs(t3.type, this._map, t3)), this._map.listens("contextmenu") && t3.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class ws {
          constructor(t3) {
            this._map = t3;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e2) {
            return this.transform.pointLocation(t2.P.convert(e2), this._map.terrain);
          }
        }
        class Ts {
          constructor(t3, e2) {
            this._map = t3, this._tr = new ws(t3), this._el = t3.getCanvasContainer(), this._container = t3.getContainer(), this._clickTolerance = e2.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(t3, e2) {
            this.isEnabled() && t3.shiftKey && 0 === t3.button && (i2.disableDrag(), this._startPos = this._lastPos = e2, this._active = true);
          }
          mousemoveWindow(t3, e2) {
            if (!this._active) return;
            const s3 = e2;
            if (this._lastPos.equals(s3) || !this._box && s3.dist(this._startPos) < this._clickTolerance) return;
            const a3 = this._startPos;
            this._lastPos = s3, this._box || (this._box = i2.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t3));
            const o3 = Math.min(a3.x, s3.x), r3 = Math.max(a3.x, s3.x), n3 = Math.min(a3.y, s3.y), l3 = Math.max(a3.y, s3.y);
            i2.setTransform(this._box, `translate(${o3}px,${n3}px)`), this._box.style.width = r3 - o3 + "px", this._box.style.height = l3 - n3 + "px";
          }
          mouseupWindow(e2, s3) {
            if (!this._active) return;
            if (0 !== e2.button) return;
            const a3 = this._startPos, o3 = s3;
            if (this.reset(), i2.suppressClick(), a3.x !== o3.x || a3.y !== o3.y) return this._map.fire(new t2.k("boxzoomend", { originalEvent: e2 })), { cameraAnimation: (t3) => t3.fitScreenCoordinates(a3, o3, this._tr.bearing, { linear: true }) };
            this._fireEvent("boxzoomcancel", e2);
          }
          keydown(t3) {
            this._active && 27 === t3.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t3));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (i2.remove(this._box), this._box = null), i2.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e2, i3) {
            return this._map.fire(new t2.k(e2, { originalEvent: i3 }));
          }
        }
        function Is(t3, e2) {
          if (t3.length !== e2.length) throw new Error(`The number of touches and points are not equal - touches ${t3.length}, points ${e2.length}`);
          const i3 = {};
          for (let s3 = 0; s3 < t3.length; s3++) i3[t3[s3].identifier] = e2[s3];
          return i3;
        }
        class Es {
          constructor(t3) {
            this.reset(), this.numTouches = t3.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(e2, i3, s3) {
            (this.centroid || s3.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e2.timeStamp), s3.length === this.numTouches && (this.centroid = function(e3) {
              const i4 = new t2.P(0, 0);
              for (const t3 of e3) i4._add(t3);
              return i4.div(e3.length);
            }(i3), this.touches = Is(s3, i3)));
          }
          touchmove(t3, e2, i3) {
            if (this.aborted || !this.centroid) return;
            const s3 = Is(i3, e2);
            for (const t4 in this.touches) {
              const e3 = s3[t4];
              (!e3 || e3.dist(this.touches[t4]) > 30) && (this.aborted = true);
            }
          }
          touchend(t3, e2, i3) {
            if ((!this.centroid || t3.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i3.length) {
              const t4 = !this.aborted && this.centroid;
              if (this.reset(), t4) return t4;
            }
          }
        }
        class Ss {
          constructor(t3) {
            this.singleTap = new Es(t3), this.numTaps = t3.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(t3, e2, i3) {
            this.singleTap.touchstart(t3, e2, i3);
          }
          touchmove(t3, e2, i3) {
            this.singleTap.touchmove(t3, e2, i3);
          }
          touchend(t3, e2, i3) {
            const s3 = this.singleTap.touchend(t3, e2, i3);
            if (s3) {
              const e3 = t3.timeStamp - this.lastTime < 500, i4 = !this.lastTap || this.lastTap.dist(s3) < 30;
              if (e3 && i4 || this.reset(), this.count++, this.lastTime = t3.timeStamp, this.lastTap = s3, this.count === this.numTaps) return this.reset(), s3;
            }
          }
        }
        class Cs {
          constructor(t3) {
            this._tr = new ws(t3), this._zoomIn = new Ss({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Ss({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(t3, e2, i3) {
            this._zoomIn.touchstart(t3, e2, i3), this._zoomOut.touchstart(t3, e2, i3);
          }
          touchmove(t3, e2, i3) {
            this._zoomIn.touchmove(t3, e2, i3), this._zoomOut.touchmove(t3, e2, i3);
          }
          touchend(t3, e2, i3) {
            const s3 = this._zoomIn.touchend(t3, e2, i3), a3 = this._zoomOut.touchend(t3, e2, i3), o3 = this._tr;
            return s3 ? (this._active = true, t3.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o3.zoom + 1, around: o3.unproject(s3) }, { originalEvent: t3 }) }) : a3 ? (this._active = true, t3.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o3.zoom - 1, around: o3.unproject(a3) }, { originalEvent: t3 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ps {
          constructor(t3) {
            this._enabled = !!t3.enable, this._moveStateManager = t3.moveStateManager, this._clickTolerance = t3.clickTolerance || 1, this._moveFunction = t3.move, this._activateOnStart = !!t3.activateOnStart, t3.assignEvents(this), this.reset();
          }
          reset(t3) {
            this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(t3);
          }
          _move(...t3) {
            const e2 = this._moveFunction(...t3);
            if (e2.bearingDelta || e2.pitchDelta || e2.around || e2.panDelta) return this._active = true, e2;
          }
          dragStart(t3, e2) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t3) && (this._moveStateManager.startMove(t3), this._lastPoint = e2.length ? e2[0] : e2, this._activateOnStart && this._lastPoint && (this._active = true));
          }
          dragMove(t3, e2) {
            if (!this.isEnabled()) return;
            const i3 = this._lastPoint;
            if (!i3) return;
            if (t3.preventDefault(), !this._moveStateManager.isValidMoveEvent(t3)) return void this.reset(t3);
            const s3 = e2.length ? e2[0] : e2;
            return !this._moved && s3.dist(i3) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = s3, this._move(i3, s3));
          }
          dragEnd(t3) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t3) && (this._moved && i2.suppressClick(), this.reset(t3));
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Ds = { 0: 1, 2: 2 };
        class Ms {
          constructor(t3) {
            this._correctEvent = t3.checkCorrectEvent;
          }
          startMove(t3) {
            const e2 = i2.mouseButton(t3);
            this._eventButton = e2;
          }
          endMove(t3) {
            delete this._eventButton;
          }
          isValidStartEvent(t3) {
            return this._correctEvent(t3);
          }
          isValidMoveEvent(t3) {
            return !function(t4, e2) {
              const i3 = Ds[e2];
              return void 0 === t4.buttons || (t4.buttons & i3) !== i3;
            }(t3, this._eventButton);
          }
          isValidEndEvent(t3) {
            return i2.mouseButton(t3) === this._eventButton;
          }
        }
        class zs {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(t3) {
            return 1 === t3.targetTouches.length;
          }
          _isSameTouchEvent(t3) {
            return t3.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(t3) {
            this._firstTouch = t3.targetTouches[0].identifier;
          }
          endMove(t3) {
            delete this._firstTouch;
          }
          isValidStartEvent(t3) {
            return this._isOneFingerTouch(t3);
          }
          isValidMoveEvent(t3) {
            return this._isOneFingerTouch(t3) && this._isSameTouchEvent(t3);
          }
          isValidEndEvent(t3) {
            return this._isOneFingerTouch(t3) && this._isSameTouchEvent(t3);
          }
        }
        const Ls = (t3) => {
          t3.mousedown = t3.dragStart, t3.mousemoveWindow = t3.dragMove, t3.mouseup = t3.dragEnd, t3.contextmenu = function(t4) {
            t4.preventDefault();
          };
        }, As = ({ enable: t3, clickTolerance: e2, bearingDegreesPerPixelMoved: s3 = 0.8 }) => {
          const a3 = new Ms({ checkCorrectEvent: (t4) => 0 === i2.mouseButton(t4) && t4.ctrlKey || 2 === i2.mouseButton(t4) });
          return new Ps({ clickTolerance: e2, move: (t4, e3) => ({ bearingDelta: (e3.x - t4.x) * s3 }), moveStateManager: a3, enable: t3, assignEvents: Ls });
        }, Rs = ({ enable: t3, clickTolerance: e2, pitchDegreesPerPixelMoved: s3 = -0.5 }) => {
          const a3 = new Ms({ checkCorrectEvent: (t4) => 0 === i2.mouseButton(t4) && t4.ctrlKey || 2 === i2.mouseButton(t4) });
          return new Ps({ clickTolerance: e2, move: (t4, e3) => ({ pitchDelta: (e3.y - t4.y) * s3 }), moveStateManager: a3, enable: t3, assignEvents: Ls });
        };
        class ks {
          constructor(t3, e2) {
            this._minTouches = t3.cooperativeGestures ? 2 : 1, this._clickTolerance = t3.clickTolerance || 1, this._map = e2, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new t2.P(0, 0), setTimeout(() => {
              this._cancelCooperativeMessage = false;
            }, 200);
          }
          touchstart(t3, e2, i3) {
            return this._calculateTransform(t3, e2, i3);
          }
          touchmove(t3, e2, i3) {
            if (this._map._cooperativeGestures && (2 === this._minTouches && i3.length < 2 && !this._cancelCooperativeMessage ? this._map._onCooperativeGesture(t3, false, i3.length) : this._cancelCooperativeMessage || (this._cancelCooperativeMessage = true)), this._active && !(i3.length < this._minTouches)) return t3.preventDefault(), this._calculateTransform(t3, e2, i3);
          }
          touchend(t3, e2, i3) {
            this._calculateTransform(t3, e2, i3), this._active && i3.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e2, i3, s3) {
            s3.length > 0 && (this._active = true);
            const a3 = Is(s3, i3), o3 = new t2.P(0, 0), r3 = new t2.P(0, 0);
            let n3 = 0;
            for (const t3 in a3) {
              const e3 = a3[t3], i4 = this._touches[t3];
              i4 && (o3._add(e3), r3._add(e3.sub(i4)), n3++, a3[t3] = e3);
            }
            if (this._touches = a3, n3 < this._minTouches || !r3.mag()) return;
            const l3 = r3.div(n3);
            return this._sum._add(l3), this._sum.mag() < this._clickTolerance ? void 0 : { around: o3.div(n3), panDelta: l3 };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Fs {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          touchstart(t3, e2, i3) {
            this._firstTwoTouches || i3.length < 2 || (this._firstTwoTouches = [i3[0].identifier, i3[1].identifier], this._start([e2[0], e2[1]]));
          }
          touchmove(t3, e2, i3) {
            if (!this._firstTwoTouches) return;
            t3.preventDefault();
            const [s3, a3] = this._firstTwoTouches, o3 = Bs(i3, e2, s3), r3 = Bs(i3, e2, a3);
            if (!o3 || !r3) return;
            const n3 = this._aroundCenter ? null : o3.add(r3).div(2);
            return this._move([o3, r3], n3, t3);
          }
          touchend(t3, e2, s3) {
            if (!this._firstTwoTouches) return;
            const [a3, o3] = this._firstTwoTouches, r3 = Bs(s3, e2, a3), n3 = Bs(s3, e2, o3);
            r3 && n3 || (this._active && i2.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(t3) {
            this._enabled = true, this._aroundCenter = !!t3 && "center" === t3.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function Bs(t3, e2, i3) {
          for (let s3 = 0; s3 < t3.length; s3++) if (t3[s3].identifier === i3) return e2[s3];
        }
        function Os(t3, e2) {
          return Math.log(t3 / e2) / Math.LN2;
        }
        class Ns extends Fs {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(t3) {
            this._startDistance = this._distance = t3[0].dist(t3[1]);
          }
          _move(t3, e2) {
            const i3 = this._distance;
            if (this._distance = t3[0].dist(t3[1]), this._active || !(Math.abs(Os(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: Os(this._distance, i3), pinchAround: e2 };
          }
        }
        function Us(t3, e2) {
          return 180 * t3.angleWith(e2) / Math.PI;
        }
        class Zs extends Fs {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(t3) {
            this._startVector = this._vector = t3[0].sub(t3[1]), this._minDiameter = t3[0].dist(t3[1]);
          }
          _move(t3, e2) {
            const i3 = this._vector;
            if (this._vector = t3[0].sub(t3[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: Us(this._vector, i3), pinchAround: e2 };
          }
          _isBelowThreshold(t3) {
            this._minDiameter = Math.min(this._minDiameter, t3.mag());
            const e2 = 25 / (Math.PI * this._minDiameter) * 360, i3 = Us(t3, this._startVector);
            return Math.abs(i3) < e2;
          }
        }
        function Gs(t3) {
          return Math.abs(t3.y) > Math.abs(t3.x);
        }
        class js extends Fs {
          constructor(t3) {
            super(), this._map = t3;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(t3, e2, i3) {
            super.touchstart(t3, e2, i3), this._currentTouchCount = i3.length;
          }
          _start(t3) {
            this._lastPoints = t3, Gs(t3[0].sub(t3[1])) && (this._valid = false);
          }
          _move(t3, e2, i3) {
            if (this._map._cooperativeGestures && this._currentTouchCount < 3) return;
            const s3 = t3[0].sub(this._lastPoints[0]), a3 = t3[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(s3, a3, i3.timeStamp), this._valid ? (this._lastPoints = t3, this._active = true, { pitchDelta: (s3.y + a3.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(t3, e2, i3) {
            if (void 0 !== this._valid) return this._valid;
            const s3 = t3.mag() >= 2, a3 = e2.mag() >= 2;
            if (!s3 && !a3) return;
            if (!s3 || !a3) return void 0 === this._firstMove && (this._firstMove = i3), i3 - this._firstMove < 100 && void 0;
            const o3 = t3.y > 0 == e2.y > 0;
            return Gs(t3) && Gs(e2) && o3;
          }
        }
        const Vs = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class qs {
          constructor(t3) {
            this._tr = new ws(t3);
            const e2 = Vs;
            this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(t3) {
            if (t3.altKey || t3.ctrlKey || t3.metaKey) return;
            let e2 = 0, i3 = 0, s3 = 0, a3 = 0, o3 = 0;
            switch (t3.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                e2 = 1;
                break;
              case 189:
              case 109:
              case 173:
                e2 = -1;
                break;
              case 37:
                t3.shiftKey ? i3 = -1 : (t3.preventDefault(), a3 = -1);
                break;
              case 39:
                t3.shiftKey ? i3 = 1 : (t3.preventDefault(), a3 = 1);
                break;
              case 38:
                t3.shiftKey ? s3 = 1 : (t3.preventDefault(), o3 = -1);
                break;
              case 40:
                t3.shiftKey ? s3 = -1 : (t3.preventDefault(), o3 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i3 = 0, s3 = 0), { cameraAnimation: (r3) => {
              const n3 = this._tr;
              r3.easeTo({ duration: 300, easeId: "keyboardHandler", easing: $s, zoom: e2 ? Math.round(n3.zoom) + e2 * (t3.shiftKey ? 2 : 1) : n3.zoom, bearing: n3.bearing + i3 * this._bearingStep, pitch: n3.pitch + s3 * this._pitchStep, offset: [-a3 * this._panStep, -o3 * this._panStep], center: n3.center }, { originalEvent: t3 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function $s(t3) {
          return t3 * (2 - t3);
        }
        const Ws = 4.000244140625;
        class Hs {
          constructor(t3, e2) {
            this._onTimeout = (t4) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t4);
            }, this._map = t3, this._tr = new ws(t3), this._el = t3.getCanvasContainer(), this._triggerRenderFrame = e2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
          }
          setZoomRate(t3) {
            this._defaultZoomRate = t3;
          }
          setWheelZoomRate(t3) {
            this._wheelZoomRate = t3;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(t3) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!t3 && "center" === t3.around);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          wheel(e2) {
            if (!this.isEnabled()) return;
            if (this._map._cooperativeGestures) {
              if (!e2[this._map._metaKey]) return;
              e2.preventDefault();
            }
            let i3 = e2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY;
            const s3 = t2.h.now(), a3 = s3 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = s3, 0 !== i3 && i3 % Ws == 0 ? this._type = "wheel" : 0 !== i3 && Math.abs(i3) < 4 ? this._type = "trackpad" : a3 > 400 ? (this._type = null, this._lastValue = i3, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(a3 * i3) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i3 += this._lastValue)), e2.shiftKey && i3 && (i3 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= i3, this._active || this._start(e2)), e2.preventDefault();
          }
          _start(e2) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const s3 = i2.mousePos(this._el, e2), a3 = this._tr;
            this._around = t2.L.convert(this._aroundCenter ? a3.center : a3.unproject(s3)), this._aroundPoint = a3.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId) return;
            if (this._frameId = null, !this.isActive()) return;
            const e2 = this._tr.transform;
            if (0 !== this._delta) {
              const t3 = "wheel" === this._type && Math.abs(this._delta) > Ws ? this._wheelZoomRate : this._defaultZoomRate;
              let i4 = 2 / (1 + Math.exp(-Math.abs(this._delta * t3)));
              this._delta < 0 && 0 !== i4 && (i4 = 1 / i4);
              const s4 = "number" == typeof this._targetZoom ? e2.zoomScale(this._targetZoom) : e2.scale;
              this._targetZoom = Math.min(e2.maxZoom, Math.max(e2.minZoom, e2.scaleZoom(s4 * i4))), "wheel" === this._type && (this._startZoom = e2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const i3 = "number" == typeof this._targetZoom ? this._targetZoom : e2.zoom, s3 = this._startZoom, a3 = this._easing;
            let o3, r3 = false;
            if ("wheel" === this._type && s3 && a3) {
              const e3 = Math.min((t2.h.now() - this._lastWheelEventTime) / 200, 1), n3 = a3(e3);
              o3 = t2.B.number(s3, i3, n3), e3 < 1 ? this._frameId || (this._frameId = true) : r3 = true;
            } else o3 = i3, r3 = true;
            return this._active = true, r3 && (this._active = false, this._finishTimeout = setTimeout(() => {
              this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200)), { noInertia: true, needsRenderFrame: !r3, zoomDelta: o3 - e2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e2) {
            let i3 = t2.bb;
            if (this._prevEase) {
              const e3 = this._prevEase, s3 = (t2.h.now() - e3.start) / e3.duration, a3 = e3.easing(s3 + 0.01) - e3.easing(s3), o3 = 0.27 / Math.sqrt(a3 * a3 + 1e-4) * 0.01, r3 = Math.sqrt(0.0729 - o3 * o3);
              i3 = t2.ba(o3, r3, 0.25, 1);
            }
            return this._prevEase = { start: t2.h.now(), duration: e2, easing: i3 }, i3;
          }
          reset() {
            this._active = false, this._zooming = false, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class Xs {
          constructor(t3, e2) {
            this._clickZoom = t3, this._tapZoom = e2;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Ks {
          constructor(t3) {
            this._tr = new ws(t3), this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(t3, e2) {
            return t3.preventDefault(), { cameraAnimation: (i3) => {
              i3.easeTo({ duration: 300, zoom: this._tr.zoom + (t3.shiftKey ? -1 : 1), around: this._tr.unproject(e2) }, { originalEvent: t3 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Qs {
          constructor() {
            this._tap = new Ss({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(t3, e2, i3) {
            if (!this._swipePoint) if (this._tapTime) {
              const s3 = e2[0], a3 = t3.timeStamp - this._tapTime < 500, o3 = this._tapPoint.dist(s3) < 30;
              a3 && o3 ? i3.length > 0 && (this._swipePoint = s3, this._swipeTouch = i3[0].identifier) : this.reset();
            } else this._tap.touchstart(t3, e2, i3);
          }
          touchmove(t3, e2, i3) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i3[0].identifier !== this._swipeTouch) return;
                const s3 = e2[0], a3 = s3.y - this._swipePoint.y;
                return this._swipePoint = s3, t3.preventDefault(), this._active = true, { zoomDelta: a3 / 128 };
              }
            } else this._tap.touchmove(t3, e2, i3);
          }
          touchend(t3, e2, i3) {
            if (this._tapTime) this._swipePoint && 0 === i3.length && this.reset();
            else {
              const s3 = this._tap.touchend(t3, e2, i3);
              s3 && (this._tapTime = t3.timeStamp, this._tapPoint = s3);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ys {
          constructor(t3, e2, i3) {
            this._el = t3, this._mousePan = e2, this._touchPan = i3;
          }
          enable(t3) {
            this._inertiaOptions = t3 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Js {
          constructor(t3, e2, i3) {
            this._pitchWithRotate = t3.pitchWithRotate, this._mouseRotate = e2, this._mousePitch = i3;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class ta {
          constructor(t3, e2, i3, s3) {
            this._el = t3, this._touchZoom = e2, this._touchRotate = i3, this._tapDragZoom = s3, this._rotationDisabled = false, this._enabled = true;
          }
          enable(t3) {
            this._touchZoom.enable(t3), this._rotationDisabled || this._touchRotate.enable(t3), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        const ea = (t3) => t3.zoom || t3.drag || t3.pitch || t3.rotate;
        class ia extends t2.k {
        }
        function sa(t3) {
          return t3.panDelta && t3.panDelta.mag() || t3.zoomDelta || t3.bearingDelta || t3.pitchDelta;
        }
        class aa {
          constructor(t3, e2) {
            this.handleWindowEvent = (t4) => {
              this.handleEvent(t4, `${t4.type}Window`);
            }, this.handleEvent = (t4, e3) => {
              if ("blur" === t4.type) return void this.stop(true);
              this._updatingCamera = true;
              const s4 = "renderFrame" === t4.type ? void 0 : t4, a3 = { needsRenderFrame: false }, o3 = {}, r3 = {}, n3 = t4.touches, l3 = n3 ? this._getMapTouches(n3) : void 0, h3 = l3 ? i2.touchPos(this._el, l3) : i2.mousePos(this._el, t4);
              for (const { handlerName: i3, handler: n4, allowed: c4 } of this._handlers) {
                if (!n4.isEnabled()) continue;
                let u4;
                this._blockedByActive(r3, c4, i3) ? n4.reset() : n4[e3 || t4.type] && (u4 = n4[e3 || t4.type](t4, h3, l3), this.mergeHandlerResult(a3, o3, u4, i3, s4), u4 && u4.needsRenderFrame && this._triggerRenderFrame()), (u4 || n4.isActive()) && (r3[i3] = n4);
              }
              const c3 = {};
              for (const t5 in this._previousActiveHandlers) r3[t5] || (c3[t5] = s4);
              this._previousActiveHandlers = r3, (Object.keys(c3).length || sa(a3)) && (this._changes.push([a3, o3, c3]), this._triggerRenderFrame()), (Object.keys(r3).length || sa(a3)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: u3 } = a3;
              u3 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u3(this._map));
            }, this._map = t3, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ps(t3), this._bearingSnap = e2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(e2);
            const s3 = this._el;
            this._listeners = [[s3, "touchstart", { passive: true }], [s3, "touchmove", { passive: false }], [s3, "touchend", void 0], [s3, "touchcancel", void 0], [s3, "mousedown", void 0], [s3, "mousemove", void 0], [s3, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [s3, "mouseover", void 0], [s3, "mouseout", void 0], [s3, "dblclick", void 0], [s3, "click", void 0], [s3, "keydown", { capture: false }], [s3, "keyup", void 0], [s3, "wheel", { passive: false }], [s3, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [t4, e3, s4] of this._listeners) i2.addEventListener(t4, e3, t4 === document ? this.handleWindowEvent : this.handleEvent, s4);
          }
          destroy() {
            for (const [t3, e2, s3] of this._listeners) i2.removeEventListener(t3, e2, t3 === document ? this.handleWindowEvent : this.handleEvent, s3);
          }
          _addDefaultHandlers(t3) {
            const e2 = this._map, s3 = e2.getCanvasContainer();
            this._add("mapEvent", new ys(e2, t3));
            const a3 = e2.boxZoom = new Ts(e2, t3);
            this._add("boxZoom", a3), t3.interactive && t3.boxZoom && a3.enable();
            const o3 = new Cs(e2), r3 = new Ks(e2);
            e2.doubleClickZoom = new Xs(r3, o3), this._add("tapZoom", o3), this._add("clickZoom", r3), t3.interactive && t3.doubleClickZoom && e2.doubleClickZoom.enable();
            const n3 = new Qs();
            this._add("tapDragZoom", n3);
            const l3 = e2.touchPitch = new js(e2);
            this._add("touchPitch", l3), t3.interactive && t3.touchPitch && e2.touchPitch.enable(t3.touchPitch);
            const h3 = As(t3), c3 = Rs(t3);
            e2.dragRotate = new Js(t3, h3, c3), this._add("mouseRotate", h3, ["mousePitch"]), this._add("mousePitch", c3, ["mouseRotate"]), t3.interactive && t3.dragRotate && e2.dragRotate.enable();
            const u3 = (({ enable: t4, clickTolerance: e3 }) => {
              const s4 = new Ms({ checkCorrectEvent: (t5) => 0 === i2.mouseButton(t5) && !t5.ctrlKey });
              return new Ps({ clickTolerance: e3, move: (t5, e4) => ({ around: e4, panDelta: e4.sub(t5) }), activateOnStart: true, moveStateManager: s4, enable: t4, assignEvents: Ls });
            })(t3), d3 = new ks(t3, e2);
            e2.dragPan = new Ys(s3, u3, d3), this._add("mousePan", u3), this._add("touchPan", d3, ["touchZoom", "touchRotate"]), t3.interactive && t3.dragPan && e2.dragPan.enable(t3.dragPan);
            const _3 = new Zs(), p3 = new Ns();
            e2.touchZoomRotate = new ta(s3, p3, _3, n3), this._add("touchRotate", _3, ["touchPan", "touchZoom"]), this._add("touchZoom", p3, ["touchPan", "touchRotate"]), t3.interactive && t3.touchZoomRotate && e2.touchZoomRotate.enable(t3.touchZoomRotate);
            const m3 = e2.scrollZoom = new Hs(e2, () => this._triggerRenderFrame());
            this._add("scrollZoom", m3, ["mousePan"]), t3.interactive && t3.scrollZoom && e2.scrollZoom.enable(t3.scrollZoom);
            const f3 = e2.keyboard = new qs(e2);
            this._add("keyboard", f3), t3.interactive && t3.keyboard && e2.keyboard.enable(), this._add("blockableMapEvent", new bs(e2));
          }
          _add(t3, e2, i3) {
            this._handlers.push({ handlerName: t3, handler: e2, allowed: i3 }), this._handlersById[t3] = e2;
          }
          stop(t3) {
            if (!this._updatingCamera) {
              for (const { handler: t4 } of this._handlers) t4.reset();
              this._inertia.clear(), this._fireEvents({}, {}, t3), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: t3 } of this._handlers) if (t3.isActive()) return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return Boolean(ea(this._eventsInProgress)) || this.isZooming();
          }
          _blockedByActive(t3, e2, i3) {
            for (const s3 in t3) if (s3 !== i3 && (!e2 || e2.indexOf(s3) < 0)) return true;
            return false;
          }
          _getMapTouches(t3) {
            const e2 = [];
            for (const i3 of t3) this._el.contains(i3.target) && e2.push(i3);
            return e2;
          }
          mergeHandlerResult(e2, i3, s3, a3, o3) {
            if (!s3) return;
            t2.e(e2, s3);
            const r3 = { handlerName: a3, originalEvent: s3.originalEvent || o3 };
            void 0 !== s3.zoomDelta && (i3.zoom = r3), void 0 !== s3.panDelta && (i3.drag = r3), void 0 !== s3.pitchDelta && (i3.pitch = r3), void 0 !== s3.bearingDelta && (i3.rotate = r3);
          }
          _applyChanges() {
            const e2 = {}, i3 = {}, s3 = {};
            for (const [a3, o3, r3] of this._changes) a3.panDelta && (e2.panDelta = (e2.panDelta || new t2.P(0, 0))._add(a3.panDelta)), a3.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + a3.zoomDelta), a3.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + a3.bearingDelta), a3.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + a3.pitchDelta), void 0 !== a3.around && (e2.around = a3.around), void 0 !== a3.pinchAround && (e2.pinchAround = a3.pinchAround), a3.noInertia && (e2.noInertia = a3.noInertia), t2.e(i3, o3), t2.e(s3, r3);
            this._updateMapTransform(e2, i3, s3), this._changes = [];
          }
          _updateMapTransform(t3, e2, i3) {
            const s3 = this._map, a3 = s3._getTransformForUpdate(), o3 = s3.terrain;
            if (!(sa(t3) || o3 && this._terrainMovement)) return this._fireEvents(e2, i3, true);
            let { panDelta: r3, zoomDelta: n3, bearingDelta: l3, pitchDelta: h3, around: c3, pinchAround: u3 } = t3;
            void 0 !== u3 && (c3 = u3), s3._stop(true), c3 = c3 || s3.transform.centerPoint;
            const d3 = a3.pointLocation(r3 ? c3.sub(r3) : c3);
            l3 && (a3.bearing += l3), h3 && (a3.pitch += h3), n3 && (a3.zoom += n3), o3 ? this._terrainMovement || !e2.drag && !e2.zoom ? e2.drag && this._terrainMovement ? a3.center = a3.pointLocation(a3.centerPoint.sub(r3)) : a3.setLocationAtPoint(d3, c3) : (this._terrainMovement = true, this._map._elevationFreeze = true, a3.setLocationAtPoint(d3, c3), this._map.once("moveend", () => {
              this._map._elevationFreeze = false, this._terrainMovement = false, a3.recalculateZoom(s3.terrain);
            })) : a3.setLocationAtPoint(d3, c3), s3._applyUpdatedTransform(a3), this._map._update(), t3.noInertia || this._inertia.record(t3), this._fireEvents(e2, i3, true);
          }
          _fireEvents(e2, i3, s3) {
            const a3 = ea(this._eventsInProgress), o3 = ea(e2), r3 = {};
            for (const t3 in e2) {
              const { originalEvent: i4 } = e2[t3];
              this._eventsInProgress[t3] || (r3[`${t3}start`] = i4), this._eventsInProgress[t3] = e2[t3];
            }
            !a3 && o3 && this._fireEvent("movestart", o3.originalEvent);
            for (const t3 in r3) this._fireEvent(t3, r3[t3]);
            o3 && this._fireEvent("move", o3.originalEvent);
            for (const t3 in e2) {
              const { originalEvent: i4 } = e2[t3];
              this._fireEvent(t3, i4);
            }
            const n3 = {};
            let l3;
            for (const t3 in this._eventsInProgress) {
              const { handlerName: e3, originalEvent: s4 } = this._eventsInProgress[t3];
              this._handlersById[e3].isActive() || (delete this._eventsInProgress[t3], l3 = i3[e3] || s4, n3[`${t3}end`] = l3);
            }
            for (const t3 in n3) this._fireEvent(t3, n3[t3]);
            const h3 = ea(this._eventsInProgress);
            if (s3 && (a3 || o3) && !h3) {
              this._updatingCamera = true;
              const e3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i4 = (t3) => 0 !== t3 && -this._bearingSnap < t3 && t3 < this._bearingSnap;
              !e3 || !e3.essential && t2.h.prefersReducedMotion ? (this._map.fire(new t2.k("moveend", { originalEvent: l3 })), i4(this._map.getBearing()) && this._map.resetNorth()) : (i4(e3.bearing || this._map.getBearing()) && (e3.bearing = 0), e3.freezeElevation = true, this._map.easeTo(e3, { originalEvent: l3 })), this._updatingCamera = false;
            }
          }
          _fireEvent(e2, i3) {
            this._map.fire(new t2.k(e2, i3 ? { originalEvent: i3 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t3) => {
              delete this._frameId, this.handleEvent(new ia("renderFrame", { timeStamp: t3 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        class oa extends t2.E {
          constructor(e2, i3) {
            super(), this._renderFrameCallback = () => {
              const e3 = Math.min((t2.h.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(e3)), e3 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = false, this._zooming = false, this.transform = e2, this._bearingSnap = i3.bearingSnap, this.on("moveend", () => {
              delete this._requestedCameraState;
            });
          }
          getCenter() {
            return new t2.L(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(t3, e2) {
            return this.jumpTo({ center: t3 }, e2);
          }
          panBy(e2, i3, s3) {
            return e2 = t2.P.convert(e2).mult(-1), this.panTo(this.transform.center, t2.e({ offset: e2 }, i3), s3);
          }
          panTo(e2, i3, s3) {
            return this.easeTo(t2.e({ center: e2 }, i3), s3);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(t3, e2) {
            return this.jumpTo({ zoom: t3 }, e2), this;
          }
          zoomTo(e2, i3, s3) {
            return this.easeTo(t2.e({ zoom: e2 }, i3), s3);
          }
          zoomIn(t3, e2) {
            return this.zoomTo(this.getZoom() + 1, t3, e2), this;
          }
          zoomOut(t3, e2) {
            return this.zoomTo(this.getZoom() - 1, t3, e2), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(t3, e2) {
            return this.jumpTo({ bearing: t3 }, e2), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(t3, e2) {
            return this.jumpTo({ padding: t3 }, e2), this;
          }
          rotateTo(e2, i3, s3) {
            return this.easeTo(t2.e({ bearing: e2 }, i3), s3);
          }
          resetNorth(e2, i3) {
            return this.rotateTo(0, t2.e({ duration: 1e3 }, e2), i3), this;
          }
          resetNorthPitch(e2, i3) {
            return this.easeTo(t2.e({ bearing: 0, pitch: 0, duration: 1e3 }, e2), i3), this;
          }
          snapToNorth(t3, e2) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t3, e2) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(t3, e2) {
            return this.jumpTo({ pitch: t3 }, e2), this;
          }
          cameraForBounds(t3, e2) {
            t3 = L2.convert(t3);
            const i3 = e2 && e2.bearing || 0;
            return this._cameraForBoxAndBearing(t3.getNorthWest(), t3.getSouthEast(), i3, e2);
          }
          _cameraForBoxAndBearing(e2, i3, s3, a3) {
            const o3 = { top: 0, bottom: 0, right: 0, left: 0 };
            if ("number" == typeof (a3 = t2.e({ padding: o3, offset: [0, 0], maxZoom: this.transform.maxZoom }, a3)).padding) {
              const t3 = a3.padding;
              a3.padding = { top: t3, bottom: t3, right: t3, left: t3 };
            }
            a3.padding = t2.e(o3, a3.padding);
            const r3 = this.transform, n3 = r3.padding, l3 = r3.project(t2.L.convert(e2)), h3 = r3.project(t2.L.convert(i3)), c3 = l3.rotate(-s3 * Math.PI / 180), u3 = h3.rotate(-s3 * Math.PI / 180), d3 = new t2.P(Math.max(c3.x, u3.x), Math.max(c3.y, u3.y)), _3 = new t2.P(Math.min(c3.x, u3.x), Math.min(c3.y, u3.y)), p3 = d3.sub(_3), m3 = (r3.width - (n3.left + n3.right + a3.padding.left + a3.padding.right)) / p3.x, f3 = (r3.height - (n3.top + n3.bottom + a3.padding.top + a3.padding.bottom)) / p3.y;
            if (f3 < 0 || m3 < 0) return void t2.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            const g3 = Math.min(r3.scaleZoom(r3.scale * Math.min(m3, f3)), a3.maxZoom), v3 = t2.P.convert(a3.offset), x3 = new t2.P((a3.padding.left - a3.padding.right) / 2, (a3.padding.top - a3.padding.bottom) / 2).rotate(s3 * Math.PI / 180), y3 = v3.add(x3).mult(r3.scale / r3.zoomScale(g3));
            return { center: r3.unproject(l3.add(h3).div(2).sub(y3)), zoom: g3, bearing: s3 };
          }
          fitBounds(t3, e2, i3) {
            return this._fitInternal(this.cameraForBounds(t3, e2), e2, i3);
          }
          fitScreenCoordinates(e2, i3, s3, a3, o3) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t2.P.convert(e2)), this.transform.pointLocation(t2.P.convert(i3)), s3, a3), a3, o3);
          }
          _fitInternal(e2, i3, s3) {
            return e2 ? (delete (i3 = t2.e(e2, i3)).padding, i3.linear ? this.easeTo(i3, s3) : this.flyTo(i3, s3)) : this;
          }
          jumpTo(e2, i3) {
            this.stop();
            const s3 = this._getTransformForUpdate();
            let a3 = false, o3 = false, r3 = false;
            return "zoom" in e2 && s3.zoom !== +e2.zoom && (a3 = true, s3.zoom = +e2.zoom), void 0 !== e2.center && (s3.center = t2.L.convert(e2.center)), "bearing" in e2 && s3.bearing !== +e2.bearing && (o3 = true, s3.bearing = +e2.bearing), "pitch" in e2 && s3.pitch !== +e2.pitch && (r3 = true, s3.pitch = +e2.pitch), null == e2.padding || s3.isPaddingEqual(e2.padding) || (s3.padding = e2.padding), this._applyUpdatedTransform(s3), this.fire(new t2.k("movestart", i3)).fire(new t2.k("move", i3)), a3 && this.fire(new t2.k("zoomstart", i3)).fire(new t2.k("zoom", i3)).fire(new t2.k("zoomend", i3)), o3 && this.fire(new t2.k("rotatestart", i3)).fire(new t2.k("rotate", i3)).fire(new t2.k("rotateend", i3)), r3 && this.fire(new t2.k("pitchstart", i3)).fire(new t2.k("pitch", i3)).fire(new t2.k("pitchend", i3)), this.fire(new t2.k("moveend", i3));
          }
          calculateCameraOptionsFromTo(e2, i3, s3, a3 = 0) {
            const o3 = t2.U.fromLngLat(e2, i3), r3 = t2.U.fromLngLat(s3, a3), n3 = r3.x - o3.x, l3 = r3.y - o3.y, h3 = r3.z - o3.z, c3 = Math.hypot(n3, l3, h3);
            if (0 === c3) throw new Error("Can't calculate camera options with same From and To");
            const u3 = Math.hypot(n3, l3), d3 = this.transform.scaleZoom(this.transform.cameraToCenterDistance / c3 / this.transform.tileSize), _3 = 180 * Math.atan2(n3, -l3) / Math.PI;
            let p3 = 180 * Math.acos(u3 / c3) / Math.PI;
            return p3 = h3 < 0 ? 90 - p3 : 90 + p3, { center: r3.toLngLat(), zoom: d3, pitch: p3, bearing: _3 };
          }
          easeTo(e2, i3) {
            this._stop(false, e2.easeId), (false === (e2 = t2.e({ offset: [0, 0], duration: 500, easing: t2.bb }, e2)).animate || !e2.essential && t2.h.prefersReducedMotion) && (e2.duration = 0);
            const s3 = this._getTransformForUpdate(), a3 = this.getZoom(), o3 = this.getBearing(), r3 = this.getPitch(), n3 = this.getPadding(), l3 = "zoom" in e2 ? +e2.zoom : a3, h3 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, o3) : o3, c3 = "pitch" in e2 ? +e2.pitch : r3, u3 = "padding" in e2 ? e2.padding : s3.padding, d3 = t2.P.convert(e2.offset);
            let _3 = s3.centerPoint.add(d3);
            const p3 = s3.pointLocation(_3), m3 = t2.L.convert(e2.center || p3);
            this._normalizeCenter(m3);
            const f3 = s3.project(p3), g3 = s3.project(m3).sub(f3), v3 = s3.zoomScale(l3 - a3);
            let x3, y3;
            e2.around && (x3 = t2.L.convert(e2.around), y3 = s3.locationPoint(x3));
            const b3 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = this._zooming || l3 !== a3, this._rotating = this._rotating || o3 !== h3, this._pitching = this._pitching || c3 !== r3, this._padding = !s3.isPaddingEqual(u3), this._easeId = e2.easeId, this._prepareEase(i3, e2.noMoveStart, b3), this.terrain && this._prepareElevation(m3), this._ease((p4) => {
              if (this._zooming && (s3.zoom = t2.B.number(a3, l3, p4)), this._rotating && (s3.bearing = t2.B.number(o3, h3, p4)), this._pitching && (s3.pitch = t2.B.number(r3, c3, p4)), this._padding && (s3.interpolatePadding(n3, u3, p4), _3 = s3.centerPoint.add(d3)), this.terrain && !e2.freezeElevation && this._updateElevation(p4), x3) s3.setLocationAtPoint(x3, y3);
              else {
                const t3 = s3.zoomScale(s3.zoom - a3), e3 = l3 > a3 ? Math.min(2, v3) : Math.max(0.5, v3), i4 = Math.pow(e3, 1 - p4), o4 = s3.unproject(f3.add(g3.mult(p4 * i4)).mult(t3));
                s3.setLocationAtPoint(s3.renderWorldCopies ? o4.wrap() : o4, _3);
              }
              this._applyUpdatedTransform(s3), this._fireMoveEvents(i3);
            }, (t3) => {
              this.terrain && this._finalizeElevation(), this._afterEase(i3, t3);
            }, e2), this;
          }
          _prepareEase(e2, i3, s3 = {}) {
            this._moving = true, i3 || s3.moving || this.fire(new t2.k("movestart", e2)), this._zooming && !s3.zooming && this.fire(new t2.k("zoomstart", e2)), this._rotating && !s3.rotating && this.fire(new t2.k("rotatestart", e2)), this._pitching && !s3.pitching && this.fire(new t2.k("pitchstart", e2));
          }
          _prepareElevation(t3) {
            this._elevationCenter = t3, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t3, this.transform.tileZoom), this._elevationFreeze = true;
          }
          _updateElevation(e2) {
            this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            const i3 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e2 < 1 && i3 !== this._elevationTarget) {
              const t3 = this._elevationTarget - this._elevationStart;
              this._elevationStart += e2 * (t3 - (i3 - (t3 * e2 + this._elevationStart)) / (1 - e2)), this._elevationTarget = i3;
            }
            this.transform.elevation = t2.B.number(this._elevationStart, this._elevationTarget, e2);
          }
          _finalizeElevation() {
            this._elevationFreeze = false, this.transform.recalculateZoom(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _applyUpdatedTransform(t3) {
            if (!this.transformCameraUpdate) return;
            const e2 = t3.clone(), { center: i3, zoom: s3, pitch: a3, bearing: o3, elevation: r3 } = this.transformCameraUpdate(e2);
            i3 && (e2.center = i3), void 0 !== s3 && (e2.zoom = s3), void 0 !== a3 && (e2.pitch = a3), void 0 !== o3 && (e2.bearing = o3), void 0 !== r3 && (e2.elevation = r3), this.transform.apply(e2);
          }
          _fireMoveEvents(e2) {
            this.fire(new t2.k("move", e2)), this._zooming && this.fire(new t2.k("zoom", e2)), this._rotating && this.fire(new t2.k("rotate", e2)), this._pitching && this.fire(new t2.k("pitch", e2));
          }
          _afterEase(e2, i3) {
            if (this._easeId && i3 && this._easeId === i3) return;
            delete this._easeId;
            const s3 = this._zooming, a3 = this._rotating, o3 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, s3 && this.fire(new t2.k("zoomend", e2)), a3 && this.fire(new t2.k("rotateend", e2)), o3 && this.fire(new t2.k("pitchend", e2)), this.fire(new t2.k("moveend", e2));
          }
          flyTo(e2, i3) {
            if (!e2.essential && t2.h.prefersReducedMotion) {
              const s4 = t2.F(e2, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(s4, i3);
            }
            this.stop(), e2 = t2.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t2.bb }, e2);
            const s3 = this._getTransformForUpdate(), a3 = this.getZoom(), o3 = this.getBearing(), r3 = this.getPitch(), n3 = this.getPadding(), l3 = "zoom" in e2 ? t2.ad(+e2.zoom, s3.minZoom, s3.maxZoom) : a3, h3 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, o3) : o3, c3 = "pitch" in e2 ? +e2.pitch : r3, u3 = "padding" in e2 ? e2.padding : s3.padding, d3 = s3.zoomScale(l3 - a3), _3 = t2.P.convert(e2.offset);
            let p3 = s3.centerPoint.add(_3);
            const m3 = s3.pointLocation(p3), f3 = t2.L.convert(e2.center || m3);
            this._normalizeCenter(f3);
            const g3 = s3.project(m3), v3 = s3.project(f3).sub(g3);
            let x3 = e2.curve;
            const y3 = Math.max(s3.width, s3.height), b3 = y3 / d3, w3 = v3.mag();
            if ("minZoom" in e2) {
              const i4 = t2.ad(Math.min(e2.minZoom, a3, l3), s3.minZoom, s3.maxZoom), o4 = y3 / s3.zoomScale(i4 - a3);
              x3 = Math.sqrt(o4 / w3 * 2);
            }
            const T3 = x3 * x3;
            function I3(t3) {
              const e3 = (b3 * b3 - y3 * y3 + (t3 ? -1 : 1) * T3 * T3 * w3 * w3) / (2 * (t3 ? b3 : y3) * T3 * w3);
              return Math.log(Math.sqrt(e3 * e3 + 1) - e3);
            }
            function E3(t3) {
              return (Math.exp(t3) - Math.exp(-t3)) / 2;
            }
            function S3(t3) {
              return (Math.exp(t3) + Math.exp(-t3)) / 2;
            }
            const C3 = I3(false);
            let P3 = function(t3) {
              return S3(C3) / S3(C3 + x3 * t3);
            }, D3 = function(t3) {
              return y3 * ((S3(C3) * (E3(e3 = C3 + x3 * t3) / S3(e3)) - E3(C3)) / T3) / w3;
              var e3;
            }, M3 = (I3(true) - C3) / x3;
            if (Math.abs(w3) < 1e-6 || !isFinite(M3)) {
              if (Math.abs(y3 - b3) < 1e-6) return this.easeTo(e2, i3);
              const t3 = b3 < y3 ? -1 : 1;
              M3 = Math.abs(Math.log(b3 / y3)) / x3, D3 = function() {
                return 0;
              }, P3 = function(e3) {
                return Math.exp(t3 * x3 * e3);
              };
            }
            return e2.duration = "duration" in e2 ? +e2.duration : 1e3 * M3 / ("screenSpeed" in e2 ? +e2.screenSpeed / x3 : +e2.speed), e2.maxDuration && e2.duration > e2.maxDuration && (e2.duration = 0), this._zooming = true, this._rotating = o3 !== h3, this._pitching = c3 !== r3, this._padding = !s3.isPaddingEqual(u3), this._prepareEase(i3, false), this.terrain && this._prepareElevation(f3), this._ease((d4) => {
              const m4 = d4 * M3, x4 = 1 / P3(m4);
              s3.zoom = 1 === d4 ? l3 : a3 + s3.scaleZoom(x4), this._rotating && (s3.bearing = t2.B.number(o3, h3, d4)), this._pitching && (s3.pitch = t2.B.number(r3, c3, d4)), this._padding && (s3.interpolatePadding(n3, u3, d4), p3 = s3.centerPoint.add(_3)), this.terrain && !e2.freezeElevation && this._updateElevation(d4);
              const y4 = 1 === d4 ? f3 : s3.unproject(g3.add(v3.mult(D3(m4))).mult(x4));
              s3.setLocationAtPoint(s3.renderWorldCopies ? y4.wrap() : y4, p3), this._applyUpdatedTransform(s3), this._fireMoveEvents(i3);
            }, () => {
              this.terrain && this._finalizeElevation(), this._afterEase(i3);
            }, e2), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(t3, e2) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const t4 = this._onEaseEnd;
              delete this._onEaseEnd, t4.call(this, e2);
            }
            if (!t3) {
              const t4 = this.handlers;
              t4 && t4.stop(false);
            }
            return this;
          }
          _ease(e2, i3, s3) {
            false === s3.animate || 0 === s3.duration ? (e2(1), i3()) : (this._easeStart = t2.h.now(), this._easeOptions = s3, this._onEaseFrame = e2, this._onEaseEnd = i3, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e2, i3) {
            e2 = t2.b5(e2, -180, 180);
            const s3 = Math.abs(e2 - i3);
            return Math.abs(e2 - 360 - i3) < s3 && (e2 -= 360), Math.abs(e2 + 360 - i3) < s3 && (e2 += 360), e2;
          }
          _normalizeCenter(t3) {
            const e2 = this.transform;
            if (!e2.renderWorldCopies || e2.lngRange) return;
            const i3 = t3.lng - e2.center.lng;
            t3.lng += i3 > 180 ? -360 : i3 < -180 ? 360 : 0;
          }
          queryTerrainElevation(e2) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(t2.L.convert(e2), this.transform.tileZoom) - this.transform.elevation : null;
          }
        }
        class ra {
          constructor(t3 = {}) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (t4) => {
              !t4 || "metadata" !== t4.sourceDataType && "visibility" !== t4.sourceDataType && "style" !== t4.dataType && "terrain" !== t4.type || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = t3;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(t3) {
            return this._map = t3, this._compact = this.options && this.options.compact, this._container = i2.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = i2.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = i2.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            i2.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(t3, e2) {
            const i3 = this._map._getUIString(`AttributionControl.${e2}`);
            t3.title = i3, t3.setAttribute("aria-label", i3);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let t3 = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t3 = t3.concat(this.options.customAttribution.map((t4) => "string" != typeof t4 ? "" : t4)) : "string" == typeof this.options.customAttribution && t3.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const t4 = this._map.style.stylesheet;
              this.styleOwner = t4.owner, this.styleId = t4.id;
            }
            const e2 = this._map.style.sourceCaches;
            for (const i4 in e2) {
              const s3 = e2[i4];
              if (s3.used || s3.usedForTerrain) {
                const e3 = s3.getSource();
                e3.attribution && t3.indexOf(e3.attribution) < 0 && t3.push(e3.attribution);
              }
            }
            t3 = t3.filter((t4) => String(t4).trim()), t3.sort((t4, e3) => t4.length - e3.length), t3 = t3.filter((e3, i4) => {
              for (let s3 = i4 + 1; s3 < t3.length; s3++) if (t3[s3].indexOf(e3) >= 0) return false;
              return true;
            });
            const i3 = t3.join(" | ");
            i3 !== this._attribHTML && (this._attribHTML = i3, t3.length ? (this._innerContainer.innerHTML = i3, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class na {
          constructor(t3 = {}) {
            this._updateCompact = () => {
              const t4 = this._container.children;
              if (t4.length) {
                const e2 = t4[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && e2.classList.add("maplibregl-compact") : e2.classList.remove("maplibregl-compact");
              }
            }, this.options = t3;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t3) {
            this._map = t3, this._compact = this.options && this.options.compact, this._container = i2.create("div", "maplibregl-ctrl");
            const e2 = i2.create("a", "maplibregl-ctrl-logo");
            return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://maplibre.org/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            i2.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class la {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(t3) {
            const e2 = ++this._id;
            return this._queue.push({ callback: t3, id: e2, cancelled: false }), e2;
          }
          remove(t3) {
            const e2 = this._currentlyRunning, i3 = e2 ? this._queue.concat(e2) : this._queue;
            for (const e3 of i3) if (e3.id === t3) return void (e3.cancelled = true);
          }
          run(t3 = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const e2 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i3 of e2) if (!i3.cancelled && (i3.callback(t3), this._cleared)) break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        const ha = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.enableTerrain": "Enable terrain", "TerrainControl.disableTerrain": "Disable terrain" };
        var ca = t2.Q([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class ua extends t2.E {
          constructor(t3) {
            super(), this.sourceCache = t3, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, t3.usedForTerrain = true, t3.tileSize = this.tileSize * 2 ** this.deltaZoom;
          }
          destruct() {
            this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
          }
          update(e2, i3) {
            this.sourceCache.update(e2, i3), this._renderableTilesKeys = [];
            const s3 = {};
            for (const a3 of e2.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i3 })) s3[a3.key] = true, this._renderableTilesKeys.push(a3.key), this._tiles[a3.key] || (a3.posMatrix = new Float64Array(16), t2.aS(a3.posMatrix, 0, t2.N, 0, t2.N, 0, 1), this._tiles[a3.key] = new W2(a3, this.tileSize));
            for (const t3 in this._tiles) s3[t3] || delete this._tiles[t3];
          }
          freeRtt(t3) {
            for (const e2 in this._tiles) {
              const i3 = this._tiles[e2];
              (!t3 || i3.tileID.equals(t3) || i3.tileID.isChildOf(t3) || t3.isChildOf(i3.tileID)) && (i3.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((t3) => this.getTileByID(t3));
          }
          getTileByID(t3) {
            return this._tiles[t3];
          }
          getTerrainCoords(e2) {
            const i3 = {};
            for (const s3 of this._renderableTilesKeys) {
              const a3 = this._tiles[s3].tileID;
              if (a3.canonical.equals(e2.canonical)) {
                const a4 = e2.clone();
                a4.posMatrix = new Float64Array(16), t2.aS(a4.posMatrix, 0, t2.N, 0, t2.N, 0, 1), i3[s3] = a4;
              } else if (a3.canonical.isChildOf(e2.canonical)) {
                const o3 = e2.clone();
                o3.posMatrix = new Float64Array(16);
                const r3 = a3.canonical.z - e2.canonical.z, n3 = a3.canonical.x - (a3.canonical.x >> r3 << r3), l3 = a3.canonical.y - (a3.canonical.y >> r3 << r3), h3 = t2.N >> r3;
                t2.aS(o3.posMatrix, 0, h3, 0, h3, 0, 1), t2.$(o3.posMatrix, o3.posMatrix, [-n3 * h3, -l3 * h3, 0]), i3[s3] = o3;
              } else if (e2.canonical.isChildOf(a3.canonical)) {
                const o3 = e2.clone();
                o3.posMatrix = new Float64Array(16);
                const r3 = e2.canonical.z - a3.canonical.z, n3 = e2.canonical.x - (e2.canonical.x >> r3 << r3), l3 = e2.canonical.y - (e2.canonical.y >> r3 << r3), h3 = t2.N >> r3;
                t2.aS(o3.posMatrix, 0, t2.N, 0, t2.N, 0, 1), t2.$(o3.posMatrix, o3.posMatrix, [n3 * h3, l3 * h3, 0]), t2.a0(o3.posMatrix, o3.posMatrix, [1 / 2 ** r3, 1 / 2 ** r3, 0]), i3[s3] = o3;
              }
            }
            return i3;
          }
          getSourceTile(t3, e2) {
            const i3 = this.sourceCache._source;
            let s3 = t3.overscaledZ - this.deltaZoom;
            if (s3 > i3.maxzoom && (s3 = i3.maxzoom), s3 < i3.minzoom) return null;
            this._sourceTileCache[t3.key] || (this._sourceTileCache[t3.key] = t3.scaledTo(s3).key);
            let a3 = this.sourceCache.getTileByID(this._sourceTileCache[t3.key]);
            if ((!a3 || !a3.dem) && e2) for (; s3 >= i3.minzoom && (!a3 || !a3.dem); ) a3 = this.sourceCache.getTileByID(t3.scaledTo(s3--).key);
            return a3;
          }
          tilesAfterTime(t3 = Date.now()) {
            return Object.values(this._tiles).filter((e2) => e2.timeAdded >= t3);
          }
        }
        class da {
          constructor(t3, e2, i3) {
            this.painter = t3, this.sourceCache = new ua(e2), this.options = i3, this.exaggeration = "number" == typeof i3.exaggeration ? i3.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e2, i3, s3, a3 = t2.N) {
            var o3;
            if (!(i3 >= 0 && i3 < a3 && s3 >= 0 && s3 < a3)) return 0;
            const r3 = this.getTerrainData(e2), n3 = null === (o3 = r3.tile) || void 0 === o3 ? void 0 : o3.dem;
            if (!n3) return 0;
            const l3 = function(t3, e3, i4) {
              var s4 = e3[0], a4 = e3[1];
              return t3[0] = i4[0] * s4 + i4[4] * a4 + i4[12], t3[1] = i4[1] * s4 + i4[5] * a4 + i4[13], t3;
            }([], [i3 / a3 * t2.N, s3 / a3 * t2.N], r3.u_terrain_matrix), h3 = [l3[0] * n3.dim, l3[1] * n3.dim], c3 = Math.floor(h3[0]), u3 = Math.floor(h3[1]), d3 = h3[0] - c3, _3 = h3[1] - u3;
            return n3.get(c3, u3) * (1 - d3) * (1 - _3) + n3.get(c3 + 1, u3) * d3 * (1 - _3) + n3.get(c3, u3 + 1) * (1 - d3) * _3 + n3.get(c3 + 1, u3 + 1) * d3 * _3;
          }
          getElevationForLngLatZoom(e2, i3) {
            const { tileID: s3, mercatorX: a3, mercatorY: o3 } = this._getOverscaledTileIDFromLngLatZoom(e2, i3);
            return this.getElevation(s3, a3 % t2.N, o3 % t2.N, t2.N);
          }
          getElevation(e2, i3, s3, a3 = t2.N) {
            return this.getDEMElevation(e2, i3, s3, a3) * this.exaggeration;
          }
          getTerrainData(e2) {
            if (!this._emptyDemTexture) {
              const e3 = this.painter.context, i4 = new t2.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new x2(e3, i4, e3.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new x2(e3, new t2.R({ width: 1, height: 1 }), e3.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t2.ao([]);
            }
            const i3 = this.sourceCache.getSourceTile(e2, true);
            if (i3 && i3.dem && (!i3.demTexture || i3.needsTerrainPrepare)) {
              const t3 = this.painter.context;
              i3.demTexture = this.painter.getTileTexture(i3.dem.stride), i3.demTexture ? i3.demTexture.update(i3.dem.getPixels(), { premultiply: false }) : i3.demTexture = new x2(t3, i3.dem.getPixels(), t3.gl.RGBA, { premultiply: false }), i3.demTexture.bind(t3.gl.NEAREST, t3.gl.CLAMP_TO_EDGE), i3.needsTerrainPrepare = false;
            }
            const s3 = i3 && i3 + i3.tileID.key + e2.key;
            if (s3 && !this._demMatrixCache[s3]) {
              const s4 = this.sourceCache.sourceCache._source.maxzoom;
              let a3 = e2.canonical.z - i3.tileID.canonical.z;
              e2.overscaledZ > e2.canonical.z && (e2.canonical.z >= s4 ? a3 = e2.canonical.z - s4 : t2.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const o3 = e2.canonical.x - (e2.canonical.x >> a3 << a3), r3 = e2.canonical.y - (e2.canonical.y >> a3 << a3), n3 = t2.bc(new Float64Array(16), [1 / (t2.N << a3), 1 / (t2.N << a3), 0]);
              t2.$(n3, n3, [o3 * t2.N, r3 * t2.N, 0]), this._demMatrixCache[e2.key] = { matrix: n3, coord: e2 };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: i3 && i3.dem && i3.dem.dim || 1, u_terrain_matrix: s3 ? this._demMatrixCache[e2.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i3 && i3.dem && i3.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i3 && i3.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i3 };
          }
          getFramebuffer(t3) {
            const e2 = this.painter, i3 = e2.width / devicePixelRatio, s3 = e2.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === i3 && this._fbo.height === s3 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new x2(e2.context, { width: i3, height: s3, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new x2(e2.context, { width: i3, height: s3, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e2.context.createFramebuffer(i3, s3, true, false), this._fbo.depthAttachment.set(e2.context.createRenderbuffer(e2.context.gl.DEPTH_COMPONENT16, i3, s3))), this._fbo.colorAttachment.set("coords" === t3 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const e2 = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const i3 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let t3 = 0, e3 = 0; t3 < this._coordsTextureSize; t3++) for (let s4 = 0; s4 < this._coordsTextureSize; s4++, e3 += 4) i3[e3 + 0] = 255 & s4, i3[e3 + 1] = 255 & t3, i3[e3 + 2] = s4 >> 8 << 4 | t3 >> 8, i3[e3 + 3] = 0;
            const s3 = new t2.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i3.buffer)), a3 = new x2(e2, s3, e2.gl.RGBA, { premultiply: false });
            return a3.bind(e2.gl.NEAREST, e2.gl.CLAMP_TO_EDGE), this._coordsTexture = a3, a3;
          }
          pointCoordinate(e2) {
            const i3 = new Uint8Array(4), s3 = this.painter.context, a3 = s3.gl;
            s3.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), a3.readPixels(e2.x, this.painter.height / devicePixelRatio - e2.y - 1, 1, 1, a3.RGBA, a3.UNSIGNED_BYTE, i3), s3.bindFramebuffer.set(null);
            const o3 = i3[0] + (i3[2] >> 4 << 8), r3 = i3[1] + ((15 & i3[2]) << 8), n3 = this.coordsIndex[255 - i3[3]], l3 = n3 && this.sourceCache.getTileByID(n3);
            if (!l3) return null;
            const h3 = this._coordsTextureSize, c3 = (1 << l3.tileID.canonical.z) * h3;
            return new t2.U(this._allowMercatorOverflow(e2, (l3.tileID.canonical.x * h3 + o3) / c3), (l3.tileID.canonical.y * h3 + r3) / c3, this.getElevation(l3.tileID, o3, r3, h3));
          }
          getTerrainMesh() {
            if (this._mesh) return this._mesh;
            const e2 = this.painter.context, i3 = new t2.bd(), s3 = new t2.b0(), a3 = this.meshSize, o3 = t2.N / a3, r3 = a3 * a3;
            for (let t3 = 0; t3 <= a3; t3++) for (let e3 = 0; e3 <= a3; e3++) i3.emplaceBack(e3 * o3, t3 * o3, 0);
            for (let t3 = 0; t3 < r3; t3 += a3 + 1) for (let e3 = 0; e3 < a3; e3++) s3.emplaceBack(e3 + t3, a3 + e3 + t3 + 1, a3 + e3 + t3 + 2), s3.emplaceBack(e3 + t3, a3 + e3 + t3 + 2, e3 + t3 + 1);
            const n3 = i3.length, l3 = n3 + 2 * (a3 + 1);
            for (const e3 of [0, 1]) for (let s4 = 0; s4 <= a3; s4++) for (const a4 of [0, 1]) i3.emplaceBack(s4 * o3, e3 * t2.N, a4);
            for (let t3 = 0; t3 < 2 * a3; t3 += 2) s3.emplaceBack(l3 + t3, l3 + t3 + 1, l3 + t3 + 3), s3.emplaceBack(l3 + t3, l3 + t3 + 3, l3 + t3 + 2), s3.emplaceBack(n3 + t3, n3 + t3 + 3, n3 + t3 + 1), s3.emplaceBack(n3 + t3, n3 + t3 + 2, n3 + t3 + 3);
            const h3 = i3.length, c3 = h3 + 2 * (a3 + 1);
            for (const e3 of [0, 1]) for (let s4 = 0; s4 <= a3; s4++) for (const a4 of [0, 1]) i3.emplaceBack(e3 * t2.N, s4 * o3, a4);
            for (let t3 = 0; t3 < 2 * a3; t3 += 2) s3.emplaceBack(h3 + t3, h3 + t3 + 1, h3 + t3 + 3), s3.emplaceBack(h3 + t3, h3 + t3 + 3, h3 + t3 + 2), s3.emplaceBack(c3 + t3, c3 + t3 + 3, c3 + t3 + 1), s3.emplaceBack(c3 + t3, c3 + t3 + 2, c3 + t3 + 3);
            return this._mesh = { indexBuffer: e2.createIndexBuffer(s3), vertexBuffer: e2.createVertexBuffer(i3, ca.members), segments: t2.S.simpleSegment(0, 0, i3.length, s3.length) }, this._mesh;
          }
          getMeshFrameDelta(e2) {
            return 2 * Math.PI * t2.be / Math.pow(2, e2) / 5;
          }
          getMinTileElevationForLngLatZoom(t3, e2) {
            var i3;
            const { tileID: s3 } = this._getOverscaledTileIDFromLngLatZoom(t3, e2);
            return null !== (i3 = this.getMinMaxElevation(s3).minElevation) && void 0 !== i3 ? i3 : 0;
          }
          getMinMaxElevation(t3) {
            const e2 = this.getTerrainData(t3).tile, i3 = { minElevation: null, maxElevation: null };
            return e2 && e2.dem && (i3.minElevation = e2.dem.min * this.exaggeration, i3.maxElevation = e2.dem.max * this.exaggeration), i3;
          }
          _getOverscaledTileIDFromLngLatZoom(e2, i3) {
            const s3 = t2.U.fromLngLat(e2.wrap()), a3 = (1 << i3) * t2.N, o3 = s3.x * a3, r3 = s3.y * a3, n3 = Math.floor(o3 / t2.N), l3 = Math.floor(r3 / t2.N);
            return { tileID: new t2.O(i3, 0, i3, n3, l3), mercatorX: o3, mercatorY: r3 };
          }
          _allowMercatorOverflow(e2, i3) {
            const s3 = e2.x < this.painter.width / 2;
            let a3 = t2.bf(i3);
            const o3 = this.painter.transform.center.lng;
            return s3 && Math.sign(a3) > 0 && Math.sign(o3) < 0 || !s3 && Math.sign(a3) < 0 && Math.sign(o3) > 0 ? (a3 = 360 * Math.sign(o3) + a3, t2.G(a3)) : i3;
          }
        }
        class _a2 {
          constructor(t3, e2, i3) {
            this._context = t3, this._size = e2, this._tileSize = i3, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const t3 of this._objects) t3.texture.destroy(), t3.fbo.destroy();
          }
          _createObject(t3) {
            const e2 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i3 = new x2(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return i3.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), e2.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), e2.colorAttachment.set(i3.texture), { id: t3, fbo: e2, texture: i3, stamp: -1, inUse: false };
          }
          getObjectForId(t3) {
            return this._objects[t3];
          }
          useObject(t3) {
            t3.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((e2) => t3.id !== e2), this._recentlyUsed.push(t3.id);
          }
          stampObject(t3) {
            t3.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const t4 of this._recentlyUsed) if (!this._objects[t4].inUse) return this._objects[t4];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const t3 = this._createObject(this._objects.length);
            return this._objects.push(t3), t3;
          }
          freeObject(t3) {
            t3.inUse = false;
          }
          freeAllObjects() {
            for (const t3 of this._objects) this.freeObject(t3);
          }
          isFull() {
            return !(this._objects.length < this._size) && false === this._objects.some((t3) => !t3.inUse);
          }
        }
        const pa = { background: true, fill: true, line: true, raster: true, hillshade: true };
        class ma {
          constructor(t3, e2) {
            this.painter = t3, this.terrain = e2, this.pool = new _a2(t3.context, 30, e2.sourceCache.tileSize * e2.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(t3) {
            return this.pool.getObjectForId(t3.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(t3, e2) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t3._order.filter((i3) => !t3._layers[i3].isHidden(e2)), this._coordsDescendingInv = {};
            for (const e3 in t3.sourceCaches) {
              this._coordsDescendingInv[e3] = {};
              const i3 = t3.sourceCaches[e3].getVisibleCoordinates();
              for (const t4 of i3) {
                const i4 = this.terrain.sourceCache.getTerrainCoords(t4);
                for (const t5 in i4) this._coordsDescendingInv[e3][t5] || (this._coordsDescendingInv[e3][t5] = []), this._coordsDescendingInv[e3][t5].push(i4[t5]);
              }
            }
            this._coordsDescendingInvStr = {};
            for (const e3 of t3._order) {
              const i3 = t3._layers[e3], s3 = i3.source;
              if (pa[i3.type] && !this._coordsDescendingInvStr[s3]) {
                this._coordsDescendingInvStr[s3] = {};
                for (const t4 in this._coordsDescendingInv[s3]) this._coordsDescendingInvStr[s3][t4] = this._coordsDescendingInv[s3][t4].map((t5) => t5.key).sort().join();
              }
            }
            for (const t4 of this._renderableTiles) for (const e3 in this._coordsDescendingInvStr) {
              const i3 = this._coordsDescendingInvStr[e3][t4.tileID.key];
              i3 && i3 !== t4.rttCoords[e3] && (t4.rtt = []);
            }
          }
          renderLayer(e2) {
            if (e2.isHidden(this.painter.transform.zoom)) return false;
            const i3 = e2.type, s3 = this.painter, a3 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e2.id;
            if (pa[i3] && (this._prevType && pa[this._prevType] || this._stacks.push([]), this._prevType = i3, this._stacks[this._stacks.length - 1].push(e2.id), !a3)) return true;
            if (pa[this._prevType] || pa[i3] && a3) {
              this._prevType = i3;
              const e3 = this._stacks.length - 1, a4 = this._stacks[e3] || [];
              for (const i4 of this._renderableTiles) {
                if (this.pool.isFull() && (es(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(i4), i4.rtt[e3]) {
                  const t3 = this.pool.getObjectForId(i4.rtt[e3].id);
                  if (t3.stamp === i4.rtt[e3].stamp) {
                    this.pool.useObject(t3);
                    continue;
                  }
                }
                const o3 = this.pool.getOrCreateFreeObject();
                this.pool.useObject(o3), this.pool.stampObject(o3), i4.rtt[e3] = { id: o3.id, stamp: o3.stamp }, s3.context.bindFramebuffer.set(o3.fbo.framebuffer), s3.context.clear({ color: t2.aT.transparent, stencil: 0 }), s3.currentStencilSource = void 0;
                for (let t3 = 0; t3 < a4.length; t3++) {
                  const e4 = s3.style._layers[a4[t3]], r3 = e4.source ? this._coordsDescendingInv[e4.source][i4.tileID.key] : [i4.tileID];
                  s3.context.viewport.set([0, 0, o3.fbo.width, o3.fbo.height]), s3._renderTileClippingMasks(e4, r3), s3.renderLayer(s3, s3.style.sourceCaches[e4.source], e4, r3), e4.source && (i4.rttCoords[e4.source] = this._coordsDescendingInvStr[e4.source][i4.tileID.key]);
                }
              }
              return es(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), pa[i3];
            }
            return false;
          }
        }
        const fa = e, ga = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: void 0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, maxTileCacheZoomLevels: t2.c.MAX_TILE_CACHE_ZOOM_LEVELS, localIdeographFontFamily: "sans-serif", transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, validateStyle: true, maxCanvasSize: [4096, 4096] }, va = (t3) => {
          t3.touchstart = t3.dragStart, t3.touchmoveWindow = t3.dragMove, t3.touchend = t3.dragEnd;
        }, xa = { showCompass: true, showZoom: true, visualizePitch: false };
        class ya {
          constructor(e2, s3, a3 = false) {
            this.mousedown = (e3) => {
              this.startMouse(t2.e({}, e3, { ctrlKey: true, preventDefault: () => e3.preventDefault() }), i2.mousePos(this.element, e3)), i2.addEventListener(window, "mousemove", this.mousemove), i2.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (t3) => {
              this.moveMouse(t3, i2.mousePos(this.element, t3));
            }, this.mouseup = (t3) => {
              this.mouseRotate.dragEnd(t3), this.mousePitch && this.mousePitch.dragEnd(t3), this.offTemp();
            }, this.touchstart = (t3) => {
              1 !== t3.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = i2.touchPos(this.element, t3.targetTouches)[0], this.startTouch(t3, this._startPos), i2.addEventListener(window, "touchmove", this.touchmove, { passive: false }), i2.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (t3) => {
              1 !== t3.targetTouches.length ? this.reset() : (this._lastPos = i2.touchPos(this.element, t3.targetTouches)[0], this.moveTouch(t3, this._lastPos));
            }, this.touchend = (t3) => {
              0 === t3.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10;
            const o3 = e2.dragRotate._mouseRotate.getClickTolerance(), r3 = e2.dragRotate._mousePitch.getClickTolerance();
            this.element = s3, this.mouseRotate = As({ clickTolerance: o3, enable: true }), this.touchRotate = (({ enable: t3, clickTolerance: e3, bearingDegreesPerPixelMoved: i3 = 0.8 }) => {
              const s4 = new zs();
              return new Ps({ clickTolerance: e3, move: (t4, e4) => ({ bearingDelta: (e4.x - t4.x) * i3 }), moveStateManager: s4, enable: t3, assignEvents: va });
            })({ clickTolerance: o3, enable: true }), this.map = e2, a3 && (this.mousePitch = Rs({ clickTolerance: r3, enable: true }), this.touchPitch = (({ enable: t3, clickTolerance: e3, pitchDegreesPerPixelMoved: i3 = -0.5 }) => {
              const s4 = new zs();
              return new Ps({ clickTolerance: e3, move: (t4, e4) => ({ pitchDelta: (e4.y - t4.y) * i3 }), moveStateManager: s4, enable: t3, assignEvents: va });
            })({ clickTolerance: r3, enable: true })), i2.addEventListener(s3, "mousedown", this.mousedown), i2.addEventListener(s3, "touchstart", this.touchstart, { passive: false }), i2.addEventListener(s3, "touchcancel", this.reset);
          }
          startMouse(t3, e2) {
            this.mouseRotate.dragStart(t3, e2), this.mousePitch && this.mousePitch.dragStart(t3, e2), i2.disableDrag();
          }
          startTouch(t3, e2) {
            this.touchRotate.dragStart(t3, e2), this.touchPitch && this.touchPitch.dragStart(t3, e2), i2.disableDrag();
          }
          moveMouse(t3, e2) {
            const i3 = this.map, { bearingDelta: s3 } = this.mouseRotate.dragMove(t3, e2) || {};
            if (s3 && i3.setBearing(i3.getBearing() + s3), this.mousePitch) {
              const { pitchDelta: s4 } = this.mousePitch.dragMove(t3, e2) || {};
              s4 && i3.setPitch(i3.getPitch() + s4);
            }
          }
          moveTouch(t3, e2) {
            const i3 = this.map, { bearingDelta: s3 } = this.touchRotate.dragMove(t3, e2) || {};
            if (s3 && i3.setBearing(i3.getBearing() + s3), this.touchPitch) {
              const { pitchDelta: s4 } = this.touchPitch.dragMove(t3, e2) || {};
              s4 && i3.setPitch(i3.getPitch() + s4);
            }
          }
          off() {
            const t3 = this.element;
            i2.removeEventListener(t3, "mousedown", this.mousedown), i2.removeEventListener(t3, "touchstart", this.touchstart, { passive: false }), i2.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), i2.removeEventListener(window, "touchend", this.touchend), i2.removeEventListener(t3, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            i2.enableDrag(), i2.removeEventListener(window, "mousemove", this.mousemove), i2.removeEventListener(window, "mouseup", this.mouseup), i2.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), i2.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let ba;
        function wa(e2, i3, s3) {
          if (e2 = new t2.L(e2.lng, e2.lat), i3) {
            const a3 = new t2.L(e2.lng - 360, e2.lat), o3 = new t2.L(e2.lng + 360, e2.lat), r3 = s3.locationPoint(e2).distSqr(i3);
            s3.locationPoint(a3).distSqr(i3) < r3 ? e2 = a3 : s3.locationPoint(o3).distSqr(i3) < r3 && (e2 = o3);
          }
          for (; Math.abs(e2.lng - s3.center.lng) > 180; ) {
            const t3 = s3.locationPoint(e2);
            if (t3.x >= 0 && t3.y >= 0 && t3.x <= s3.width && t3.y <= s3.height) break;
            e2.lng > s3.center.lng ? e2.lng -= 360 : e2.lng += 360;
          }
          return e2;
        }
        const Ta = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function Ia(t3, e2, i3) {
          const s3 = t3.classList;
          for (const t4 in Ta) s3.remove(`maplibregl-${i3}-anchor-${t4}`);
          s3.add(`maplibregl-${i3}-anchor-${e2}`);
        }
        class Ea extends t2.E {
          constructor(e2) {
            if (super(), this._onKeyPress = (t3) => {
              const e3 = t3.code, i3 = t3.charCode || t3.keyCode;
              "Space" !== e3 && "Enter" !== e3 && 32 !== i3 && 13 !== i3 || this.togglePopup();
            }, this._onMapClick = (t3) => {
              const e3 = t3.originalEvent.target, i3 = this._element;
              this._popup && (e3 === i3 || i3.contains(e3)) && this.togglePopup();
            }, this._update = (t3) => {
              if (!this._map) return;
              const e3 = this._map.loaded() && !this._map.isMoving();
              ("terrain" === (null == t3 ? void 0 : t3.type) || "render" === (null == t3 ? void 0 : t3.type) && !e3) && this._map.once("render", this._update), this._map.transform.renderWorldCopies && (this._lngLat = wa(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
              let s3 = "";
              "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? s3 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (s3 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let a3 = "";
              "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? a3 = "rotateX(0deg)" : "map" === this._pitchAlignment && (a3 = `rotateX(${this._map.getPitch()}deg)`), t3 && "moveend" !== t3.type || (this._pos = this._pos.round()), i2.setTransform(this._element, `${Ta[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${a3} ${s3}`), this._map.terrain && !this._opacityTimeout && (this._opacityTimeout = setTimeout(() => {
                const t4 = this._map.unproject(this._pos), e4 = 40075016686e-3 * Math.abs(Math.cos(this._lngLat.lat * Math.PI / 180)) / Math.pow(2, this._map.transform.tileZoom + 8);
                this._element.style.opacity = t4.distanceTo(this._lngLat) > 20 * e4 ? "0.2" : "1.0", this._opacityTimeout = null;
              }, 100));
            }, this._onMove = (e3) => {
              if (!this._isDragging) {
                const t3 = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = e3.point.dist(this._pointerdownPos) >= t3;
              }
              this._isDragging && (this._pos = e3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t2.k("dragstart"))), this.fire(new t2.k("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t2.k("dragend")), this._state = "inactive";
            }, this._addDragHandler = (t3) => {
              this._element.contains(t3.originalEvent.target) && (t3.preventDefault(), this._positionDelta = t3.point.sub(this._pos).add(this._offset), this._pointerdownPos = t3.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e2 && e2.anchor || "center", this._color = e2 && e2.color || "#3FB1CE", this._scale = e2 && e2.scale || 1, this._draggable = e2 && e2.draggable || false, this._clickTolerance = e2 && e2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = e2 && e2.rotation || 0, this._rotationAlignment = e2 && e2.rotationAlignment || "auto", this._pitchAlignment = e2 && e2.pitchAlignment && "auto" !== e2.pitchAlignment ? e2.pitchAlignment : this._rotationAlignment, e2 && e2.element) this._element = e2.element, this._offset = t2.P.convert(e2 && e2.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = i2.create("div"), this._element.setAttribute("aria-label", "Map marker");
              const s3 = i2.createNS("http://www.w3.org/2000/svg", "svg"), a3 = 41, o3 = 27;
              s3.setAttributeNS(null, "display", "block"), s3.setAttributeNS(null, "height", `${a3}px`), s3.setAttributeNS(null, "width", `${o3}px`), s3.setAttributeNS(null, "viewBox", `0 0 ${o3} ${a3}`);
              const r3 = i2.createNS("http://www.w3.org/2000/svg", "g");
              r3.setAttributeNS(null, "stroke", "none"), r3.setAttributeNS(null, "stroke-width", "1"), r3.setAttributeNS(null, "fill", "none"), r3.setAttributeNS(null, "fill-rule", "evenodd");
              const n3 = i2.createNS("http://www.w3.org/2000/svg", "g");
              n3.setAttributeNS(null, "fill-rule", "nonzero");
              const l3 = i2.createNS("http://www.w3.org/2000/svg", "g");
              l3.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l3.setAttributeNS(null, "fill", "#000000");
              const h3 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const t3 of h3) {
                const e3 = i2.createNS("http://www.w3.org/2000/svg", "ellipse");
                e3.setAttributeNS(null, "opacity", "0.04"), e3.setAttributeNS(null, "cx", "10.5"), e3.setAttributeNS(null, "cy", "5.80029008"), e3.setAttributeNS(null, "rx", t3.rx), e3.setAttributeNS(null, "ry", t3.ry), l3.appendChild(e3);
              }
              const c3 = i2.createNS("http://www.w3.org/2000/svg", "g");
              c3.setAttributeNS(null, "fill", this._color);
              const u3 = i2.createNS("http://www.w3.org/2000/svg", "path");
              u3.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), c3.appendChild(u3);
              const d3 = i2.createNS("http://www.w3.org/2000/svg", "g");
              d3.setAttributeNS(null, "opacity", "0.25"), d3.setAttributeNS(null, "fill", "#000000");
              const _3 = i2.createNS("http://www.w3.org/2000/svg", "path");
              _3.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d3.appendChild(_3);
              const p3 = i2.createNS("http://www.w3.org/2000/svg", "g");
              p3.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p3.setAttributeNS(null, "fill", "#FFFFFF");
              const m3 = i2.createNS("http://www.w3.org/2000/svg", "g");
              m3.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const f3 = i2.createNS("http://www.w3.org/2000/svg", "circle");
              f3.setAttributeNS(null, "fill", "#000000"), f3.setAttributeNS(null, "opacity", "0.25"), f3.setAttributeNS(null, "cx", "5.5"), f3.setAttributeNS(null, "cy", "5.5"), f3.setAttributeNS(null, "r", "5.4999962");
              const g3 = i2.createNS("http://www.w3.org/2000/svg", "circle");
              g3.setAttributeNS(null, "fill", "#FFFFFF"), g3.setAttributeNS(null, "cx", "5.5"), g3.setAttributeNS(null, "cy", "5.5"), g3.setAttributeNS(null, "r", "5.4999962"), m3.appendChild(f3), m3.appendChild(g3), n3.appendChild(l3), n3.appendChild(c3), n3.appendChild(d3), n3.appendChild(p3), n3.appendChild(m3), s3.appendChild(n3), s3.setAttributeNS(null, "height", a3 * this._scale + "px"), s3.setAttributeNS(null, "width", o3 * this._scale + "px"), this._element.appendChild(s3), this._offset = t2.P.convert(e2 && e2.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (t3) => {
              t3.preventDefault();
            }), this._element.addEventListener("mousedown", (t3) => {
              t3.preventDefault();
            }), Ia(this._element, this._anchor, "marker"), e2 && e2.className) for (const t3 of e2.className.split(" ")) this._element.classList.add(t3);
            this._popup = null;
          }
          addTo(t3) {
            return this.remove(), this._map = t3, t3.getCanvasContainer().appendChild(this._element), t3.on("move", this._update), t3.on("moveend", this._update), t3.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), i2.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e2) {
            return this._lngLat = t2.L.convert(e2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(t3) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t3) {
              if (!("offset" in t3.options)) {
                const e2 = 38.1, i3 = 13.5, s3 = Math.abs(i3) / Math.SQRT2;
                t3.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [s3, -1 * (e2 - i3 + s3)], "bottom-right": [-s3, -1 * (e2 - i3 + s3)], left: [i3, -1 * (e2 - i3)], right: [-13.5, -1 * (e2 - i3)] } : this._offset;
              }
              this._popup = t3, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const t3 = this._popup;
            return t3 ? (t3.isOpen() ? t3.remove() : t3.addTo(this._map), this) : this;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e2) {
            return this._offset = t2.P.convert(e2), this._update(), this;
          }
          addClassName(t3) {
            this._element.classList.add(t3);
          }
          removeClassName(t3) {
            this._element.classList.remove(t3);
          }
          toggleClassName(t3) {
            return this._element.classList.toggle(t3);
          }
          setDraggable(t3) {
            return this._draggable = !!t3, this._map && (t3 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(t3) {
            return this._rotation = t3 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(t3) {
            return this._rotationAlignment = t3 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(t3) {
            return this._pitchAlignment = t3 && "auto" !== t3 ? t3 : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
        }
        const Sa = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let Ca = 0, Pa = false;
        const Da = { maxWidth: 100, unit: "metric" };
        function Ma(t3, e2, i3) {
          const s3 = i3 && i3.maxWidth || 100, a3 = t3._container.clientHeight / 2, o3 = t3.unproject([0, a3]), r3 = t3.unproject([s3, a3]), n3 = o3.distanceTo(r3);
          if (i3 && "imperial" === i3.unit) {
            const i4 = 3.2808 * n3;
            i4 > 5280 ? za(e2, s3, i4 / 5280, t3._getUIString("ScaleControl.Miles")) : za(e2, s3, i4, t3._getUIString("ScaleControl.Feet"));
          } else i3 && "nautical" === i3.unit ? za(e2, s3, n3 / 1852, t3._getUIString("ScaleControl.NauticalMiles")) : n3 >= 1e3 ? za(e2, s3, n3 / 1e3, t3._getUIString("ScaleControl.Kilometers")) : za(e2, s3, n3, t3._getUIString("ScaleControl.Meters"));
        }
        function za(t3, e2, i3, s3) {
          const a3 = function(t4) {
            const e3 = Math.pow(10, `${Math.floor(t4)}`.length - 1);
            let i4 = t4 / e3;
            return i4 = i4 >= 10 ? 10 : i4 >= 5 ? 5 : i4 >= 3 ? 3 : i4 >= 2 ? 2 : i4 >= 1 ? 1 : function(t5) {
              const e4 = Math.pow(10, Math.ceil(-Math.log(t5) / Math.LN10));
              return Math.round(t5 * e4) / e4;
            }(i4), e3 * i4;
          }(i3);
          t3.style.width = e2 * (a3 / i3) + "px", t3.innerHTML = `${a3}&nbsp;${s3}`;
        }
        const La = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, Aa = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function Ra(e2) {
          if (e2) {
            if ("number" == typeof e2) {
              const i3 = Math.round(Math.abs(e2) / Math.SQRT2);
              return { center: new t2.P(0, 0), top: new t2.P(0, e2), "top-left": new t2.P(i3, i3), "top-right": new t2.P(-i3, i3), bottom: new t2.P(0, -e2), "bottom-left": new t2.P(i3, -i3), "bottom-right": new t2.P(-i3, -i3), left: new t2.P(e2, 0), right: new t2.P(-e2, 0) };
            }
            if (e2 instanceof t2.P || Array.isArray(e2)) {
              const i3 = t2.P.convert(e2);
              return { center: i3, top: i3, "top-left": i3, "top-right": i3, bottom: i3, "bottom-left": i3, "bottom-right": i3, left: i3, right: i3 };
            }
            return { center: t2.P.convert(e2.center || [0, 0]), top: t2.P.convert(e2.top || [0, 0]), "top-left": t2.P.convert(e2["top-left"] || [0, 0]), "top-right": t2.P.convert(e2["top-right"] || [0, 0]), bottom: t2.P.convert(e2.bottom || [0, 0]), "bottom-left": t2.P.convert(e2["bottom-left"] || [0, 0]), "bottom-right": t2.P.convert(e2["bottom-right"] || [0, 0]), left: t2.P.convert(e2.left || [0, 0]), right: t2.P.convert(e2.right || [0, 0]) };
          }
          return Ra(new t2.P(0, 0));
        }
        const ka = { extend: (e2, ...i3) => t2.e(e2, ...i3), run(t3) {
          t3();
        }, logToElement(t3, e2 = false, i3 = "log") {
          const s3 = window.document.getElementById(i3);
          s3 && (e2 && (s3.innerHTML = ""), s3.innerHTML += `<br>${t3}`);
        } }, Fa = e;
        class Ba {
          static get version() {
            return Fa;
          }
          static get workerCount() {
            return tt.workerCount;
          }
          static set workerCount(t3) {
            tt.workerCount = t3;
          }
          static get maxParallelImageRequests() {
            return t2.c.MAX_PARALLEL_IMAGE_REQUESTS;
          }
          static set maxParallelImageRequests(e2) {
            t2.c.MAX_PARALLEL_IMAGE_REQUESTS = e2;
          }
          static get workerUrl() {
            return t2.c.WORKER_URL;
          }
          static set workerUrl(e2) {
            t2.c.WORKER_URL = e2;
          }
          static addProtocol(e2, i3) {
            t2.c.REGISTERED_PROTOCOLS[e2] = i3;
          }
          static removeProtocol(e2) {
            delete t2.c.REGISTERED_PROTOCOLS[e2];
          }
        }
        return Ba.Map = class extends oa {
          constructor(e2) {
            if (t2.bg.mark(t2.bh.create), null != (e2 = t2.e({}, ga, e2)).minZoom && null != e2.maxZoom && e2.minZoom > e2.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != e2.minPitch && null != e2.maxPitch && e2.minPitch > e2.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != e2.minPitch && e2.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (null != e2.maxPitch && e2.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (super(new rs(e2.minZoom, e2.maxZoom, e2.minPitch, e2.maxPitch, e2.renderWorldCopies), { bearingSnap: e2.bearingSnap }), this._cooperativeGesturesOnWheel = (t3) => {
              this._onCooperativeGesture(t3, t3[this._metaKey], 1);
            }, this._contextLost = (e3) => {
              e3.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t2.k("webglcontextlost", { originalEvent: e3 }));
            }, this._contextRestored = (e3) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new t2.k("webglcontextrestored", { originalEvent: e3 }));
            }, this._onMapScroll = (t3) => {
              if (t3.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = e2.interactive, this._cooperativeGestures = e2.cooperativeGestures, this._metaKey = 0 === navigator.platform.indexOf("Mac") ? "metaKey" : "ctrlKey", this._maxTileCacheSize = e2.maxTileCacheSize, this._maxTileCacheZoomLevels = e2.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = e2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e2.preserveDrawingBuffer, this._antialias = e2.antialias, this._trackResize = e2.trackResize, this._bearingSnap = e2.bearingSnap, this._refreshExpiredTiles = e2.refreshExpiredTiles, this._fadeDuration = e2.fadeDuration, this._crossSourceCollisions = e2.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e2.collectResourceTiming, this._renderTaskQueue = new la(), this._controls = [], this._mapId = t2.a2(), this._locale = t2.e({}, ha, e2.locale), this._clickTolerance = e2.clickTolerance, this._overridePixelRatio = e2.pixelRatio, this._maxCanvasSize = e2.maxCanvasSize, this.transformCameraUpdate = e2.transformCameraUpdate, this._imageQueueHandle = h2.addThrottleControl(() => this.isMoving()), this._requestManager = new u2(e2.transformRequest), "string" == typeof e2.container) {
              if (this._container = document.getElementById(e2.container), !this._container) throw new Error(`Container '${e2.container}' not found.`);
            } else {
              if (!(e2.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = e2.container;
            }
            if (e2.maxBounds && this.setMaxBounds(e2.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
              this.painter.terrainFacilitator.dirty = true, this._update(true);
            }), this.once("idle", () => {
              this._idleTriggered = true;
            }), "undefined" != typeof window) {
              addEventListener("online", this._onWindowOnline, false);
              let t3 = false;
              const e3 = ns((t4) => {
                this._trackResize && !this._removed && this.resize(t4)._update();
              }, 50);
              this._resizeObserver = new ResizeObserver((i3) => {
                t3 ? e3(i3) : t3 = true;
              }), this._resizeObserver.observe(this._container);
            }
            this.handlers = new aa(this, e2), this._cooperativeGestures && this._setupCooperativeGestures(), this._hash = e2.hash && new ls("string" == typeof e2.hash && e2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e2.center, zoom: e2.zoom, bearing: e2.bearing, pitch: e2.pitch }), e2.bounds && (this.resize(), this.fitBounds(e2.bounds, t2.e({}, e2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e2.localIdeographFontFamily, this._validateStyle = e2.validateStyle, e2.style && this.setStyle(e2.style, { localIdeographFontFamily: e2.localIdeographFontFamily }), e2.attributionControl && this.addControl(new ra({ customAttribution: e2.customAttribution })), e2.maplibreLogo && this.addControl(new na(), e2.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet);
            }), this.on("data", (e3) => {
              this._update("style" === e3.dataType), this.fire(new t2.k(`${e3.dataType}data`, e3));
            }), this.on("dataloading", (e3) => {
              this.fire(new t2.k(`${e3.dataType}dataloading`, e3));
            }), this.on("dataabort", (e3) => {
              this.fire(new t2.k("sourcedataabort", e3));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(e2, i3) {
            if (void 0 === i3 && (i3 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd) return this.fire(new t2.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const s3 = e2.onAdd(this);
            this._controls.push(e2);
            const a3 = this._controlPositions[i3];
            return -1 !== i3.indexOf("bottom") ? a3.insertBefore(s3, a3.firstChild) : a3.appendChild(s3), this;
          }
          removeControl(e2) {
            if (!e2 || !e2.onRemove) return this.fire(new t2.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i3 = this._controls.indexOf(e2);
            return i3 > -1 && this._controls.splice(i3, 1), e2.onRemove(this), this;
          }
          hasControl(t3) {
            return this._controls.indexOf(t3) > -1;
          }
          calculateCameraOptionsFromTo(t3, e2, i3, s3) {
            return null == s3 && this.terrain && (s3 = this.terrain.getElevationForLngLatZoom(i3, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(t3, e2, i3, s3);
          }
          resize(e2) {
            var i3;
            const s3 = this._containerDimensions(), a3 = s3[0], o3 = s3[1], r3 = this._getClampedPixelRatio(a3, o3);
            if (this._resizeCanvas(a3, o3, r3), this.painter.resize(a3, o3, r3), this.painter.overLimit()) {
              const t3 = this.painter.context.gl;
              this._maxCanvasSize = [t3.drawingBufferWidth, t3.drawingBufferHeight];
              const e3 = this._getClampedPixelRatio(a3, o3);
              this._resizeCanvas(a3, o3, e3), this.painter.resize(a3, o3, e3);
            }
            this.transform.resize(a3, o3), null === (i3 = this._requestedCameraState) || void 0 === i3 || i3.resize(a3, o3);
            const n3 = !this._moving;
            return n3 && (this.stop(), this.fire(new t2.k("movestart", e2)).fire(new t2.k("move", e2))), this.fire(new t2.k("resize", e2)), n3 && this.fire(new t2.k("moveend", e2)), this;
          }
          _getClampedPixelRatio(t3, e2) {
            const { 0: i3, 1: s3 } = this._maxCanvasSize, a3 = this.getPixelRatio(), o3 = t3 * a3, r3 = e2 * a3;
            return Math.min(o3 > i3 ? i3 / o3 : 1, r3 > s3 ? s3 / r3 : 1) * a3;
          }
          getPixelRatio() {
            var t3;
            return null !== (t3 = this._overridePixelRatio) && void 0 !== t3 ? t3 : devicePixelRatio;
          }
          setPixelRatio(t3) {
            this._overridePixelRatio = t3, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(t3) {
            return this.transform.setMaxBounds(L2.convert(t3)), this._update();
          }
          setMinZoom(t3) {
            if ((t3 = null == t3 ? -2 : t3) >= -2 && t3 <= this.transform.maxZoom) return this.transform.minZoom = t3, this._update(), this.getZoom() < t3 && this.setZoom(t3), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t3) {
            if ((t3 = null == t3 ? 22 : t3) >= this.transform.minZoom) return this.transform.maxZoom = t3, this._update(), this.getZoom() > t3 && this.setZoom(t3), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t3) {
            if ((t3 = null == t3 ? 0 : t3) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (t3 >= 0 && t3 <= this.transform.maxPitch) return this.transform.minPitch = t3, this._update(), this.getPitch() < t3 && this.setPitch(t3), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t3) {
            if ((t3 = null == t3 ? 60 : t3) > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (t3 >= this.transform.minPitch) return this.transform.maxPitch = t3, this._update(), this.getPitch() > t3 && this.setPitch(t3), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(t3) {
            return this.transform.renderWorldCopies = t3, this._update();
          }
          getCooperativeGestures() {
            return this._cooperativeGestures;
          }
          setCooperativeGestures(t3) {
            return this._cooperativeGestures = t3, this._cooperativeGestures ? this._setupCooperativeGestures() : this._destroyCooperativeGestures(), this;
          }
          project(e2) {
            return this.transform.locationPoint(t2.L.convert(e2), this.style && this.terrain);
          }
          unproject(e2) {
            return this.transform.pointLocation(t2.P.convert(e2), this.terrain);
          }
          isMoving() {
            var t3;
            return this._moving || (null === (t3 = this.handlers) || void 0 === t3 ? void 0 : t3.isMoving());
          }
          isZooming() {
            var t3;
            return this._zooming || (null === (t3 = this.handlers) || void 0 === t3 ? void 0 : t3.isZooming());
          }
          isRotating() {
            var t3;
            return this._rotating || (null === (t3 = this.handlers) || void 0 === t3 ? void 0 : t3.isRotating());
          }
          _createDelegatedListener(t3, e2, i3) {
            if ("mouseenter" === t3 || "mouseover" === t3) {
              let s3 = false;
              const a3 = (a4) => {
                const o3 = this.getLayer(e2) ? this.queryRenderedFeatures(a4.point, { layers: [e2] }) : [];
                o3.length ? s3 || (s3 = true, i3.call(this, new gs(t3, this, a4.originalEvent, { features: o3 }))) : s3 = false;
              };
              return { layer: e2, listener: i3, delegates: { mousemove: a3, mouseout: () => {
                s3 = false;
              } } };
            }
            if ("mouseleave" === t3 || "mouseout" === t3) {
              let s3 = false;
              const a3 = (a4) => {
                (this.getLayer(e2) ? this.queryRenderedFeatures(a4.point, { layers: [e2] }) : []).length ? s3 = true : s3 && (s3 = false, i3.call(this, new gs(t3, this, a4.originalEvent)));
              }, o3 = (e3) => {
                s3 && (s3 = false, i3.call(this, new gs(t3, this, e3.originalEvent)));
              };
              return { layer: e2, listener: i3, delegates: { mousemove: a3, mouseout: o3 } };
            }
            {
              const s3 = (t4) => {
                const s4 = this.getLayer(e2) ? this.queryRenderedFeatures(t4.point, { layers: [e2] }) : [];
                s4.length && (t4.features = s4, i3.call(this, t4), delete t4.features);
              };
              return { layer: e2, listener: i3, delegates: { [t3]: s3 } };
            }
          }
          on(t3, e2, i3) {
            if (void 0 === i3) return super.on(t3, e2);
            const s3 = this._createDelegatedListener(t3, e2, i3);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t3] = this._delegatedListeners[t3] || [], this._delegatedListeners[t3].push(s3);
            for (const t4 in s3.delegates) this.on(t4, s3.delegates[t4]);
            return this;
          }
          once(t3, e2, i3) {
            if (void 0 === i3) return super.once(t3, e2);
            const s3 = this._createDelegatedListener(t3, e2, i3);
            for (const t4 in s3.delegates) this.once(t4, s3.delegates[t4]);
            return this;
          }
          off(t3, e2, i3) {
            return void 0 === i3 ? super.off(t3, e2) : (this._delegatedListeners && this._delegatedListeners[t3] && ((s3) => {
              const a3 = this._delegatedListeners[t3];
              for (let t4 = 0; t4 < a3.length; t4++) {
                const s4 = a3[t4];
                if (s4.layer === e2 && s4.listener === i3) {
                  for (const t5 in s4.delegates) this.off(t5, s4.delegates[t5]);
                  return a3.splice(t4, 1), this;
                }
              }
            })(), this);
          }
          queryRenderedFeatures(e2, i3) {
            if (!this.style) return [];
            let s3;
            const a3 = e2 instanceof t2.P || Array.isArray(e2), o3 = a3 ? e2 : [[0, 0], [this.transform.width, this.transform.height]];
            if (i3 = i3 || (a3 ? {} : e2) || {}, o3 instanceof t2.P || "number" == typeof o3[0]) s3 = [t2.P.convert(o3)];
            else {
              const e3 = t2.P.convert(o3[0]), i4 = t2.P.convert(o3[1]);
              s3 = [e3, new t2.P(i4.x, e3.y), i4, new t2.P(e3.x, i4.y), e3];
            }
            return this.style.queryRenderedFeatures(s3, i3, this.transform);
          }
          querySourceFeatures(t3, e2) {
            return this.style.querySourceFeatures(t3, e2);
          }
          setStyle(e2, i3) {
            return false !== (i3 = t2.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i3)).diff && i3.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e2 ? (this._diffStyle(e2, i3), this) : (this._localIdeographFontFamily = i3.localIdeographFontFamily, this._updateStyle(e2, i3));
          }
          setTransformRequest(t3) {
            return this._requestManager.setTransformRequest(t3), this;
          }
          _getUIString(t3) {
            const e2 = this._locale[t3];
            if (null == e2) throw new Error(`Missing UI string '${t3}'`);
            return e2;
          }
          _updateStyle(t3, e2) {
            if (e2.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(t3, e2));
            const i3 = this.style && e2.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!t3)), t3 ? (this.style = new se2(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t3 ? this.style.loadURL(t3, e2, i3) : this.style.loadJSON(t3, e2, i3), this) : (delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new se2(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(e2, i3) {
            if ("string" == typeof e2) {
              const s3 = this._requestManager.transformRequest(e2, c2.Style);
              t2.f(s3, (e3, s4) => {
                e3 ? this.fire(new t2.j(e3)) : s4 && this._updateDiff(s4, i3);
              });
            } else "object" == typeof e2 && this._updateDiff(e2, i3);
          }
          _updateDiff(e2, i3) {
            try {
              this.style.setState(e2, i3) && this._update(true);
            } catch (s3) {
              t2.w(`Unable to perform style diff: ${s3.message || s3.error || s3}.  Rebuilding the style from scratch.`), this._updateStyle(e2, i3);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : t2.w("There is no style added to the map.");
          }
          addSource(t3, e2) {
            return this._lazyInitEmptyStyle(), this.style.addSource(t3, e2), this._update(true);
          }
          isSourceLoaded(e2) {
            const i3 = this.style && this.style.sourceCaches[e2];
            if (void 0 !== i3) return i3.loaded();
            this.fire(new t2.j(new Error(`There is no source with ID '${e2}'`)));
          }
          setTerrain(e2) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e2) {
              const i3 = this.style.sourceCaches[e2.source];
              if (!i3) throw new Error(`cannot load terrain, because there exists no source with ID: ${e2.source}`);
              for (const i4 in this.style._layers) {
                const s3 = this.style._layers[i4];
                "hillshade" === s3.type && s3.source === e2.source && t2.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new da(this.painter, i3, e2), this.painter.renderToTexture = new ma(this.painter, this.terrain), this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (t3) => {
                "style" === t3.dataType ? this.terrain.sourceCache.freeRtt() : "source" === t3.dataType && t3.tile && (t3.sourceId !== e2.source || this._elevationFreeze || (this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(t3.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform._minEleveationForCurrentTile = 0, this.transform.elevation = 0;
            return this.fire(new t2.k("terrain", { terrain: e2 })), this;
          }
          getTerrain() {
            var t3, e2;
            return null !== (e2 = null === (t3 = this.terrain) || void 0 === t3 ? void 0 : t3.options) && void 0 !== e2 ? e2 : null;
          }
          areTilesLoaded() {
            const t3 = this.style && this.style.sourceCaches;
            for (const e2 in t3) {
              const i3 = t3[e2]._tiles;
              for (const t4 in i3) {
                const e3 = i3[t4];
                if ("loaded" !== e3.state && "errored" !== e3.state) return false;
              }
            }
            return true;
          }
          addSourceType(t3, e2, i3) {
            return this._lazyInitEmptyStyle(), this.style.addSourceType(t3, e2, i3);
          }
          removeSource(t3) {
            return this.style.removeSource(t3), this._update(true);
          }
          getSource(t3) {
            return this.style.getSource(t3);
          }
          addImage(e2, i3, s3 = {}) {
            const { pixelRatio: a3 = 1, sdf: o3 = false, stretchX: r3, stretchY: n3, content: l3 } = s3;
            if (this._lazyInitEmptyStyle(), !(i3 instanceof HTMLImageElement || t2.a(i3))) {
              if (void 0 === i3.width || void 0 === i3.height) return this.fire(new t2.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: s4, height: h3, data: c3 } = i3, u3 = i3;
                return this.style.addImage(e2, { data: new t2.R({ width: s4, height: h3 }, new Uint8Array(c3)), pixelRatio: a3, stretchX: r3, stretchY: n3, content: l3, sdf: o3, version: 0, userImage: u3 }), u3.onAdd && u3.onAdd(this, e2), this;
              }
            }
            {
              const { width: s4, height: h3, data: c3 } = t2.h.getImageData(i3);
              this.style.addImage(e2, { data: new t2.R({ width: s4, height: h3 }, c3), pixelRatio: a3, stretchX: r3, stretchY: n3, content: l3, sdf: o3, version: 0 });
            }
          }
          updateImage(e2, i3) {
            const s3 = this.style.getImage(e2);
            if (!s3) return this.fire(new t2.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const a3 = i3 instanceof HTMLImageElement || t2.a(i3) ? t2.h.getImageData(i3) : i3, { width: o3, height: r3, data: n3 } = a3;
            if (void 0 === o3 || void 0 === r3) return this.fire(new t2.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (o3 !== s3.data.width || r3 !== s3.data.height) return this.fire(new t2.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const l3 = !(i3 instanceof HTMLImageElement || t2.a(i3));
            return s3.data.replace(n3, l3), this.style.updateImage(e2, s3), this;
          }
          getImage(t3) {
            return this.style.getImage(t3);
          }
          hasImage(e2) {
            return e2 ? !!this.style.getImage(e2) : (this.fire(new t2.j(new Error("Missing required image id"))), false);
          }
          removeImage(t3) {
            this.style.removeImage(t3);
          }
          loadImage(t3, e2) {
            h2.getImage(this._requestManager.transformRequest(t3, c2.Image), e2);
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(t3, e2) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(t3, e2), this._update(true);
          }
          moveLayer(t3, e2) {
            return this.style.moveLayer(t3, e2), this._update(true);
          }
          removeLayer(t3) {
            return this.style.removeLayer(t3), this._update(true);
          }
          getLayer(t3) {
            return this.style.getLayer(t3);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(t3, e2, i3) {
            return this.style.setLayerZoomRange(t3, e2, i3), this._update(true);
          }
          setFilter(t3, e2, i3 = {}) {
            return this.style.setFilter(t3, e2, i3), this._update(true);
          }
          getFilter(t3) {
            return this.style.getFilter(t3);
          }
          setPaintProperty(t3, e2, i3, s3 = {}) {
            return this.style.setPaintProperty(t3, e2, i3, s3), this._update(true);
          }
          getPaintProperty(t3, e2) {
            return this.style.getPaintProperty(t3, e2);
          }
          setLayoutProperty(t3, e2, i3, s3 = {}) {
            return this.style.setLayoutProperty(t3, e2, i3, s3), this._update(true);
          }
          getLayoutProperty(t3, e2) {
            return this.style.getLayoutProperty(t3, e2);
          }
          setGlyphs(t3, e2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(t3, e2), this._update(true);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(t3, e2, i3 = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(t3, e2, i3, (t4) => {
              t4 || this._update(true);
            }), this;
          }
          removeSprite(t3) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(t3), this._update(true);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(t3, e2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(t3, e2, (t4) => {
              t4 || this._update(true);
            }), this;
          }
          setLight(t3, e2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(t3, e2), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setFeatureState(t3, e2) {
            return this.style.setFeatureState(t3, e2), this._update();
          }
          removeFeatureState(t3, e2) {
            return this.style.removeFeatureState(t3, e2), this._update();
          }
          getFeatureState(t3) {
            return this.style.getFeatureState(t3);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let t3 = 0, e2 = 0;
            return this._container && (t3 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t3, e2];
          }
          _setupContainer() {
            const t3 = this._container;
            t3.classList.add("maplibregl-map");
            const e2 = this._canvasContainer = i2.create("div", "maplibregl-canvas-container", t3);
            this._interactive && e2.classList.add("maplibregl-interactive"), this._canvas = i2.create("canvas", "maplibregl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
            const s3 = this._containerDimensions(), a3 = this._getClampedPixelRatio(s3[0], s3[1]);
            this._resizeCanvas(s3[0], s3[1], a3);
            const o3 = this._controlContainer = i2.create("div", "maplibregl-control-container", t3), r3 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t4) => {
              r3[t4] = i2.create("div", `maplibregl-ctrl-${t4} `, o3);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _setupCooperativeGestures() {
            this._cooperativeGesturesScreen = i2.create("div", "maplibregl-cooperative-gesture-screen", this._container);
            let t3 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.windowsHelpText ? this._cooperativeGestures.windowsHelpText : "Use Ctrl + scroll to zoom the map";
            0 === navigator.platform.indexOf("Mac") && (t3 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.macHelpText ? this._cooperativeGestures.macHelpText : "Use ⌘ + scroll to zoom the map"), this._cooperativeGesturesScreen.innerHTML = `
            <div class="maplibregl-desktop-message">${t3}</div>
            <div class="maplibregl-mobile-message">${"boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.mobileHelpText ? this._cooperativeGestures.mobileHelpText : "Use two fingers to move the map"}</div>
        `, this._cooperativeGesturesScreen.setAttribute("aria-hidden", "true"), this._canvasContainer.addEventListener("wheel", this._cooperativeGesturesOnWheel, false), this._canvasContainer.classList.add("maplibregl-cooperative-gestures");
          }
          _destroyCooperativeGestures() {
            i2.remove(this._cooperativeGesturesScreen), this._canvasContainer.removeEventListener("wheel", this._cooperativeGesturesOnWheel, false), this._canvasContainer.classList.remove("maplibregl-cooperative-gestures");
          }
          _resizeCanvas(t3, e2, i3) {
            this._canvas.width = Math.floor(i3 * t3), this._canvas.height = Math.floor(i3 * e2), this._canvas.style.width = `${t3}px`, this._canvas.style.height = `${e2}px`;
          }
          _setupPainter() {
            const t3 = { alpha: true, stencil: true, depth: true, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false };
            let e2 = null;
            this._canvas.addEventListener("webglcontextcreationerror", (i4) => {
              e2 = { requestedAttributes: t3 }, i4 && (e2.statusMessage = i4.statusMessage, e2.type = i4.type);
            }, { once: true });
            const i3 = this._canvas.getContext("webgl2", t3) || this._canvas.getContext("webgl", t3);
            if (!i3) {
              const t4 = "Failed to initialize WebGL";
              throw e2 ? (e2.message = t4, new Error(JSON.stringify(e2))) : new Error(t4);
            }
            this.painter = new is(i3, this.transform), s2.testSupport(i3);
          }
          _onCooperativeGesture(t3, e2, i3) {
            return !e2 && i3 < 2 && (this._cooperativeGesturesScreen.classList.add("maplibregl-show"), setTimeout(() => {
              this._cooperativeGesturesScreen.classList.remove("maplibregl-show");
            }, 100)), false;
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(t3) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || t3, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(t3) {
            return this._update(), this._renderTaskQueue.add(t3);
          }
          _cancelRenderFrame(t3) {
            this._renderTaskQueue.remove(t3);
          }
          _render(e2) {
            const i3 = this._idleTriggered ? this._fadeDuration : 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e2), this._removed) return;
            let s3 = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const e3 = this.transform.zoom, a4 = t2.h.now();
              this.style.zoomHistory.update(e3, a4);
              const o3 = new t2.a8(e3, { now: a4, fadeDuration: i3, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), r3 = o3.crossFadingFactor();
              1 === r3 && r3 === this._crossFadingFactor || (s3 = true, this._crossFadingFactor = r3), this.style.update(o3);
            }
            this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform._minEleveationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, i3, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: i3, showPadding: this.showPadding }), this.fire(new t2.k("render")), this.loaded() && !this._loaded && (this._loaded = true, t2.bg.mark(t2.bh.load), this.fire(new t2.k("load"))), this.style && (this.style.hasTransitions() || s3) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const a3 = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return a3 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t2.k("idle")), !this._loaded || this._fullyLoaded || a3 || (this._fullyLoaded = true, t2.bg.mark(t2.bh.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;
          }
          remove() {
            var e2;
            this._hash && this._hash.remove();
            for (const t3 of this._controls) t3.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, false), h2.removeThrottleControl(this._imageQueueHandle), null === (e2 = this._resizeObserver) || void 0 === e2 || e2.disconnect();
            const s3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            s3 && s3.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), i2.remove(this._canvasContainer), i2.remove(this._controlContainer), this._cooperativeGestures && this._destroyCooperativeGestures(), this._container.classList.remove("maplibregl-map"), t2.bg.clearMetrics(), this._removed = true, this.fire(new t2.k("remove"));
          }
          triggerRepaint() {
            this.style && !this._frame && (this._frame = t2.h.frame((e2) => {
              t2.bg.frame(e2), this._frame = null, this._render(e2);
            }));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(t3) {
            this._showTileBoundaries !== t3 && (this._showTileBoundaries = t3, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(t3) {
            this._showPadding !== t3 && (this._showPadding = t3, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(t3) {
            this._showCollisionBoxes !== t3 && (this._showCollisionBoxes = t3, t3 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(t3) {
            this._showOverdrawInspector !== t3 && (this._showOverdrawInspector = t3, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(t3) {
            this._repaint !== t3 && (this._repaint = t3, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(t3) {
            this._vertices = t3, this._update();
          }
          get version() {
            return fa;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
        }, Ba.NavigationControl = class {
          constructor(e2) {
            this._updateZoomButtons = () => {
              const t3 = this._map.getZoom(), e3 = t3 === this._map.getMaxZoom(), i3 = t3 === this._map.getMinZoom();
              this._zoomInButton.disabled = e3, this._zoomOutButton.disabled = i3, this._zoomInButton.setAttribute("aria-disabled", e3.toString()), this._zoomOutButton.setAttribute("aria-disabled", i3.toString());
            }, this._rotateCompassArrow = () => {
              const t3 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
              this._compassIcon.style.transform = t3;
            }, this._setButtonTitle = (t3, e3) => {
              const i3 = this._map._getUIString(`NavigationControl.${e3}`);
              t3.title = i3, t3.setAttribute("aria-label", i3);
            }, this.options = t2.e({}, xa, e2), this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t3) => this._map.zoomIn({}, { originalEvent: t3 })), i2.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t3) => this._map.zoomOut({}, { originalEvent: t3 })), i2.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t3) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t3 }) : this._map.resetNorth({}, { originalEvent: t3 });
            }), this._compassIcon = i2.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(t3) {
            return this._map = t3, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ya(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            i2.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(t3, e2) {
            const s3 = i2.create("button", t3, this._container);
            return s3.type = "button", s3.addEventListener("click", e2), s3;
          }
        }, Ba.GeolocateControl = class extends t2.E {
          constructor(e2) {
            super(), this._onSuccess = (e3) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e3)) return this._setErrorState(), this.fire(new t2.k("outofmaxbounds", e3)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e3, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t2.k("geolocate", e3)), this._finish();
              }
            }, this._updateCamera = (e3) => {
              const i3 = new t2.L(e3.coords.longitude, e3.coords.latitude), s3 = e3.coords.accuracy, a3 = this._map.getBearing(), o3 = t2.e({ bearing: a3 }, this.options.fitBoundsOptions), r3 = L2.fromLngLat(i3, s3);
              this._map.fitBounds(r3, o3, { geolocateSource: true });
            }, this._updateMarker = (e3) => {
              if (e3) {
                const i3 = new t2.L(e3.coords.longitude, e3.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i3).addTo(this._map), this._userLocationDotMarker.setLngLat(i3).addTo(this._map), this._accuracy = e3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, this._onError = (e3) => {
              if (this._map) {
                if (this.options.trackUserLocation) if (1 === e3.code) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = t3, this._geolocateButton.setAttribute("aria-label", t3), void 0 !== this._geolocationWatchID && this._clearWatch();
                } else {
                  if (3 === e3.code && Pa) return;
                  this._setErrorState();
                }
                "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t2.k("error", e3)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = (e3) => {
              if (this._map) {
                if (this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this._geolocateButton = i2.create("button", "maplibregl-ctrl-geolocate", this._container), i2.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === e3) {
                  t2.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4);
                } else {
                  const t3 = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.title = t3, this._geolocateButton.setAttribute("aria-label", t3);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = i2.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Ea({ element: this._dotElement }), this._circleElement = i2.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ea({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e4) => {
                  e4.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e4.originalEvent && "resize" === e4.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t2.k("trackuserlocationend")));
                });
              }
            }, this.options = t2.e({}, Sa, e2);
          }
          onAdd(t3) {
            return this._map = t3, this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), function(t4, e2 = false) {
              void 0 === ba || e2 ? void 0 !== window.navigator.permissions ? window.navigator.permissions.query({ name: "geolocation" }).then((e3) => {
                ba = "denied" !== e3.state, t4(ba);
              }).catch(() => {
                ba = !!window.navigator.geolocation, t4(ba);
              }) : (ba = !!window.navigator.geolocation, t4(ba)) : t4(ba);
            }(this._setupUI), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), i2.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ca = 0, Pa = false;
          }
          _isOutOfMapMaxBounds(t3) {
            const e2 = this._map.getMaxBounds(), i3 = t3.coords;
            return e2 && (i3.longitude < e2.getWest() || i3.longitude > e2.getEast() || i3.latitude < e2.getSouth() || i3.latitude > e2.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadius() {
            const t3 = this._map.getBounds(), e2 = t3.getSouthEast(), i3 = t3.getNorthEast(), s3 = e2.distanceTo(i3), a3 = Math.ceil(this._accuracy / (s3 / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${a3}px`, this._circleElement.style.height = `${a3}px`;
          }
          trigger() {
            if (!this._setup) return t2.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new t2.k("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Ca--, Pa = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t2.k("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t2.k("trackuserlocationstart"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let t3;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ca++, Ca > 1 ? (t3 = { maximumAge: 6e5, timeout: 0 }, Pa = true) : (t3 = this.options.positionOptions, Pa = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t3);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, Ba.AttributionControl = ra, Ba.LogoControl = na, Ba.ScaleControl = class {
          constructor(e2) {
            this._onMove = () => {
              Ma(this._map, this._container, this.options);
            }, this.setUnit = (t3) => {
              this.options.unit = t3, Ma(this._map, this._container, this.options);
            }, this.options = t2.e({}, Da, e2);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t3) {
            return this._map = t3, this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", t3.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            i2.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, Ba.FullscreenControl = class extends t2.E {
          constructor(e2 = {}) {
            super(), this._onFullscreenChange = () => {
              (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = false, e2 && e2.container && (e2.container instanceof HTMLElement ? this._container = e2.container : t2.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(t3) {
            return this._map = t3, this._container || (this._container = this._map.getContainer()), this._controlContainer = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            i2.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const t3 = this._fullscreenButton = i2.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            i2.create("span", "maplibregl-ctrl-icon", t3).setAttribute("aria-hidden", "true"), t3.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const t3 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", t3), this._fullscreenButton.title = t3;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t2.k("fullscreenstart")), this._map._cooperativeGestures && (this._prevCooperativeGestures = this._map._cooperativeGestures, this._map.setCooperativeGestures())) : (this.fire(new t2.k("fullscreenend")), this._prevCooperativeGestures && (this._map.setCooperativeGestures(this._prevCooperativeGestures), delete this._prevCooperativeGestures));
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, Ba.TerrainControl = class {
          constructor(t3) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.disableTerrain")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.enableTerrain"));
            }, this.options = t3;
          }
          onAdd(t3) {
            return this._map = t3, this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = i2.create("button", "maplibregl-ctrl-terrain", this._container), i2.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            i2.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, Ba.Popup = class extends t2.E {
          constructor(e2) {
            super(), this.remove = () => (this._content && i2.remove(this._content), this._container && (i2.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t2.k("close")), this), this._onMouseUp = (t3) => {
              this._update(t3.point);
            }, this._onMouseMove = (t3) => {
              this._update(t3.point);
            }, this._onDrag = (t3) => {
              this._update(t3.point);
            }, this._update = (t3) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = i2.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = i2.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const t4 of this.options.className.split(" ")) this._container.classList.add(t4);
                this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = wa(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !t3) return;
              const e3 = this._pos = this._trackPointer && t3 ? t3 : this._map.project(this._lngLat);
              let s3 = this.options.anchor;
              const a3 = Ra(this.options.offset);
              if (!s3) {
                const t4 = this._container.offsetWidth, i3 = this._container.offsetHeight;
                let o4;
                o4 = e3.y + a3.bottom.y < i3 ? ["top"] : e3.y > this._map.transform.height - i3 ? ["bottom"] : [], e3.x < t4 / 2 ? o4.push("left") : e3.x > this._map.transform.width - t4 / 2 && o4.push("right"), s3 = 0 === o4.length ? "bottom" : o4.join("-");
              }
              const o3 = e3.add(a3[s3]).round();
              i2.setTransform(this._container, `${Ta[s3]} translate(${o3.x}px,${o3.y}px)`), Ia(this._container, s3, "popup");
            }, this._onClose = () => {
              this.remove();
            }, this.options = t2.e(Object.create(La), e2);
          }
          addTo(e2) {
            return this._map && this.remove(), this._map = e2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t2.k("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e2) {
            return this._lngLat = t2.L.convert(e2), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(t3) {
            return this.setDOMContent(document.createTextNode(t3));
          }
          setHTML(t3) {
            const e2 = document.createDocumentFragment(), i3 = document.createElement("body");
            let s3;
            for (i3.innerHTML = t3; s3 = i3.firstChild, s3; ) e2.appendChild(s3);
            return this.setDOMContent(e2);
          }
          getMaxWidth() {
            var t3;
            return null === (t3 = this._container) || void 0 === t3 ? void 0 : t3.style.maxWidth;
          }
          setMaxWidth(t3) {
            return this.options.maxWidth = t3, this._update(), this;
          }
          setDOMContent(t3) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = i2.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(t3), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(t3) {
            this._container && this._container.classList.add(t3);
          }
          removeClassName(t3) {
            this._container && this._container.classList.remove(t3);
          }
          setOffset(t3) {
            return this.options.offset = t3, this._update(), this;
          }
          toggleClassName(t3) {
            if (this._container) return this._container.classList.toggle(t3);
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = i2.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const t3 = this._container.querySelector(Aa);
            t3 && t3.focus();
          }
        }, Ba.Marker = Ea, Ba.Style = se2, Ba.LngLat = t2.L, Ba.LngLatBounds = L2, Ba.Point = t2.P, Ba.MercatorCoordinate = t2.U, Ba.Evented = t2.E, Ba.AJAXError = t2.bi, Ba.config = t2.c, Ba.CanvasSource = Z2, Ba.GeoJSONSource = B2, Ba.ImageSource = N2, Ba.RasterDEMTileSource = F2, Ba.RasterTileSource = k2, Ba.VectorTileSource = R2, Ba.VideoSource = U2, Ba.setRTLTextPlugin = t2.bj, Ba.getRTLTextPluginStatus = t2.bk, Ba.prewarm = function() {
          st().acquire(J2);
        }, Ba.clearPrewarmedResources = function() {
          const t3 = it;
          t3 && (t3.isPreloaded() && 1 === t3.numActive() ? (t3.release(J2), it = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, ka.extend(Ba, { isSafari: t2.ac, getPerformanceMetrics: t2.bg.getPerformanceMetrics }), Ba;
      });
      var maplibregl$1 = maplibregl;
      return maplibregl$1;
    });
  })(maplibreGl$1);
  return maplibreGl$1.exports;
}
var maplibreGlExports = requireMaplibreGl();
class LogicalLayerDefaultRenderer {
  constructor() {
    __publicField(this, "errorSetter", (e) => {
      console.warn(
        "Hook for renderer errors not installed. You must add it in logical layer by setErrorState method"
      );
    });
    /** Call it in renderer */
    __publicField(this, "onError", (e) => {
      if (e instanceof Error) {
        this.errorSetter(e);
      } else if (typeof e === "string") {
        this.errorSetter(new Error(e));
      } else {
        this.errorSetter(new Error("unknown"));
      }
    });
  }
  /** Call it in logical layer atom */
  setErrorState(cb) {
    this.errorSetter = cb;
  }
  setupExtension(atom2) {
    return;
  }
  willInit(args) {
    return;
  }
  willMount(args) {
    return;
  }
  willUnMount(args) {
    return;
  }
  willHide(args) {
    return;
  }
  willUnhide(args) {
    return;
  }
  willLegendUpdate(args) {
    return;
  }
  willSourceUpdate(args) {
    return;
  }
  willDestroy(args) {
    return;
  }
}
const LAYER_BIVARIATE_PREFIX = "bivariate-layer-";
const SOURCE_BIVARIATE_PREFIX = "bivariate-source-";
const categoriesSettings = {
  overlay: {
    name: TranslationService.t("categories.overlays"),
    openByDefault: true,
    mutuallyExclusive: false,
    order: 1
  },
  base: {
    name: TranslationService.t("categories.basemap"),
    openByDefault: false,
    mutuallyExclusive: true,
    order: 2
  }
};
const groupSettings = {
  layersInSelectedArea: {
    name: TranslationService.t("groups.layers_in_selected_area"),
    openByDefault: true,
    mutuallyExclusive: false,
    order: 0
  },
  user_layers: {
    name: TranslationService.t("groups.your_layers"),
    openByDefault: true,
    mutuallyExclusive: false,
    order: 1
  },
  bivariate: {
    name: TranslationService.t("groups.kontur_analytics"),
    openByDefault: true,
    mutuallyExclusive: true,
    order: 2
  },
  qa: {
    name: TranslationService.t("groups.qa"),
    openByDefault: true,
    mutuallyExclusive: false,
    order: 3
  },
  osmbasedmap: {
    name: TranslationService.t("groups.osmbasedmap"),
    openByDefault: false,
    mutuallyExclusive: false,
    order: 4
  },
  other: {
    name: TranslationService.t("groups.other"),
    openByDefault: false,
    mutuallyExclusive: false,
    order: 999
  },
  elevation: {
    name: TranslationService.t("groups.elevation"),
    openByDefault: true,
    mutuallyExclusive: false
  },
  photo: {
    name: TranslationService.t("groups.photo"),
    openByDefault: true,
    mutuallyExclusive: false
  },
  map: {
    name: TranslationService.t("groups.map"),
    openByDefault: true,
    mutuallyExclusive: false
  }
};
const layerTypesOrdered = [
  "background",
  "raster",
  "hillshade",
  "heatmap",
  "fill",
  "fill-extrusion",
  "line",
  "circle",
  "symbol",
  "custom"
];
class LayersOrderManager {
  constructor() {
    __publicField(this, "_baseMapFirstLayerIdx", null);
    __publicField(this, "_map", null);
    __publicField(this, "_layersSettings", null);
    __publicField(this, "_layersParentsIds", null);
    __publicField(this, "_unsubscribe", []);
    __publicField(this, "_typesOrder", [...layerTypesOrdered]);
    __publicField(this, "_awaitingTasks", /* @__PURE__ */ new Set());
  }
  init(map, mapLibreParentsIds2, layersSettingsAtom2) {
    this._map = map;
    this._unsubscribe.push(
      layersSettingsAtom2.subscribe(
        (layersSetting) => this._layersSettings = layersSetting
      )
    );
    this._layersParentsIds = mapLibreParentsIds2;
    this._baseMapFirstLayerIdx = (map.getStyle().layers ?? []).length - 1;
    this._awaitingTasks.forEach((task) => {
      this._awaitingTasks.delete(task);
      task(map);
    });
  }
  destroy() {
    this._unsubscribe.forEach((fn) => fn());
  }
  getIdToMountOnTypesTop(type, id, cb) {
    this._asyncWrap(type, id, cb, this._getIdToMountOnTypesTopSync.bind(this));
  }
  getIdToMountOnTypesBottom(type, id, cb) {
    this._asyncWrap(type, id, cb, this._getIdToMountOnTypesBottomSync.bind(this));
  }
  _getIdToMountOnTypesTopSync(map, type, id) {
    var _a2, _b, _c, _d;
    const orderedLayers = this._getMountedOrderedLayers(map);
    if (!(orderedLayers == null ? void 0 : orderedLayers.size)) return;
    const mountedLayersOfGivenType = orderedLayers.get(type);
    const givenLayerParentKey = (_a2 = this._layersParentsIds) == null ? void 0 : _a2.get(id);
    const givenLayerSettings = (_c = (_b = this._layersSettings) == null ? void 0 : _b.get(givenLayerParentKey || "")) == null ? void 0 : _c.data;
    if (!givenLayerSettings) {
      console.warn("settings were not found for layer ", type, id);
      return;
    }
    const givenCategory = givenLayerSettings.category;
    const higherLayerOfGivenType = mountedLayersOfGivenType == null ? void 0 : mountedLayersOfGivenType.find((searchingLayer) => {
      if (givenCategory === "base") return searchingLayer.category !== "base";
      if (givenCategory === "overlay") return searchingLayer.category === void 0;
    });
    if (givenCategory && higherLayerOfGivenType) {
      return higherLayerOfGivenType.layer.id;
    }
    if (!higherLayerOfGivenType || !givenCategory) {
      const higherMountedType = this._typesOrder.slice(this._typesOrder.indexOf(type) + 1).find((higherType) => {
        var _a3;
        return (_a3 = orderedLayers.get(higherType)) == null ? void 0 : _a3.length;
      });
      if (!higherMountedType) return void 0;
      const higherMountedLayer = (_d = orderedLayers.get(higherMountedType)) == null ? void 0 : _d[0].layer.id;
      return higherMountedLayer;
    }
  }
  _getIdToMountOnTypesBottomSync(map, type, id) {
    var _a2, _b, _c, _d;
    const orderedLayers = this._getMountedOrderedLayers(map);
    if (!(orderedLayers == null ? void 0 : orderedLayers.size)) return;
    const mountedLayersOfGivenType = orderedLayers.get(type);
    const givenLayerParentKey = (_a2 = this._layersParentsIds) == null ? void 0 : _a2.get(id);
    const givenLayerSettings = (_c = (_b = this._layersSettings) == null ? void 0 : _b.get(givenLayerParentKey || "")) == null ? void 0 : _c.data;
    if (!givenLayerSettings) {
      console.warn("settings were not found for layer ", type, id);
      return;
    }
    const givenCategory = givenLayerSettings.category;
    const firstLayerOfNextCategory = (() => {
      if (givenCategory === "base") return mountedLayersOfGivenType == null ? void 0 : mountedLayersOfGivenType[0];
      if (givenCategory === "overlay")
        return mountedLayersOfGivenType == null ? void 0 : mountedLayersOfGivenType.find(
          (searchingLayer) => searchingLayer.category === "overlay" || searchingLayer.category === void 0
        );
      if (givenCategory === void 0)
        return mountedLayersOfGivenType == null ? void 0 : mountedLayersOfGivenType.find(
          (searchingLayer) => searchingLayer.category === void 0
        );
    })();
    if (firstLayerOfNextCategory) return firstLayerOfNextCategory.layer.id;
    if (!(mountedLayersOfGivenType == null ? void 0 : mountedLayersOfGivenType.length) || !firstLayerOfNextCategory) {
      const higherMountedType = this._typesOrder.slice(this._typesOrder.indexOf(type) + 1).find((higherType) => {
        var _a3;
        return (_a3 = orderedLayers.get(higherType)) == null ? void 0 : _a3.length;
      });
      if (!higherMountedType) return void 0;
      const higherMountedLayer = (_d = orderedLayers.get(higherMountedType)) == null ? void 0 : _d[0].layer.id;
      return higherMountedLayer;
    }
  }
  _getMountedOrderedLayers(map) {
    if (this._baseMapFirstLayerIdx === null) return;
    const allLayers = map.getStyle().layers ?? [];
    if (allLayers.length === 0) {
      return void 0;
    }
    const customLayers = allLayers.slice(this._baseMapFirstLayerIdx + 1);
    if (!customLayers.length) return void 0;
    const mountedOrderedLayers = /* @__PURE__ */ new Map();
    customLayers.forEach((layer) => {
      var _a2, _b, _c, _d;
      const layerParentId = (_a2 = this._layersParentsIds) == null ? void 0 : _a2.get(layer.id);
      if (!layerParentId) return console.warn("id was not found for", layer.id, layer);
      const orderedLayersUnderSameType = mountedOrderedLayers.get(layer.type) || [];
      orderedLayersUnderSameType.push({
        layer,
        category: (_d = (_c = (_b = this._layersSettings) == null ? void 0 : _b.get(layerParentId)) == null ? void 0 : _c.data) == null ? void 0 : _d.category
      });
      mountedOrderedLayers.set(layer.type, orderedLayersUnderSameType);
    });
    return mountedOrderedLayers;
  }
  _asyncWrap(type, id, cb, syncFunction) {
    const map = this._map;
    if (map === null || this._baseMapFirstLayerIdx === null) {
      this._awaitingTasks.add((map2) => {
        cb(syncFunction(map2, type, id));
      });
    } else {
      cb(syncFunction(map, type, id));
    }
  }
}
const layersOrderManager = new LayersOrderManager();
const mapLibreParentsIds = /* @__PURE__ */ new Map();
function layerByOrder(map, layersOrderManager$1 = layersOrderManager) {
  function addAboveLayerWithSameType(maplibreLayer, uiLayerId) {
    mapLibreParentsIds.set(maplibreLayer.id, uiLayerId);
    layersOrderManager$1.getIdToMountOnTypesTop(
      maplibreLayer.type,
      maplibreLayer.id,
      (id) => map.addLayer(maplibreLayer, id)
    );
  }
  function addUnderLayerWithSameType(maplibreLayer, uiLayerId) {
    mapLibreParentsIds.set(maplibreLayer.id, uiLayerId);
    layersOrderManager$1.getIdToMountOnTypesBottom(
      maplibreLayer.type,
      maplibreLayer.id,
      (id) => map.addLayer(maplibreLayer, id)
    );
  }
  function addAboveAllExistingLayers(maplibreLayer, uiLayerId) {
    mapLibreParentsIds.set(maplibreLayer.id, uiLayerId);
    map.addLayer(maplibreLayer, void 0);
  }
  return {
    addAboveLayerWithSameType,
    addUnderLayerWithSameType,
    addAboveAllExistingLayers
  };
}
const waitMapEvent = (map, event) => new Promise((res, rej) => {
  try {
    map.on(event, res);
  } catch (error2) {
    rej(error2);
  }
});
function mapLoaded(map) {
  if (!map._loaded) {
    return waitMapEvent(map, "load");
  }
  return;
}
const defaultListeners = {
  click: [],
  mousemove: [],
  mouseleave: []
};
function registerMapListener(eventType, listener, priority1to100 = 50, layerId) {
  mapListenersAtom.addMapListener.dispatch(eventType, listener, priority1to100);
  return () => {
    mapListenersAtom.removeMapListener.dispatch(eventType, listener);
  };
}
const mapListenersAtom = createAtom(
  {
    addMapListener: (eventType, listener, priority) => ({
      eventType,
      listener,
      priority
    }),
    removeMapListener: (eventType, listener) => ({
      eventType,
      listener
    })
  },
  ({ onAction }, state = defaultListeners) => {
    onAction("addMapListener", ({ eventType, listener, priority }) => {
      const listenerCategory = [...state[eventType]];
      if (!listenerCategory.length) listenerCategory.push({ listener, priority });
      else
        for (let i2 = 0; i2 < listenerCategory.length; i2++) {
          const listenerWrap = listenerCategory[i2];
          if (priority < listenerWrap.priority) {
            listenerCategory.splice(i2, 0, { listener, priority });
            break;
          } else if (listenerWrap.priority === priority) {
            listenerCategory.splice(i2 + 1, 0, { listener, priority });
            break;
          } else if (!listenerCategory[i2 + 1]) {
            listenerCategory.push({ listener, priority });
            break;
          } else if (priority > listenerWrap.priority && priority < listenerCategory[i2 + 1].priority) {
            listenerCategory.splice(i2 + 1, 0, { listener, priority });
            break;
          }
        }
      state = { ...state, [eventType]: listenerCategory };
    });
    onAction(
      "removeMapListener",
      ({ eventType, listener }) => state[eventType] = state[eventType].filter((l2) => l2.listener !== listener)
    );
    return state;
  },
  "[Shared state] mapListenersAtom"
);
const hexagon = "_hexagon_1g4ry_1";
const s$4 = {
  hexagon
};
const Hexagon = ({ color, children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$4.hexagon, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { background: color }, children }) });
};
const tootipRoot = "_tootipRoot_blnig_1";
const labels = "_labels_blnig_5";
const column$2 = "_column_blnig_11";
const bivariateHexagonPopupContentRoot$1 = "_bivariateHexagonPopupContentRoot_blnig_22";
const s$3 = {
  tootipRoot,
  labels,
  column: column$2,
  bivariateHexagonPopupContentRoot: bivariateHexagonPopupContentRoot$1
};
const bivariateHexagonPopupContentRoot = s$3.bivariateHexagonPopupContentRoot;
const getXIndicatorLabelByindex = (index2) => {
  if (isBottomSide(index2)) return LOW;
  if (isTopSide(index2)) return HIGH;
  return MEDIUM;
};
const getYIndicatorLabelByindex = (index2) => {
  if (isLeftSide(index2)) return LOW;
  if (isRightSide(index2)) return HIGH;
  return MEDIUM;
};
const MapHexTooltip = ({
  hexagonColor,
  axis: axis2,
  cellIndex,
  cellLabel,
  values
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$3.tootipRoot, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Hexagon, { color: hexagonColor, children: cellLabel }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$3.labels, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$3.column, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: axis2.x.label || formatBivariateAxisLabel(axis2.x.quotients) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: axis2.y.label || formatBivariateAxisLabel(axis2.y.quotients) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$3.column, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: values.x }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: values.y })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$3.column, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: getXIndicatorLabelByindex(cellIndex) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: getYIndicatorLabelByindex(cellIndex) })
      ] })
    ] })
  ] });
};
const DEFAULT_GREEN = "rgba(90, 200, 127, 0.5)";
const DEFAULT_RED = "rgba(228, 26, 28, 0.5)";
const sentimentDefault = ["bad", "good"];
const sentimentReversed = ["good", "bad"];
var double = { exports: {} };
double.exports;
var hasRequiredDouble;
function requireDouble() {
  if (hasRequiredDouble) return double.exports;
  hasRequiredDouble = 1;
  (function(module) {
    var hasTypedArrays = false;
    if (typeof Float64Array !== "undefined") {
      var DOUBLE_VIEW = new Float64Array(1), UINT_VIEW = new Uint32Array(DOUBLE_VIEW.buffer);
      DOUBLE_VIEW[0] = 1;
      hasTypedArrays = true;
      if (UINT_VIEW[1] === 1072693248) {
        let toDoubleLE = function(lo, hi) {
          UINT_VIEW[0] = lo;
          UINT_VIEW[1] = hi;
          return DOUBLE_VIEW[0];
        }, lowUintLE = function(n2) {
          DOUBLE_VIEW[0] = n2;
          return UINT_VIEW[0];
        }, highUintLE = function(n2) {
          DOUBLE_VIEW[0] = n2;
          return UINT_VIEW[1];
        };
        module.exports = function doubleBitsLE(n2) {
          DOUBLE_VIEW[0] = n2;
          return [UINT_VIEW[0], UINT_VIEW[1]];
        };
        module.exports.pack = toDoubleLE;
        module.exports.lo = lowUintLE;
        module.exports.hi = highUintLE;
      } else if (UINT_VIEW[0] === 1072693248) {
        let toDoubleBE = function(lo, hi) {
          UINT_VIEW[1] = lo;
          UINT_VIEW[0] = hi;
          return DOUBLE_VIEW[0];
        }, lowUintBE = function(n2) {
          DOUBLE_VIEW[0] = n2;
          return UINT_VIEW[1];
        }, highUintBE = function(n2) {
          DOUBLE_VIEW[0] = n2;
          return UINT_VIEW[0];
        };
        module.exports = function doubleBitsBE(n2) {
          DOUBLE_VIEW[0] = n2;
          return [UINT_VIEW[1], UINT_VIEW[0]];
        };
        module.exports.pack = toDoubleBE;
        module.exports.lo = lowUintBE;
        module.exports.hi = highUintBE;
      } else {
        hasTypedArrays = false;
      }
    }
    if (!hasTypedArrays) {
      let toDouble = function(lo, hi) {
        buffer.writeUInt32LE(lo, 0, true);
        buffer.writeUInt32LE(hi, 4, true);
        return buffer.readDoubleLE(0, true);
      }, lowUint = function(n2) {
        buffer.writeDoubleLE(n2, 0, true);
        return buffer.readUInt32LE(0, true);
      }, highUint = function(n2) {
        buffer.writeDoubleLE(n2, 0, true);
        return buffer.readUInt32LE(4, true);
      };
      var buffer = new Buffer(8);
      module.exports = function doubleBits(n2) {
        buffer.writeDoubleLE(n2, 0, true);
        return [buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true)];
      };
      module.exports.pack = toDouble;
      module.exports.lo = lowUint;
      module.exports.hi = highUint;
    }
    module.exports.sign = function(n2) {
      return module.exports.hi(n2) >>> 31;
    };
    module.exports.exponent = function(n2) {
      var b2 = module.exports.hi(n2);
      return (b2 << 1 >>> 21) - 1023;
    };
    module.exports.fraction = function(n2) {
      var lo = module.exports.lo(n2);
      var hi = module.exports.hi(n2);
      var b2 = hi & (1 << 20) - 1;
      if (hi & 2146435072) {
        b2 += 1 << 20;
      }
      return [lo, b2];
    };
    module.exports.denormalized = function(n2) {
      var hi = module.exports.hi(n2);
      return !(hi & 2146435072);
    };
  })(double);
  return double.exports;
}
var nextafter_1;
var hasRequiredNextafter;
function requireNextafter() {
  if (hasRequiredNextafter) return nextafter_1;
  hasRequiredNextafter = 1;
  var doubleBits = requireDouble();
  var SMALLEST_DENORM = Math.pow(2, -1074);
  var UINT_MAX = -1 >>> 0;
  nextafter_1 = nextafter2;
  function nextafter2(x2, y2) {
    if (isNaN(x2) || isNaN(y2)) {
      return NaN;
    }
    if (x2 === y2) {
      return x2;
    }
    if (x2 === 0) {
      if (y2 < 0) {
        return -SMALLEST_DENORM;
      } else {
        return SMALLEST_DENORM;
      }
    }
    var hi = doubleBits.hi(x2);
    var lo = doubleBits.lo(x2);
    if (y2 > x2 === x2 > 0) {
      if (lo === UINT_MAX) {
        hi += 1;
        lo = 0;
      } else {
        lo += 1;
      }
    } else {
      if (lo === 0) {
        lo = UINT_MAX;
        hi -= 1;
      } else {
        lo -= 1;
      }
    }
    return doubleBits.pack(lo, hi);
  }
  return nextafter_1;
}
var nextafterExports = requireNextafter();
const nextafter = /* @__PURE__ */ getDefaultExportFromCjs(nextafterExports);
class MapMath {
  constructor() {
    __publicField(this, "add", (x2, y2) => ["+", x2, y2]);
    __publicField(this, "sub", (x2, y2) => ["-", x2, y2]);
    __publicField(this, "mult", (x2, y2) => ["*", x2, y2]);
    __publicField(this, "div", (x2, y2) => ["/", x2, y2]);
    __publicField(this, "log", (x2) => ["ln", x2]);
    __publicField(this, "log10", (x2) => ["log10", x2]);
    __publicField(this, "sqrt", (x2) => ["sqrt", x2]);
    __publicField(this, "cbrt", (x2) => this.mult(this.sign(x2), ["^", this.abs(x2), 1 / 3]));
    __publicField(this, "abs", (x2) => ["abs", x2]);
    __publicField(this, "sign", (x2) => ["case", ["<", x2, 0], -1, 1]);
    __publicField(this, "clamp", (x2, min2, max2) => [
      "let",
      "clampedX",
      ["to-number", x2, Number.POSITIVE_INFINITY],
      [
        "case",
        ["<", ["var", "clampedX"], min2],
        min2,
        [">", ["var", "clampedX"], max2],
        max2,
        ["var", "clampedX"]
      ]
    ]);
    __publicField(this, "min", (v1, v2) => [
      "let",
      "v1",
      ["to-number", v1, Number.POSITIVE_INFINITY],
      "v2",
      ["to-number", v2, Number.POSITIVE_INFINITY],
      ["case", ["<", ["var", "v2"], ["var", "v1"]], ["var", "v2"], ["var", "v1"]]
    ]);
    __publicField(this, "max", (v1, v2) => [
      "let",
      "v1",
      ["to-number", v1, Number.NEGATIVE_INFINITY],
      "v2",
      ["to-number", v2, Number.NEGATIVE_INFINITY],
      ["case", [">", ["var", "v2"], ["var", "v1"]], ["var", "v2"], ["var", "v1"]]
    ]);
  }
}
class JsMath {
  constructor() {
    __publicField(this, "add", (x2, y2) => x2 + y2);
    __publicField(this, "sub", (x2, y2) => x2 - y2);
    __publicField(this, "mult", (x2, y2) => x2 * y2);
    __publicField(this, "div", (x2, y2) => x2 / y2);
    __publicField(this, "log", (x2) => Math.log(x2));
    __publicField(this, "log10", (x2) => Math.log10(x2));
    __publicField(this, "sqrt", (x2) => Math.sqrt(x2));
    __publicField(this, "cbrt", (x2) => Math.cbrt(x2));
    __publicField(this, "abs", (x2) => Math.abs(x2));
    __publicField(this, "sign", (x2) => Math.sign(x2));
    __publicField(this, "clamp", (x2, min2, max2) => {
      if (x2 < min2) {
        return min2;
      }
      if (x2 > max2) {
        return max2;
      }
      return x2;
    });
    __publicField(this, "min", (v1, v2) => Math.min(v1, v2));
    __publicField(this, "max", (v1, v2) => Math.max(v1, v2));
  }
}
const equalSentiments = (a2, b2) => a2.length === b2.length && a2.every((x2, i2) => x2 === b2[i2]);
const nextFloatValueInDirection = (value2, direction, transformation) => {
  const deltaAdjustmentFunctions = {
    cube_root: (x2) => Math.cbrt(x2),
    square_root: (x2) => Math.sqrt(x2),
    log: (x2) => 10 * x2,
    log_epsilon: (x2) => 10 * x2
  };
  const sign = Math.sign(direction - value2);
  const nextNumber = nextafter(value2, direction);
  const delta = Math.abs(value2 - nextNumber);
  if (delta < 1 && transformation && deltaAdjustmentFunctions[transformation]) {
    let adjustedDelta = deltaAdjustmentFunctions[transformation](delta);
    if (adjustedDelta > 1) {
      adjustedDelta = 0.1;
    }
    return value2 + sign * adjustedDelta;
  }
  return nextNumber;
};
class Calculations {
  constructor(operations) {
    __publicField(this, "math");
    this.math = operations;
  }
  rate({ num, den }) {
    return this.math.div(num, den);
  }
  normalize({ x: x2, min: min2, max: max2 }) {
    return this.math.div(this.math.sub(x2, min2), this.math.sub(max2, min2));
  }
  transform({
    x: x2,
    min: min2,
    max: max2,
    datasetMin,
    transformation
  }) {
    switch (transformation) {
      case "no":
        return {
          tX: x2,
          tMin: min2,
          tMax: max2
        };
      /* square_root: sign(x)√(|x|) */
      case "square_root":
        return {
          tX: this.math.mult(this.math.sign(x2), this.math.sqrt(this.math.abs(x2))),
          tMin: this.math.mult(this.math.sign(min2), this.math.sqrt(this.math.abs(min2))),
          tMax: this.math.mult(this.math.sign(max2), this.math.sqrt(this.math.abs(max2)))
        };
      /* cube_root:  ∛x */
      case "cube_root":
        return {
          tX: this.math.cbrt(x2),
          tMin: this.math.cbrt(min2),
          tMax: this.math.cbrt(max2)
        };
      /* log(x - datasetMin + 1) */
      case "log":
        if (datasetMin === void 0) {
          throw new Error("Could not find required data for given transformation");
        }
        return {
          tX: this.math.log10(this.math.add(this.math.sub(x2, datasetMin), 1)),
          tMin: this.math.log10(this.math.add(this.math.sub(min2, datasetMin), 1)),
          tMax: this.math.log10(this.math.add(this.math.sub(max2, datasetMin), 1))
        };
      /* log(x - datasetMin + ε) */
      case "log_epsilon":
        if (datasetMin === void 0) {
          throw new Error("Could not find required data for given transformation");
        }
        return {
          tX: this.math.log10(
            this.math.add(this.math.sub(x2, datasetMin), Number.EPSILON)
          ),
          tMin: this.math.log10(
            this.math.add(this.math.sub(min2, datasetMin), Number.EPSILON)
          ),
          tMax: this.math.log10(
            this.math.add(this.math.sub(max2, datasetMin), Number.EPSILON)
          )
        };
    }
  }
  invert(x2) {
    return this.math.sub(1, x2);
  }
  scale(x2, coefficient) {
    return this.math.mult(x2, coefficient);
  }
  clamp(x2, min2, max2) {
    return this.math.clamp(x2, min2, max2);
  }
  min(v1, v2) {
    return this.math.min(v1, v2);
  }
  max(v1, v2) {
    return this.math.max(v1, v2);
  }
}
const inStyleCalculations = new Calculations(new MapMath());
const inViewCalculations = new Calculations(new JsMath());
const calculateLayerPipeline = (operations, getValue) => ({
  axis: axis2,
  range,
  coefficient,
  sentiment,
  transformationFunction,
  transformation,
  normalization,
  outliers,
  datasetStats
}) => {
  const [num, den] = axis2;
  let min2 = range[0];
  const max2 = range[1];
  if (min2 === max2) {
    min2 = nextFloatValueInDirection(
      min2,
      Number.NEGATIVE_INFINITY,
      (transformation == null ? void 0 : transformation.transformation) ?? transformationFunction
    );
  }
  const datasetMin = datasetStats == null ? void 0 : datasetStats.minValue;
  const inverted = equalSentiments(sentiment, sentimentReversed);
  if (!inverted)
    console.assert(
      equalSentiments(sentiment, sentimentDefault),
      "Not inverted equals default"
    );
  const values = getValue({ num, den });
  const rate = operations.rate(values);
  const clamped = outliers === "clamp" ? operations.clamp(rate, min2, max2) : rate;
  let { tX, tMin, tMax } = operations.transform({
    x: clamped,
    min: min2,
    max: max2,
    datasetMin,
    transformation: (transformation == null ? void 0 : transformation.transformation) ?? transformationFunction
  });
  if ((transformation == null ? void 0 : transformation.transformation) && (transformation == null ? void 0 : transformation.transformation) !== "no" && isNumber(transformation.lowerBound) && isNumber(transformation.upperBound)) {
    let lowerBound = transformation.lowerBound;
    const upperBound = transformation.upperBound;
    if (lowerBound === upperBound) {
      lowerBound = nextFloatValueInDirection(lowerBound, Number.NEGATIVE_INFINITY);
    }
    tMin = operations.max(tMin, lowerBound);
    tMax = operations.min(tMax, upperBound);
    if (outliers !== "unmodified") {
      tX = operations.clamp(tX, tMin, tMax);
    }
  }
  const normalized = normalization === "max-min" ? operations.normalize({ x: tX, min: tMin, max: tMax }) : tX;
  const orientated = inverted ? operations.invert(normalized) : normalized;
  const scaled = operations.scale(orientated, coefficient);
  return scaled;
};
const SOURCE_LAYER_MCDA = "stats";
const calculateLayer = calculateLayerPipeline(inStyleCalculations, (axis2) => ({
  num: ["get", axis2.num],
  den: ["get", axis2.den]
}));
function filterSetup(layers2) {
  const conditions = [
    anyCondition(
      ...layers2.map(
        ({ axis: axis2 }) => notEqual(["/", featureProp(axis2[0]), featureProp(axis2[1])], 0)
      )
    )
  ];
  layers2.forEach(({ axis: axis2, range, outliers }) => {
    if (outliers === "hide") {
      conditions.push(
        greaterOrEqual(["/", featureProp(axis2[0]), featureProp(axis2[1])], range[0]),
        lessOrEqual(["/", featureProp(axis2[0]), featureProp(axis2[1])], range[1])
      );
    }
  });
  layers2.forEach(({ axis: axis2, range }) => {
    conditions.push(
      // this checks for 0 in denominator (0 in denominator makes the result === Infinity)
      notEqual(featureProp(axis2[1]), 0)
    );
  });
  if (conditions.length > 1) {
    return allCondition(...conditions);
  }
  return conditions[0];
}
function linearNormalization(layers2) {
  if (layers2.length === 1) {
    return ["/", calculateLayer(layers2.at(0)), layers2.at(0).coefficient];
  } else {
    return ["/", ["+", ...layers2.map(calculateLayer)], sumBy(layers2, "coefficient")];
  }
}
function sentimentPaint({
  colorsConfig,
  mcdaResult,
  absoluteMin,
  absoluteMax
}) {
  if (colorsConfig.type !== "sentiments") {
    console.error(`Expected sentiments color config, but got ${colorsConfig.type}`);
    return void 0;
  }
  const { good = DEFAULT_GREEN, bad = DEFAULT_RED } = colorsConfig.parameters;
  const midpoints = Array.isArray(colorsConfig.parameters.midpoints) ? colorsConfig.parameters.midpoints : [];
  const colorPoints = [
    { value: absoluteMin, color: bad },
    ...midpoints,
    { value: absoluteMax, color: good }
  ];
  return {
    "fill-color": [
      "let",
      "mcdaResult",
      mcdaResult,
      [
        "case",
        [
          "all",
          [">=", ["var", "mcdaResult"], absoluteMin],
          ["<=", ["var", "mcdaResult"], absoluteMax]
        ],
        [
          "interpolate-hcl",
          ["linear"],
          ["var", "mcdaResult"],
          ...colorPoints.flatMap((point) => [point.value, point.color])
        ],
        // paint all values below absoluteMin (0 by default) same as absoluteMin
        ["<", ["var", "mcdaResult"], absoluteMin],
        bad,
        // paint all values above absoluteMax (1 by default) same as absoluteMax
        [">", ["var", "mcdaResult"], absoluteMax],
        good,
        // Default color value. We get here in case of incorrect values (null, NaN etc)
        // Transparent features don't show popups on click
        "transparent"
      ]
    ],
    "fill-opacity": 1,
    "fill-antialias": false
  };
}
function expressionsPaint({
  colorsConfig,
  mcdaResult,
  absoluteMax,
  absoluteMin
}) {
  return Object.entries(colorsConfig.parameters).reduce(
    (acc, [paintProp, expression]) => {
      acc[paintProp] = Array.isArray(expression) ? [
        "let",
        "mcdaResult",
        ["to-number", mcdaResult, -9999],
        // falsy values become -9999,
        "absoluteMax",
        ["to-number", absoluteMax, -9999],
        // falsy values become -9999,
        "absoluteMin",
        ["to-number", absoluteMin, -9999],
        // falsy values become -9999,
        ...expression
      ] : expression;
      return acc;
    },
    {}
  );
}
function generateLayerPaint(props) {
  switch (props.colorsConfig.type) {
    case "sentiments":
      return sentimentPaint(props);
    case "mapLibreExpression":
      return expressionsPaint(props);
  }
}
function createMCDAStyle(config2) {
  const [absoluteMin = 0, absoluteMax = 1] = config2.layers.reduce(
    (acc, l2) => {
      const range = l2.normalization === "no" ? l2.range : [0, 1];
      if (acc.length === 0) return [...range];
      acc[0] = Math.min(acc[0], range[0]);
      acc[1] = Math.min(acc[1], range[1]);
      return acc;
    },
    []
  );
  const mcdaResult = linearNormalization(config2.layers);
  const layerStyle = {
    id: config2.id,
    type: "fill",
    layout: {},
    filter: filterSetup(config2.layers),
    // TODO - MCDA should have separate from bivariate renderer
    paint: generateLayerPaint({
      colorsConfig: config2.colors,
      mcdaResult,
      absoluteMin,
      absoluteMax
    }),
    source: config2.id + "_source",
    // this id is replaced inside the Renderer
    "source-layer": SOURCE_LAYER_MCDA
  };
  return layerStyle;
}
TranslationService.t(
  "multivariate.multivariate_analysis"
);
const DEFAULT_MULTIBIVARIATE_STEPS = [
  {
    value: 0
  },
  {
    value: 0.33
  },
  {
    value: 0.67
  },
  {
    value: 1
  }
];
const DEFAULT_MULTIBIVARIATE_COLORS = [
  {
    id: "A1",
    color: "rgba(232, 232, 157, 0.5)"
  },
  {
    id: "A2",
    color: "rgba(229, 154, 55, 0.5)"
  },
  {
    id: "A3",
    color: "rgba(228, 26, 28, 0.5)"
  },
  {
    id: "B1",
    color: "rgba(203, 240, 211, 0.5)"
  },
  {
    id: "B2",
    color: "rgba(228, 185, 129, 0.5)"
  },
  {
    id: "B3",
    color: "rgba(228, 127, 129, 0.5)"
  },
  {
    id: "C1",
    color: "rgba(135, 198, 144, 0.5)"
  },
  {
    id: "C2",
    color: "rgba(109, 179, 92, 0.5)"
  },
  {
    id: "C3",
    color: "rgba(102, 154, 112, 0.5)"
  }
];
function generateBivariateColorsAndStyleForMultivariateLayer(config2, sourceLayer) {
  var _a2, _b, _c, _d;
  if (!config2.base || !config2.score) {
    console.error("Both base and annex are required for bivariate style", config2);
    throw Error("Both base and annex are required for bivariate style");
  }
  const colors = ((_a2 = config2.colors) == null ? void 0 : _a2.type) === "bivariate" ? (_b = config2.colors) == null ? void 0 : _b.colors : DEFAULT_MULTIBIVARIATE_COLORS;
  if (!colors) {
    console.error("Proper color theme not found. Using default colors.");
  }
  const bivariateStyle = createBivariateMultivariateStyle({
    score: config2.score.config,
    base: config2.base.config,
    baseSteps: ((_c = config2.stepOverrides) == null ? void 0 : _c.baseSteps) ?? DEFAULT_MULTIBIVARIATE_STEPS,
    scoreSteps: ((_d = config2.stepOverrides) == null ? void 0 : _d.scoreSteps) ?? DEFAULT_MULTIBIVARIATE_STEPS,
    colors,
    sourceLayer
  });
  return [colors, bivariateStyle];
}
function setupColorClasses(baseValue, annexValue, baseSteps, annexSteps, colors) {
  return addVariable(
    "baseValue",
    baseValue,
    addVariable(
      "annexValue",
      annexValue,
      addVariable(
        "class",
        classResolver(
          {
            propName: getVariable("annexValue"),
            borders: annexSteps.reduce(
              (acc, { value: value2 }) => (acc.push(value2), acc),
              []
            )
          },
          {
            propName: getVariable("baseValue"),
            borders: baseSteps.reduce(
              (acc, { value: value2 }) => (acc.push(value2), acc),
              []
            )
          }
        ),
        colorResolver("class", colors, "transparent")
      )
    )
  );
}
function createBivariateMultivariateStyle({
  score,
  base,
  scoreSteps,
  baseSteps,
  colors,
  sourceLayer,
  id = "multivariate-bivariate"
}) {
  const annexValueExpression = linearNormalization(score.layers);
  const baseValueExpression = linearNormalization(base.layers);
  const filter = filterSetup([...score.layers, ...base.layers]);
  const style2 = {
    id,
    type: "fill",
    layout: {},
    filter,
    paint: {
      "fill-color": setupColorClasses(
        baseValueExpression,
        annexValueExpression,
        baseSteps,
        scoreSteps,
        colorsMap(colors)
      ),
      "fill-opacity": 1,
      "fill-antialias": false
    },
    source: id + "_source"
    // this id is replaced inside the Renderer, do we need it here just as a placeholder?
  };
  {
    style2["source-layer"] = sourceLayer;
  }
  return style2;
}
function multivariateDimensionToScore(axis2) {
  return linearNormalization(axis2.config.layers);
}
const DEFAULT_OPACITY_STEPS = [
  { minScore: 0.66, opacity: 1 },
  { minScore: 0.33, opacity: 0.55 },
  { minScore: 0, opacity: 0.2 }
];
function createOpacityStepsExpression(opacityMCDA, opacitySteps = DEFAULT_OPACITY_STEPS) {
  const opacityScore = multivariateDimensionToScore(opacityMCDA);
  const conditions = [];
  for (let i2 = 0; i2 < opacitySteps.length - 1; i2 += 1) {
    conditions.push(
      [">=", opacityScore, opacitySteps[i2].minScore],
      opacitySteps[i2].opacity
    );
  }
  conditions.push(opacitySteps[opacitySteps.length - 1].opacity);
  return ["case", ...conditions];
}
const styleConfigs = {
  mcda: (config2) => {
    return new Array(createMCDAStyle(config2));
  },
  multivariate: (config2) => {
    let multivariateStyle;
    if (config2.base) {
      const colorsAndStyle = generateBivariateColorsAndStyleForMultivariateLayer(
        config2,
        SOURCE_LAYER_BIVARIATE
      );
      multivariateStyle = colorsAndStyle[1];
    } else {
      multivariateStyle = createMCDAStyle(config2.score.config);
    }
    if (config2.opacity !== void 0) {
      const opacity = !isNumber(config2.opacity) ? createOpacityStepsExpression(config2.opacity) : config2.opacity;
      multivariateStyle = {
        ...multivariateStyle,
        paint: { ...multivariateStyle.paint, "fill-opacity": opacity }
      };
    }
    return Array(multivariateStyle);
  }
};
function roundNumberToPrecision(value2, decimals, removeTrailingZeros = false, exponentialDecimals) {
  const precisionThreshold = Math.pow(10, -decimals);
  if (Math.abs(value2) < precisionThreshold && Math.abs(value2) > 0) {
    return value2.toExponential(
      isNumber(exponentialDecimals) ? exponentialDecimals : decimals
    );
  } else {
    return removeTrailingZeros ? Number.parseFloat(value2.toFixed(decimals)).toString() : value2.toFixed(decimals);
  }
}
const result = "_result_1l50n_1";
const tableBody = "_tableBody_1l50n_6";
const list = "_list_1l50n_10";
const entryName = "_entryName_1l50n_18";
const s$2 = {
  result,
  tableBody,
  list,
  entryName
};
function OneLayerPopup({
  layer,
  normalized,
  resultMCDA
}) {
  const key = `${layer.axis[0]}-${layer.axis[1]}`;
  const [num, den] = reactExports.useMemo(
    () => layer.axis.map((ax) => capitalize(ax.replaceAll("_", " "))),
    [layer]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: s$2.list, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: s$2.entryName, children: [
        num,
        ":"
      ] }),
      " ",
      roundNumberToPrecision(normalized[key].numValue, 3, false, 2)
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: s$2.entryName, children: [
        den,
        ":"
      ] }),
      " ",
      roundNumberToPrecision(normalized[key].denValue, 3, false, 2)
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: s$2.entryName, children: [
        num,
        " / ",
        den,
        ":"
      ] }),
      " ",
      roundNumberToPrecision(resultMCDA, 2, true)
    ] })
  ] });
}
function MultiLayerPopup({ layers: layers2, normalized, resultMCDA }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Layer" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Range" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Coefficient" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Value" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Normalized Value" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { className: s$2.tableBody, children: [
      layers2.map(({ axis: axis2, range, coefficient }, index2) => {
        const [min2, max2] = range;
        const [num, den] = axis2;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
            num,
            " / ",
            den
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
            roundNumberToPrecision(min2, 2, true),
            " -",
            " ",
            roundNumberToPrecision(max2, 2, true)
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: coefficient }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: roundNumberToPrecision(normalized[`${num}-${den}`].val, 3) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: roundNumberToPrecision(normalized[`${num}-${den}`].norm, 3) })
        ] }, `${num}-${den}-${index2}`);
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("td", { colSpan: 5, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("b", { className: s$2.result, children: [
        "Result: ",
        roundNumberToPrecision(resultMCDA, 2, true)
      ] }) }) })
    ] })
  ] });
}
function PopupMCDA({ layers: layers2, normalized, resultMCDA }) {
  return layers2.length === 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    OneLayerPopup,
    {
      layer: layers2.at(0),
      normalized,
      resultMCDA
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(MultiLayerPopup, { layers: layers2, normalized, resultMCDA });
}
function createTableWithCalculations(feature, layers2) {
  const calculateLayer2 = calculateLayerPipeline(inViewCalculations, ({ num, den }) => {
    var _a2, _b;
    return {
      num: (_a2 = feature.properties) == null ? void 0 : _a2[num],
      den: (_b = feature.properties) == null ? void 0 : _b[den]
    };
  });
  return layers2.reduce((acc, layer) => {
    var _a2, _b, _c, _d;
    const [num, den] = layer.axis;
    const value2 = ((_a2 = feature.properties) == null ? void 0 : _a2[num]) / ((_b = feature.properties) == null ? void 0 : _b[den]);
    acc[`${num}-${den}`] = {
      val: value2,
      norm: calculateLayer2(layer),
      numValue: (_c = feature.properties) == null ? void 0 : _c[num],
      denValue: (_d = feature.properties) == null ? void 0 : _d[den]
    };
    return acc;
  }, {});
}
function calcMcdaIndex(layers2, normalized) {
  const sumNormalized = sumBy(Object.values(normalized), "norm");
  const coeffsSum = sumBy(layers2, "coefficient");
  return sumNormalized / coeffsSum;
}
function generateMCDALayersTableAndScore(feature, layers2) {
  const mcdaLayersTable = createTableWithCalculations(feature, layers2);
  const resultMCDAScore = calcMcdaIndex(layers2, mcdaLayersTable);
  return { mcdaLayersTable, resultMCDAScore };
}
function generateMCDAPopupTable(feature, layers2) {
  const { mcdaLayersTable, resultMCDAScore } = generateMCDALayersTableAndScore(
    feature,
    layers2
  );
  return PopupMCDA({ layers: layers2, normalized: mcdaLayersTable, resultMCDA: resultMCDAScore });
}
function generateMCDAPopupContent(feature, layers2) {
  const popupNode = document.createElement("div");
  clientExports.createRoot(popupNode).render(generateMCDAPopupTable(feature, layers2));
  return popupNode;
}
function setTileScheme(rawUrl, mapSource) {
  const isTMS = rawUrl.includes("{-y}");
  if (isTMS) {
    mapSource.scheme = "tms";
  }
}
function fillColorEmptyOrTransparent(feature) {
  var _a2;
  const fillColor = (_a2 = feature.layer.paint) == null ? void 0 : _a2["fill-color"];
  return fillColor ? fillColor.a === 0 : true;
}
function isFeatureVisible(feature) {
  if (fillColorEmptyOrTransparent(feature)) return false;
  return true;
}
function featureHaveId(feature) {
  return haveValue(feature.id);
}
function filterFeatures(sourceId, ev) {
  return ev.target.queryRenderedFeatures(ev.point).filter((f2) => f2.source.includes(sourceId)).filter(isFeatureVisible).filter(featureHaveId);
}
function createFeatureStateHandlers(ctx) {
  const activeFeatures = /* @__PURE__ */ new Set();
  const hoveredFeatures = /* @__PURE__ */ new Set();
  const setFeatureState = (featureId, newState) => {
    const source = ctx.map.getSource(ctx.sourceId);
    if (!source) {
      console.error("map - no source for", ctx.sourceId);
      return;
    }
    ctx.map.setFeatureState(
      { source: ctx.sourceId, id: featureId, sourceLayer: ctx.sourceLayer },
      newState
    );
  };
  return {
    onClick: (ev) => {
      activeFeatures.forEach((featureId) => {
        setFeatureState(featureId, { active: false });
      });
      activeFeatures.clear();
      const features = filterFeatures(ctx.sourceId, ev);
      if (!features.length) {
        return true;
      }
      features.forEach((feature) => {
        setFeatureState(feature.id, { active: true });
        activeFeatures.add(feature.id);
      });
      return true;
    },
    onMouseMove: (ev) => {
      hoveredFeatures.forEach((featureId) => {
        setFeatureState(featureId, { hover: false });
      });
      hoveredFeatures.clear();
      const features = filterFeatures(ctx.sourceId, ev);
      if (!features.length) {
        return true;
      }
      features.forEach((feature) => {
        setFeatureState(feature.id, { hover: true });
        hoveredFeatures.add(feature.id);
      });
      return true;
    },
    onMouseLeave: (ev) => {
      hoveredFeatures.forEach((featureId) => {
        setFeatureState(featureId, { hover: false });
      });
      hoveredFeatures.clear();
      return true;
    },
    reset: () => {
      activeFeatures.forEach((featureId) => {
        setFeatureState(featureId, { active: false });
      });
      activeFeatures.clear();
      hoveredFeatures.forEach((featureId) => {
        setFeatureState(featureId, { hover: false });
      });
      hoveredFeatures.clear();
    }
  };
}
function generateLayerFromLegend(legend2, sourceLayer) {
  if (legend2.type === "bivariate") {
    return generateLayerStyleFromBivariateLegend(legend2, sourceLayer);
  }
  throw new Error(`Unexpected legend type '${legend2.type}'`);
}
const convertFillColorToRGBA = (fillColor, withTransparency = true) => `rgba(${fillColor.r * 255 * 2},${fillColor.g * 255 * 2},${fillColor.b * 255 * 2}${withTransparency ? "," + fillColor.a : ""})`;
function calcValueByNumeratorDenominator(cellValues, numerator, denominator) {
  const numeratorValue = cellValues[numerator];
  const denominatorValue = cellValues[denominator];
  if (numeratorValue == null || denominatorValue == null) return "0.00";
  if (denominatorValue === 0) return void 0;
  return (numeratorValue / denominatorValue).toFixed(2);
}
class BivariateRenderer extends LogicalLayerDefaultRenderer {
  constructor({
    id,
    layersOrderManager: layersOrderManager2
  }) {
    super();
    __publicField(this, "id");
    __publicField(this, "_layerId");
    __publicField(this, "_sourceId");
    __publicField(this, "_layersOrderManager");
    __publicField(this, "_popup");
    __publicField(this, "_listenersCleaningTasks", /* @__PURE__ */ new Set());
    __publicField(this, "cleanUpListeners", () => {
      this._listenersCleaningTasks.forEach((task) => task());
      this._listenersCleaningTasks.clear();
    });
    /* Active and hover feature state */
    __publicField(this, "_borderLayerId");
    __publicField(this, "resetFeatureStates");
    __publicField(this, "removeBivariatePopupClickHandler");
    __publicField(this, "onMapZoom", (ev) => {
      this.cleanPopup();
    });
    this.id = id;
    this._layersOrderManager = layersOrderManager2;
    this._sourceId = SOURCE_BIVARIATE_PREFIX + this.id;
  }
  async addHoverAndActiveFeatureState(map, style2) {
    await mapLoaded(map);
    const sourceId = this._sourceId;
    const borderLayerId = sourceId + "_border";
    if (map.getLayer(borderLayerId)) {
      return;
    }
    const borderLayerStyle = {
      ...H3_HOVER_LAYER,
      id: borderLayerId,
      source: sourceId,
      "source-layer": SOURCE_LAYER_BIVARIATE
    };
    layerByOrder(map, this._layersOrderManager).addAboveLayerWithSameType(
      borderLayerStyle,
      this.id
    );
    this._borderLayerId = borderLayerId;
    const { onClick, onMouseMove, onMouseLeave, reset: reset2 } = createFeatureStateHandlers({
      map,
      sourceId,
      sourceLayer: SOURCE_LAYER_BIVARIATE
    });
    this._listenersCleaningTasks.add(registerMapListener("click", onClick, 60));
    this._listenersCleaningTasks.add(registerMapListener("mousemove", onMouseMove, 60));
    this._listenersCleaningTasks.add(registerMapListener("mouseleave", onMouseLeave, 60));
    this.resetFeatureStates = reset2;
  }
  async mountBivariateLayer(map, layer, legend2) {
    const maxZoom = getMaxNumeratorZoomLevel(
      [(legend2 == null ? void 0 : legend2.axis.x.quotients) ?? [], (legend2 == null ? void 0 : legend2.axis.y.quotients) ?? []],
      layer.maxZoom || FALLBACK_BIVARIATE_MAX_ZOOM
    );
    const mapSource = {
      type: "vector",
      tiles: layer.source.urls.map((url2) => adaptTileUrl(url2)),
      minzoom: layer.minZoom || FALLBACK_BIVARIATE_MIN_ZOOM,
      maxzoom: maxZoom
    };
    setTileScheme(layer.source.urls[0], mapSource);
    await mapLoaded(map);
    if (map.getSource(this._sourceId) === void 0) {
      map.addSource(this._sourceId, mapSource);
    }
    if (legend2) {
      const layerStyle = generateLayerFromLegend(legend2, SOURCE_LAYER_BIVARIATE);
      const layerId = `${LAYER_BIVARIATE_PREFIX + this.id}`;
      if (map.getLayer(layerId)) {
        return;
      }
      const layer2 = { ...layerStyle, id: layerId, source: this._sourceId };
      layerByOrder(map, this._layersOrderManager).addAboveLayerWithSameType(
        layer2,
        this.id
      );
      this._layerId = layer2.id;
    } else {
      throw new Error(`[Bivariate ${this.id}] Vector layers must have legend`);
    }
  }
  addBivariatePopup(map, legend2) {
    const clickHandler = (ev) => {
      var _a2;
      const features = ev.target.queryRenderedFeatures(ev.point).filter((f2) => f2.source.includes(this._sourceId));
      if (!features.length || !legend2 || !features[0].geometry) return true;
      const [feature] = features;
      if (!isFeatureVisible(feature)) return true;
      if (!feature.properties) return true;
      const [xNumerator, xDenominator] = legend2.axis.x.quotient;
      const [yNumerator, yDenominator] = legend2.axis.y.quotient;
      const xValue = calcValueByNumeratorDenominator(
        feature.properties,
        xNumerator,
        xDenominator
      );
      const yValue = calcValueByNumeratorDenominator(
        feature.properties,
        yNumerator,
        yDenominator
      );
      if (!xValue || !yValue) return true;
      const fillColor = (_a2 = feature.layer.paint) == null ? void 0 : _a2["fill-color"];
      if (!fillColor) return true;
      const rgba = convertFillColorToRGBA(fillColor);
      const cells2 = invertClusters(legend2.steps, "label");
      const cellLabel = getCellLabelByValue(
        legend2.axis.x.steps,
        legend2.axis.y.steps,
        Number(xValue),
        Number(yValue)
      );
      const cellIndex = cells2.findIndex((i2) => i2.label === cellLabel);
      const popupNode = document.createElement("div");
      clientExports.createRoot(popupNode).render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          MapHexTooltip,
          {
            cellLabel: cells2[cellIndex].label,
            cellIndex,
            axis: legend2.axis,
            values: { x: xValue, y: yValue },
            hexagonColor: rgba
          }
        )
      );
      this.cleanPopup();
      this._popup = new maplibreGlExports.Popup({
        closeOnClick: true,
        className: bivariateHexagonPopupContentRoot,
        maxWidth: "none",
        focusAfterOpen: false,
        offset: 15
      }).setLngLat(ev.lngLat).setDOMContent(popupNode).addTo(map);
      this._popup.once("close", () => {
        var _a3;
        (_a3 = this.resetFeatureStates) == null ? void 0 : _a3.call(this);
      });
      return true;
    };
    if (this.removeBivariatePopupClickHandler) {
      this.removeBivariatePopupClickHandler();
      this._listenersCleaningTasks.delete(this.removeBivariatePopupClickHandler);
    }
    const removeClickListener = registerMapListener("click", clickHandler, 60);
    this._listenersCleaningTasks.add(removeClickListener);
    this.removeBivariatePopupClickHandler = removeClickListener;
  }
  async mountMCDALayer(map, layer, style2) {
    const minZoomLevel = isNumber(layer.minZoom) ? layer.minZoom : FALLBACK_BIVARIATE_MIN_ZOOM;
    const maxZoomLevel = isNumber(layer.maxZoom) ? layer.maxZoom : getMaxMCDAZoomLevel(style2.config, FALLBACK_BIVARIATE_MAX_ZOOM);
    const mapSource = {
      type: "vector",
      tiles: layer.source.urls.map((url2) => adaptTileUrl(url2)),
      minzoom: minZoomLevel,
      maxzoom: maxZoomLevel
    };
    setTileScheme(layer.source.urls[0], mapSource);
    await mapLoaded(map);
    if (map.getSource(this._sourceId) === void 0) {
      map.addSource(this._sourceId, mapSource);
    }
    const layerId = `${LAYER_BIVARIATE_PREFIX + this.id}`;
    if (map.getLayer(layerId)) {
      return;
    }
    const layerStyle = styleConfigs.mcda(style2.config)[0];
    const layerRes = { ...layerStyle, id: layerId, source: this._sourceId };
    layerByOrder(map, this._layersOrderManager).addAboveLayerWithSameType(
      layerRes,
      this.id
    );
    this._layerId = layerId;
  }
  addMCDAPopup(map, style2) {
    const clickHandler = (ev) => {
      const features = ev.target.queryRenderedFeatures(ev.point).filter((f2) => f2.source.includes(this._sourceId));
      if (!features.length || !features[0].geometry) return true;
      const [feature] = features;
      if (!isFeatureVisible(feature)) return true;
      const popupNode = generateMCDAPopupContent(feature, style2.config.layers);
      dispatchMetricsEvent("mcda_popup");
      this.cleanPopup();
      this._popup = new maplibreGlExports.Popup({
        closeOnClick: true,
        className: bivariateHexagonPopupContentRoot,
        maxWidth: "none",
        focusAfterOpen: false,
        offset: 15
      }).setLngLat(ev.lngLat).setDOMContent(popupNode).addTo(map);
      this._popup.once("close", () => {
        var _a2;
        (_a2 = this.resetFeatureStates) == null ? void 0 : _a2.call(this);
      });
      return true;
    };
    this.cleanUpListeners();
    const removeClickListener = registerMapListener("click", clickHandler, 60);
    this._listenersCleaningTasks.add(removeClickListener);
  }
  _updateMap(map, layerData, legend2, isVisible, style2) {
    if (layerData == null) return;
    if ((style2 == null ? void 0 : style2.type) === "mcda") {
      this.mountMCDALayer(map, layerData, style2);
      this.addMCDAPopup(map, style2);
    } else {
      this.mountBivariateLayer(map, layerData, legend2);
      this.addBivariatePopup(map, legend2);
    }
    this.addHoverAndActiveFeatureState(map, style2);
    if (!isVisible) this.willHide({ map });
  }
  cleanPopup() {
    if (this._popup) {
      this._popup.remove();
      this._popup = null;
    }
  }
  /* ========== Hooks ========== */
  willSourceUpdate({ map, state }) {
    if (state.source) {
      console.debug(`[${this.id} layer renderer]: Source updated`);
      this._updateMap(
        map,
        state.source,
        state.legend,
        state.isVisible,
        state.style
      );
    } else {
      console.debug(
        `[${this.id} layer renderer]: Source not available, waiting for next update`
      );
    }
  }
  willMount({ map, state }) {
    map.on("zoom", this.onMapZoom);
    if (state.source) {
      this._updateMap(
        map,
        state.source,
        state.legend,
        state.isVisible,
        state.style
      );
    } else {
      console.debug(
        `[${this.id} layer renderer]: Source not available, waiting for next update`
      );
    }
  }
  willUnMount({ map }) {
    var _a2;
    if (this._layerId && map.getLayer(this._layerId)) {
      map.removeLayer(this._layerId);
      this._layerId = void 0;
    } else {
      console.warn(
        `Can't remove layer with ID: ${this._layerId}. Layer does't exist in map`
      );
    }
    if (this._borderLayerId && map.getLayer(this._borderLayerId)) {
      map.removeLayer(this._borderLayerId);
      this._borderLayerId = void 0;
    } else {
      console.warn(
        `Can't remove layer with ID: ${this._borderLayerId}. Layer does't exist in map`
      );
    }
    this.cleanPopup();
    (_a2 = this.resetFeatureStates) == null ? void 0 : _a2.call(this);
    if (map.getSource(this._sourceId)) {
      map.removeSource(this._sourceId);
    } else {
      console.warn(
        `Can't remove source with ID: ${this._sourceId}. Source does't exist in map`
      );
    }
    this.cleanUpListeners();
    map.off("zoom", this.onMapZoom);
  }
  willHide({ map }) {
    if (this._layerId === void 0 || map === null) return;
    if (map.getLayer(this._layerId) !== void 0) {
      map.setLayoutProperty(this._layerId, "visibility", "none");
      this.cleanPopup();
    } else {
      console.warn(
        `Can't hide layer with ID: ${this._layerId}. Layer doesn't exist on the map`
      );
    }
  }
  willUnhide({ map }) {
    if (this._layerId === void 0 || map === null) return;
    if (map.getLayer(this._layerId) !== void 0) {
      map.setLayoutProperty(this._layerId, "visibility", "visible");
    } else {
      console.warn(
        `Cannot unhide layer with ID: ${this._layerId}. Layer doesn't exist on the map`
      );
    }
  }
  willDestroy({ map }) {
    if (this._layerId === void 0 || this._borderLayerId === void 0 || map === null)
      return;
    if (map.getLayer(this._layerId) !== void 0 || map.getLayer(this._borderLayerId) !== void 0) {
      this.willUnMount({ map });
    }
  }
}
const enabledLayersAtom$1 = createSetAtom(/* @__PURE__ */ new Set(), "enabledLayers");
const mountedLayersAtom = createMapAtom(
  /* @__PURE__ */ new Map(),
  "mountedLayers"
);
let _lastUpdatedState_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = mountedLayersAtom.getState();
mountedLayersAtom.subscribe((s2) => {
  _lastUpdatedState_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = s2;
});
const currentMapAtom = createAtom(
  {
    setMap: (map) => map,
    resetMap: () => null
  },
  ({ onAction, schedule }, state = null) => {
    onAction("setMap", (map) => {
      if (map !== state) {
        state = map;
        schedule((dispatch) => {
          dispatch(mountedLayersAtom.clear());
        });
      }
    });
    onAction("resetMap", () => {
      state = null;
      schedule((dispatch) => {
        dispatch(mountedLayersAtom.clear());
      });
    });
    return state;
  },
  "[Shared state] currentMapAtom"
);
function downloadObject(data, fileName, indentation) {
  const file = new Blob([JSON.stringify(data, null, indentation)], { type: "json" });
  const a2 = document.createElement("a");
  const url2 = URL.createObjectURL(file);
  a2.href = url2;
  a2.download = fileName;
  document.body.appendChild(a2);
  a2.click();
  clearTimeout(
    setTimeout(function() {
      document.body.removeChild(a2);
      window.URL.revokeObjectURL(url2);
    }, 0)
  );
}
const FOCUSED_GEOMETRY_LOGICAL_LAYER_ID = "focused-geometry";
const REFERENCE_AREA_LOGICAL_LAYER_ID = "reference-area";
TranslationService.t(
  "reference_area_layer.settings.name"
);
/*!
 * hash-wasm (https://www.npmjs.com/package/hash-wasm)
 * (c) Dani Biro
 * @license MIT
 */
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
class Mutex {
  constructor() {
    this.mutex = Promise.resolve();
  }
  lock() {
    let begin = () => {
    };
    this.mutex = this.mutex.then(() => new Promise(begin));
    return new Promise((res) => {
      begin = res;
    });
  }
  dispatch(fn) {
    return __awaiter(this, void 0, void 0, function* () {
      const unlock = yield this.lock();
      try {
        return yield Promise.resolve(fn());
      } finally {
        unlock();
      }
    });
  }
}
var _a;
function getGlobal() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  return global;
}
const globalObject = getGlobal();
const nodeBuffer = (_a = globalObject.Buffer) !== null && _a !== void 0 ? _a : null;
const textEncoder = globalObject.TextEncoder ? new globalObject.TextEncoder() : null;
function hexCharCodesToInt(a2, b2) {
  return (a2 & 15) + (a2 >> 6 | a2 >> 3 & 8) << 4 | (b2 & 15) + (b2 >> 6 | b2 >> 3 & 8);
}
function writeHexToUInt8(buf, str) {
  const size = str.length >> 1;
  for (let i2 = 0; i2 < size; i2++) {
    const index2 = i2 << 1;
    buf[i2] = hexCharCodesToInt(str.charCodeAt(index2), str.charCodeAt(index2 + 1));
  }
}
function hexStringEqualsUInt8(str, buf) {
  if (str.length !== buf.length * 2) {
    return false;
  }
  for (let i2 = 0; i2 < buf.length; i2++) {
    const strIndex = i2 << 1;
    if (buf[i2] !== hexCharCodesToInt(str.charCodeAt(strIndex), str.charCodeAt(strIndex + 1))) {
      return false;
    }
  }
  return true;
}
const alpha = "a".charCodeAt(0) - 10;
const digit = "0".charCodeAt(0);
function getDigestHex(tmpBuffer, input, hashLength) {
  let p2 = 0;
  for (let i2 = 0; i2 < hashLength; i2++) {
    let nibble = input[i2] >>> 4;
    tmpBuffer[p2++] = nibble > 9 ? nibble + alpha : nibble + digit;
    nibble = input[i2] & 15;
    tmpBuffer[p2++] = nibble > 9 ? nibble + alpha : nibble + digit;
  }
  return String.fromCharCode.apply(null, tmpBuffer);
}
const getUInt8Buffer = nodeBuffer !== null ? (data) => {
  if (typeof data === "string") {
    const buf = nodeBuffer.from(data, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
  }
  if (nodeBuffer.isBuffer(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.length);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
  throw new Error("Invalid data type!");
} : (data) => {
  if (typeof data === "string") {
    return textEncoder.encode(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
  throw new Error("Invalid data type!");
};
const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const base64Lookup = new Uint8Array(256);
for (let i2 = 0; i2 < base64Chars.length; i2++) {
  base64Lookup[base64Chars.charCodeAt(i2)] = i2;
}
function getDecodeBase64Length(data) {
  let bufferLength = Math.floor(data.length * 0.75);
  const len = data.length;
  if (data[len - 1] === "=") {
    bufferLength -= 1;
    if (data[len - 2] === "=") {
      bufferLength -= 1;
    }
  }
  return bufferLength;
}
function decodeBase64(data) {
  const bufferLength = getDecodeBase64Length(data);
  const len = data.length;
  const bytes = new Uint8Array(bufferLength);
  let p2 = 0;
  for (let i2 = 0; i2 < len; i2 += 4) {
    const encoded1 = base64Lookup[data.charCodeAt(i2)];
    const encoded2 = base64Lookup[data.charCodeAt(i2 + 1)];
    const encoded3 = base64Lookup[data.charCodeAt(i2 + 2)];
    const encoded4 = base64Lookup[data.charCodeAt(i2 + 3)];
    bytes[p2] = encoded1 << 2 | encoded2 >> 4;
    p2 += 1;
    bytes[p2] = (encoded2 & 15) << 4 | encoded3 >> 2;
    p2 += 1;
    bytes[p2] = (encoded3 & 3) << 6 | encoded4 & 63;
    p2 += 1;
  }
  return bytes;
}
const MAX_HEAP = 16 * 1024;
const WASM_FUNC_HASH_LENGTH = 4;
const wasmMutex = new Mutex();
const wasmModuleCache = /* @__PURE__ */ new Map();
function WASMInterface(binary, hashLength) {
  return __awaiter(this, void 0, void 0, function* () {
    let wasmInstance = null;
    let memoryView = null;
    let initialized = false;
    if (typeof WebAssembly === "undefined") {
      throw new Error("WebAssembly is not supported in this environment!");
    }
    const writeMemory = (data, offset2 = 0) => {
      memoryView.set(data, offset2);
    };
    const getMemory = () => memoryView;
    const getExports = () => wasmInstance.exports;
    const setMemorySize = (totalSize) => {
      wasmInstance.exports.Hash_SetMemorySize(totalSize);
      const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      memoryView = new Uint8Array(memoryBuffer, arrayOffset, totalSize);
    };
    const getStateSize = () => {
      const view = new DataView(wasmInstance.exports.memory.buffer);
      const stateSize = view.getUint32(wasmInstance.exports.STATE_SIZE, true);
      return stateSize;
    };
    const loadWASMPromise = wasmMutex.dispatch(() => __awaiter(this, void 0, void 0, function* () {
      if (!wasmModuleCache.has(binary.name)) {
        const asm = decodeBase64(binary.data);
        const promise = WebAssembly.compile(asm);
        wasmModuleCache.set(binary.name, promise);
      }
      const module = yield wasmModuleCache.get(binary.name);
      wasmInstance = yield WebAssembly.instantiate(module, {
        // env: {
        //   emscripten_memcpy_big: (dest, src, num) => {
        //     const memoryBuffer = wasmInstance.exports.memory.buffer;
        //     const memView = new Uint8Array(memoryBuffer, 0);
        //     memView.set(memView.subarray(src, src + num), dest);
        //   },
        //   print_memory: (offset, len) => {
        //     const memoryBuffer = wasmInstance.exports.memory.buffer;
        //     const memView = new Uint8Array(memoryBuffer, 0);
        //     console.log('print_int32', memView.subarray(offset, offset + len));
        //   },
        // },
      });
    }));
    const setupInterface = () => __awaiter(this, void 0, void 0, function* () {
      if (!wasmInstance) {
        yield loadWASMPromise;
      }
      const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      memoryView = new Uint8Array(memoryBuffer, arrayOffset, MAX_HEAP);
    });
    const init = (bits = null) => {
      initialized = true;
      wasmInstance.exports.Hash_Init(bits);
    };
    const updateUInt8Array = (data) => {
      let read = 0;
      while (read < data.length) {
        const chunk = data.subarray(read, read + MAX_HEAP);
        read += chunk.length;
        memoryView.set(chunk);
        wasmInstance.exports.Hash_Update(chunk.length);
      }
    };
    const update = (data) => {
      if (!initialized) {
        throw new Error("update() called before init()");
      }
      const Uint8Buffer = getUInt8Buffer(data);
      updateUInt8Array(Uint8Buffer);
    };
    const digestChars = new Uint8Array(hashLength * 2);
    const digest = (outputType, padding = null) => {
      if (!initialized) {
        throw new Error("digest() called before init()");
      }
      initialized = false;
      wasmInstance.exports.Hash_Final(padding);
      if (outputType === "binary") {
        return memoryView.slice(0, hashLength);
      }
      return getDigestHex(digestChars, memoryView, hashLength);
    };
    const save2 = () => {
      if (!initialized) {
        throw new Error("save() can only be called after init() and before digest()");
      }
      const stateOffset = wasmInstance.exports.Hash_GetState();
      const stateLength = getStateSize();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      const internalState = new Uint8Array(memoryBuffer, stateOffset, stateLength);
      const prefixedState = new Uint8Array(WASM_FUNC_HASH_LENGTH + stateLength);
      writeHexToUInt8(prefixedState, binary.hash);
      prefixedState.set(internalState, WASM_FUNC_HASH_LENGTH);
      return prefixedState;
    };
    const load = (state) => {
      if (!(state instanceof Uint8Array)) {
        throw new Error("load() expects an Uint8Array generated by save()");
      }
      const stateOffset = wasmInstance.exports.Hash_GetState();
      const stateLength = getStateSize();
      const overallLength = WASM_FUNC_HASH_LENGTH + stateLength;
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      if (state.length !== overallLength) {
        throw new Error(`Bad state length (expected ${overallLength} bytes, got ${state.length})`);
      }
      if (!hexStringEqualsUInt8(binary.hash, state.subarray(0, WASM_FUNC_HASH_LENGTH))) {
        throw new Error("This state was written by an incompatible hash implementation");
      }
      const internalState = state.subarray(WASM_FUNC_HASH_LENGTH);
      new Uint8Array(memoryBuffer, stateOffset, stateLength).set(internalState);
      initialized = true;
    };
    const isDataShort = (data) => {
      if (typeof data === "string") {
        return data.length < MAX_HEAP / 4;
      }
      return data.byteLength < MAX_HEAP;
    };
    let canSimplify = isDataShort;
    switch (binary.name) {
      case "argon2":
      case "scrypt":
        canSimplify = () => true;
        break;
      case "blake2b":
      case "blake2s":
        canSimplify = (data, initParam) => initParam <= 512 && isDataShort(data);
        break;
      case "blake3":
        canSimplify = (data, initParam) => initParam === 0 && isDataShort(data);
        break;
      case "xxhash64":
      // cannot simplify
      case "xxhash3":
      case "xxhash128":
      case "crc64":
        canSimplify = () => false;
        break;
    }
    const calculate = (data, initParam = null, digestParam = null) => {
      if (!canSimplify(data, initParam)) {
        init(initParam);
        update(data);
        return digest("hex", digestParam);
      }
      const buffer = getUInt8Buffer(data);
      memoryView.set(buffer);
      wasmInstance.exports.Hash_Calculate(buffer.length, initParam, digestParam);
      return getDigestHex(digestChars, memoryView, hashLength);
    };
    yield setupInterface();
    return {
      getMemory,
      writeMemory,
      getExports,
      setMemorySize,
      init,
      update,
      digest,
      save: save2,
      load,
      calculate,
      hashLength
    };
  });
}
function lockedCreate(mutex, binary, hashLength) {
  return __awaiter(this, void 0, void 0, function* () {
    const unlock = yield mutex.lock();
    const wasm = yield WASMInterface(binary, hashLength);
    unlock();
    return wasm;
  });
}
new Mutex();
new Mutex();
new Mutex();
new Mutex();
var name$g = "crc32";
var data$g = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwgHAAEBAQIAAwUEAQECAgYOAn8BQZDJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAgtIYXNoX1VwZGF0ZQADCkhhc2hfRmluYWwABA1IYXNoX0dldFN0YXRlAAUOSGFzaF9DYWxjdWxhdGUABgpTVEFURV9TSVpFAwEKkggHBQBBgAkLwwMBA39BgIkBIQFBACECA0AgAUEAQQBBAEEAQQBBAEEAQQAgAkEBcWsgAHEgAkEBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnM2AgAgAUEEaiEBIAJBAWoiAkGAAkcNAAtBACEAA0AgAEGEkQFqIABBhIkBaigCACICQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEmQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYShAWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhKkBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEsQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYS5AWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhMEBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzNgIAIABBBGoiAEH8B0cNAAsLJwACQEEAKAKAyQEgAEYNACAAEAFBACAANgKAyQELQQBBADYChMkBC4gDAQN/QQAoAoTJAUF/cyEBQYAJIQICQCAAQQhJDQBBgAkhAgNAIAJBBGooAgAiA0EOdkH8B3FBgJEBaigCACADQRZ2QfwHcUGAiQFqKAIAcyADQQZ2QfwHcUGAmQFqKAIAcyADQf8BcUECdEGAoQFqKAIAcyACKAIAIAFzIgFBFnZB/AdxQYCpAWooAgBzIAFBDnZB/AdxQYCxAWooAgBzIAFBBnZB/AdxQYC5AWooAgBzIAFB/wFxQQJ0QYDBAWooAgBzIQEgAkEIaiECIABBeGoiAEEHSw0ACwsCQCAARQ0AAkACQCAAQQFxDQAgACEDDAELIAFB/wFxIAItAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQFqIQIgAEF/aiEDCyAAQQFGDQADQCABQf8BcSACLQAAc0ECdEGAiQFqKAIAIAFBCHZzIgFB/wFxIAJBAWotAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQJqIQIgA0F+aiIDDQALC0EAIAFBf3M2AoTJAQsyAQF/QQBBACgChMkBIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyNgKACQsGAEGEyQELWQACQEEAKAKAyQEgAUYNACABEAFBACABNgKAyQELQQBBADYChMkBIAAQA0EAQQAoAoTJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCgAkLCwsBAEGACAsEBAAAAA==";
var hash$g = "d2eba587";
var wasmJson$g = {
  name: name$g,
  data: data$g,
  hash: hash$g
};
const mutex$h = new Mutex();
let wasmCache$h = null;
function validatePoly(poly) {
  if (!Number.isInteger(poly) || poly < 0 || poly > 4294967295) {
    return new Error("Polynomial must be a valid 32-bit long unsigned integer");
  }
  return null;
}
function crc32(data, polynomial = 3988292384) {
  if (validatePoly(polynomial)) {
    return Promise.reject(validatePoly(polynomial));
  }
  if (wasmCache$h === null) {
    return lockedCreate(mutex$h, wasmJson$g, 4).then((wasm) => {
      wasmCache$h = wasm;
      return wasmCache$h.calculate(data, polynomial);
    });
  }
  try {
    const hash = wasmCache$h.calculate(data, polynomial);
    return Promise.resolve(hash);
  } catch (err) {
    return Promise.reject(err);
  }
}
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
new Mutex();
const episodesPanelState = createAtom(
  {
    open: () => null,
    close: () => null
  },
  ({ onAction }, state = { isOpen: false }) => {
    onAction("open", () => state = { ...state, isOpen: true });
    onAction("close", () => state = { ...state, isOpen: false });
    return state;
  },
  "episodesPanelState"
);
const focusedGeometryAtom = createAtom(
  {
    setFocusedGeometry: (source, geometry) => ({ source, geometry }),
    _update: (fGeometry) => fGeometry,
    reset: () => null,
    episodesPanelState
  },
  ({ onAction, schedule, create: create2 }, state = null) => {
    onAction("setFocusedGeometry", ({ source, geometry }) => {
      if (source && geometry) {
        dispatchMetricsEvent("select_area");
        schedule(async (dispatch, ctx) => {
          const hash = await crc32(JSON.stringify({ geometry, source }));
          if (!state || !ctx.hash || ctx.hash !== hash) {
            ctx.hash = hash;
            const geometryWithHash = { ...geometry, hash };
            dispatch(create2("_update", { source, geometry: geometryWithHash }));
          }
        });
      } else {
        state = null;
      }
    });
    onAction("reset", () => {
      state = null;
    });
    onAction("_update", (fGeometry) => {
      state = fGeometry;
    });
    return state;
  },
  "[Shared state] focusedGeometryAtom"
);
function updateReferenceArea(referenceAreaGeometry) {
  const referenceAreaConfiguration = { referenceAreaGeometry };
  return updateFeatureConfiguration(
    AppFeature.REFERENCE_AREA,
    referenceAreaConfiguration,
    {
      errorsConfig: { messages: TranslationService.t("reference_area.error_couldnt_save") }
    }
  );
}
function updateFeatureConfiguration(featureId, featureConfiguration, requestConfig) {
  return apiClient.put(
    `/features/${featureId}?appId=${configRepo.get().id}`,
    featureConfiguration,
    {
      ...requestConfig,
      authRequirement: apiClient.AUTH_REQUIREMENT.MUST
    }
  );
}
const referenceAreaAtom = atom(
  getReferenceAreaFromConfigRepo(),
  "[Shared state] referenceAreaAtom"
);
function getReferenceAreaFromConfigRepo() {
  const features = configRepo.get().features;
  const refAreaGeometry = features[AppFeature.REFERENCE_AREA] && typeof features[AppFeature.REFERENCE_AREA] === "object" ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    features[AppFeature.REFERENCE_AREA].referenceAreaGeometry
  ) : null;
  if ((refAreaGeometry == null ? void 0 : refAreaGeometry.type) === "FeatureCollection" || (refAreaGeometry == null ? void 0 : refAreaGeometry.type) === "Feature") {
    return refAreaGeometry;
  }
  return null;
}
action(async (ctx, geometry) => {
  if (geometry) {
    dispatchMetricsEvent("ref_area");
    const hash = geometry.hash ? geometry.hash : await crc32(JSON.stringify({ geometry }));
    const referenceAreaOld = ctx.get(referenceAreaAtom);
    if (!referenceAreaOld || !referenceAreaOld.hash || referenceAreaOld.hash !== hash) {
      const geometryWithHash = { ...geometry, hash };
      referenceAreaAtom(ctx, geometryWithHash);
    }
  } else {
    referenceAreaAtom(ctx, null);
  }
}, "setReferenceArea");
const resetReferenceArea = action(async (ctx) => {
  await updateReferenceArea(null);
  referenceAreaAtom(ctx, null);
}, "resetReferenceArea");
const hiddenLayersAtom = createSetAtom(/* @__PURE__ */ new Set(), "hiddenLayers");
const layersEditorsAtom = createMapAtom(
  /* @__PURE__ */ new Map(),
  "layersLegends"
);
function deepFreeze(object) {
  if (object && typeof object === "object") {
    const propNames = Object.getOwnPropertyNames(object);
    for (const name of propNames) {
      const value2 = object[name];
      deepFreeze(value2);
    }
    return Object.freeze(object);
  }
  return object;
}
const defaultSettings$1 = groupSettings;
const settingsMock$1 = new Proxy(defaultSettings$1, {
  get(target, prop, receiver) {
    const originalValue = Reflect.get(target, prop, receiver);
    if (originalValue) return originalValue;
    return {
      name: prop,
      openByDefault: true,
      mutuallyExclusive: false,
      order: 100
    };
  },
  set(target, prop, val, receiver) {
    return Reflect.set(target, prop, val, receiver);
  }
});
const layersGroupsSettingsAtom = createAtom(
  {},
  ({}, state = settingsMock$1) => {
    return state;
  },
  "layersGroupsSettingsAtom"
);
const defaultSettings = categoriesSettings;
const settingsMock = new Proxy(defaultSettings, {
  get(target, prop, receiver) {
    const originalValue = Reflect.get(target, prop, receiver);
    if (originalValue) return originalValue;
    return {
      name: prop,
      openByDefault: true,
      mutuallyExclusive: false,
      order: 100
    };
  },
  set(target, prop, val, receiver) {
    return Reflect.set(target, prop, val, receiver);
  }
});
const layersCategoriesSettingsAtom = createAtom(
  {},
  ({}, state = settingsMock) => {
    return state;
  },
  "layersCategoriesSettingsAtom"
);
const getMutualExcludedActions = (() => {
  let groupsSettings = null;
  layersGroupsSettingsAtom.subscribe((s2) => groupsSettings = s2);
  let categorySettings = null;
  layersCategoriesSettingsAtom.subscribe((s2) => categorySettings = s2);
  let enabledLayers = null;
  enabledLayersAtom$1.subscribe((s2) => enabledLayers = s2);
  let layersSettings = null;
  layersSettingsAtom$1.subscribe((s2) => layersSettings = s2);
  return (state) => {
    var _a2, _b, _c, _d;
    if (!groupsSettings || !categorySettings || !enabledLayers || !layersSettings) {
      return [];
    }
    const targetLayerCategory = (_a2 = state.settings) == null ? void 0 : _a2.category;
    const targetLayerGroup = (_b = state.settings) == null ? void 0 : _b.group;
    const isInMutuallyExclusiveCategory = targetLayerCategory && ((_c = categorySettings[targetLayerCategory]) == null ? void 0 : _c.mutuallyExclusive);
    const isInMutuallyExclusiveGroup = targetLayerGroup && ((_d = groupsSettings[targetLayerGroup]) == null ? void 0 : _d.mutuallyExclusive);
    if (!isInMutuallyExclusiveCategory && !isInMutuallyExclusiveGroup) {
      return [];
    }
    const mutualExcludeIds = /* @__PURE__ */ new Set();
    enabledLayers.forEach((enabledLayerId) => {
      var _a3, _b2;
      if (state.id === enabledLayerId) return;
      const enabledLayerSettings = layersSettings.get(enabledLayerId);
      if (!enabledLayerSettings) return;
      if (isInMutuallyExclusiveCategory) {
        if (((_a3 = enabledLayerSettings.data) == null ? void 0 : _a3.category) === targetLayerCategory) {
          mutualExcludeIds.add(enabledLayerId);
        }
      } else if (isInMutuallyExclusiveGroup) {
        if (((_b2 = enabledLayerSettings.data) == null ? void 0 : _b2.group) === targetLayerGroup) {
          mutualExcludeIds.add(enabledLayerId);
        }
      }
    });
    return Array.from(mutualExcludeIds).map((id) => enabledLayersAtom$1.delete(id));
  };
})();
const logicalLayerActions = {
  enable: () => null,
  disable: () => null,
  hide: () => null,
  show: () => null,
  download: () => null,
  destroy: () => null,
  clean: () => null
};
const annotatedError = (id) => (...e) => console.error(`[Logical layer: ${id}]:`, ...e);
function createLogicalLayerAtom(id, renderer, registry, customMap) {
  let hasBeenDestroyed = false;
  const logicalLayerAtom = createAtom(
    {
      ...logicalLayerActions,
      layersSettingsAtom: layersSettingsAtom$1,
      layersLegendsAtom,
      layersMetaAtom,
      layersSourcesAtom,
      enabledLayersAtom: enabledLayersAtom$1,
      mountedLayersAtom,
      hiddenLayersAtom,
      layersMenusAtom,
      layersEditorsAtom,
      _patchState: (newState) => newState
    },
    ({ get: get2, onAction, getUnlistedState, onInit, schedule, create: create2 }, state = {
      id,
      error: null,
      isEnabled: false,
      isLoading: false,
      isMounted: false,
      isEditable: false,
      isVisible: true,
      isDownloadable: false,
      settings: null,
      meta: null,
      legend: null,
      source: null,
      contextMenu: null,
      style: null,
      editor: null
    }) => {
      var _a2, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k;
      const actions = [];
      const map = customMap || getUnlistedState(currentMapAtom);
      const fallbackAsyncState = {
        isLoading: false,
        data: null,
        error: null
      };
      const asyncLayerSettings = get2("layersSettingsAtom").get(id) ?? fallbackAsyncState;
      const asyncLayerMeta = get2("layersMetaAtom").get(id) ?? fallbackAsyncState;
      const asyncLayerLegend = get2("layersLegendsAtom").get(id) ?? fallbackAsyncState;
      const asyncLayerSource = get2("layersSourcesAtom").get(id) ?? fallbackAsyncState;
      const asyncLayerEditor = get2("layersEditorsAtom").get(id) ?? fallbackAsyncState;
      const layersMenus = get2("layersMenusAtom").get(id) ?? null;
      const logError = annotatedError(state.id);
      let mounted = get2("mountedLayersAtom");
      if (_lastUpdatedState_DO_NOT_USE_OR_YOU_WILL_BE_FIRED !== mounted) {
        if (configRepo.get().id === "8906feaf-fc18-4180-bb5f-ff545cf65100") {
          console.debug("Apply workaround");
          mounted = _lastUpdatedState_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        }
      }
      const newState = {
        id: state.id,
        error: state.error,
        isLoading: [
          asyncLayerSettings,
          asyncLayerMeta,
          asyncLayerLegend,
          asyncLayerSource
        ].some((s2) => s2.isLoading),
        isEnabled: get2("enabledLayersAtom").has(id),
        isMounted: mounted.has(id),
        isVisible: !get2("hiddenLayersAtom").has(id),
        isDownloadable: ((_a2 = asyncLayerSource.data) == null ? void 0 : _a2.source.type) === "geojson" || ((_c = (_b = asyncLayerSource.data) == null ? void 0 : _b.style) == null ? void 0 : _c.type) === "mcda" || ((_e2 = (_d = asyncLayerSource.data) == null ? void 0 : _d.style) == null ? void 0 : _e2.type) === "multivariate",
        isEditable: (((_g = (_f = asyncLayerSource.data) == null ? void 0 : _f.style) == null ? void 0 : _g.type) === "mcda" || ((_i = (_h = asyncLayerSource.data) == null ? void 0 : _h.style) == null ? void 0 : _i.type) === "multivariate") && !!((_j = asyncLayerSettings.data) == null ? void 0 : _j.ownedByUser),
        settings: deepFreeze(asyncLayerSettings.data),
        meta: deepFreeze(asyncLayerMeta.data),
        legend: deepFreeze(asyncLayerLegend.data),
        source: deepFreeze(asyncLayerSource.data),
        contextMenu: deepFreeze(layersMenus),
        style: ((_k = asyncLayerSource.data) == null ? void 0 : _k.style) ?? null,
        editor: deepFreeze(asyncLayerEditor.data)
      };
      onInit(() => {
        try {
          renderer.willInit({ map, state: { ...newState } });
        } catch (e) {
          logError(e);
          newState.error = e;
        }
      });
      onAction("enable", () => {
        newState.isEnabled = true;
        actions.push(enabledLayersAtom$1.set(id), ...getMutualExcludedActions(state));
      });
      onAction("disable", () => {
        newState.isEnabled = false;
        actions.push(enabledLayersAtom$1.delete(id));
      });
      onAction("hide", () => {
        if (!map) return;
        try {
          renderer.willHide({ map, state: { ...newState } });
          newState.isVisible = false;
          actions.push(hiddenLayersAtom.set(id));
        } catch (e) {
          logError(e);
          newState.error = e;
        }
      });
      onAction("show", () => {
        if (!map) return;
        try {
          renderer.willUnhide({ map, state: { ...newState } });
          newState.isVisible = true;
          actions.push(hiddenLayersAtom.delete(id));
        } catch (e) {
          logError(e);
          newState.error = e;
        }
      });
      onAction("download", () => {
        var _a3, _b2, _c2, _d2, _e3, _f2;
        try {
          if (!state.isDownloadable) return;
          if (!((_a3 = state.source) == null ? void 0 : _a3.source)) {
            logError("Download failed, source unavailable");
            return;
          }
          if (state.source.source.type === "geojson") {
            downloadObject(
              state.source.source.data,
              `${((_b2 = state.settings) == null ? void 0 : _b2.name) && spacesToUnderscore(state.settings.name) || state.id || "map layer"}_${(/* @__PURE__ */ new Date()).toISOString()}.geojson`
            );
          } else if (((_c2 = state.source.style) == null ? void 0 : _c2.type) === "mcda") {
            downloadObject(
              state.source.style,
              `${((_d2 = state.settings) == null ? void 0 : _d2.name) || state.id || "MCDA"}-${(/* @__PURE__ */ new Date()).toISOString()}.json`,
              2
            );
          } else if (((_e3 = state.source.style) == null ? void 0 : _e3.type) === "multivariate") {
            downloadObject(
              state.source.style,
              `${((_f2 = state.settings) == null ? void 0 : _f2.name) || state.id || "MVA"}-${(/* @__PURE__ */ new Date()).toISOString()}.json`,
              2
            );
          } else {
            logError("Only geojson layers, MCDA or MVA can be downloaded");
          }
        } catch (e) {
          logError(e);
          newState.error = e;
        }
      });
      onAction("clean", () => {
        if (id === FOCUSED_GEOMETRY_LOGICAL_LAYER_ID) {
          schedule((dispatch) => dispatch(focusedGeometryAtom.reset()));
        }
        if (id === REFERENCE_AREA_LOGICAL_LAYER_ID) {
          resetReferenceArea(store.v3ctx);
        }
      });
      const syncNotFinished = !hasBeenDestroyed && newState.isEnabled !== newState.isMounted;
      const mountStateNotApplied = state.isMounted !== newState.isMounted;
      if (!mountStateNotApplied && syncNotFinished && !newState.isLoading) {
        try {
          if (!newState.isMounted) {
            if (map) {
              renderer.willMount({ map, state: { ...newState } });
              newState.isMounted = true;
              actions.push(mountedLayersAtom.set(id, logicalLayerAtom));
            }
          } else {
            if (map) {
              renderer.willUnMount({
                map,
                state: { ...newState }
              });
              newState.isMounted = false;
              actions.push(mountedLayersAtom.delete(id));
            }
          }
        } catch (e) {
          logError(e);
          newState.error = e;
        }
      }
      if (state.isMounted && newState.isMounted) {
        const legendHaveUpdate = state.legend !== newState.legend;
        if (legendHaveUpdate) {
          if (map)
            try {
              renderer.willLegendUpdate({
                map,
                state: { ...newState }
              });
            } catch (e) {
              logError(e);
              newState.error = e;
            }
        }
        const sourceHaveUpdate = state.source !== newState.source;
        if (sourceHaveUpdate) {
          if (map)
            try {
              renderer.willSourceUpdate({
                map,
                state: { ...newState }
              });
            } catch (e) {
              logError(e);
              newState.error = e;
            }
        }
      }
      onAction("destroy", () => {
        hasBeenDestroyed = true;
        try {
          renderer.willDestroy({ map, state: { ...newState } });
          const layersRegistryState = getUnlistedState(registry);
          if (layersRegistryState.has(state.id)) {
            actions.push(
              registry.unregister(state.id, {
                notifyLayerAboutDestroy: false
                // cancel layer.destroy() call from registry
              })
            );
          }
        } catch (e) {
          logError(e);
          newState.error = e;
        }
      });
      onAction("_patchState", (patch) => {
        Object.assign(newState, patch);
      });
      if (actions.length) {
        schedule((dispatch) => {
          dispatch(actions);
          renderer.setErrorState((e) => {
            logError(e);
            dispatch(create2("_patchState", { error: e.message }));
          });
        });
      }
      return newState;
    },
    { id, decorators: [] }
  );
  return logicalLayerAtom;
}
const cleanUpActionsMap = /* @__PURE__ */ new WeakMap();
const unsubscribes = /* @__PURE__ */ new WeakMap();
const createLayersRegistryAtom = (id) => {
  const atom2 = createAtom(
    {
      register: (r2) => Array.isArray(r2) ? r2 : [r2],
      unregister: (id2, { notifyLayerAboutDestroy } = {}) => ({ ids: Array.isArray(id2) ? id2 : [id2], notifyLayerAboutDestroy }),
      _delete: (id2) => Array.isArray(id2) ? id2 : [id2]
    },
    ({ onAction, create: create2, schedule }, state = /* @__PURE__ */ new Map()) => {
      onAction("register", (requests) => {
        const newState = new Map(state);
        requests.forEach(({ id: id2, renderer, cleanUpActions, map }) => {
          const layerAtom = createLogicalLayerAtom(id2, renderer, atom2, map);
          newState.set(id2, layerAtom);
          if (cleanUpActions) {
            cleanUpActionsMap.set(layerAtom, cleanUpActions);
          }
          unsubscribes.set(
            layerAtom,
            layerAtom.subscribe(() => null)
          );
        });
        state = newState;
      });
      onAction("unregister", ({ ids, notifyLayerAboutDestroy }) => {
        ids.forEach((id2) => {
          const layerAtom = state.get(id2);
          if (layerAtom) {
            schedule((dispatch) => {
              const unsubscribe = unsubscribes.get(layerAtom);
              unsubscribe();
              const actions = [
                ...cleanUpActionsMap.get(layerAtom) || [],
                /* Not clear enabledLayersAtom, because it store only user choices,
                 * and we want to store it even when layer unavailable */
                mountedLayersAtom.delete(id2),
                hiddenLayersAtom.delete(id2),
                /**
                 * notifyLayerAboutDestroy == false means that
                 * this action called from inside layerAtom.destroy()
                 * and not needed to cal it again
                 */
                notifyLayerAboutDestroy && layerAtom.destroy(),
                /* Delete layer from registry in one transaction with other states */
                create2("_delete", id2)
              ].filter((i2) => Boolean(i2));
              dispatch(actions);
            });
          } else {
            console.error(`Attempt unregister not existing layer with id: ${id2}`);
          }
        });
      });
      onAction("_delete", (ids) => {
        const newState = new Map(state);
        ids.forEach((id2) => {
          newState.delete(id2);
        });
        state = newState;
      });
      return state;
    },
    id
  );
  return atom2;
};
const layersRegistryAtom$1 = createLayersRegistryAtom("layersRegistryAtom");
function v3toV2(v3atom, v3Actions, store$1 = store) {
  const v2Atom = createAtom({}, () => {
  }, { store: store$1, v3atom });
  if (v3Actions) {
    Object.entries(v3Actions).map((act) => actionV3ToV2(act, [v2Atom], store$1)).forEach(
      ({ name, actionCreator }) => Object.assign(v2Atom, { [name]: actionCreator })
    );
  }
  return v2Atom;
}
let actionIdCounter = 0;
function actionV3ToV2([name, action$1], targets, store$1 = store) {
  const type = action$1.__reatom.name ?? `name_${actionIdCounter++}`;
  const actionCreator = function(payload) {
    return {
      payload,
      type,
      v3action: action$1,
      targets
    };
  };
  actionCreator.type = type;
  actionCreator.dispatch = (...a2) => store$1.dispatch(actionCreator(...a2));
  actionCreator.v3action = action(type);
  return { name, actionCreator };
}
function isAtomLike(state) {
  return "loading" in state || "error" in state;
}
function generateErrorMessage(e) {
  if (isAbortError(e)) {
    return ABORT_ERROR_MESSAGE;
  } else {
    return isErrorWithMessage(e) ? e.message : typeof e === "string" ? e : "Unknown";
  }
}
function verboseLog(name, verbose) {
  return (...args) => verbose && console.debug(`[${name}]:`, ...args);
}
const getUniqueId = /* @__PURE__ */ ((mem) => {
  return (newId) => {
    if (!mem.has(newId)) {
      mem.add(newId);
      return newId;
    }
    console.warn(`Atom with name ${newId} already exist. Full page reload recommended`);
    const uniqId = newId + performance.now();
    return getUniqueId(uniqId);
  };
})(/* @__PURE__ */ new Set());
const defaultOptions = {
  inheritState: false,
  store,
  auto: true,
  verbose: false
};
function createAsyncAtom(depsAtom, fetcher, name, resourceAtomOptions = {}) {
  const options = {
    ...resourceAtomOptions,
    auto: resourceAtomOptions.auto ?? defaultOptions.auto,
    inheritState: resourceAtomOptions.inheritState ?? defaultOptions.inheritState,
    store: resourceAtomOptions.store ?? defaultOptions.store,
    verbose: resourceAtomOptions.verbose ?? defaultOptions.verbose
  };
  const debug = verboseLog(name, options.verbose);
  const asyncAtomName = getUniqueId(name);
  const asyncAtom = atom(
    {
      loading: false,
      data: null,
      error: null,
      lastParams: null,
      dirty: false
    },
    asyncAtomName
  );
  let abortController = null;
  let deferredCancel;
  const requestAction = action(async (ctx, params) => {
    if (abortController) {
      await cancelAction(ctx);
    }
    asyncAtom(ctx, (state) => ({
      ...state,
      error: null,
      lastParams: params,
      dirty: true,
      // for unblock refetch
      loading: true
    }));
    try {
      abortController = new AbortController();
      const data = await ctx.schedule(() => {
        if (abortController) {
          return abortable(abortController, fetcher(params, abortController));
        } else {
          throw Error("abortController was reset before it was used");
        }
      });
      abortController.signal.throwIfAborted();
      asyncAtom(ctx, (state) => ({ ...state, data, lastParams: params, loading: false }));
    } catch (error2) {
      asyncAtom(ctx, (state) => ({
        ...state,
        lastParams: params,
        loading: false,
        error: generateErrorMessage(error2)
      }));
      if (isAbortError(error2)) {
        deferredCancel == null ? void 0 : deferredCancel.resolve();
      }
    } finally {
      abortController = null;
    }
  }, `${asyncAtomName}.requestAction`);
  const cancelAction = action(async (ctx) => {
    if (abortController) {
      deferredCancel = deferred();
      await ctx.schedule(async () => {
        abortController == null ? void 0 : abortController.abort();
        return await deferredCancel.promise;
      });
    }
  }, `${asyncAtomName}.cancelAction`);
  const refetchAction = action((ctx) => {
    const { lastParams, dirty, loading: loading2 } = ctx.get(asyncAtom);
    if (dirty) {
      !loading2 && requestAction(ctx, lastParams);
    } else {
      console.error(`[${name}]:`, "Do not call refetch before request");
    }
  }, `${asyncAtomName}.refetchAction`);
  const actions = {
    request: requestAction,
    refetch: refetchAction,
    cancel: cancelAction
  };
  if (depsAtom) {
    const onChange2 = (ctx, depsAtomState) => {
      debug("Deps atom changed");
      if (isObject$1(depsAtomState)) {
        if (options.inheritState) {
          asyncAtom(ctx, (state) => ({
            ...state,
            loading: depsAtomState.loading || state.loading,
            error: depsAtomState.error || state.error
          }));
        }
        if (isAtomLike(depsAtomState)) {
          if (!depsAtomState.loading && !depsAtomState.error && depsAtomState.dirty) {
            requestAction(ctx, depsAtomState.data);
          }
        } else {
          requestAction(ctx, depsAtomState);
        }
      } else {
        if (depsAtomState !== null) {
          requestAction(ctx, depsAtomState);
        } else {
          console.warn(
            `Resource atom with name ${name} skips running as its dependency state ${depsAtom == null ? void 0 : depsAtom.id} is null`
          );
        }
      }
    };
    depsAtom.subscribe((s2) => null);
    if (options.auto) {
      onChange2(options.store.v3ctx, options.store.getState(depsAtom));
    }
    depsAtom.v3atom.onChange(onChange2);
    return v3toV2(asyncAtom, actions, options.store);
  } else {
    if (options.auto) {
      requestAction(options.store.v3ctx, null);
    }
  }
  return v3toV2(asyncAtom, actions, options.store);
}
function deferred() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    // @ts-expect-error -- `resolve` is defined inside the promise.
    resolve,
    // @ts-expect-error -- `reject` is defined inside the promise.
    reject
  };
}
const IMPORTANT_BIVARIATE_LAYERS = [
  ["count", "area_km2"],
  ["building_count", "area_km2"],
  ["highway_length", "area_km2"],
  ["local_hours", "area_km2"],
  ["avgmax_ts", "one"],
  ["days_mintemp_above_25c_1c", "one"],
  ["population", "area_km2"],
  ["total_hours", "area_km2"],
  ["view_count", "area_km2"]
];
function recursiveCopy(src) {
  const target = Array.isArray(src) ? [] : {};
  for (const prop in src) {
    const value2 = src[prop];
    if (value2 && typeof value2 === "object") {
      target[prop] = recursiveCopy(value2);
    } else {
      target[prop] = value2;
    }
  }
  return target;
}
const deepCopy = window.structuredClone ?? recursiveCopy;
function isGeometryEmpty(geometry) {
  var _a2, _b;
  if (!geometry) return true;
  if (geometry.type !== "GeometryCollection" && ((_a2 = geometry.coordinates) == null ? void 0 : _a2.length)) {
    return false;
  }
  if (geometry.type === "GeometryCollection" && ((_b = geometry.geometries) == null ? void 0 : _b.length)) {
    return false;
  }
  return true;
}
function isGeoJSONEmpty(geoJSON) {
  var _a2;
  if (!geoJSON) return true;
  switch (geoJSON.type) {
    case "FeatureCollection":
      return !((_a2 = geoJSON.features) == null ? void 0 : _a2.length);
    case "Feature":
      return isGeometryEmpty(geoJSON.geometry);
    default:
      return isGeometryEmpty(geoJSON);
  }
}
function cleanupGeometry(geom) {
  var _a2;
  const newGeom = deepCopy(geom);
  if ("properties" in newGeom) {
    newGeom.properties = {};
  }
  if ("features" in newGeom && ((_a2 = newGeom.features) == null ? void 0 : _a2.length)) {
    newGeom.features = newGeom.features.map(
      (feature) => cleanupGeometry(feature)
    );
  }
  return newGeom;
}
function createBivariateQuery(geom) {
  const body = {
    importantLayers: IMPORTANT_BIVARIATE_LAYERS
  };
  if (geom && !isGeoJSONEmpty(geom)) {
    body.geoJSON = cleanupGeometry(geom);
  }
  return body;
}
function parseGraphQLErrors(response) {
  if (response.hasOwnProperty("errors") && Array.isArray(response["errors"])) {
    return response["errors"].reduce((acc, errorObj) => {
      if (errorObj.hasOwnProperty("message")) {
        acc.push(errorObj["message"]);
      }
      return acc;
    }, []).join("<br/>");
  }
}
function axisDTOtoAxis(dto) {
  var _a2;
  return {
    ...dto,
    id: dto.quotient.join("|"),
    label: dto.label ? formatCustomBivariateAxisLabel(dto.label, dto.quotients) : formatBivariateAxisLabel(dto.quotients),
    transformation: {
      ...dto.transformation,
      transformation: ((_a2 = dto.transformation) == null ? void 0 : _a2.transformation) ?? "no"
    }
  };
}
const bivariateStatisticsDependencyAtom = v3toV2(
  atom((ctx) => {
    const focusedGeometry = ctx.spy(focusedGeometryAtom.v3atom);
    return { focusedGeometry };
  })
);
let worldStatsCache;
const bivariateStatisticsResourceAtom$1 = createAsyncAtom(
  bivariateStatisticsDependencyAtom,
  async ({ focusedGeometry }, abortController) => {
    if (!(focusedGeometry == null ? void 0 : focusedGeometry.geometry) && worldStatsCache) {
      return worldStatsCache;
    }
    try {
      const body = createBivariateQuery(focusedGeometry == null ? void 0 : focusedGeometry.geometry);
      const responseData = await apiClient.post("/bivariate_matrix", body, {
        signal: abortController.signal,
        retry: { attempts: 2 }
      });
      if (!responseData) {
        throw new Error(TranslationService.t("no_data_received"));
      }
      const { data } = responseData;
      if (!data) {
        const msg = parseGraphQLErrors(responseData);
        throw new Error(msg || TranslationService.t("no_data_received"));
      }
      const statsDTO = data.polygonStatistic.bivariateStatistic;
      if (!statsDTO || !Array.isArray(statsDTO == null ? void 0 : statsDTO.correlationRates)) {
        throw new Error(TranslationService.t("wrong_data_received"));
      }
      const stat = {
        ...statsDTO,
        axis: statsDTO.axis.map((ax) => axisDTOtoAxis(ax))
      };
      if (isGeoJSONEmpty(focusedGeometry == null ? void 0 : focusedGeometry.geometry) && !worldStatsCache) {
        worldStatsCache = stat;
      }
      return stat;
    } catch (e) {
      if (isApiError(e) && e.problem.kind === "canceled") {
        return null;
      }
      throw e;
    }
  },
  "bivariateStatisticsResource"
);
function extractAvailableNumeratorsWithDenominators(stat) {
  const { correlationRates } = stat;
  const x2 = [];
  const y2 = [];
  for (const correlationRate of correlationRates) {
    const xQuotient = correlationRate.x.quotient;
    const xParent = correlationRate.x.parent || xQuotient;
    let xGroup = x2.find((g2) => g2.parent === JSON.stringify(xParent));
    if (!xGroup) {
      xGroup = {
        parent: JSON.stringify(xParent),
        quotients: [xQuotient],
        selectedQuotient: xQuotient
      };
      x2.push(xGroup);
    } else if (!xGroup.quotients.find((q2) => JSON.stringify(q2) === JSON.stringify(xQuotient))) {
      xGroup.quotients.push(xQuotient);
    }
    const yQuotient = correlationRate.y.quotient;
    const yParent = correlationRate.y.parent || yQuotient;
    let yGroup = y2.find((g2) => g2.parent === JSON.stringify(yParent));
    if (!yGroup) {
      yGroup = {
        parent: JSON.stringify(yParent),
        quotients: [yQuotient],
        selectedQuotient: yQuotient
      };
      y2.push(yGroup);
    } else if (!yGroup.quotients.find((q2) => JSON.stringify(q2) === JSON.stringify(yQuotient))) {
      yGroup.quotients.push(yQuotient);
    }
  }
  for (const group of x2) {
    const parent = group.quotients.find((q2) => JSON.stringify(q2) === group.parent);
    if (parent) {
      group.selectedQuotient = parent;
    }
  }
  for (const group of y2) {
    const parent = group.quotients.find((q2) => JSON.stringify(q2) === group.parent);
    if (parent) {
      group.selectedQuotient = parent;
    }
  }
  return { x: x2, y: y2 };
}
const bivariateNumeratorsAtom = atom(
  (ctx, state = { xGroups: [], yGroups: [] }) => {
    const { data: stats, loading: loading2 } = ctx.spy(bivariateStatisticsResourceAtom$1.v3atom);
    if (stats && !loading2) {
      const numerators = extractAvailableNumeratorsWithDenominators(stats);
      return { xGroups: numerators.x, yGroups: numerators.y };
    }
    return state;
  },
  "bivariateNumeratorsAtom"
);
const setNumeratorsAction = action((ctx, nums) => {
  bivariateNumeratorsAtom(ctx, nums);
}, "setNumeratorsAction");
const onCalculateSelectedCell = (xGroups, yGroups, matrixSelection) => {
  const xIndex = xGroups ? xGroups.findIndex(
    (group) => group.selectedQuotient[0] === (matrixSelection == null ? void 0 : matrixSelection.xNumerator) && group.selectedQuotient[1] === (matrixSelection == null ? void 0 : matrixSelection.xDenominator)
  ) : -1;
  const yIndex = yGroups ? yGroups.findIndex(
    (group) => group.selectedQuotient[0] === (matrixSelection == null ? void 0 : matrixSelection.yNumerator) && group.selectedQuotient[1] === (matrixSelection == null ? void 0 : matrixSelection.yDenominator)
  ) : -1;
  return { x: xIndex, y: yIndex };
};
const selectQuotientInGroupByNumDen = (groups2, numId, denId) => {
  const newGroups = [...groups2];
  let selectedQuotient;
  const groupIndex = newGroups.findIndex(({ quotients }) => {
    selectedQuotient = quotients.find(
      (q2) => q2[0] === numId && q2[1] === denId
    );
    return selectedQuotient;
  });
  if (selectedQuotient) {
    newGroups[groupIndex] = { ...newGroups[groupIndex], selectedQuotient };
  }
  return newGroups;
};
const DEFAULT_STATE = {
  xNumerator: null,
  xDenominator: null,
  yNumerator: null,
  yDenominator: null,
  selectedCell: null,
  selectCellCallback: null
};
function formatSelection(xNumerator, xDenominator, yNumerator, yDenominator) {
  return { xNumerator, xDenominator, yNumerator, yDenominator };
}
const enabledLayersAtom = enabledLayersAtom$1.v3atom;
const layersRegistryAtom = layersRegistryAtom$1.v3atom;
const layersRegistryAtom_register = layersRegistryAtom$1.register.v3action;
const layersSettingsAtom = layersSettingsAtom$1.v3atom;
const bivariateStatisticsResourceAtom = bivariateStatisticsResourceAtom$1.v3atom;
let bivariateLayerAtomId;
const bivariateMatrixSelectionAtom = atom(
  DEFAULT_STATE,
  "bivariateMatrixSelectionAtom"
);
const calculateSelectedCellAction = action((ctx) => {
  const { xGroups, yGroups } = ctx.get(bivariateNumeratorsAtom);
  const state = ctx.get(bivariateMatrixSelectionAtom);
  const nextSelectedCell = onCalculateSelectedCell(
    xGroups,
    yGroups,
    formatSelection(
      state.xNumerator,
      state.xDenominator,
      state.yNumerator,
      state.yDenominator
    )
  );
  const currentCell = state.selectedCell;
  if (!currentCell || nextSelectedCell.x !== currentCell.x || nextSelectedCell.y !== currentCell.y) {
    bivariateMatrixSelectionAtom(ctx, { ...state, selectedCell: nextSelectedCell });
  }
}, "calculateSelectedCellAction");
const setSelectCellCallbackAction = action((ctx, selectCellCallback) => {
  bivariateMatrixSelectionAtom(ctx, (state) => ({ ...state, selectCellCallback }));
}, "setSelectCellCallbackAction");
const callSelectCellCallbackAction = action((ctx, objWithXY) => {
  var _a2, _b;
  const { x: x2, y: y2 } = objWithXY;
  (_b = (_a2 = ctx.get(bivariateMatrixSelectionAtom)) == null ? void 0 : _a2.selectCellCallback) == null ? void 0 : _b.call(_a2, x2, y2);
}, "callSelectCellCallbackAction");
const resetSelectionAction = action((ctx) => {
  bivariateMatrixSelectionAtom(ctx, (state) => {
    ctx.schedule(() => {
      var _a2;
      (_a2 = state == null ? void 0 : state.selectCellCallback) == null ? void 0 : _a2.call(state, -1, -1);
    });
    return {
      ...state,
      xNumerator: null,
      xDenominator: null,
      yNumerator: null,
      yDenominator: null,
      selectedCell: null
    };
  });
}, "resetSelectionAction");
action((ctx) => {
  const layer = getEnabledBivariateLayer(ctx);
  if (!layer || !(layer == null ? void 0 : layer.legend)) {
    resetSelectionAction(ctx);
    return;
  }
  const axis2 = layer.legend.axis;
  if (axis2) {
    const preselectionFormatted = formatSelection(
      axis2.x.quotient[0] || null,
      axis2.x.quotient[1] || null,
      axis2.y.quotient[0] || null,
      axis2.y.quotient[1] || null
    );
    const { xGroups, yGroups } = ctx.get(bivariateNumeratorsAtom);
    const nextSelectedCell = onCalculateSelectedCell(
      xGroups,
      yGroups,
      preselectionFormatted
    );
    if (nextSelectedCell.x >= 0 && nextSelectedCell.y >= 0) {
      ctx.schedule(() => {
        presetMatrixSelectionAction(ctx, preselectionFormatted);
        callSelectCellCallbackAction(ctx, nextSelectedCell);
      });
      return;
    }
    let newXGroups = xGroups;
    let newYGroups = yGroups;
    if (nextSelectedCell.x === -1) {
      newXGroups = selectQuotientInGroupByNumDen(
        xGroups,
        axis2.x.quotient[0],
        axis2.x.quotient[1]
      );
    }
    if (nextSelectedCell.y === -1) {
      newYGroups = selectQuotientInGroupByNumDen(
        yGroups,
        axis2.y.quotient[0],
        axis2.y.quotient[1]
      );
    }
    const finishSelection = onCalculateSelectedCell(
      newXGroups,
      newYGroups,
      preselectionFormatted
    );
    ctx.schedule(() => {
      if (finishSelection.x >= 0 && finishSelection.y >= 0) {
        setNumeratorsAction(ctx, { xGroups: newXGroups, yGroups: newYGroups });
        presetMatrixSelectionAction(ctx, preselectionFormatted);
        callSelectCellCallbackAction(ctx, finishSelection);
      } else {
        resetSelectionAction(ctx);
      }
    });
  }
}, "runPreselectionAction");
const presetMatrixSelectionAction = action((ctx, selection) => {
  bivariateMatrixSelectionAtom(ctx, (state) => ({ ...state, ...selection }));
  calculateSelectedCellAction(ctx);
}, "presetMatrixSelectionAction");
const enableBivariateLayerAction = action((ctx, lId) => {
  const registry = ctx.get(layersRegistryAtom);
  const layer = registry.get(lId);
  if (layer) {
    layer.enable.v3action(ctx);
  }
}, "enableBivariateLayerAction");
const disableBivariateLayerAction = action(
  (ctx, bivariateLayerAtomId2) => {
    const registry = ctx.get(layersRegistryAtom);
    if (bivariateLayerAtomId2) {
      const layerAtom = registry.get(bivariateLayerAtomId2);
      layerAtom && layerAtom.destroy.v3action(ctx);
    }
  },
  "disableBivariateLayerAction"
);
action(
  (ctx, xNumerator, xDenominator, yNumerator, yDenominator) => {
    bivariateMatrixSelectionAtom(ctx, (state) => ({
      ...state,
      xNumerator,
      xDenominator,
      yNumerator,
      yDenominator
    }));
    calculateSelectedCellAction(ctx);
    if (xNumerator === null || yNumerator === null) return;
    const { xGroups, yGroups } = ctx.get(bivariateNumeratorsAtom);
    const stats = ctx.get(bivariateStatisticsResourceAtom).data;
    if (stats === null) return;
    if (!xGroups || !yGroups || !xGroups.length || !yGroups.length) return;
    if (!xDenominator || !yDenominator) return;
    const res = generateColorThemeAndBivariateStyle(
      xNumerator,
      xDenominator,
      yNumerator,
      yDenominator,
      stats,
      SOURCE_LAYER_BIVARIATE
    );
    if (res) {
      const [colorTheme, bivariateStyle] = res;
      const legend2 = createBivariateLegend(
        "Bivariate Layer",
        colorTheme,
        xNumerator,
        xDenominator,
        yNumerator,
        yDenominator,
        stats
      );
      if (legend2) {
        const bivStyle = bivariateStyle;
        const biSource = bivStyle.source;
        const id = bivStyle.id;
        const meta2 = createBivariateMeta(
          xNumerator,
          xDenominator,
          yNumerator,
          yDenominator,
          stats
        );
        const source = biSource ? {
          id,
          maxZoom: biSource.maxzoom,
          minZoom: biSource.minzoom,
          source: {
            type: biSource.type,
            urls: biSource.tiles,
            tileSize: 512,
            apiKey: ""
          }
        } : void 0;
        const [updateActions, cleanUpActions] = createUpdateLayerActions([
          {
            id,
            legend: legend2,
            meta: meta2,
            source
          }
        ]);
        const currentSettings = ctx.get(layersSettingsAtom);
        if (!currentSettings.has(id)) {
          updateActions.push(
            ...createUpdateLayerActions([
              {
                id,
                settings: {
                  id,
                  name: "Bivariate Layer",
                  category: "overlay",
                  group: "bivariate",
                  ownedByUser: true
                }
              }
            ]).flat()
          );
        }
        if (updateActions.length) {
          store.dispatch(updateActions);
        }
        const currentRegistry = ctx.get(layersRegistryAtom);
        if (!currentRegistry.has(id)) {
          disableBivariateLayerAction(ctx, bivariateLayerAtomId);
          bivariateLayerAtomId = id;
          layersRegistryAtom_register(ctx, [
            {
              id,
              renderer: new BivariateRenderer({ id }),
              cleanUpActions
            }
          ]);
          enableBivariateLayerAction(ctx, id);
        }
      }
    }
  },
  "setMatrixSelectionAction"
);
function getEnabledBivariateLayer(ctx) {
  const enabledLayers = ctx.get(enabledLayersAtom);
  const registry = ctx.get(layersRegistryAtom);
  const layer = [...enabledLayers].map((layer2) => {
    var _a2;
    return (_a2 = registry.get(layer2)) == null ? void 0 : _a2.getState();
  }).find((layer2) => {
    var _a2;
    return layer2 && layer2.isEnabled && ((_a2 = layer2.legend) == null ? void 0 : _a2.type) === "bivariate";
  });
  return layer;
}
const BivariateMatrixContext = reactExports.createContext(null);
const MATRIX_CELL_SIDE = 37;
const MATRIX_SCALE = 0.7;
const BIVARIATE_MATRIX_WIDTH_SHIFT = MATRIX_CELL_SIDE / Math.sqrt(2);
const BIVARIATE_MATRIX_HEIGHT_SHIFT = MATRIX_CELL_SIDE / Math.sqrt(2);
function useGridStyle(x2, y2, cellSize = 0) {
  const memoizedGridStyle = reactExports.useMemo(
    () => ({
      display: "inline-grid",
      "--cell-size": cellSize === 0 ? "initial" : `${cellSize}px`,
      gridTemplateRows: `repeat(${y2}, ${cellSize === 0 ? "auto" : cellSize + "px"})`,
      gridTemplateColumns: `repeat(${x2}, ${cellSize === 0 ? "auto" : cellSize + "px"})`
    }),
    [x2, y2, cellSize]
  );
  return memoizedGridStyle;
}
function generateCellStyles(maxCols, maxRows) {
  const cellStyles = [];
  for (let i2 = 0; i2 < maxCols; i2++) {
    cellStyles[i2] = [];
    for (let j2 = 0; j2 < maxRows; j2++) {
      cellStyles[i2][j2] = {
        gridColumn: `${i2} / ${i2 + 1}`,
        gridRow: `${j2} / ${j2 + 1}`
      };
    }
  }
  return cellStyles;
}
function useBaseMatrixDimension(xHeadings, yHeadings) {
  const memoizedBaseDimension = reactExports.useMemo(() => {
    if (!xHeadings || !xHeadings.length || !yHeadings || !yHeadings.length) return 0;
    let xLength = calculateStringWidth(xHeadings[0].label);
    for (let i2 = 1; i2 < xHeadings.length; i2++) {
      const iStrWidth = calculateStringWidth(xHeadings[i2].label);
      const shift2 = i2 * BIVARIATE_MATRIX_HEIGHT_SHIFT;
      if (iStrWidth > xLength + shift2) {
        xLength = iStrWidth - shift2;
      }
    }
    let yLength = calculateStringWidth(yHeadings[0].label);
    for (let i2 = 1; i2 < yHeadings.length; i2++) {
      const iStrWidth = calculateStringWidth(yHeadings[i2].label);
      const shift2 = i2 * BIVARIATE_MATRIX_WIDTH_SHIFT;
      if (iStrWidth > yLength + shift2) {
        yLength = iStrWidth - shift2;
      }
    }
    return xLength > yLength ? xLength : yLength;
  }, [xHeadings, yHeadings]);
  return memoizedBaseDimension;
}
const canvas = document.createElement("canvas");
const context = canvas.getContext("2d") || {};
context.font = "normal 13px Roboto";
const QUOTIENT_ICON_SIZE = 30;
const QUOTIENTS_DROPDOWN_SIZE = 90;
function calculateStringWidth(str) {
  return context.measureText(str).width + QUOTIENT_ICON_SIZE + QUOTIENTS_DROPDOWN_SIZE;
}
function calculateHeadingsStyle(baseDimension, vertical, index2) {
  return vertical ? { height: `${baseDimension + index2 * BIVARIATE_MATRIX_HEIGHT_SHIFT}px` } : { width: `${baseDimension + index2 * BIVARIATE_MATRIX_WIDTH_SHIFT}px` };
}
const hoveredCell = "_hoveredCell_12w9a_1";
const valueCell = "_valueCell_12w9a_5";
const rotatedCell = "_rotatedCell_12w9a_18";
const valueFill = "_valueFill_12w9a_27";
const disabled = "_disabled_12w9a_38";
const selectedCol = "_selectedCol_12w9a_42";
const first = "_first_12w9a_47";
const last = "_last_12w9a_51";
const selectedRow = "_selectedRow_12w9a_55";
const styles$6 = {
  hoveredCell,
  valueCell,
  rotatedCell,
  valueFill,
  disabled,
  selectedCol,
  first,
  last,
  selectedRow
};
const BivariateMatrixCell = reactExports.forwardRef(
  ({
    value: value2,
    x: x2,
    y: y2,
    className,
    onMouseOver,
    onMouseOut,
    onClick,
    disabled: disabled2 = false,
    style: style2,
    firstRow,
    firstCol,
    lastRow,
    lastCol
  }, ref) => {
    const containerRef = reactExports.useRef(null);
    let isHovered = false;
    let isFromSelectedRow = false;
    let isFromSelectedCol = false;
    const baseClassNames = clsx(styles$6.valueCell, className, disabled2 && styles$6.disabled);
    function generateClassNames() {
      return `${baseClassNames} ${clsx({
        [styles$6.hoveredCell]: isHovered,
        [styles$6.selectedCol]: isFromSelectedCol,
        [styles$6.selectedRow]: isFromSelectedRow,
        [styles$6.first]: firstRow && isFromSelectedCol || firstCol && isFromSelectedRow,
        [styles$6.last]: lastRow && isFromSelectedCol || lastCol && isFromSelectedRow
      })}`;
    }
    reactExports.useImperativeHandle(ref, () => ({
      setHovered: () => {
        if (containerRef.current) {
          isHovered = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetHovered: () => {
        if (containerRef.current) {
          isHovered = false;
          containerRef.current.className = generateClassNames();
        }
      },
      setSelectedCol: () => {
        if (containerRef.current) {
          isFromSelectedCol = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetSelectedCol: () => {
        if (containerRef.current) {
          isFromSelectedCol = false;
          containerRef.current.className = generateClassNames();
        }
      },
      setSelectedRow: () => {
        if (containerRef.current) {
          isFromSelectedRow = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetSelectedRow: () => {
        if (containerRef.current) {
          isFromSelectedRow = false;
          containerRef.current.className = generateClassNames();
        }
      }
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: containerRef,
        className: baseClassNames,
        style: style2,
        onMouseOver: () => {
          onMouseOver(x2, y2);
        },
        onClick: (e) => {
          onClick(x2, y2, e);
        },
        onMouseOut,
        children: !disabled2 && value2 !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          Math.abs(value2) >= 0.1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: styles$6.valueFill,
              style: { transform: `scale(${Math.abs(value2)})` }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.rotatedCell, children: value2 == null ? void 0 : value2.toFixed(3) })
        ] }) : null
      }
    );
  }
);
BivariateMatrixCell.displayName = "BivariateMatrixCell";
const matrixContainer = "_matrixContainer_i0ppr_14";
const rotatedMatrix = "_rotatedMatrix_i0ppr_21";
const styles$5 = {
  matrixContainer,
  rotatedMatrix
};
const horConnector = "_horConnector_zzmmn_1";
const vertConnector = "_vertConnector_zzmmn_7";
const connectorBody = "_connectorBody_zzmmn_13";
const hovered$1 = "_hovered_zzmmn_28";
const selected$2 = "_selected_zzmmn_33";
const styles$4 = {
  horConnector,
  vertConnector,
  connectorBody,
  hovered: hovered$1,
  selected: selected$2
};
const BivariateMatrixCellConnector = reactExports.forwardRef(
  ({ type, style: style2 }, ref) => {
    const containerRef = reactExports.useRef(null);
    let isHovered = false;
    let isSelected = false;
    const baseClassNames = styles$4.connectorBody;
    function generateClassNames() {
      return `${baseClassNames} ${clsx({
        [styles$4.hovered]: isHovered,
        [styles$4.selected]: isSelected
      })}`;
    }
    reactExports.useImperativeHandle(ref, () => ({
      setHovered: () => {
        if (containerRef.current) {
          isHovered = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetHovered: () => {
        if (containerRef.current) {
          isHovered = false;
          containerRef.current.className = generateClassNames();
        }
      },
      setSelectedCol: () => {
        if (type === "vertical" && containerRef.current) {
          isSelected = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetSelectedCol: () => {
        if (type === "vertical" && containerRef.current) {
          isSelected = false;
          containerRef.current.className = generateClassNames();
        }
      },
      setSelectedRow: () => {
        if (type === "horizontal" && containerRef.current) {
          isSelected = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetSelectedRow: () => {
        if (type === "horizontal" && containerRef.current) {
          isSelected = false;
          containerRef.current.className = generateClassNames();
        }
      }
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: type === "horizontal" ? styles$4.horConnector : styles$4.vertConnector,
        style: style2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4.connectorBody, ref: containerRef })
      }
    );
  }
);
BivariateMatrixCellConnector.displayName = "BivariateMatrixCellConnector";
const denominatorIcon = "_denominatorIcon_2n0u5_1";
const styles$3 = {
  denominatorIcon
};
const PopulationIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_4777_147920)", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M4.59226 5.6715C4.57385 5.68982 4.55581 5.70848 4.53814 5.72748C4.27818 6.00698 4.09843 6.3591 4.03058 6.74363C4.30836 6.45062 4.50699 6.08183 4.59226 5.6715ZM10.3266 5.66248C10.4117 6.0808 10.6146 6.45633 10.8991 6.75295C10.8325 6.3648 10.6519 6.00926 10.3899 5.7275C10.3693 5.70537 10.3482 5.68368 10.3266 5.66248ZM10.927 7.12889C10.2881 7.58142 9.93487 8.39557 10.1356 9.23105L10.3024 9.92533L10.8712 7.55816C10.9059 7.41385 10.924 7.27018 10.927 7.12889ZM10.8167 12.0655L11.135 13.3906C11.2431 13.8401 11.6451 14.157 12.1074 14.157H12.8928C13.3551 14.157 13.7571 13.8401 13.8651 13.3906L14.8646 9.23105C15.0886 8.29843 14.6225 7.39238 13.8391 6.98624C14.3731 6.58123 14.718 5.93987 14.718 5.21796C14.718 3.99301 13.725 3 12.5001 3C12.1224 3 11.7669 3.09436 11.4556 3.26079C11.4174 3.85333 11.25 4.41104 10.9816 4.90556C11.0898 5.00751 11.1903 5.11726 11.2822 5.23375C11.2821 5.22849 11.2821 5.22323 11.2821 5.21796C11.2821 4.5453 11.8274 4 12.5001 4C13.1727 4 13.718 4.5453 13.718 5.21796C13.718 5.89062 13.1727 6.43592 12.5001 6.43592C12.2381 6.43592 11.9954 6.35321 11.7968 6.21249C11.9482 6.7042 11.975 7.24459 11.8435 7.79175C11.9191 7.77351 11.9983 7.7638 12.0803 7.7638H12.9199C13.5667 7.7638 14.0433 8.36854 13.8922 8.99743L12.8928 13.157L12.1074 13.157L11.3309 9.92533L10.8167 12.0655ZM4.10776 12.0505L3.78577 13.3906C3.67777 13.8401 3.27574 14.157 2.81344 14.157H2.02803C1.56574 14.157 1.16371 13.8401 1.0557 13.3906L0.0562696 9.23105C-0.167809 8.29845 0.298349 7.39241 1.08167 6.98626C0.547652 6.58125 0.202745 5.93988 0.202745 5.21796C0.202745 3.99301 1.19576 3 2.42071 3C2.80138 3 3.15965 3.0959 3.47268 3.26486C3.5114 3.85587 3.67872 4.41215 3.94647 4.90553C3.83535 5.01024 3.73236 5.12317 3.63841 5.24319C3.63858 5.2348 3.63867 5.22639 3.63867 5.21796C3.63867 4.5453 3.09337 4 2.42071 4C1.74804 4 1.20274 4.5453 1.20274 5.21796C1.20274 5.89062 1.74804 6.43592 2.42071 6.43592C2.68679 6.43592 2.93294 6.3506 3.1333 6.20582C2.98006 6.69932 2.95243 7.24213 3.0845 7.79178L3.08494 7.79363C3.00708 7.77418 2.92528 7.7638 2.84055 7.7638H2.00092C1.35413 7.7638 0.877492 8.36854 1.0286 8.99742L2.02803 13.157L2.81344 13.157L3.59353 9.91034L4.10776 12.0505ZM4.62199 9.91034L4.78521 9.23105C4.98518 8.39877 4.63543 7.58765 4.00112 7.13409C4.00445 7.2737 4.02258 7.41562 4.05683 7.55816L4.62199 9.91034Z",
            fill: "black"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M9.46348 3C9.46348 4.10457 8.56805 5 7.46348 5C6.35891 5 5.46348 4.10457 5.46348 3C5.46348 1.89543 6.35891 1 7.46348 1C8.56805 1 9.46348 1.89543 9.46348 3ZM9.52339 5.18101C10.1023 4.63409 10.4635 3.85923 10.4635 3C10.4635 1.34315 9.12033 0 7.46348 0C5.80662 0 4.46348 1.34315 4.46348 3C4.46348 3.85922 4.8247 4.63408 5.40356 5.181C4.4317 5.4836 3.80296 6.50391 4.05627 7.55816L5.68205 14.3245C5.79005 14.774 6.19208 15.0909 6.65437 15.0909H8.27254C8.73483 15.0909 9.13686 14.774 9.24487 14.3245L10.8706 7.55816C11.1239 6.50392 10.4952 5.48363 9.52339 5.18101ZM6.00092 6.09091H8.92599C9.57278 6.09091 10.0494 6.69564 9.89832 7.32453L8.27254 14.0909H6.65437L5.0286 7.32453C4.87749 6.69564 5.35414 6.09091 6.00092 6.09091Z",
            fill: "black"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_4777_147920", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "24", height: "24", fill: "white" }) }) })
    ]
  }
);
const AreaIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 15 15",
    fill: "none",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M14.6012 12.1833C15.0887 12.6708 15.0887 13.4833 14.6012 13.9708L13.7346 14.8375C13.6262 14.9458 13.5179 15 13.3554 15C13.2471 15 13.0846 14.9458 12.9762 14.8375C12.7596 14.6208 12.7596 14.2958 12.9762 14.1333L13.4637 13.6458H3.33874C2.20124 13.6458 1.33457 12.725 1.33457 11.5875V1.4625L0.847072 1.95C0.630406 2.16667 0.305406 2.16667 0.142906 1.95C-0.0195943 1.73333 -0.073761 1.40833 0.142906 1.24583L1.00957 0.379167C1.49707 -0.108333 2.30957 -0.108333 2.79707 0.379167L3.66374 1.24583C3.88041 1.4625 3.88041 1.7875 3.66374 1.95C3.55541 2.05833 3.39291 2.05833 3.28457 2.05833C3.17624 2.05833 3.01374 2.00417 2.90541 1.89583L2.36374 1.35417V11.5875C2.36374 12.1292 2.79707 12.6167 3.39291 12.6167H13.5721L13.0304 12.075C12.8137 11.8583 12.8137 11.5333 13.0304 11.3708C13.2471 11.1542 13.5721 11.1542 13.7346 11.3708L14.6012 12.1833ZM13.4637 0H6.85541C6.58457 0 6.36791 0.216667 6.36791 0.4875C6.36791 0.758333 6.58457 0.975 6.85541 0.975H13.4096C13.6804 0.975 13.8971 1.19167 13.8971 1.4625V8.125C13.8971 8.39583 14.1137 8.6125 14.3846 8.6125C14.6554 8.6125 14.8721 8.39583 14.8721 8.125V1.51667C14.9804 0.704167 14.2762 0 13.4637 0ZM8.45541 9.72083C8.72624 9.72083 8.94291 9.50417 8.94291 9.23333V6.95833C8.94291 6.2 8.29291 5.55 7.53457 5.55C7.20957 5.55 6.88457 5.65833 6.66791 5.875C6.45124 5.65833 6.12624 5.55 5.80124 5.55C5.58457 5.55 5.42207 5.60417 5.25957 5.65833C5.15124 5.55 5.04291 5.49583 4.88041 5.49583C4.60957 5.49583 4.39291 5.7125 4.39291 5.98333V9.17917C4.39291 9.45 4.60957 9.66667 4.88041 9.66667C5.15124 9.66667 5.36791 9.45 5.36791 9.17917V6.95833C5.36791 6.74167 5.53041 6.57917 5.74707 6.57917C5.96374 6.57917 6.12624 6.74167 6.12624 6.95833V9.23333C6.12624 9.50417 6.34291 9.72083 6.61374 9.72083C6.88457 9.72083 7.10124 9.50417 7.10124 9.23333V6.95833C7.10124 6.74167 7.26374 6.57917 7.48041 6.57917C7.69707 6.57917 7.85957 6.74167 7.85957 6.95833V9.23333C7.91374 9.50417 8.18457 9.72083 8.45541 9.72083ZM10.7304 3.7625C10.0804 3.7625 9.53874 4.30417 9.53874 4.95417C9.53874 5.225 9.75541 5.44167 10.0262 5.44167C10.2971 5.44167 10.5137 5.225 10.5137 4.95417C10.5137 4.84583 10.5679 4.79167 10.6762 4.79167C10.7304 4.79167 10.8387 4.84583 10.8387 4.95417C10.8387 5.00833 10.7304 5.225 10.2429 5.76667C9.9179 6.09167 9.64707 6.3625 9.64707 6.3625C9.48457 6.525 9.4304 6.74167 9.53874 6.90417C9.59291 7.12083 9.80957 7.22917 10.0262 7.22917H11.3804C11.6512 7.22917 11.8679 7.0125 11.8679 6.74167C11.8679 6.47083 11.6512 6.25417 11.3804 6.25417H11.2721C11.7054 5.7125 11.9221 5.33333 11.9221 5.00833C11.9221 4.25 11.3804 3.7625 10.7304 3.7625Z",
        fill: "black"
      }
    )
  }
);
const BuildingsIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 15 15",
    fill: "none",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M13.5938 15C14.112 15 14.5312 14.5807 14.5312 14.0625V7.5C14.5312 6.9818 14.112 6.5625 13.5938 6.5625H12.6562V0.9375C12.6562 0.419297 12.237 0 11.7188 0H5.15625C4.63805 0 4.21875 0.419297 4.21875 0.9375V2.8125H1.40625C0.888047 2.8125 0.46875 3.2318 0.46875 3.75V14.0625C0.46875 14.5807 0.888047 15 1.40625 15H13.5938ZM1.40625 3.75H4.21875V5.5H3.5C3.22386 5.5 3 5.72386 3 6C3 6.27614 3.22386 6.5 3.5 6.5H4.21875V8H3.5C3.22386 8 3 8.22386 3 8.5C3 8.77614 3.22386 9 3.5 9H4.21875V10.5H3.5C3.22386 10.5 3 10.7239 3 11C3 11.2761 3.22386 11.5 3.5 11.5H4.21875V14.0625H1.40625V3.75ZM5.15625 0.9375H11.7188V14.0625H8.90625V11.25H7.96875V14.0625H5.15625V0.9375ZM12.6562 7.5H13.5938V14.0625H12.6562V7.5ZM6 9.5C6 9.22386 6.22386 9 6.5 9H10.5C10.7761 9 11 9.22386 11 9.5C11 9.77614 10.7761 10 10.5 10H6.5C6.22386 10 6 9.77614 6 9.5ZM6.5 3C6.22386 3 6 3.22386 6 3.5C6 3.77614 6.22386 4 6.5 4H10.5C10.7761 4 11 3.77614 11 3.5C11 3.22386 10.7761 3 10.5 3H6.5ZM6 7.5C6 7.22386 6.22386 7 6.5 7H10.5C10.7761 7 11 7.22386 11 7.5C11 7.77614 10.7761 8 10.5 8H6.5C6.22386 8 6 7.77614 6 7.5ZM6.5 5C6.22386 5 6 5.22386 6 5.5C6 5.77614 6.22386 6 6.5 6H10.5C10.7761 6 11 5.77614 11 5.5C11 5.22386 10.7761 5 10.5 5H6.5Z",
        fill: "black"
      }
    )
  }
);
const PopulatedAreaIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M14.4949 0.505013C14.7683 0.77838 14.7683 1.2216 14.4949 1.49496L1.49493 14.495C1.22156 14.7683 0.778343 14.7683 0.504977 14.495C0.23161 14.2216 0.23161 13.7784 0.504977 13.505L13.505 0.505013C13.7783 0.231646 14.2216 0.231646 14.4949 0.505013ZM14.495 6.50503C14.7683 6.77839 14.7683 7.22161 14.495 7.49497L7.49497 14.495C7.22161 14.7683 6.77839 14.7683 6.50503 14.495C6.23166 14.2216 6.23166 13.7784 6.50503 13.505L13.505 6.50503C13.7784 6.23166 14.2216 6.23166 14.495 6.50503ZM8.49498 1.49497C8.76834 1.22161 8.76834 0.778392 8.49498 0.505025C8.22161 0.231658 7.77839 0.231658 7.50503 0.505025L0.505025 7.50503C0.231658 7.77839 0.231658 8.22161 0.505025 8.49498C0.778392 8.76834 1.22161 8.76834 1.49497 8.49498L8.49498 1.49497ZM3.49497 0.505025C3.76834 0.778392 3.76834 1.22161 3.49497 1.49497L1.49497 3.49497C1.22161 3.76834 0.778392 3.76834 0.505025 3.49497C0.231658 3.22161 0.231658 2.77839 0.505025 2.50503L2.50503 0.505025C2.77839 0.231658 3.22161 0.231658 3.49497 0.505025ZM14.495 12.495C14.7684 12.2216 14.7684 11.7784 14.495 11.505C14.2217 11.2317 13.7784 11.2317 13.5051 11.505L11.5051 13.505C11.2317 13.7784 11.2317 14.2216 11.5051 14.495C11.7784 14.7683 12.2217 14.7683 12.495 14.495L14.495 12.495Z",
        fill: "black"
      }
    )
  }
);
const OneIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 15 15",
    fill: "none",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M8.60002 4C8.60002 3.75732 8.45384 3.53854 8.22963 3.44567C8.00543 3.3528 7.74736 3.40413 7.57576 3.57573L5.57576 5.57573C5.34145 5.81005 5.34145 6.18995 5.57576 6.42426C5.81007 6.65857 6.18997 6.65857 6.42429 6.42426L7.40002 5.44852V10.4H6.50002C6.16865 10.4 5.90002 10.6686 5.90002 11C5.90002 11.3314 6.16865 11.6 6.50002 11.6H9.50002C9.8314 11.6 10.1 11.3314 10.1 11C10.1 10.6686 9.8314 10.4 9.50002 10.4H8.60002V4Z",
        fill: "black"
      }
    )
  }
);
const TotalRoadsIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 15 15",
    fill: "none",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M2.31257 14.9513C2.38285 14.9835 2.45927 15.0001 2.53658 15C2.66433 14.9997 2.78777 14.9537 2.88462 14.8704C2.98148 14.7871 3.04538 14.672 3.0648 14.5457L5.20765 0.617136C5.22508 0.478692 5.1878 0.338912 5.10375 0.227531C5.0197 0.116151 4.89551 0.0419601 4.75759 0.0207426C4.61968 -0.00047491 4.47893 0.0329551 4.36529 0.113921C4.25164 0.194887 4.17407 0.316999 4.14908 0.454279L2.00622 14.3828C1.99447 14.4593 1.9994 14.5373 2.02067 14.6116C2.04193 14.686 2.07903 14.7548 2.12942 14.8134C2.17981 14.8721 2.24229 14.9191 2.31257 14.9513ZM12.9007 14.8704C12.9975 14.9537 13.121 14.9997 13.2487 15C13.326 15.0001 13.4025 14.9835 13.4727 14.9513C13.543 14.9191 13.6055 14.8721 13.6559 14.8134C13.7063 14.7548 13.7434 14.686 13.7646 14.6116C13.7859 14.5373 13.7908 14.4593 13.7791 14.3828L11.6362 0.454279C11.6112 0.316999 11.5337 0.194887 11.42 0.113921C11.3064 0.0329551 11.1656 -0.00047491 11.0277 0.0207426C10.8898 0.0419601 10.7656 0.116151 10.6816 0.227531C10.5975 0.338912 10.5602 0.478692 10.5777 0.617136L12.7205 14.5457C12.7399 14.672 12.8038 14.7871 12.9007 14.8704ZM8.5 10.5C8.5 10.2239 8.27614 10 8 10C7.72386 10 7.5 10.2239 7.5 10.5V14.5C7.5 14.7761 7.72386 15 8 15C8.27614 15 8.5 14.7761 8.5 14.5V10.5ZM8 4C8.27614 4 8.5 4.22386 8.5 4.5V7.5C8.5 7.77614 8.27614 8 8 8C7.72386 8 7.5 7.77614 7.5 7.5V4.5C7.5 4.22386 7.72386 4 8 4ZM8.5 1C8.5 0.723858 8.27614 0.5 8 0.5C7.72386 0.5 7.5 0.723858 7.5 1V2C7.5 2.27614 7.72386 2.5 8 2.5C8.27614 2.5 8.5 2.27614 8.5 2V1Z",
        fill: "black"
      }
    )
  }
);
const iconMapper = {
  population: /* @__PURE__ */ jsxRuntimeExports.jsx(PopulationIcon, {}),
  area_km2: /* @__PURE__ */ jsxRuntimeExports.jsx(AreaIcon, {}),
  total_building_count: /* @__PURE__ */ jsxRuntimeExports.jsx(BuildingsIcon, {}),
  populated_area_km2: /* @__PURE__ */ jsxRuntimeExports.jsx(PopulatedAreaIcon, {}),
  one: /* @__PURE__ */ jsxRuntimeExports.jsx(OneIcon, {})
};
const tooltipTextMapper = {
  population: TranslationService.t("bivariate.matrix.icon.population"),
  area_km2: TranslationService.t("bivariate.matrix.icon.area_km2"),
  total_building_count: TranslationService.t("bivariate.matrix.icon.total_building_count"),
  populated_area_km2: TranslationService.t("bivariate.matrix.icon.populated_area_km2"),
  one: TranslationService.t("bivariate.matrix.icon.one")
};
const DenominatorIcon = ({ iconId }) => {
  const icon2 = iconMapper[iconId] || /* @__PURE__ */ jsxRuntimeExports.jsx(TotalRoadsIcon, {});
  const tooltipText = tooltipTextMapper[iconId] || TranslationService.t("bivariate.matrix.icon.roads");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleTooltip, { content: tooltipText, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.denominatorIcon, children: icon2 }) });
};
const createGlobalState = (initialState) => {
  let globalState = initialState;
  const listeners = /* @__PURE__ */ new Set();
  const setGlobalState = (nextGlobalState) => {
    globalState = nextGlobalState;
    listeners.forEach((listener) => listener());
  };
  return () => {
    const [state, setState] = reactExports.useState(globalState);
    reactExports.useEffect(() => {
      const listener = () => {
        setState(globalState);
      };
      listeners.add(listener);
      listener();
      return () => {
        listeners.delete(listener);
      };
    }, []);
    return [state, setGlobalState];
  };
};
const useHeadingGlobalState = createGlobalState({
  headingId: ""
});
const denominators = "_denominators_1m5c6_1";
const row$1 = "_row_1m5c6_5";
const column$1 = "_column_1m5c6_9";
const denominatorsContainer = "_denominatorsContainer_1m5c6_43";
const quotientItem = "_quotientItem_1m5c6_79";
const selected$1 = "_selected_1m5c6_85";
const styles$2 = {
  denominators,
  row: row$1,
  column: column$1,
  denominatorsContainer,
  quotientItem,
  selected: selected$1
};
const QuotientItem = ({
  numeratorId,
  denominatorId,
  numeratorLabel,
  quality,
  onSelectQuotient,
  isSelected = false
}) => {
  const onClick = (ev) => {
    ev.stopPropagation();
    onSelectQuotient(numeratorId, denominatorId);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: clsx(styles$2.quotientItem, isSelected && styles$2.selected),
      onClick,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DenominatorIcon, { iconId: denominatorId }),
        sessionStorage.getItem("BIVARIATE_QA_MOD") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "qualityLabel", children: quality !== null && quality !== void 0 ? quality : "&nbsp;" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "quotientLabel", children: numeratorLabel })
      ]
    }
  );
};
const SCALING_BACK = 100 / 70;
const MODAL_MARGIN = 5;
const QuotientSelector = reactExports.memo(
  ({
    id,
    quotients,
    selectedQuotient,
    onSelectQuotient,
    type,
    children
  }) => {
    const [headingState, setHeadingState] = useHeadingGlobalState();
    const toggleVisibility = (e) => {
      e.stopPropagation();
      if (headingState.headingId === id) {
        setHeadingState({ headingId: "", width: 0 });
      } else {
        const selectorPosition = e.currentTarget.getBoundingClientRect();
        const wholeRowPosition = e.currentTarget.parentElement.parentElement.getBoundingClientRect();
        const width = Math.ceil(
          (selectorPosition.left - wholeRowPosition.left) * SCALING_BACK + MODAL_MARGIN
        );
        setHeadingState({ headingId: id, width });
      }
    };
    const selectQuotient = reactExports.useCallback(
      (numId, denId) => {
        setHeadingState({ headingId: "" });
        onSelectQuotient(numId, denId);
      },
      [setHeadingState, onSelectQuotient]
    );
    const [selected2, notSelected] = reactExports.useMemo(() => {
      const selectedIndex = quotients.findIndex(
        ({ id: id2 }) => id2[0] === selectedQuotient.id[0] && id2[1] === selectedQuotient.id[1]
      );
      if (selectedIndex >= 0) {
        return [
          quotients[selectedIndex],
          quotients.filter((_2, i2) => i2 !== selectedIndex)
        ];
      }
      return [null, quotients];
    }, [quotients, selectedQuotient.id]);
    const renderQuotientItem = ({ id: id2, label: numeratorLabel, quality }, isSelected) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      QuotientItem,
      {
        onSelectQuotient: selectQuotient,
        quality,
        numeratorId: id2[0],
        denominatorId: id2[1],
        numeratorLabel,
        isSelected
      },
      JSON.stringify(id2)
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: clsx({
          [styles$2.denominators]: true,
          [styles$2.row]: type === "horizontal",
          [styles$2.column]: type === "vertical"
        }),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: toggleVisibility, children }),
          headingState.headingId === id && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: styles$2.denominatorsContainer,
              style: type === "horizontal" ? {
                left: -headingState.width,
                right: 0
              } : {
                top: -headingState.width,
                bottom: 0
              },
              children: [
                selected2 && renderQuotientItem(selected2, true),
                notSelected.map((item) => renderQuotientItem(item, false))
              ]
            }
          )
        ]
      }
    );
  }
);
QuotientSelector.displayName = "QuotientSelector";
const axisRecord = "_axisRecord_1dbhd_8";
const container$1 = "_container_1dbhd_13";
const column = "_column_1dbhd_34";
const row = "_row_1dbhd_43";
const selected = "_selected_1dbhd_110";
const corner = "_corner_1dbhd_142";
const hovered = "_hovered_1dbhd_146";
const verticalText = "_verticalText_1dbhd_173";
const quotientsCountLabel = "_quotientsCountLabel_1dbhd_185";
const styles$1 = {
  axisRecord,
  container: container$1,
  column,
  row,
  selected,
  corner,
  hovered,
  verticalText,
  quotientsCountLabel
};
const getHeadingPositionStyle = (isColum, index2) => {
  const styles2 = {
    gridColumn: isColum ? `${index2 + 3} / ${index2 + 4}` : "1",
    gridRow: isColum ? "1" : `${index2 + 3} / ${index2 + 4}`
  };
  return styles2;
};
const BivariateMatrixHeadingEntry = reactExports.forwardRef(
  ({
    index: index2,
    type,
    className,
    selectedIndex = -1,
    headerCell,
    id,
    onCellHover,
    onCellClick,
    onSelectQuotient,
    baseDimension,
    calculateHeadingsStyle: calculateHeadingsStyle2
  }, ref) => {
    const onMouseOver = () => {
      onCellHover(index2);
    };
    const onMouseOut = () => {
      onCellHover(null);
    };
    const onClick = (ev) => {
      const target = ev.target;
      if (target.tagName === "svg" || target.tagName === "path" || target.className && target.className.indexOf && target.className.indexOf("denominator") !== -1)
        return;
      onCellClick(index2, ev);
    };
    const selectQuotient = reactExports.useCallback(
      (numId, denId) => {
        onSelectQuotient(index2, numId, denId);
      },
      [onSelectQuotient, index2]
    );
    const numberOfAdditionalQuotientsInGroup = headerCell.quotients.length > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.quotientsCountLabel, children: [
      "+",
      headerCell.quotients.length - 1,
      " layers",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Memo$20, {})
    ] }) : null;
    const containerRef = reactExports.useRef(null);
    let isHovered = false;
    let isSelected = false;
    const isHorizontal = type === "horizontal";
    const isVertical = type === "vertical";
    const baseClassNames = clsx({
      [className || ""]: className,
      [styles$1.axisRecord]: true,
      [styles$1.column]: isVertical,
      [styles$1.row]: isHorizontal,
      [styles$1.verticalText]: isVertical,
      horizontal: isHorizontal,
      vertical: isVertical
    });
    function generateClassNames() {
      return `${baseClassNames} ${clsx({
        [styles$1.hovered]: isHovered,
        [styles$1.selected]: isSelected
      })}`;
    }
    reactExports.useImperativeHandle(ref, () => ({
      setHovered: () => {
        if (containerRef.current) {
          isHovered = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetHovered: () => {
        if (containerRef.current) {
          isHovered = false;
          containerRef.current.className = generateClassNames();
        }
      },
      setSelectedCol: () => {
        if (isVertical && containerRef.current) {
          isSelected = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetSelectedCol: () => {
        if (isVertical && containerRef.current) {
          isSelected = false;
          containerRef.current.className = generateClassNames();
        }
      },
      setSelectedRow: () => {
        if (isHorizontal && containerRef.current) {
          isSelected = true;
          containerRef.current.className = generateClassNames();
        }
      },
      resetSelectedRow: () => {
        if (isHorizontal && containerRef.current) {
          isSelected = false;
          containerRef.current.className = generateClassNames();
        }
      }
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: containerRef,
        onMouseEnter: onMouseOver,
        onMouseOut,
        onClick,
        style: getHeadingPositionStyle(type === "vertical", index2),
        className: baseClassNames,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: calculateHeadingsStyle2(baseDimension, isVertical, index2),
            className: styles$1.container,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1.corner }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(DenominatorIcon, { iconId: headerCell.selectedQuotient.id[1] }),
              sessionStorage.getItem("BIVARIATE_QA_MOD") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "qualityLabel", children: headerCell.quality ? headerCell.quality : "&nbsp;" }),
              headerCell.label,
              numberOfAdditionalQuotientsInGroup && /* @__PURE__ */ jsxRuntimeExports.jsx(
                QuotientSelector,
                {
                  id: `quotient_${id}`,
                  onSelectQuotient: selectQuotient,
                  selectedQuotient: headerCell.selectedQuotient,
                  quotients: headerCell.quotients,
                  type,
                  children: numberOfAdditionalQuotientsInGroup
                }
              )
            ]
          }
        )
      }
    );
  }
);
BivariateMatrixHeadingEntry.displayName = "BivariateMatrixHeadingEntry";
const axisCaptionRoot = "_axisCaptionRoot_1yhrg_1";
const axisCaptionAnchor = "_axisCaptionAnchor_1yhrg_6";
const axisCaptionBody = "_axisCaptionBody_1yhrg_10";
const tooltipHover = "_tooltipHover_1yhrg_24";
const axisCaptionText = "_axisCaptionText_1yhrg_33";
const s$1 = {
  axisCaptionRoot,
  axisCaptionAnchor,
  axisCaptionBody,
  tooltipHover,
  axisCaptionText
};
const AXIS_CAPTIONS_TOOTIP_TEXT = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$1.axisCaptionText, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: TranslationService.t("bivariate.matrix.caption.tooltip.p1") }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: TranslationService.t("bivariate.matrix.caption.tooltip.li1") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: TranslationService.t("bivariate.matrix.caption.tooltip.li2") })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: TranslationService.t("bivariate.matrix.caption.tooltip.b") }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: TranslationService.t("bivariate.matrix.caption.tooltip.p2") }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: TranslationService.t("bivariate.matrix.caption.tooltip.p3") })
] });
const AxisCaptions = ({ baseDimension = 0 }) => {
  const rootRef = reactExports.useRef(null);
  reactExports.useLayoutEffect(() => {
    var _a2;
    (_a2 = rootRef.current) == null ? void 0 : _a2.scrollIntoView({ block: "center" });
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$1.axisCaptionRoot, ref: rootRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s$1.axisCaptionAnchor, style: { left: -baseDimension }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$1.axisCaptionBody, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(LongArrow, { position: "left" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleTooltip, { content: AXIS_CAPTIONS_TOOTIP_TEXT, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s$1.tooltipHover, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: TranslationService.t("bivariate.matrix.caption.base_axis") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Memo$11, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: TranslationService.t("bivariate.matrix.caption.annex_axis") })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LongArrow, { position: "right" })
  ] }) }) });
};
const LongArrow = ({ position = "left" }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "6",
    height: "22",
    viewBox: "0 0 6 22",
    fill: "none",
    transform: position === "left" ? "rotate(90)" : "rotate(-90)",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M3 1V20.5",
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M1 18L3 21.5L5 18",
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      )
    ]
  }
);
const CELL_INDEX_X_OFFSET = 3;
const CELL_INDEX_Y_OFFSET = 3;
const MATRIX_CORNERS_OVERFLOW = 15;
const BivariateMatrixControl = ({
  matrix,
  xHeadings,
  yHeadings,
  onSelectCell,
  selectedCell,
  cellSize = 0,
  onSelectQuotient
}) => {
  const containerRef = reactExports.useRef(null);
  const bivariateMatrixContext = reactExports.useContext(BivariateMatrixContext);
  const cellRowReferences = [];
  const cellColumnReferences = [];
  let hoveredColIndex = -1;
  let hoveredRowIndex = -1;
  const selectedColIndex = reactExports.useRef((selectedCell == null ? void 0 : selectedCell.x) ?? -1);
  const selectedRowIndex = reactExports.useRef((selectedCell == null ? void 0 : selectedCell.y) ?? -1);
  const setSelectCellCallback = useAction(setSelectCellCallbackAction);
  const setCellReference = (ref, rowIndex, colIndex) => {
    if (rowIndex >= 0) {
      if (!cellRowReferences[rowIndex]) {
        cellRowReferences[rowIndex] = [];
      }
      cellRowReferences[rowIndex].push(ref);
    }
    if (colIndex >= 0) {
      if (!cellColumnReferences[colIndex]) {
        cellColumnReferences[colIndex] = [];
      }
      cellColumnReferences[colIndex].push(ref);
    }
  };
  const onMouseOver = (x2, y2) => {
    if (hoveredColIndex !== x2) {
      hoveredColIndex = x2;
      if (hoveredColIndex !== -1) {
        const columns = cellColumnReferences[hoveredColIndex];
        if (columns) {
          columns.forEach((clmn) => {
            clmn == null ? void 0 : clmn.setHovered();
          });
        }
      }
    }
    if (hoveredRowIndex !== y2) {
      hoveredRowIndex = y2;
      if (hoveredRowIndex !== -1) {
        const rows = cellRowReferences[hoveredRowIndex];
        if (rows) {
          rows.forEach((rw) => {
            rw == null ? void 0 : rw.setHovered();
          });
        }
      }
    }
  };
  const onMouseOut = () => {
    if (hoveredColIndex !== -1) {
      const columns = cellColumnReferences[hoveredColIndex];
      if (columns) {
        columns.forEach((clmn) => {
          clmn == null ? void 0 : clmn.resetHovered();
        });
      }
      hoveredColIndex = -1;
    }
    if (hoveredRowIndex !== -1) {
      const rows = cellRowReferences[hoveredRowIndex];
      if (rows) {
        rows.forEach((rw) => {
          rw == null ? void 0 : rw.resetHovered();
        });
      }
      hoveredRowIndex = -1;
    }
  };
  const onCellHoverX = (cellIndex) => {
    onMouseOut();
    if (cellIndex) {
      onMouseOver(cellIndex, hoveredRowIndex);
    }
  };
  const onCellHoverY = (cellIndex) => {
    onMouseOut();
    if (cellIndex) {
      onMouseOver(hoveredColIndex, cellIndex);
    }
  };
  const onResetSelected = () => {
    if (selectedColIndex.current !== -1) {
      const columns = cellColumnReferences[selectedColIndex.current];
      if (columns) {
        columns.forEach((clmn) => {
          clmn == null ? void 0 : clmn.resetSelectedCol();
        });
      }
      selectedColIndex.current = -1;
    }
    if (selectedRowIndex.current !== -1) {
      const rows = cellRowReferences[selectedRowIndex.current];
      if (rows) {
        rows.forEach((rw) => {
          rw == null ? void 0 : rw.resetSelectedRow();
        });
      }
      selectedRowIndex.current = -1;
    }
  };
  const onInnerSelect = (x2, y2, e) => {
    onResetSelected();
    onSelectRowCol(x2, y2);
    onSelectCell(x2, y2, e);
  };
  const onOuterSelect = (x2, y2) => {
    onResetSelected();
    onSelectRowCol(x2, y2);
  };
  const onSelectRowCol = (x2, y2) => {
    if (x2 !== -1 && selectedColIndex.current !== x2) {
      selectedColIndex.current = x2;
      const columns = cellColumnReferences[selectedColIndex.current];
      if (columns) {
        columns.forEach((clmn) => {
          clmn == null ? void 0 : clmn.setSelectedCol();
        });
      }
    }
    if (y2 !== -1 && selectedRowIndex.current !== y2) {
      selectedRowIndex.current = y2;
      const rows = cellRowReferences[selectedRowIndex.current];
      if (rows) {
        rows.forEach((rw) => {
          rw == null ? void 0 : rw.setSelectedRow();
        });
      }
    }
  };
  const onCellSelectX = (cellIndex, e) => {
    onInnerSelect(cellIndex, selectedRowIndex.current, e);
  };
  const onCellSelectY = (cellIndex, e) => {
    onInnerSelect(selectedColIndex.current, cellIndex, e);
  };
  const selectQuotientX = reactExports.useCallback(
    (index2, numId, denId, e) => {
      onSelectQuotient(false, index2, numId, denId, e);
    },
    [onSelectQuotient]
  );
  const selectQuotientY = reactExports.useCallback(
    (index2, numId, denId, e) => {
      onSelectQuotient(true, index2, numId, denId, e);
    },
    [onSelectQuotient]
  );
  const baseDimension = useBaseMatrixDimension(xHeadings, yHeadings);
  const rotatedMatrixWrapperSide = Math.sqrt(
    Math.pow(xHeadings.length * MATRIX_CELL_SIDE, 2) + Math.pow(yHeadings.length * MATRIX_CELL_SIDE, 2)
  ) * MATRIX_SCALE + MATRIX_CORNERS_OVERFLOW;
  reactExports.useEffect(() => {
    bivariateMatrixContext == null ? void 0 : bivariateMatrixContext.onMatrixPositionRecalculated(
      baseDimension,
      rotatedMatrixWrapperSide
    );
    if (containerRef.current) containerRef.current.style.visibility = "visible";
  }, [baseDimension]);
  const gridStyle = useGridStyle(xHeadings.length + 1, yHeadings.length + 1, cellSize);
  const matrixContainerStyles = reactExports.useMemo(
    () => ({
      width: rotatedMatrixWrapperSide,
      height: rotatedMatrixWrapperSide
    }),
    [rotatedMatrixWrapperSide]
  );
  const cellStyles = reactExports.useMemo(() => {
    return generateCellStyles(
      xHeadings.length + CELL_INDEX_X_OFFSET,
      yHeadings.length + CELL_INDEX_Y_OFFSET
    );
  }, [xHeadings, yHeadings]);
  reactExports.useEffect(() => {
    setSelectCellCallback(onOuterSelect.bind(void 0));
    if (selectedCell && (selectedCell.x !== -1 || selectedCell.y !== -1)) {
      onOuterSelect(selectedCell.x, selectedCell.y);
    }
  }, [matrix]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: containerRef,
      className: styles$5.matrixContainer,
      style: matrixContainerStyles,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: gridStyle, className: styles$5.rotatedMatrix, children: [
        matrix.map((_row, rowIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          BivariateMatrixCellConnector,
          {
            type: "horizontal",
            style: cellStyles[-1 + CELL_INDEX_X_OFFSET][rowIndex + CELL_INDEX_Y_OFFSET],
            ref: (rf) => setCellReference(rf, rowIndex, -1)
          },
          `${rowIndex}_row_connector`
        )),
        matrix[0].map((_col, colIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          BivariateMatrixCellConnector,
          {
            type: "vertical",
            style: cellStyles[colIndex + CELL_INDEX_X_OFFSET][-1 + CELL_INDEX_Y_OFFSET],
            ref: (rf) => setCellReference(rf, -1, colIndex)
          },
          `${colIndex}_col_connector`
        )),
        matrix.map(
          (row2, rowIndex) => row2.map((val, colIndex) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              BivariateMatrixCell,
              {
                x: colIndex,
                y: rowIndex,
                onClick: onInnerSelect,
                onMouseOver,
                onMouseOut,
                style: cellStyles[colIndex + CELL_INDEX_X_OFFSET][rowIndex + CELL_INDEX_Y_OFFSET],
                ref: (rf) => setCellReference(rf, rowIndex, colIndex),
                value: val === null ? void 0 : val,
                disabled: val === null,
                firstRow: rowIndex === 0,
                firstCol: colIndex === 0,
                lastRow: rowIndex === matrix.length - 1,
                lastCol: colIndex === row2.length - 1
              },
              `matrix_cell_${colIndex}_${rowIndex}`
            );
          })
        ),
        [...yHeadings].reverse().map((entry, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          BivariateMatrixHeadingEntry,
          {
            id: `hor_${yHeadings.length - 1 - index2}`,
            index: yHeadings.length - 1 - index2,
            type: "horizontal",
            selectedIndex: selectedCell == null ? void 0 : selectedCell.y,
            headerCell: entry,
            onCellHover: onCellHoverY,
            onCellClick: onCellSelectY,
            onSelectQuotient: selectQuotientY,
            baseDimension,
            calculateHeadingsStyle,
            ref: (rf) => setCellReference(rf, yHeadings.length - 1 - index2, -1)
          },
          `hor_${yHeadings.length - 1 - index2}`
        )),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AxisCaptions, { baseDimension }),
        xHeadings.map((entry, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          BivariateMatrixHeadingEntry,
          {
            id: `vert_${index2}`,
            index: index2,
            type: "vertical",
            selectedIndex: selectedCell == null ? void 0 : selectedCell.x,
            headerCell: entry,
            onCellHover: onCellHoverX,
            onCellClick: onCellSelectX,
            onSelectQuotient: selectQuotientX,
            baseDimension,
            calculateHeadingsStyle,
            ref: (rf) => setCellReference(rf, -1, index2)
          },
          `vert_${index2}`
        ))
      ] })
    }
  );
};
BivariateMatrixControl.displayName = "BivariateMatrixControl";
const BivariateMatrixControlComponent = reactExports.memo(
  BivariateMatrixControl,
  (oldProps, newProps) => oldProps.matrix === newProps.matrix
);
const mock = {
  xGroups: [
    {
      parent: '["count","area_km2"]',
      quotients: [["count", "area_km2"]],
      selectedQuotient: ["count", "area_km2"]
    },
    {
      parent: '["local_hours","area_km2"]',
      quotients: [
        ["count", "populated_area_km2"],
        ["population_prev", "populated_area_km2"],
        ["gdp", "populated_area_km2"],
        ["population_prev", "area_km2"],
        ["gdp", "area_km2"],
        ["mandays_maxtemp_over_32c_1c", "populated_area_km2"],
        ["building_count", "populated_area_km2"],
        ["mandays_maxtemp_over_32c_1c", "area_km2"],
        ["osm_users", "area_km2"],
        ["total_hours", "populated_area_km2"],
        ["covid19_confirmed", "populated_area_km2"],
        ["covid19_confirmed", "area_km2"],
        ["osm_users", "populated_area_km2"],
        ["local_hours", "area_km2"],
        ["local_hours", "populated_area_km2"]
      ],
      selectedQuotient: ["local_hours", "area_km2"]
    },
    {
      parent: '["building_count","area_km2"]',
      quotients: [["building_count", "area_km2"]],
      selectedQuotient: ["building_count", "area_km2"]
    },
    {
      parent: '["total_hours","area_km2"]',
      quotients: [["total_hours", "area_km2"]],
      selectedQuotient: ["total_hours", "area_km2"]
    },
    {
      parent: '["highway_length","area_km2"]',
      quotients: [
        ["total_road_length", "area_km2"],
        ["highway_length", "area_km2"]
      ],
      selectedQuotient: ["highway_length", "area_km2"]
    },
    {
      parent: '["view_count","area_km2"]',
      quotients: [
        ["view_count", "populated_area_km2"],
        ["view_count_bf2402", "populated_area_km2"],
        ["view_count", "area_km2"],
        ["view_count_bf2402", "area_km2"]
      ],
      selectedQuotient: ["view_count", "area_km2"]
    },
    {
      parent: '["highway_length","populated_area_km2"]',
      quotients: [["highway_length", "populated_area_km2"]],
      selectedQuotient: ["highway_length", "populated_area_km2"]
    },
    {
      parent: '["total_road_length","populated_area_km2"]',
      quotients: [["total_road_length", "populated_area_km2"]],
      selectedQuotient: ["total_road_length", "populated_area_km2"]
    },
    {
      parent: '["man_distance_to_hospital","area_km2"]',
      quotients: [["man_distance_to_hospital", "area_km2"]],
      selectedQuotient: ["man_distance_to_hospital", "area_km2"]
    },
    {
      parent: '["unknown_forest","total_building_count"]',
      quotients: [
        ["total_road_length", "total_building_count"],
        ["unknown_forest", "total_building_count"]
      ],
      selectedQuotient: ["unknown_forest", "total_building_count"]
    },
    {
      parent: '["forest","total_building_count"]',
      quotients: [
        ["highway_length", "total_building_count"],
        ["forest", "total_building_count"]
      ],
      selectedQuotient: ["forest", "total_building_count"]
    },
    {
      parent: '["man_distance_to_hospital","populated_area_km2"]',
      quotients: [["man_distance_to_hospital", "populated_area_km2"]],
      selectedQuotient: ["man_distance_to_hospital", "populated_area_km2"]
    },
    {
      parent: '["man_distance_to_fire_brigade","area_km2"]',
      quotients: [["man_distance_to_fire_brigade", "area_km2"]],
      selectedQuotient: ["man_distance_to_fire_brigade", "area_km2"]
    },
    {
      parent: '["osm_users","population"]',
      quotients: [["osm_users", "population"]],
      selectedQuotient: ["osm_users", "population"]
    },
    {
      parent: '["unknown_forest","population"]',
      quotients: [
        ["total_road_length", "population"],
        ["unknown_forest", "population"]
      ],
      selectedQuotient: ["unknown_forest", "population"]
    },
    {
      parent: '["count","total_building_count"]',
      quotients: [["count", "total_building_count"]],
      selectedQuotient: ["count", "total_building_count"]
    },
    {
      parent: '["highway_length","population"]',
      quotients: [
        ["forest", "population"],
        ["highway_length", "population"]
      ],
      selectedQuotient: ["highway_length", "population"]
    },
    {
      parent: '["man_distance_to_fire_brigade","populated_area_km2"]',
      quotients: [["man_distance_to_fire_brigade", "populated_area_km2"]],
      selectedQuotient: ["man_distance_to_fire_brigade", "populated_area_km2"]
    }
  ],
  yGroups: [
    {
      parent: '["local_hours","area_km2"]',
      quotients: [
        ["population", "populated_area_km2"],
        ["total_building_count", "populated_area_km2"],
        ["count", "populated_area_km2"],
        ["population_prev", "populated_area_km2"],
        ["total_building_count", "area_km2"],
        ["gdp", "populated_area_km2"],
        ["mandays_maxtemp_over_32c_1c", "populated_area_km2"],
        ["population_prev", "area_km2"],
        ["gdp", "area_km2"],
        ["building_count", "populated_area_km2"],
        ["mandays_maxtemp_over_32c_1c", "area_km2"],
        ["total_hours", "populated_area_km2"],
        ["osm_users", "area_km2"],
        ["covid19_confirmed", "populated_area_km2"],
        ["osm_users", "populated_area_km2"],
        ["covid19_confirmed", "area_km2"],
        ["local_hours", "populated_area_km2"],
        ["local_hours", "area_km2"]
      ],
      selectedQuotient: ["local_hours", "area_km2"]
    },
    {
      parent: '["population","area_km2"]',
      quotients: [["population", "area_km2"]],
      selectedQuotient: ["population", "area_km2"]
    },
    {
      parent: '["count","area_km2"]',
      quotients: [["count", "area_km2"]],
      selectedQuotient: ["count", "area_km2"]
    },
    {
      parent: '["building_count","area_km2"]',
      quotients: [["building_count", "area_km2"]],
      selectedQuotient: ["building_count", "area_km2"]
    },
    {
      parent: '["total_hours","area_km2"]',
      quotients: [["total_hours", "area_km2"]],
      selectedQuotient: ["total_hours", "area_km2"]
    },
    {
      parent: '["highway_length","area_km2"]',
      quotients: [
        ["total_road_length", "area_km2"],
        ["highway_length", "area_km2"]
      ],
      selectedQuotient: ["highway_length", "area_km2"]
    },
    {
      parent: '["view_count","area_km2"]',
      quotients: [
        ["view_count", "populated_area_km2"],
        ["view_count_bf2402", "populated_area_km2"],
        ["view_count", "area_km2"],
        ["view_count_bf2402", "area_km2"]
      ],
      selectedQuotient: ["view_count", "area_km2"]
    },
    {
      parent: '["highway_length","populated_area_km2"]',
      quotients: [["highway_length", "populated_area_km2"]],
      selectedQuotient: ["highway_length", "populated_area_km2"]
    },
    {
      parent: '["total_road_length","populated_area_km2"]',
      quotients: [["total_road_length", "populated_area_km2"]],
      selectedQuotient: ["total_road_length", "populated_area_km2"]
    },
    {
      parent: '["man_distance_to_hospital","area_km2"]',
      quotients: [["man_distance_to_hospital", "area_km2"]],
      selectedQuotient: ["man_distance_to_hospital", "area_km2"]
    },
    {
      parent: '["unknown_forest","total_building_count"]',
      quotients: [
        ["total_road_length", "total_building_count"],
        ["unknown_forest", "total_building_count"]
      ],
      selectedQuotient: ["unknown_forest", "total_building_count"]
    },
    {
      parent: '["forest","total_building_count"]',
      quotients: [
        ["highway_length", "total_building_count"],
        ["forest", "total_building_count"]
      ],
      selectedQuotient: ["forest", "total_building_count"]
    },
    {
      parent: '["populated_area_km2","area_km2"]',
      quotients: [["populated_area_km2", "area_km2"]],
      selectedQuotient: ["populated_area_km2", "area_km2"]
    },
    {
      parent: '["count","population"]',
      quotients: [
        ["populated_area_km2", "population"],
        ["count", "population"]
      ],
      selectedQuotient: ["count", "population"]
    },
    {
      parent: '["populated_area_km2","total_building_count"]',
      quotients: [["populated_area_km2", "total_building_count"]],
      selectedQuotient: ["populated_area_km2", "total_building_count"]
    },
    {
      parent: '["man_distance_to_hospital","populated_area_km2"]',
      quotients: [["man_distance_to_hospital", "populated_area_km2"]],
      selectedQuotient: ["man_distance_to_hospital", "populated_area_km2"]
    },
    {
      parent: '["man_distance_to_fire_brigade","area_km2"]',
      quotients: [["man_distance_to_fire_brigade", "area_km2"]],
      selectedQuotient: ["man_distance_to_fire_brigade", "area_km2"]
    },
    {
      parent: '["osm_users","population"]',
      quotients: [["osm_users", "population"]],
      selectedQuotient: ["osm_users", "population"]
    },
    {
      parent: '["unknown_forest","population"]',
      quotients: [
        ["total_road_length", "population"],
        ["unknown_forest", "population"]
      ],
      selectedQuotient: ["unknown_forest", "population"]
    },
    {
      parent: '["forest","population"]',
      quotients: [
        ["highway_length", "population"],
        ["forest", "population"]
      ],
      selectedQuotient: ["forest", "population"]
    },
    {
      parent: '["avg_elevation","one"]',
      quotients: [["avg_elevation", "one"]],
      selectedQuotient: ["avg_elevation", "one"]
    },
    {
      parent: '["man_distance_to_fire_brigade","populated_area_km2"]',
      quotients: [["man_distance_to_fire_brigade", "populated_area_km2"]],
      selectedQuotient: ["man_distance_to_fire_brigade", "populated_area_km2"]
    }
  ],
  matrix: [
    [
      0.6330778143702572,
      null,
      0.5428354424212366,
      0.8125028273732107,
      0.41794744630059005,
      0.49075709882519214,
      0.26266841211785613,
      0.17540431775688137,
      0.2817357956135096,
      -0.08277918866628682,
      -0.07354014808858399,
      0.19952042019781102,
      0.2900699030570146,
      -0.09959194444606909,
      -0.05653224901990311,
      -0.08121946780800145,
      -0.06293349539553206,
      0.210717984018573
    ],
    [
      0.7671266114613431,
      0.4624540160877126,
      0.7461271344307278,
      0.6236796022803118,
      0.4651837775930101,
      0.6983788201180583,
      0.3282268564011803,
      0.23940172696613696,
      0.6102526069773476,
      -0.06854993994184201,
      -0.06300652330464818,
      0.5425853155901724,
      0.5357120339754239,
      -0.12569275885753226,
      -0.05722122475056985,
      -0.044124976285712575,
      -0.07252302728830883,
      0.46170009422253117
    ],
    [
      null,
      0.6330778143702572,
      0.9448400352897224,
      0.8088667700993942,
      0.5478619819586914,
      0.7272525499712613,
      0.39403434829318645,
      0.27693369264722456,
      0.4212553882513244,
      -0.09219840214177631,
      -0.08214624778695,
      0.3334796387999488,
      0.3381396079397914,
      -0.11599438338517783,
      -0.0603311321070773,
      null,
      -0.0709735871498622,
      0.24799941442360907
    ],
    [
      0.9448400352897224,
      0.5428354424212366,
      null,
      0.676324490987385,
      0.495437368648744,
      0.6083458288157841,
      0.3469868158515808,
      0.2430950316469889,
      0.4310608323815133,
      -0.09512147612349764,
      -0.08309756332167413,
      0.3452068134908724,
      0.33210650851954204,
      -0.1245886065474142,
      -0.059708735955503585,
      -0.14339940649431673,
      -0.07375589630648925,
      0.24325119232100342
    ],
    [
      0.8088667700993942,
      0.8125028273732107,
      0.676324490987385,
      null,
      0.5189347708683577,
      0.6884534708417488,
      0.33187782018548295,
      0.2219184858913333,
      0.35395740401150805,
      -0.09412791983951108,
      -0.0863908043684727,
      0.26082399416277346,
      0.349163057602413,
      -0.0749918701328735,
      -0.06355840786694379,
      -0.06179508212619175,
      -0.06748437844937322,
      0.25841056419208985
    ],
    [
      0.5478619819586914,
      0.41794744630059005,
      0.495437368648744,
      0.5189347708683577,
      null,
      0.38324804690465736,
      null,
      0.414339823397522,
      0.3069414868687711,
      -0.10644082342648567,
      -0.10931575987231072,
      0.2754560009958487,
      0.2569523390521722,
      -0.11051731563471724,
      -0.08226769814606767,
      604231582566239e-18,
      null,
      0.20899371630213479
    ],
    [
      0.7272525499712613,
      0.49075709882519214,
      0.6083458288157841,
      0.6884534708417488,
      0.38324804690465736,
      null,
      0.30947144087595235,
      0.22699474527609945,
      0.2830320630422097,
      -0.04226615774405834,
      -0.037742340113614686,
      0.23762065170375052,
      0.23266705566189747,
      -0.05154149468310855,
      -0.02870286844834339,
      -0.031190214624625075,
      -0.03390072345440923,
      0.18581115270615528
    ],
    [
      0.39403434829318645,
      0.26266841211785613,
      0.3469868158515808,
      0.33187782018548295,
      null,
      0.30947144087595235,
      null,
      0.9304780288243525,
      0.13914319427120514,
      0.3291875622555688,
      0.3720654440390036,
      0.1934927693146689,
      0.10623582254983449,
      7285286560751833e-19,
      0.19378449287322094,
      0.32680720759696696,
      null,
      0.16809925893975913
    ],
    [
      0.27693369264722456,
      0.17540431775688137,
      0.2430950316469889,
      0.2219184858913333,
      0.414339823397522,
      0.22699474527609945,
      0.9304780288243525,
      null,
      0.09020847847993732,
      0.42400942691094484,
      0.5064709774524677,
      0.1712970613845418,
      0.06714970974071707,
      0.01180306783229655,
      0.2255650150706005,
      0.3599655140069753,
      0.30252787549965515,
      0.15970052255248204
    ],
    [
      0.4212553882513244,
      0.2817357956135096,
      0.4310608323815133,
      0.35395740401150805,
      0.3069414868687711,
      0.2830320630422097,
      0.13914319427120514,
      0.09020847847993732,
      null,
      -0.06649666693010343,
      -0.06343156740380441,
      null,
      0.6841527486069171,
      -0.13779469419376966,
      -0.0635847915251171,
      -0.026485710953304663,
      -0.08026301675299034,
      0.6178257434320957
    ],
    [
      -0.09219840214177631,
      -0.08277918866628682,
      -0.09512147612349764,
      -0.09412791983951108,
      -0.10644082342648567,
      -0.04226615774405834,
      0.3291875622555688,
      0.42400942691094484,
      -0.06649666693010343,
      null,
      0.7678796845524921,
      0.012760506344240884,
      -0.054701981754940544,
      0.1344540319549378,
      null,
      0.5631324180563558,
      0.3071029030398512,
      0.04014411156301263
    ],
    [
      -0.08214624778695,
      -0.07354014808858399,
      -0.08309756332167413,
      -0.0863908043684727,
      -0.10931575987231072,
      -0.037742340113614686,
      0.3720654440390036,
      0.5064709774524677,
      -0.06343156740380441,
      0.7678796845524921,
      null,
      0.014062866759102748,
      -0.05210682697853124,
      0.11091668928613378,
      0.2990964999949313,
      0.5385399665532266,
      0.22651079092994508,
      0.04521239572328026
    ],
    [
      0.33092297487284617,
      0.306348164358225,
      0.3238400065207823,
      0.3693496848744186,
      0.38871869483912574,
      0.1581862969025989,
      -0.3471496502086163,
      -0.43374811025089965,
      0.33796301073828167,
      -0.3268410473725932,
      -0.3386739643520862,
      0.055679399245274847,
      0.3020796910928048,
      -0.04623557252911246,
      -0.19287576889960628,
      -0.23886314058329716,
      -0.1732637367181755,
      0.02241746611798094
    ],
    [
      null,
      -0.05985205635299918,
      -0.07346388019658537,
      -0.04156216899598115,
      -0.06836488141749311,
      -0.03935680545094748,
      0.12058512533492027,
      0.13212728757237097,
      -0.11270465651638581,
      0.15970627541493335,
      0.13401194122424062,
      -0.12384718246215928,
      -0.10414752849189488,
      0.7574388860132296,
      0.48388350772788513,
      null,
      0.6315662616124519,
      -0.11571785360027256
    ],
    [
      -0.2290337466539601,
      -0.1757661352019487,
      -0.24760184223062584,
      -0.18278999260309406,
      -0.1710761141838468,
      -0.09542438099888385,
      -0.059267030345385996,
      -0.013539781630611262,
      -0.09643066932644401,
      0.43854582251146346,
      0.3609544353566733,
      -0.07178405902927397,
      -0.06341025046618942,
      0.22096261180630974,
      0.10541941385096928,
      0.5599627595822098,
      0.1278673522191922,
      -0.032944279661146915
    ],
    [
      0.3334796387999488,
      0.19952042019781102,
      0.3452068134908724,
      0.26082399416277346,
      0.2754560009958487,
      0.23762065170375052,
      0.1934927693146689,
      0.1712970613845418,
      null,
      0.012760506344240884,
      0.014062866759102748,
      null,
      0.6310066640401927,
      -0.1500265206387344,
      -0.06689746899862688,
      0.01986212506899432,
      -0.08550943488376969,
      0.676555546708353
    ],
    [
      0.3381396079397914,
      0.2900699030570146,
      0.33210650851954204,
      0.349163057602413,
      0.2569523390521722,
      0.23266705566189747,
      0.10623582254983449,
      0.06714970974071707,
      0.6841527486069171,
      -0.054701981754940544,
      -0.05210682697853124,
      0.6310066640401927,
      null,
      -0.12258332045801432,
      -0.0567307219837807,
      -0.022320716664225384,
      -0.07178249009741255,
      null
    ],
    [
      -0.11599438338517783,
      -0.09959194444606909,
      -0.1245886065474142,
      -0.0749918701328735,
      -0.11051731563471724,
      -0.05154149468310855,
      7285286560751833e-19,
      0.01180306783229655,
      -0.13779469419376966,
      0.1344540319549378,
      0.11091668928613378,
      -0.1500265206387344,
      -0.12258332045801432,
      null,
      0.4348018015155649,
      0.1802672705079899,
      0.5785565720280881,
      -0.1349910962529299
    ],
    [
      -0.0603311321070773,
      -0.05653224901990311,
      -0.059708735955503585,
      -0.06355840786694379,
      -0.08226769814606767,
      -0.02870286844834339,
      0.19378449287322094,
      0.2255650150706005,
      -0.0635847915251171,
      null,
      0.2990964999949313,
      -0.06689746899862688,
      -0.0567307219837807,
      0.4348018015155649,
      null,
      0.16176932292012,
      0.7133807791437314,
      -0.05999313994718329
    ],
    [
      -0.06778027180778882,
      -0.06094700100554602,
      -0.06749293269532497,
      -0.07015551687145612,
      -0.09380332086205506,
      -0.03214432503025587,
      0.20746554020517102,
      0.2523547017592986,
      -0.07210328538123267,
      0.4203440217106889,
      null,
      -0.0750002557187531,
      -0.06409549706414985,
      0.49720071299727603,
      0.8986894662282207,
      0.19577005850577103,
      0.7147205376873481,
      -0.06663105366067186
    ],
    [
      -0.1314723477716716,
      -0.10888331650996384,
      -0.12016811312503141,
      -0.14500851581063834,
      -0.14651760866997154,
      -0.0894267074095959,
      -0.10021629943072725,
      -0.02053796018986287,
      -0.08959271152178999,
      0.07728964320941438,
      0.11382059101409457,
      -0.055901670004619375,
      -0.07981810377749747,
      0.12046075802517535,
      0.07334344740483416,
      -0.020568856117619418,
      0.12080907584004444,
      -0.040957057721220644
    ],
    [
      0.24799941442360907,
      0.210717984018573,
      0.24325119232100342,
      0.25841056419208985,
      0.20899371630213479,
      0.18581115270615528,
      0.16809925893975913,
      0.15970052255248204,
      0.6178257434320957,
      0.04014411156301263,
      0.04521239572328026,
      0.676555546708353,
      null,
      -0.1349910962529299,
      -0.05999313994718329,
      0.035960163104143954,
      -0.07699941382657573,
      null
    ]
  ],
  indicators: [
    {
      name: "mhr_index",
      label: "Multi-hazard risk PDC GRVA",
      copyrights: [
        "© 2022 Pacific Disaster Center. https://www.pdc.org/privacy-policy/"
      ],
      direction: [["unimportant"], ["important", "bad"]]
    },
    {
      name: "mhe_index",
      label: "Multi-hazard exposure PDC GRVA",
      copyrights: [
        "© 2022 Pacific Disaster Center. https://www.pdc.org/privacy-policy/"
      ],
      direction: [["unimportant"], ["important", "bad"]]
    },
    {
      name: "coping_capacity_index",
      label: "Coping Capacity PDC GRVA",
      copyrights: [
        "© 2022 Pacific Disaster Center. https://www.pdc.org/privacy-policy/"
      ],
      direction: [["important", "bad"], ["good"]]
    },
    {
      name: "resilience_index",
      label: "Resilience PDC GRVA",
      copyrights: [
        "© 2022 Pacific Disaster Center. https://www.pdc.org/privacy-policy/"
      ],
      direction: [["important", "bad"], ["good"]]
    },
    {
      name: "vulnerability_index",
      label: "Vulnerability PDC GRVA",
      copyrights: [
        "© 2022 Pacific Disaster Center. https://www.pdc.org/privacy-policy/"
      ],
      direction: [["unimportant"], ["important", "bad"]]
    },
    {
      name: "count",
      label: "OSM Objects",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "count_6_months",
      label: "OSM Objects (last 6 months)",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "view_count",
      label: "OSM Map Views",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [
        ["bad", "unimportant"],
        ["good", "important"]
      ]
    },
    {
      name: "avgmax_ts",
      label: "OSM Last Edit Date (avg)",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad", "unimportant"], ["good"]]
    },
    {
      name: "max_ts",
      label: "OSM Last Edit Date (max)",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad", "unimportant"], ["good"]]
    },
    {
      name: "min_ts",
      label: "OSM First Edit Date (min)",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["good"], ["neutral"]]
    },
    {
      name: "osm_users",
      label: "OSM Mappers Edited Here",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "building_count",
      label: "OSM Buildings",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "building_count_6_months",
      label: "OSM Buildings (last 6 months)",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "highway_length",
      label: "OSM Road Length",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "highway_length_6_months",
      label: "OSM Road Length (last 6 months)",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "local_hours",
      label: "OSM Mapping Hours by Local Mappers",
      copyrights: [
        "© Kontur https://kontur.io/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "total_hours",
      label: "OSM Mapping Hours by All Mappers",
      copyrights: [
        "© Kontur https://kontur.io/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "pop_disability_total",
      label: "Population with a disability",
      copyrights: [
        "© United States Census Bureau. 2019 5-Year American Community Survey (ACS). https://www.census.gov/en.html"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "forest",
      label: "Forest Landcover Area",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "pop_not_well_eng_speak",
      label: "Population with a difficulty speaking English",
      copyrights: [
        "© United States Census Bureau. 2019 5-Year American Community Survey (ACS). https://www.census.gov/en.html"
      ],
      direction: [["good"], ["important", "bad"]]
    },
    {
      name: "evergreen_needle_leaved_forest",
      label: "Evergreen Needle-leaved Forest Landcover Area",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "pop_under_5_total",
      label: "Population under age of 5",
      copyrights: [
        "© United States Census Bureau. 2019 5-Year American Community Survey (ACS). https://www.census.gov/en.html"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "shrubs",
      label: "Shrubland Area",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "pop_over_65_total",
      label: "Population over age of 65",
      copyrights: [
        "© United States Census Bureau. 2019 5-Year American Community Survey (ACS). https://www.census.gov/en.html"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "herbage",
      label: "Herbaceous Landcover Area",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "poverty_families_total",
      label: "Families living below poverty line",
      copyrights: [
        "© United States Census Bureau. 2019 5-Year American Community Survey (ACS). https://www.census.gov/en.html"
      ],
      direction: [["unimportant, good"], ["important"]]
    },
    {
      name: "unknown_forest",
      label: "Unknown Forest Type Landcover Area",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "volcanos_count",
      label: "Number of volcanos",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "covid19_vaccines",
      label: "COVID19 Vaccine Acceptance",
      copyrights: ["© Data from Delphi COVIDcast, covidcast.cmu.edu"],
      direction: [["bad"], ["neutral"]]
    },
    {
      name: "covid19_confirmed",
      label: "COVID19 Confirmed Cases",
      copyrights: ["© Data from JHU CSSE COVID-19 Dataset"],
      direction: [["good"], ["bad"]]
    },
    {
      name: "avg_slope",
      label: "Average slope",
      copyrights: ["© Data from General Bathymatric Chart of the Oceans, www.gebco.net"],
      direction: [
        ["good", "unimportant"],
        ["bad", "important"]
      ]
    },
    {
      name: "avg_elevation",
      label: "Average elevation",
      copyrights: ["© Data from General Bathymatric Chart of the Oceans, www.gebco.net"],
      direction: [
        ["good", "unimportant"],
        ["bad", "important"]
      ]
    },
    {
      name: "gdp",
      label: "Gross Domestic Product",
      copyrights: [
        "© Kontur https://kontur.io/",
        "© 2019 The World Bank Group, CC-BY 4.0",
        "Facebook Connectivity Lab and Center for International Earth Science Information Network - CIESIN - Columbia University. 2016. High Resolution Settlement Layer (HRSL). Source imagery for HRSL © 2016 DigitalGlobe. https://dataforgood.fb.com/tools/population-density-maps/",
        "Dataset: Schiavina, Marcello; Freire, Sergio; MacManus, Kytt (2019): GHS population grid multitemporal (1975, 1990, 2000, 2015) R2019A. European Commission, Joint Research Centre (JRC) DOI: 10.2905/42E8BE89-54FF-464E-BE7B-BF9E64DA5218 PID: http://data.europa.eu/89h/0c6b9751-a71f-4062-830b-43c9f432370f Concept & Methodology: Freire, Sergio; MacManus, Kytt; Pesaresi, Martino; Doxsey-Whitfield, Erin; Mills, Jane (2016): Development of new open and free multi-temporal global population grids at 250 m resolution. Geospatial Data in a Changing World; Association of Geographic Information Laboratories in Europe (AGILE). AGILE 2016",
        "Copernicus Global Land Service: Land Cover 100m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, Myroslava Lesiv, Nandin-Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050",
        "Microsoft Buildings: Canada, Tanzania, Uganda, USA: This data is licensed by Microsoft under the Open Data Commons Open Database License (ODbL).",
        "@ OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "population_prev",
      label: "Population (previous version)",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Facebook Connectivity Lab and Center for International Earth Science Information Network - CIESIN - Columbia University. 2016. High Resolution Settlement Layer (HRSL). Source imagery for HRSL © 2016 DigitalGlobe. https://dataforgood.fb.com/tools/population-density-maps/",
        "Dataset: Schiavina, Marcello; Freire, Sergio; MacManus, Kytt (2019): GHS population grid multitemporal (1975, 1990, 2000, 2015) R2019A. European Commission, Joint Research Centre (JRC) DOI: 10.2905/42E8BE89-54FF-464E-BE7B-BF9E64DA5218 PID: http://data.europa.eu/89h/0c6b9751-a71f-4062-830b-43c9f432370f Concept & Methodology: Freire, Sergio; MacManus, Kytt; Pesaresi, Martino; Doxsey-Whitfield, Erin; Mills, Jane (2016): Development of new open and free multi-temporal global population grids at 250 m resolution. Geospatial Data in a Changing World; Association of Geographic Information Laboratories in Europe (AGILE). AGILE 2016",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050",
        "Microsoft Buildings: Australia, Canada, Tanzania, Uganda, USA: This data is licensed by Microsoft under the Open Data Commons Open Database License (ODbL).",
        "NZ Building Outlines data sourced from the LINZ Data Service - https://data.linz.govt.nz/",
        "Geoalert Urban Mapping: Chechnya, Moscow region, Tyva - https://github.com/Geoalert/urban-mapping",
        "Unconstrained Individual countries 2020 (100m resolution): WorldPop - https://www.worldpop.org/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "wildfires",
      label: "Wildfire Days Per Year",
      copyrights: [
        "© NRT VIIRS 375 m Active Fire product VJ114IMGTDL_NRT. Available on-line [https://earthdata.nasa.gov/firms]. doi: 10.5067/FIRMS/VIIRS/VJ114IMGT_NRT.002",
        "NRT VIIRS 375 m Active Fire product VNP14IMGT. Available on-line [https://earthdata.nasa.gov/firms]. doi:10.5067/FIRMS/VIIRS/VNP14IMGT_NRT.002",
        "MODIS Collection 6 NRT Hotspot / Active Fire Detections MCD14DL. Available on-line [https://earthdata.nasa.gov/firms]. doi: 10.5067/FIRMS/MODIS/MCD14DL.NRT.006",
        "MODIS Collection 6 NRT Hotspot / Active Fire Detections MCD14ML. Available on-line [https://earthdata.nasa.gov/firms]. doi: 10.5067/FIRMS/MODIS/MCD14ML"
      ],
      direction: [
        ["good", "unimportant"],
        ["bad", "important"]
      ]
    },
    {
      name: "avg_ndvi",
      label: "Average NDVI, JUN 2019",
      copyrights: [
        "© Data from Sentinel-2 L2A 120m Mosaic, CC-BY 4.0, https://forum.sentinel-hub.com/c/aws-sentinel"
      ],
      direction: [["bad"], ["good"]]
    },
    {
      name: "industrial_area",
      label: "OSM industrial area",
      copyrights: [
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "pop_without_car",
      label: "Population without a car",
      copyrights: [
        "© United States Census Bureau. 2019 5-Year American Community Survey (ACS). https://www.census.gov/en.html"
      ],
      direction: [["neutral"], ["important"]]
    },
    {
      name: "area_km2",
      label: "Area",
      copyrights: ["Concept of areas © Brahmagupta, René Descartes"],
      direction: [["neutral"], ["neutral"]]
    },
    {
      name: "days_maxtemp_over_32c_1c",
      label: "Days above 32C, recent scenario",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "days_maxtemp_over_32c_2c",
      label: "Days above 32C, potential scenario (2C)",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "days_mintemp_above_25c_1c",
      label: "Nights above 25C, recent scenario",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "days_mintemp_above_25c_2c",
      label: "Nights above 25C, potential scenario(2C)",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "days_maxwetbulb_over_32c_1c",
      label: "Days above 32C wet-bulb, recent scenario",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "days_maxwetbulb_over_32c_2c",
      label: "Days above 32C wet-bulb, potential scenario(2C)",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "mandays_maxtemp_over_32c_1c",
      label: "Man-days above 32C, recent scenario",
      copyrights: [
        "© 2021 Probable Futures, a Project of the SouthCoast Community Foundation. https://probablefutures.org/, CC BY 4.0"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "man_distance_to_fire_brigade",
      label: "Man-distance to fire brigade",
      copyrights: [
        "© Kontur https://kontur.io/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "man_distance_to_hospital",
      label: "Man-distance to hospitals",
      copyrights: [
        "© Kontur https://kontur.io/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["good"], ["bad"]]
    },
    {
      name: "total_road_length",
      label: "Total Roads length",
      copyrights: [
        "©2019 Facebook, Inc. and its affiliates https://github.com/facebookmicrosites/Open-Mapping-At-Facebook/blob/main/LICENSE.md",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "foursquare_places_count",
      label: "Foursquare Japan places count",
      copyrights: ["©Foursquare Labs Inc", "Sample data"],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "foursquare_visits_count",
      label: "Foursquare Japan visits count",
      copyrights: ["©Foursquare Labs Inc", "Sample data"],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "one",
      label: "1",
      copyrights: ["Numbers © Muḥammad ibn Mūsā al-Khwārizmī"],
      direction: [["neutral"], ["neutral"]]
    },
    {
      name: "populated_area_km2",
      label: "Populated area",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Facebook Connectivity Lab and Center for International Earth Science Information Network - CIESIN - Columbia University. 2016. High Resolution Settlement Layer (HRSL). Source imagery for HRSL © 2016 DigitalGlobe. https://dataforgood.fb.com/tools/population-density-maps/",
        "Dataset: Schiavina, Marcello; Freire, Sergio; MacManus, Kytt (2019): GHS population grid multitemporal (1975, 1990, 2000, 2015) R2019A. European Commission, Joint Research Centre (JRC) DOI: 10.2905/42E8BE89-54FF-464E-BE7B-BF9E64DA5218 PID: http://data.europa.eu/89h/0c6b9751-a71f-4062-830b-43c9f432370f Concept & Methodology: Freire, Sergio; MacManus, Kytt; Pesaresi, Martino; Doxsey-Whitfield, Erin; Mills, Jane (2016): Development of new open and free multi-temporal global population grids at 250 m resolution. Geospatial Data in a Changing World; Association of Geographic Information Laboratories in Europe (AGILE). AGILE 2016",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050",
        "Microsoft Buildings: Australia, Canada, Tanzania, Uganda, USA: This data is licensed by Microsoft under the Open Data Commons Open Database License (ODbL).",
        "NZ Building Outlines data sourced from the LINZ Data Service - https://data.linz.govt.nz/",
        "Geoalert Urban Mapping: Chechnya, Moscow region, Tyva - https://github.com/Geoalert/urban-mapping",
        "Unconstrained Individual countries 2020 (100m resolution): WorldPop - https://www.worldpop.org/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "population",
      label: "Population",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Facebook Connectivity Lab and Center for International Earth Science Information Network - CIESIN - Columbia University. 2016. High Resolution Settlement Layer (HRSL). Source imagery for HRSL © 2016 DigitalGlobe. https://dataforgood.fb.com/tools/population-density-maps/",
        "Dataset: Schiavina, Marcello; Freire, Sergio; MacManus, Kytt (2019): GHS population grid multitemporal (1975, 1990, 2000, 2015) R2019A. European Commission, Joint Research Centre (JRC) DOI: 10.2905/42E8BE89-54FF-464E-BE7B-BF9E64DA5218 PID: http://data.europa.eu/89h/0c6b9751-a71f-4062-830b-43c9f432370f Concept & Methodology: Freire, Sergio; MacManus, Kytt; Pesaresi, Martino; Doxsey-Whitfield, Erin; Mills, Jane (2016): Development of new open and free multi-temporal global population grids at 250 m resolution. Geospatial Data in a Changing World; Association of Geographic Information Laboratories in Europe (AGILE). AGILE 2016",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050",
        "Microsoft Buildings: Australia, Canada, Tanzania, Uganda, USA: This data is licensed by Microsoft under the Open Data Commons Open Database License (ODbL).",
        "NZ Building Outlines data sourced from the LINZ Data Service - https://data.linz.govt.nz/",
        "Geoalert Urban Mapping: Chechnya, Moscow region, Tyva - https://github.com/Geoalert/urban-mapping",
        "Unconstrained Individual countries 2020 (100m resolution): WorldPop - https://www.worldpop.org/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "total_building_count",
      label: "Total Buildings Estimate",
      copyrights: [
        "© Kontur https://kontur.io/",
        "Copernicus Global Land Service: Land Cover 100 m: Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, MyroslavaLesiv, Nandin - Erdene Tsendbazar, … Steffen Fritz. (2020). Copernicus Global Land Service: Land Cover 100m: collection 3: epoch 2019: Globe (Version V3.0.1) Data set. Zenodo. http://doi.org/10.5281/zenodo.3939050",
        "Geoalert Urban Mapping: Chechnya, Moscow region, Tyva - https://github.com/Geoalert/urban-mapping",
        "Microsoft Buildings: Australia, Canada, Tanzania, Uganda, USA: This data is licensed by Microsoft under the Open Data Commons Open Database License (ODbL).",
        "NZ Building Outlines data sourced from the LINZ Data Service - https://data.linz.govt.nz/",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [["unimportant"], ["important"]]
    },
    {
      name: "view_count_bf2402",
      label: "OSM Map Views 30 days before 24.02.2022",
      copyrights: [
        "© Kontur",
        "© OpenStreetMap contributors https://www.openstreetmap.org/copyright"
      ],
      direction: [
        ["bad", "unimportant"],
        ["good", "important"]
      ]
    }
  ]
};
const axisMatrix = "_axisMatrix_13uay_1";
const styles = {
  axisMatrix
};
const mapHeaderCell = (group, indicators) => {
  var _a2, _b;
  return {
    label: ((_a2 = indicators.find((indicator2) => indicator2.name === group.selectedQuotient[0])) == null ? void 0 : _a2.label) || "",
    selectedQuotient: {
      id: group.selectedQuotient,
      label: (_b = indicators.find((indicator2) => indicator2.name === group.selectedQuotient[1])) == null ? void 0 : _b.label
    },
    quality: "1",
    quotients: group.quotients.map((quotient) => {
      var _a3;
      return {
        id: quotient,
        label: (_a3 = indicators.find((indicator2) => indicator2.name === quotient[0])) == null ? void 0 : _a3.label,
        quality: "1"
      };
    })
  };
};
function BivariateMatrixControlFixture() {
  const headings = reactExports.useMemo(() => {
    if (!mock.indicators || !mock.xGroups || !mock.xGroups.length || !mock.yGroups || !mock.yGroups.length) {
      return null;
    }
    const mapWithIndicators = (group) => (
      // eslint-disable-next-line
      mapHeaderCell(group, mock == null ? void 0 : mock.indicators)
    );
    return {
      x: mock.xGroups.map(mapWithIndicators),
      y: mock.yGroups.map(mapWithIndicators)
    };
  }, [mock]);
  const [selectedCell, setSelectedCell] = reactExports.useState(null);
  const onSelectCellHandler = reactExports.useCallback((x2, y2, e) => {
    console.log("onSelectCellHandler", x2, y2, e);
    setSelectedCell({ x: x2, y: y2 });
  }, []);
  const onSelectQuotient = reactExports.useCallback(
    (horizontal, index2, numId, denId) => {
      console.log("onSelectQuotient", horizontal, index2, numId, denId);
    },
    []
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reatomContext.Provider, { value: store.v3ctx, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.axisMatrix, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BivariateMatrixControlComponent,
      {
        matrix: mock.matrix,
        xHeadings: headings == null ? void 0 : headings.x,
        yHeadings: headings == null ? void 0 : headings.y,
        onSelectCell: onSelectCellHandler,
        selectedCell,
        onSelectQuotient
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PopupTooltip, {})
  ] }) });
}
const fixture7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: BivariateMatrixControlFixture
}, Symbol.toStringTag, { value: "Module" }));
const lazily = (loader) => new Proxy({}, {
  get: (target, componentName) => {
    if (typeof componentName === "string") {
      return reactExports.lazy(() => loader(componentName).then((x2) => ({
        default: x2[componentName]
      })));
    }
  }
});
const GREETINGS_DISABLED_LS_KEY = "bivariate-greetings-disabled";
const container = "_container_zzzsn_1";
const closeButton = "_closeButton_zzzsn_8";
const style = {
  container,
  closeButton
};
const { BivariateGreetings } = lazily(() => __vitePreload(() => import("./BivariateGreetings-BRpYZzH9.js"), true ? __vite__mapDeps([0,1]) : void 0, import.meta.url));
const BivariateGreetingsContainer = ({
  className
}) => {
  const [isComponentShown, setComponentShown] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const greetingsDisabled = localStorage$1.getItem(GREETINGS_DISABLED_LS_KEY);
    if (!greetingsDisabled && !isComponentShown) {
      setComponentShown(true);
    }
  }, []);
  const onCloseBtnClick = () => {
    setComponentShown(false);
    localStorage$1.setItem(GREETINGS_DISABLED_LS_KEY, "true");
  };
  return isComponentShown ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clsx(className, style.container), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(BivariateGreetings, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: onCloseBtnClick, className: style.closeButton, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Memo$23, {}) })
  ] }) : null;
};
const BivariateGreetings_fixture = () => /* @__PURE__ */ jsxRuntimeExports.jsx(BivariateGreetingsContainer, {});
const fixture8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: BivariateGreetings_fixture
}, Symbol.toStringTag, { value: "Module" }));
const UniComponents_fixture = /* @__PURE__ */ jsxRuntimeExports.jsx("blockquote", { style: { width: 390 }, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    StackedProgressBar,
    {
      value: [
        { title: "% processed", value: 57, color: "green" },
        { title: "% received", value: 75, color: "orange" }
      ],
      caption: "Stacked Progress Bar"
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    StackedProgressBar,
    {
      value: [{ title: "%", value: 33, color: "red" }],
      caption: "Progress"
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    StackedProgressBar,
    {
      value: [
        { title: "% jaw", value: 7, color: "green" },
        { title: "% drip", value: 26, color: "orange" },
        { title: "% flock", value: 75, color: "red" },
        { title: "% mass", value: 95, color: "blue" }
      ],
      caption: "5 step Progress"
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsx(SeverityIndicator, { value: "MODERATE" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(SeverityIndicator, { value: "UNKNOWN" })
].map((Element2) => [Element2, /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {})]) });
const fixture9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: UniComponents_fixture
}, Symbol.toStringTag, { value: "Module" }));
const LegendGrid = "_LegendGrid_16y0t_1";
const LegendGridCell = "_LegendGridCell_16y0t_10";
const LegendGridCellChanged = "_LegendGridCellChanged_16y0t_17";
const LegendGridCellUndefinedChanged = "_LegendGridCellUndefinedChanged_16y0t_23";
const CircleIndicator = "_CircleIndicator_16y0t_27";
const UndefinedColorsIndicator = "_UndefinedColorsIndicator_16y0t_37";
const s = {
  LegendGrid,
  LegendGridCell,
  LegendGridCellChanged,
  LegendGridCellUndefinedChanged,
  CircleIndicator,
  UndefinedColorsIndicator
};
const MiniLegend = ({ legendSteps, changes = {} }) => {
  const corners = CORNER_POINTS_INDEXES.map((corner2) => legendSteps[corner2]);
  const legendStepsHasUndefinedColor = legendSteps.some((step) => step.isFallbackColor);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s.LegendGrid, children: [
    corners.map((cell2) => {
      var _a2;
      let cellColor = cell2.color;
      let changed = false;
      let cellBorderClass;
      let style2;
      if (changes[cell2.label]) {
        changed = true;
        const nextColor = (_a2 = changes[cell2.label]) == null ? void 0 : _a2.color;
        cellColor = nextColor;
        cellBorderClass = nextColor ? s.LegendGridCellChanged : s.LegendGridCellUndefinedChanged;
      }
      if (cellColor) style2 = { backgroundColor: cellColor };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: clsx(s.LegendGridCell, cellBorderClass),
          style: style2,
          children: changed && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s.CircleIndicator })
        },
        cell2.label
      );
    }),
    legendStepsHasUndefinedColor && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s.UndefinedColorsIndicator, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlarmIcon, {}) })
  ] });
};
const AlarmIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "10", cy: "10", r: "10", fill: "white" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M10 3C6.13438 3 3 6.13438 3 10C3 13.8656 6.13438 17 10 17C13.8656 17 17 13.8656 17 10C17 6.13438 13.8656 3 10 3ZM10 15.8125C6.79063 15.8125 4.1875 13.2094 4.1875 10C4.1875 6.79063 6.79063 4.1875 10 4.1875C13.2094 4.1875 15.8125 6.79063 15.8125 10C15.8125 13.2094 13.2094 15.8125 10 15.8125Z",
          fill: "#F5222D"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M9.25 12.75C9.25 12.9489 9.32902 13.1397 9.46967 13.2803C9.61032 13.421 9.80109 13.5 10 13.5C10.1989 13.5 10.3897 13.421 10.5303 13.2803C10.671 13.1397 10.75 12.9489 10.75 12.75C10.75 12.5511 10.671 12.3603 10.5303 12.2197C10.3897 12.079 10.1989 12 10 12C9.80109 12 9.61032 12.079 9.46967 12.2197C9.32902 12.3603 9.25 12.5511 9.25 12.75ZM9.625 11H10.375C10.4438 11 10.5 10.9438 10.5 10.875V6.625C10.5 6.55625 10.4438 6.5 10.375 6.5H9.625C9.55625 6.5 9.5 6.55625 9.5 6.625V10.875C9.5 10.9438 9.55625 11 9.625 11Z",
          fill: "#F5222D"
        }
      )
    ]
  }
);
const mockResponse = [
  {
    label: "A1",
    color: "rgba(232,232,157,0.5)"
  },
  {
    label: "A2",
    color: "rgba(216,159,88,0.5)"
  },
  {
    label: "A3",
    color: "rgba(228,26,28,0.5)"
  },
  {
    label: "B1",
    color: "rgba(169,218,122,0.5)"
  },
  {
    label: "B2",
    color: "rgba(159,171,87,0.5)"
  },
  {
    label: "B3",
    color: "rgba(140,127,57,0.5)"
  },
  {
    label: "C1",
    color: "rgba(90,200,127,0.5)"
  },
  {
    label: "C2",
    color: "rgba(88,176,117,0.5)"
  },
  {
    label: "C3",
    color: "rgba(83,152,106,0.5)"
  }
];
const MiniLegend_fixture = /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "div",
  {
    style: {
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-start"
    },
    children: [
      "All next colors - undefined",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MiniLegend,
        {
          legendSteps: mockResponse,
          changes: {
            A1: { color: void 0 },
            A3: { color: void 0 },
            C1: { color: void 0 },
            C3: { color: void 0 }
          }
        }
      ),
      "No changes",
      /* @__PURE__ */ jsxRuntimeExports.jsx(MiniLegend, { legendSteps: mockResponse, changes: {} }),
      "All changed",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MiniLegend,
        {
          legendSteps: mockResponse,
          changes: {
            A1: { color: "rgba(173, 169, 200, 0.5)" },
            A3: { color: "rgba(12, 155, 237, 0.5)" },
            C1: { color: "rgba(171, 216, 237, 0.5)" },
            C3: { color: "rgba(83, 152, 106, 0.5)" }
          }
        }
      ),
      "Half of cells changed",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MiniLegend,
        {
          legendSteps: mockResponse,
          changes: {
            A1: { color: "rgba(173, 169, 200, 0.5)" },
            C3: { color: "rgba(83, 152, 106, 0.5)" }
          }
        }
      ),
      "Half of cells changed, half comes incorrect",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MiniLegend,
        {
          legendSteps: mockResponse,
          changes: {
            A1: { color: void 0 },
            A3: { color: "rgba(12, 155, 237, 0.5)" },
            C1: { color: "rgba(173, 169, 200, 0.5)" },
            C3: { color: void 0 }
          }
        }
      )
    ]
  }
);
const fixture10 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: MiniLegend_fixture
}, Symbol.toStringTag, { value: "Module" }));
const rendererConfig = {
  "playgroundUrl": "http://127.0.0.1:5000",
  "containerQuerySelector": null
};
const fixtures = {
  "src/features/subscriptions/Plans.fixture.tsx": { module: fixture0 },
  "src/core/pages/PagesDocument.fixture.tsx": { module: fixture1 },
  "src/components/Uni/LayoutDebugger.fixture.tsx": { module: fixture2 },
  "src/components/Uni/FieldsRegistry.fixture.tsx": { module: fixture3 },
  "src/components/Uni/ComponentsRegistry.fixture.tsx": { module: fixture4 },
  "src/components/LinkRenderer/LinkRenderer.fixture.tsx": { module: fixture5 },
  "src/components/BivariateLegend/BivariateLegend.fixture.tsx": { module: fixture6 },
  "src/features/bivariate_manager/fixtures/BivariateMatrixControl.fixture.tsx": { module: fixture7 },
  "src/features/bivariate_manager/fixtures/BivariateGreetings.fixture.tsx": { module: fixture8 },
  "src/components/Uni/Components/UniComponents.fixture.tsx": { module: fixture9 },
  "src/features/bivariate_color_manager/components/MiniLegend/MiniLegend.fixture.tsx": { module: fixture10 }
};
const decorators = {};
const moduleWrappers = {
  lazy: false,
  fixtures,
  decorators
};
const _virtual_cosmosImports = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  moduleWrappers,
  rendererConfig
}, Symbol.toStringTag, { value: "Module" }));
export {
  _virtual_cosmosImports as _,
  jsxRuntimeExports as j
};
